<inspections profile="Project Default"><group name="有效性问题" path="Groovy"><inspection shortName="GroovyDuplicateSwitchBranch" defaultSeverity="WARNING" displayName="重复 switch case" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;switch&lt;/code&gt; 语句的 &lt;code&gt;case&lt;/code&gt; 标签中的重复表达式。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
switch (n) {
  case 1: //重复
    break
  case 1: //重复
    System.out.println("2")
    break
  default:
    System.out.println("default");
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="GroovyUnreachableStatement" defaultSeverity="WARNING" displayName="不可到达的语句" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告无法到达的语句。 如果该语句位于无线循环、&lt;code&gt;return&lt;/code&gt;、&lt;code&gt;break&lt;/code&gt; 或 &lt;code&gt;continue&lt;/code&gt; 语句后，则可能发生这种情况。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;void&lt;/b&gt; foo (int n) {
      if (n &lt; 1) {
          return
          &lt;b&gt;print('This statement is unreachable')&lt;/b&gt;
      }
      while (true){
          print ('Hello, world!')
      }
      &lt;b&gt;print('This statement is unreachable too')&lt;/b&gt;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="JSON 和 JSON5" path=""><inspection shortName="JsonStandardCompliance" defaultSeverity="ERROR" displayName="符合 JSON 标准" enabled="false" language="JSON" pluginId="com.intellij" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 JSON 文件与&lt;a href="https://tools.ietf.org/html/rfc7159"&gt;语言规范&lt;/a&gt;的以下差异：
&lt;ul&gt;
  &lt;li&gt;行或块注释（可配置）。&lt;/li&gt;
  &lt;li&gt;多个顶层值（用于 JSON Lines 文件，可针对其他文件配置）。&lt;/li&gt;
  &lt;li&gt;对象或数组中的尾随逗号（可配置）。&lt;/li&gt;
  &lt;li&gt;用单引号引用的字符串。&lt;/li&gt;
  &lt;li&gt;属性键不是由双引号引用的字符串。&lt;/li&gt;
  &lt;li&gt;用 NaN 或正无穷大/负无穷大数值作为浮点文字（可配置）。&lt;/li&gt;
&lt;/ul&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JsonSchemaDeprecation" defaultSeverity="WEAK WARNING" displayName="弃用的 JSON 属性" enabled="false" language="JSON" pluginId="com.intellij" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 JSON 文件中弃用的属性。&lt;br&gt;
请注意，JSON 架构规范中尚未定义弃用机制，
并且该检查使用了非标准的扩展 'deprecationMessage'。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JsonDuplicatePropertyKeys" defaultSeverity="WARNING" displayName="对象文字中的重复键" enabled="false" language="JSON" pluginId="com.intellij" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对象文字中重复的键。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JsonPathEvaluateUnknownKey" defaultSeverity="WARNING" displayName="为 JSONPath 求值表达式使用未知属性键" enabled="false" language="JSONPath" pluginId="com.intellij" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告要评估的 JSON 源文档中缺少的 JSONPath 表达式中的键。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JsonPathUnknownFunction" defaultSeverity="WARNING" displayName="未知 JSONPath 函数" enabled="false" language="JSONPath" pluginId="com.intellij" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在 JSONPath 函数调用中使用了未知名称，而不是已知的标准函数名称：
&lt;code&gt;concat&lt;/code&gt;、&lt;code&gt;keys&lt;/code&gt;、&lt;code&gt;length&lt;/code&gt;、&lt;code&gt;min&lt;/code&gt;、&lt;code&gt;max&lt;/code&gt;、&lt;code&gt;avg&lt;/code&gt;、&lt;code&gt;stddev&lt;/code&gt;、&lt;code&gt;sum&lt;/code&gt;。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JsonPathUnknownOperator" defaultSeverity="WARNING" displayName="未知 JSONPath 运算符" enabled="false" language="JSONPath" pluginId="com.intellij" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在 JSONPath 表达式中使用了未知运算符，而不是其中一种标准运算符：
&lt;code&gt;in&lt;/code&gt;、&lt;code&gt;nin&lt;/code&gt;、&lt;code&gt;subsetof&lt;/code&gt;、&lt;code&gt;anyof&lt;/code&gt;、&lt;code&gt;noneof&lt;/code&gt;、&lt;code&gt;size&lt;/code&gt;、&lt;code&gt;empty&lt;/code&gt;、&lt;code&gt;contains&lt;/code&gt;。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JsonSchemaRefReference" defaultSeverity="WARNING" displayName="未解析的 '$ref' 和 '$schema' 引用" enabled="false" language="JSON" pluginId="com.intellij" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 JSON 架构中未解析的 &lt;code&gt;$ref&lt;/code&gt; 或 &lt;code&gt;$schema&lt;/code&gt; 路径。&lt;br&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="Json5StandardCompliance" defaultSeverity="ERROR" displayName="符合 JSON5 标准" enabled="false" language="JSON5" pluginId="com.intellij" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 JSON5 文件中&lt;a href="http://json5.org"&gt;语言规范&lt;/a&gt;不一致的情况。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JsonSchemaCompliance" defaultSeverity="WARNING" displayName="符合 JSON 架构" enabled="false" language="JSON" pluginId="com.intellij" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 JSON 文件与分配给它的 &lt;a href="https://json-schema.org"&gt;JSON 模式&lt;/a&gt;之间的不一致。&lt;br&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="代码样式问题" path="Java"><inspection shortName="ObjectsEqualsCanBeSimplified" defaultSeverity="INFORMATION" displayName="'Objects.equals()' 可被替换为 'equals()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对 &lt;code&gt;Objects.equals(a, b)&lt;/code&gt; 的调用，其中第一个实参是静态已知为非 null。
&lt;p&gt;如果两个实参都是基元，此类调用可以安全地替换为 &lt;code&gt;a.equals(b)&lt;/code&gt; 或 &lt;code&gt;a == b&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String defaultName = "default";
  boolean isDefault = Objects.equals(defaultName, name);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String defaultName = "default";
  boolean isDefault = defaultName.equals(name);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2018.3 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SingleElementAnnotation" defaultSeverity="INFORMATION" displayName="非规范化注解" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告速记形式的注解并建议以具有特性名称的正常形式重写它们。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @SuppressWarnings("foo")
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @SuppressWarnings(value = "foo")
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="UnnecessaryToStringCall" defaultSeverity="WARNING" displayName="对 'toString()' 的调用不必要" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在以下情况下使用的 &lt;code&gt;toString()&lt;/code&gt; 调用：
&lt;ul&gt;
  &lt;li&gt;在字符串串联中&lt;/li&gt;
  &lt;li&gt;在 &lt;code&gt;java.lang.StringBuilder#append()&lt;/code&gt; 或 &lt;code&gt;java.lang.StringBuffer#append()&lt;/code&gt; 方法中&lt;/li&gt;
  &lt;li&gt;在 &lt;code&gt;java.io.PrintWriter&lt;/code&gt; 或 &lt;code&gt;java.io.PrintStream&lt;/code&gt; 的方法中&lt;/li&gt;
  &lt;li&gt;在 &lt;code&gt;org.slf4j.Logger&lt;/code&gt; 的方法中&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在这些情况下，转换为字符串将由底层库方法处理，不需要显式调用 &lt;code&gt;toString()&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  System.out.println(this.toString())
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  System.out.println(this)
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  请注意，没有 &lt;code&gt;toString()&lt;/code&gt; 调用，代码语义可能会有所不同：如果表达式为 null，则将使用 &lt;code&gt;null&lt;/code&gt; 字符串，而不是抛出 &lt;code&gt;NullPointerException&lt;/code&gt;。&lt;/p&gt;
  &lt;p&gt;使用 &lt;b&gt;仅在已知限定符为非 null 时报告&lt;/b&gt; 选项以避免对可能为 null 的值发出警告。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnqualifiedInnerClassAccess" defaultSeverity="WARNING" displayName="非限定内部类访问" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对未使用封闭类名称限定的内部类的引用。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  import foo.Foo.Bar;

  class Foo {
    class Bar {}
  }

  class Baz {
    void f(Bar bar) {}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    class Bar {}
  }

  class Baz {
    void f(Foo.Bar bar) {}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用检查设置可以忽略对同一类中的内部类的引用，因此这些类不需要导入。
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MethodRefCanBeReplacedWithLambda" defaultSeverity="INFORMATION" displayName="方法引用可被替换为 lambda" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告方法引用，例如 &lt;code&gt;MyClass::myMethod&lt;/code&gt; 和 &lt;code&gt;myObject::myMethod&lt;/code&gt;，并建议将它们替换为等效的 lambda 表达式。
&lt;p&gt;Lambda 表达式比方法引用更容易修改。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  System.out::println
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后： &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  s -&amp;gt; System.out.println(s)
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;默认情况下，此检查不会高亮显示编辑器中的代码，而仅提供快速修复。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MultipleVariablesInDeclaration" defaultSeverity="INFORMATION" displayName="一个声明中的多个变量" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在单个声明中声明的多个变量，并建议为每个变量创建单独的声明。
&lt;p&gt;一些编码标准禁止此类声明。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int x = 1, y = 2;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int x = 1;
  int y = 2;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;配置检查：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用 &lt;b&gt;忽略 'for' 循环声明&lt;/b&gt; 选项可忽略在 'for' 循环语句的初始化中声明的多个变量，例如：
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;for&lt;/b&gt; (int i = 0, max = list.size(); i &amp;gt; max; i++) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;使用 &lt;b&gt;仅在单个声明中对不同的数组维度发出警告&lt;/b&gt; 选项，以仅在单个声明中声明具有不同数组维度的变量时发出警告，例如：
&lt;pre&gt;&lt;code&gt;
  String s = "", array[];
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;small&gt;2019.2 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JoinDeclarationAndAssignmentJava" defaultSeverity="INFORMATION" displayName="赋值可与声明联接" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以与变量声明联接的变量赋值。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int x;
  x = 1;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;快速修复将赋值转换为初始值设定项：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int x = 1;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2018.3 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnqualifiedMethodAccess" defaultSeverity="WARNING" displayName="未使用 'this' 限定的实例方法调用" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对同一实例上未使用 &lt;code&gt;this&lt;/code&gt; 限定的非 &lt;code&gt;static&lt;/code&gt; 方法的调用。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    void bar() {}

    void foo() {
      bar();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    void bar() {}

    void foo() {
      this.bar();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ChainedEquality" defaultSeverity="WARNING" displayName="链式相等比较" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告链式相等比较。
&lt;p&gt;此类比较可能令人困惑：&lt;code&gt;a == b == c&lt;/code&gt; 表示 &lt;code&gt;(a == b) == c&lt;/code&gt;，但可能 &lt;code&gt;a == b &amp;&amp; a == c&lt;/code&gt; 是有意为之。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean chainedEquality(boolean a, boolean b, boolean c) {
    return a == b == c;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;您可以使用圆括号使比较不那么令人困惑：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean chainedEquality(boolean a, boolean b, boolean c) {
    return (a == b) == c;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DiamondCanBeReplacedWithExplicitTypeArguments" defaultSeverity="INFORMATION" displayName="diamond 可被替换为显式类型实参" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告泛型类的实例化，其中使用 &lt;b&gt;&amp;lt;&amp;gt;&lt;/b&gt; 符号（菱形）代替类型形参。

&lt;p&gt;快速修复会将 &lt;b&gt;&amp;lt;&amp;gt;&lt;/b&gt;（菱形）替换为显式类型形参。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;List &amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;List &amp;lt;String&amp;gt; list = new ArrayList&amp;lt;String&amp;gt;()&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  &lt;i&gt;菱形运算符&lt;/i&gt;在 Java 7 中出现。
  此检查有助于为向后兼容早期 Java 版本而降级。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FuseStreamOperations" defaultSeverity="WARNING" displayName="后续步骤可以融合到Stream API链中" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
检测 Stream API 链之外的可以合并到其中的转换。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  List&amp;lt;String&amp;gt; list = stream.collect(Collectors.toList());
  list.sort(null);
  return list.toArray(new String[list.size()]);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;转换后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  return stream.sorted().toArray(String[]::new);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  请注意，有时转换后的 Stream 链可能会将显式 &lt;code&gt;ArrayList&lt;/code&gt; 替换为 &lt;code&gt;Collectors.toList()&lt;/code&gt; 或将显式 &lt;code&gt;HashSet&lt;/code&gt; 替换为 &lt;code&gt;Collectors.toSet()&lt;/code&gt;。 当前库实现会在内部使用这些集合。 但是，这种方法不是很可靠，将来可能会更改代码的语义。&lt;/p&gt;

&lt;!-- tooltip end --&gt;
&lt;p&gt;如果您对此感到担心，请使用&lt;b&gt;不建议使用 'toList()' 或 'toSet()' 收集器&lt;/b&gt;选项来建议使用 &lt;code&gt;Collectors.toCollection()&lt;/code&gt; 而不是 &lt;code&gt;toList&lt;/code&gt; 和 &lt;code&gt;toSet&lt;/code&gt; 收集器。
&lt;p&gt;仅当项目或模块的语言级别为 8 或更高时，此检查才会报告。&lt;/p&gt;
&lt;!--&lt;p&gt;&lt;small&gt;New in 2017.3&lt;/small&gt;&lt;/p&gt;--&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LambdaCanBeReplacedWithAnonymous" defaultSeverity="INFORMATION" displayName="lambda 可被替换为匿名类" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以替换为匿名类的 lambda 表达式。
&lt;p&gt;
  如果需要在匿名类中实现其他方法，则将 lambda 表达式扩展到匿名类会很有用。
&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  s -&gt; System.out.println(s)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;new Consumer&amp;lt;String&amp;gt;() {
  @Override
  public void accept(String s) {
    System.out.println(s);
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  &lt;i&gt;Lambda 表达式&lt;/i&gt;在 Java 8 中出现。
  此检查有助于为向后兼容早期 Java 版本而降级。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="BoundedWildcard" defaultSeverity="WARNING" displayName="可以使用有界通配符" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以使用&lt;a href="https://en.wikipedia.org/wiki/Wildcard_(Java)"&gt;有界通配符&lt;/a&gt;的通用方法形参。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void process(Consumer&amp;lt;Number&amp;gt; consumer);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;应替换为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void process(Consumer&amp;lt;? super Number&amp;gt; consumer);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  此方法签名更灵活，因为它接受更多类型：不仅是 &lt;code&gt;Consumer&amp;lt;Number&amp;gt;&lt;/code&gt;，还有 &lt;code&gt;Consumer&amp;lt;Object&amp;gt;&lt;/code&gt;。
&lt;/p&gt;
&lt;p&gt;同样，在协变位置输入形参：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  T produce(Producer&amp;lt;T&amp;gt; p);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;应替换为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  T produce(Producer&amp;lt;? extends T&amp;gt; p);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  引用 &lt;em&gt;Effective Java&lt;/em&gt; 第三版中的 &lt;a href="https://en.wikipedia.org/wiki/Joshua_Bloch#Effective_Java"&gt;Joshua Bloch&lt;/a&gt;：
&lt;/p&gt;
&lt;blockquote&gt;
  &lt;h4&gt;第 31 项：使用有界通配符增加 API 灵活性&lt;/h4&gt;
  在 API 中使用通配符类型虽然麻烦，但会使 API 更加灵活。
  如果您编写的库将被广泛使用，则应强制正确使用通配符类型。
  记住基本规则：生产者-extends, 使用者-super (PECS)。
  还要记住，所有 Comparable 和 Comparator 都是消费者。
&lt;/blockquote&gt;

&lt;p&gt;
  使用检查选项可以切换以下各项的报告：
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;
      不变类。 一个不变类的示例是 &lt;code&gt;java.util.List&amp;lt;T&amp;gt;&lt;/code&gt;，因为它既接受值（通过 &lt;code&gt;List.add(T)&lt;/code&gt; 方法）又生成值（通过 &lt;code&gt;T List.get()&lt;/code&gt; 方法）。
    &lt;/p&gt;
    &lt;p&gt;
      另一方面，&lt;code&gt;contravariant&lt;/code&gt; 类只接收值，例如，只有方法 &lt;code&gt;accept(T)&lt;/code&gt; 的 &lt;code&gt;java.util.function.Consumer&amp;lt;T&amp;gt;&lt;/code&gt;。 类似地，&lt;code&gt;covariant&lt;/code&gt; 类只产生值，例如，只有方法 &lt;code&gt;T get()&lt;/code&gt; 的 &lt;code&gt;java.util.function.Supplier&amp;lt;T&amp;gt;&lt;/code&gt;。
    &lt;/p&gt;
    &lt;p&gt;
      人们经常在协变/逆变类中使用有界通配符，但避免在不变类中使用通配符，例如 &lt;code&gt;void process(List&amp;lt;? extends T&amp;gt; l)&lt;/code&gt;。
      禁用此选项可以忽略这种不变类并保留它们的严格类型，例如 &lt;code&gt;void process(List&amp;lt;T&amp;gt; l)&lt;/code&gt;。
    &lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;
      可视为不属于公共 API 一部分的 &lt;code&gt;private&lt;/code&gt; 方法
    &lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;
      实例方法
    &lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnqualifiedFieldAccess" defaultSeverity="WARNING" displayName="未使用 'this' 限定的实例字段访问" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告未使用 &lt;code&gt;this&lt;/code&gt; 或某些其他限定符限定的字段访问操作。
&lt;p&gt;
  某些编码样式要求对所有字段访问操作进行限定，以防止与局部变量或局部形参访问混淆。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    int foo;

    void bar() {
      foo += 1;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    int foo;

    void bar() {
      this.foo += 1;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReturnSeparatedFromComputation" defaultSeverity="INFORMATION" displayName="与结果计算分离的 'return'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告返回局部变量的 &lt;code&gt;return&lt;/code&gt; 语句，其中变量的值在同一方法中的其他位置计算。
&lt;p&gt;快速修复通过将 return 语句移动到计算变量值的位置来内联返回的变量。
  当返回值无法内联到 &lt;code&gt;return&lt;/code&gt; 语句中时，快速修复尝试将 return 语句移动到尽可能接近计算的返回值的位置。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int n = -1;
  for (int i = 0; i &amp;lt; a.length; i++) {
    if (a[i] == b) {
      n = i;
      break;
    }
  }
  return n;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int n = -1;
  for (int i = 0; i &amp;lt; a.length; i++) {
    if (a[i] == b) {
      return i;
    }
  }
  return n;
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MoveFieldAssignmentToInitializer" defaultSeverity="INFORMATION" displayName="字段赋值可以移至初始值设定项中" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
建议将使用赋值的字段的初始化替换为字段声明中的初始化。
&lt;p&gt;仅当字段赋值位于实例或 static 初始值设定项中时报告，并且将其与字段声明联接可能比较安全。
  在其他情况下（比如构造函数中的赋值），提供的快速修复不会高亮显示，因为修正可能会更改语义。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class MyClass {
    static final int intConstant;
    
    static {
      intConstant = 10;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
该快速修复会将赋予的值移至字段初始值设定项，并移除类初始值设定项（如果可能）：
&lt;pre&gt;&lt;code&gt;
  class MyClass {
    static final int intConstant = 10;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;small&gt;自从 2017.2&lt;/small&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LambdaBodyCanBeCodeBlock" defaultSeverity="INFORMATION" displayName="lambda 体可以是代码块" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告主体为表达式的 lambda，并建议将表达式主体转换为代码块。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  n&amp;nbsp;-&amp;gt;&amp;nbsp;n&amp;nbsp;+&amp;nbsp;1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;n -&amp;gt; {
  return n + 1;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="BlockMarkerComments" defaultSeverity="WARNING" displayName="块标记注释" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告用作代码块标记的注释。
该快速修复会移除此类注释。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  while (i &amp;lt; 10) {
    i++;
  } // end while
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  while (i &amp;lt; 10) {
    i++;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="OptionalToIf" defaultSeverity="INFORMATION" displayName="'Optional' 可被替换为 'if' 语句序列" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可替换为 &lt;code&gt;if&lt;/code&gt; 语句序列的 &lt;code&gt;Optional&lt;/code&gt; 调用链。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  return Optional.ofNullable(name)
    .map(this::extractInitials)
    .map(initials -&gt; initials.toUpperCase(Locale.ENGLISH))
    .orElseGet(this::getDefault);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (name != null) {
    String initials = extractInitials(name);
    if (initials != null) return initials.toUpperCase(Locale.ENGLISH);
  }
  return getDefault();
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  &lt;code&gt;java.util.Optional&lt;/code&gt; 在 Java 8 中出现。
  此检查有助于为向后兼容早期 Java 版本而降级。
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;2020.2 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReturnThis" defaultSeverity="WARNING" displayName="返回 'this'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告返回 &lt;code&gt;this&lt;/code&gt; 的方法。
&lt;p&gt;
  虽然此类返回是有效的，但很少有必要，并且通常表明该方法旨在被用作类似方法调用链的一部分（例如，&lt;code&gt;buffer.append("foo").append( "bar").append("baz")&lt;/code&gt;）。
  许多编码标准不赞成此类链。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public Builder append(String str) {
    // [...]
    return this;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryConstantArrayCreationExpression" defaultSeverity="WARNING" displayName="常量数组创建中的冗余 'new' 表达式" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以替换为数组初始值设定项的常量新数组表达式。 数组初始值设定项可以省略类型，因为它已在赋值的左侧指定。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int[] foo = new int[] {42};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int[] foo = {42};
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ArrayCreationWithoutNewKeyword" defaultSeverity="INFORMATION" displayName="创建不带 'new' 表达式的数组" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告没有 &lt;code&gt;new&lt;/code&gt; 数组表达式的数组初始化器并建议添加它们。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int[] a = {42}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int[] a = new int[]{42}
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="NestedMethodCall" defaultSeverity="WARNING" displayName="嵌套方法调用" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告用作另一个方法调用的形参的方法调用。
&lt;p&gt;该快速修复会引入一个变量，使代码更简单，也更易于调试。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public int y() { return 1; }
  public int f(int x) { return 2 * x; }

  public void foo() {
      int x = f(y());
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public int y() { return 1; }
  public int f(int x) { return 2 * x; }

  public void foo() {
      int y = y();
      int x = f(y);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
使用检查选项可以切换以下各项的报告：
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;字段初始值设定项中的方法调用&lt;/li&gt;
  &lt;li&gt;对 static 方法的调用&lt;/li&gt;
  &lt;li&gt;对简单 getter 的调用&lt;/li&gt;
&lt;/ul&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LocalCanBeFinal" defaultSeverity="WARNING" displayName="局部变量或形参可以是 'final'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可能在其声明中添加了 &lt;code&gt;final&lt;/code&gt; 修饰符的形参或局部变量。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  ArrayList&amp;lt;Integer&amp;gt; list = new ArrayList();
  fill(list);
  return list;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  final ArrayList&amp;lt;Integer&amp;gt; list = new ArrayList();
  fill(list);
  return list;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用该检查的选项可定义是否应报告形参或局部变量。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="FieldMayBeFinal" defaultSeverity="WARNING" displayName="字段可能为 'final'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以安全地设为 &lt;code&gt;final&lt;/code&gt; 的字段。
所有 &lt;code&gt;final&lt;/code&gt; 字段都应具有一个不会更改的值，从而使代码更易于推理。
&lt;p&gt;为避免分析开销过大，此检查仅报告字段是否具有 &lt;code&gt;private&lt;/code&gt; 修饰符或者是否在局部类或匿名类中定义。
  如果满足以下条件，字段可以为 &lt;code&gt;final&lt;/code&gt;：
&lt;ul&gt;
  &lt;li&gt;字段为 &lt;code&gt;static&lt;/code&gt;，并在其声明或 &lt;code&gt;static&lt;/code&gt; 初始值设定项中进行了一次初始化。&lt;/li&gt;
  &lt;li&gt;字段为非 &lt;code&gt;static&lt;/code&gt;，并在其声明、实例初始值设定项或每个构造函数中进行了一次初始化&lt;/li&gt;
&lt;/ul&gt;
并且字段未在其他任何地方进行修改。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Person {
    private String name; // 可以为 final

    Person(String name) {
      this.name = name;
    }

    public String getName() {
      return name;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Person {
    private final String name;

    Person(String name) {
      this.name = name;
    }

    public String getName() {
      return name;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ControlFlowStatementWithoutBraces" defaultSeverity="INFORMATION" displayName="不带大括号的控制流语句" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告没有大括号的 &lt;code&gt;if&lt;/code&gt;、&lt;code&gt;while&lt;/code&gt;、&lt;code&gt;do&lt;/code&gt; 或 &lt;code&gt;for&lt;/code&gt; 语句。
一些代码样式，例如 &lt;a href="https://google.github.io/styleguide/javaguide.html"&gt;Google Java 样式指南&lt;/a&gt;，要求所有控制语句都要带大括号。
&lt;p&gt;
  在向不带大括号的控制语句添加更多语句时，重要的是不要忘记添加大括号。
  在注释掉一行代码时，在不使用大括号时也必须更加小心，以免无意中使下一条语句成为控制流语句的一部分。
  始终使用大括号可以更安全地插入或注释掉一行代码。
&lt;p&gt;
  如果始终遵循使用大括号的代码样式，则很可能不会发生 &lt;a href="https://www.imperialviolet.org/2014/02/22/applebug.html"&gt;goto fail 漏洞&lt;/a&gt;。
  带大括号的控制语句使控制流更易于查看，而无需依赖于可能不正确的缩进。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Strange {
    void x(boolean one, boolean two) {
      if(one)
        if(two)
          foo();
      else
        bar();
    }

    void foo() {}
    void bar() {}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;快速修复用大括号包装语句体：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Strange {
    void x(boolean one, boolean two) {
      if(one) {
        if(two) {
          foo();
        } else {
          bar();
        }
      }
    }

    void foo() {}
    void bar() {}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CStyleArrayDeclaration" defaultSeverity="WARNING" displayName="C 样式数组声明" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告以 C 风格语法编写的数组声明，其中数组指示符中括号放置在变量名称之后或方法形参列表之后。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;public&lt;/b&gt; String process(String value[])[] {
    return value;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;大多数代码风格更喜欢 Java 风格的数组声明，其中数组指示符中括号附加到类型名称，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;public&lt;/b&gt; String[] process(String[] value) {
    return value;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;配置检查：&lt;/p&gt;
&lt;p&gt;
使用 &lt;b&gt;忽略变量中的C样式声明&lt;/b&gt; 选项仅报告方法返回类型的 C 样式数组声明。
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantLabeledSwitchRuleCodeBlock" defaultSeverity="WARNING" displayName="标记的 switch 规则具有冗余代码块" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告带有冗余代码块的 &lt;code&gt;switch&lt;/code&gt; 语句或 &lt;code&gt;switch&lt;/code&gt; 表达式的标记规则。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String s = switch (n) {
    case 1 -&gt; { yield Integer.toString(n); }
    default -&gt; "default";
  };
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String s = switch (n) {
    case 1 -&gt; Integer.toString(n);
    default -&gt; "default";
  };
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;仅当项目或模块的语言级别为 14 或更高时，此检查才会报告。&lt;/p&gt;
&lt;p&gt;&lt;small&gt;2019.1 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryCallToStringValueOf" defaultSeverity="WARNING" displayName="到 'String' 的不必要转换" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在不需要显式字符串转换的字符串串联中使用或作为库方法实参使用的静态方法调用，例如 &lt;code&gt;String.valueOf()&lt;/code&gt; 或 &lt;code&gt;Integer.toString()&lt;/code&gt;。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  System.out.println("Number: " + Integer.toString(count));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  System.out.println("Number: " + count);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;其中显式字符串转换被认为是冗余的库方法：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    类 &lt;code&gt;java.io.PrintWriter&lt;/code&gt;, &lt;code&gt;java.io.PrintStream&lt;/code&gt;
    &lt;ul&gt;&lt;li&gt;&lt;code&gt;print()&lt;/code&gt;, &lt;code&gt;println()&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    类 &lt;code&gt;java.lang.StringBuilder&lt;/code&gt;, &lt;code&gt;java.lang.StringBuffer&lt;/code&gt;
    &lt;ul&gt;&lt;li&gt;&lt;code&gt;append()&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;
  &lt;/li&gt;

  &lt;li&gt;
    类 &lt;code&gt;org.slf4j.Logger&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code&gt;trace()&lt;/code&gt;, &lt;code&gt;debug()&lt;/code&gt;, &lt;code&gt;info()&lt;/code&gt;, &lt;code&gt;warn()&lt;/code&gt;, &lt;code&gt;error()&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryParentheses" defaultSeverity="INFORMATION" displayName="不必要的圆括号" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告任何不必要的圆括号。
&lt;p&gt;如果移除圆括号后表达式的评估顺序保持不变，则不需要圆括号。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int n = 3 + (9 * 8);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int n = 3 + 9 * 8;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;配置检查：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;使用&lt;b&gt;忽略澄清圆括号&lt;/b&gt;选项可忽略有助于明确二元表达式的圆括号。 圆括号澄清被括起来的表达式是一个 &lt;code&gt;instanceof&lt;/code&gt; 更大表达式一部分的表达式或包含与父表达式不同运算符。&lt;/li&gt;
  &lt;li&gt;使用&lt;b&gt;忽略条件表达式条件周围的圆括号&lt;/b&gt;选项以忽略条件表达式条件周围的任何圆括号。 一些编码标准规定所有这些条件都必须用圆括号括起来。&lt;/li&gt;
  &lt;li&gt;
    使用&lt;b&gt;忽略单个非正式类型 lambda 形参周围的圆括号&lt;/b&gt;选项可忽略 lambda 表达式中单个 lambda 形参周围的圆括号。
  &lt;/li&gt;
&lt;/ul&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessarySemicolon" defaultSeverity="WARNING" displayName="不必要的分号" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告任何不必要的分号，包括在类成员之间、块语句内部或类定义之后使用的分号。
&lt;p&gt;尽管这些分号在 Java 中有效，但它们是冗余的，可以被删除。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class C {
    ;
    void m() throws Exception {
        try (AutoCloseable r1 = createAutoCloseable();) {
          ;
        }
    }
    ;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class C {
    void m() throws Exception {
      try (AutoCloseable r1 = createAutoCloseable()) {
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RecordCanBeClass" defaultSeverity="INFORMATION" displayName="记录可以转换为类" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告记录类并建议将它们转换为普通类。
&lt;p&gt;通过将快速修复应用到此记录，此检查可以将 Java 记录移动到使用早期 Java 版本的代码库。&lt;/p&gt;
&lt;p&gt;
  请注意，生成的类并不完全等同于原始记录：
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;结果的类不再扩展 &lt;code&gt;java.lang.Record&lt;/code&gt;，因此 &lt;code&gt;instanceof Record&lt;/code&gt; 返回 &lt;code&gt;false&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Class.isRecord()&lt;/code&gt; 和 &lt;code&gt;Class.getRecordComponents()&lt;/code&gt; 等反射方法会产生不同的结果。&lt;/li&gt;
  &lt;li&gt;生成的 &lt;code&gt;hashCode()&lt;/code&gt; 实现可能会产生不同的结果，因为故意没有指定计算记录 &lt;code&gt;hashCode&lt;/code&gt; 的公式。&lt;/li&gt;
  &lt;li&gt;记录序列化机制不同于普通类。
    有关详细信息，请参阅 &lt;i&gt;Java 对象序列化规范&lt;/i&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  record Point(int x, int y) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  final class Point {
    private final int x;
    private final int y;

    Point(int x, int y) {
      this.x = x;
      this.y = y;
    }

    public int x() { return x; }

    public int y() { return y; }

    @Override
    public boolean equals(Object obj) {
      if (obj == this) return true;
      if (obj == null || obj.getClass() != this.getClass()) return false;
      var that = (Point)obj;
      return this.x == that.x &amp;&amp;
             this.y == that.y;
    }

    @Override
    public int hashCode() {
      return Objects.hash(x, y);
    }

    @Override
    public String toString() {
      return "Point[" +
             "x=" + x + ", " +
             "y=" + y + ']';
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;仅当项目或模块的语言级别为 16 或更高时，此检查才会报告。&lt;/p&gt;
&lt;p&gt;&lt;small&gt;2020.3 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryQualifierForThis" defaultSeverity="WARNING" displayName="'this' 或 'super' 的限定符不必要" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告不必要的 &lt;code&gt;this&lt;/code&gt; 或 &lt;code&gt;super&lt;/code&gt; 限定。
&lt;p&gt;
  在 &lt;code&gt;this&lt;/code&gt; 或 &lt;code&gt;super&lt;/code&gt; 上使用限定符来消除代码引用的歧义可能很容易通过自动重构变得不必要，为了清楚起见应该删除。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    void foo() {}
  }

  class Bar extends Foo {
    void bar() {
      Bar.super.foo();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    void foo() {}
  }

  class Bar extends Foo {
    void bar() {
      super.foo();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SimplifiableIfStatement" defaultSeverity="INFORMATION" displayName="'if' 语句可被替换为条件或布尔表达式" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以替换为使用 &lt;code&gt;&amp;&amp;&lt;/code&gt;、&lt;code&gt;||&lt;/code&gt;、&lt;code&gt;==&lt;/code&gt;、&lt;code&gt;!=&lt;/code&gt; 或 &lt;code&gt;?:&lt;/code&gt; 运算符的条件的 &lt;code&gt;if&lt;/code&gt; 语句 。
&lt;p&gt;结果通常更短，但并不总是更清晰，因此不建议在每种情况下都应用此修复程序。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (condition) return true; else return foo;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  return condition || foo;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;配置检查：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
  当建议使用 &lt;code&gt;?:&lt;/code&gt; 运算符时，请使用 &lt;b&gt;不建议使用 '?:' 运算符&lt;/b&gt; 选项禁用警告。 在这种情况下，只会突出显示 &lt;code&gt;&amp;&amp;&lt;/code&gt;、&lt;code&gt;||&lt;/code&gt;、&lt;code&gt;==&lt;/code&gt; 和 &lt;code&gt;!=&lt;/code&gt; 建议。 快速修复仍将在编辑器中可用。
&lt;/li&gt;
&lt;li&gt;
  使用 &lt;b&gt;忽略链式 'if' 语句&lt;/b&gt; 选项禁用 &lt;code&gt;if-else&lt;/code&gt; 链的警告 快速修复仍将在编辑器中可用。
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;small&gt;2018.2 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MissortedModifiers" defaultSeverity="WARNING" displayName="错位修饰符" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告修饰符不符合规范首选顺序（如 Java 语言规范中所述）的声明。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    native public final void foo();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    public final native void foo();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;使用检查设置可以：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;
      切换位置错误的注解的报告：
       （带有 &lt;code&gt;ElementType.TYPE_USE&lt;/code&gt; 的&lt;em&gt;不&lt;/em&gt;紧接在类型之前和修饰符关键字之后的注解，或其他&lt;em&gt;不&lt;/em&gt;在修饰符关键字之前的注解）。
      禁用此选项后，任何注解都可以放置在修饰符关键字之前或之后。
      将始终报告在修饰符关键字之间带有注解的修饰符列表。
    &lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;
      指定 &lt;code&gt;ElementType.TYPE_USE&lt;/code&gt; 注解是否应直接置于类型之前，即使该注解指定了其他目标。
    &lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ChainedMethodCall" defaultSeverity="WARNING" displayName="链式方法调用" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告目标是另一个方法调用的方法调用。
该快速修复会建议引入局部变量。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class X {
    int foo(File f) {
      return f.getName().length();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class X {
    int foo(File f) {
      final String name = f.getName();
      return name.length();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;使用检查选项来切换以下各项的警告：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;
      字段初始值设定项中的链式方法调用，例如 &lt;code&gt;private final int i = new Random().nextInt();&lt;/code&gt;
    &lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;
      在相同的类型上运算的链式方法调用，例如，&lt;code&gt;new StringBuilder().append("x: ").append(new X()).append("y: ").append(new Y()).toString();&lt;/code&gt;。
    &lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="OptionalContainsCollection" defaultSeverity="WARNING" displayName="'Optional' 包含数组或集合" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告包含数组或集合类型形参的 &lt;code&gt;java.util.Optional&lt;/code&gt; 或 &lt;code&gt;com.google.common.base.Optional&lt;/code&gt; 类型。
&lt;p&gt;在此类情况下，使用空的数组或集合来表示无结果更为清晰。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Optional&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; foo() {
    return Optional.empty();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此代码可能如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  List&amp;lt;Integer&amp;gt; foo() {
    return new List&amp;lt;&amp;gt;();
  }
  &lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantFieldInitialization" defaultSeverity="WARNING" displayName="冗余字段初始化" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告显式初始化为其默认值的字段。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    int foo = 0;
    List bar = null;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    int foo;
    List bar;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用检查设置可以仅报告显式 &lt;code&gt;null&lt;/code&gt; 初始化，例如：
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    int foo = 0;     // 无警告
    List bar = null; // 冗余字段初始化警告
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StreamToLoop" defaultSeverity="INFORMATION" displayName="Stream API 调用链可被替换为循环" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以自动转换为经典循环的 Stream API 链、&lt;code&gt;Iterable.forEach()&lt;/code&gt; 和 &lt;code&gt;Map.forEach()&lt;/code&gt; 调用。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String joinNonEmpty(List&amp;lt;String&amp;gt; list) {
    return list.stream() // 流可以转换为循环
      .filter(s -&gt; !s.isEmpty())
      .map(String::trim)
      .collect(Collectors.joining(", "));
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String joinNonEmpty(List&amp;lt;String&amp;gt; list) {
    StringJoiner joiner = new StringJoiner(", ");
    for (String s : list) {
      if (!s.isEmpty()) {
        String trim = s.trim();
        joiner.add(trim);
      }
    }
    return joiner.toString();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  请注意，有时此检查可能会导致轻微的语义变化。
  必须特别注意短路，因为流短路未指定读取的实际元素数。
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  &lt;i&gt;Stream API&lt;/i&gt; 在 Java 8 中出现。
  此检查有助于为向后兼容早期 Java 版本而降级。
&lt;/p&gt;
&lt;p&gt;配置检查：&lt;/p&gt;
&lt;p&gt;使用 &lt;b&gt;通过 Stream.iterator() 迭代未知的流源&lt;/b&gt; 选项来建议转换来源无法识别的流。
  在这种情况下，迭代器将从流中创建。
  例如，选择复选框时，此处将建议转换：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  List&amp;lt;ProcessHandle&amp;gt; handles = ProcessHandle.allProcesses().collect(Collectors.toList());&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在这种情况下，结果如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  List&amp;lt;ProcessHandle&amp;gt; handles = new ArrayList&amp;lt;&amp;gt;();
  for (Iterator&amp;lt;ProcessHandle&amp;gt; it = ProcessHandle.allProcesses().iterator(); it.hasNext(); ) {
    ProcessHandle allProcess = it.next();
    handles.add(allProcess);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;small&gt;2017.1 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LiteralAsArgToStringEquals" defaultSeverity="WARNING" displayName="字符串文字可以为 'equals()' 限定符" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告包含字符串文字实参的 &lt;code&gt;String.equals()&lt;/code&gt; 或 &lt;code&gt;String.equalsIgnoreCase()&lt;/code&gt; 调用。
&lt;p&gt;某些编码标准指定字符串文字应当为 &lt;code&gt;equals()&lt;/code&gt; 的限定符而不是实参，从而最大限度减少 &lt;code&gt;NullPointerException&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;可以通过快速修复交换文字和表达式。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean isFoo(String value) {
    return value.equals("foo");
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean isFoo(String value) {
    return "foo".equals(value);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnqualifiedStaticUsage" defaultSeverity="WARNING" displayName="非限定静态访问" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告未用类名称限定的 static 成员的用法。
&lt;p&gt;
如果 static 成员在同一个类中，是合法的，但可能令人困惑。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    static void foo() {}
    static int x;

    void bar() {
      foo();
      System.out.println(x);
    }

    static void baz() { foo(); }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    static void foo() {}
    static int x;

    void bar() {
      Foo.foo();
      System.out.println(Foo.x);
    }

    static void baz() { Foo.foo(); }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;使用检查设置可以切换以下各项的报告：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;
      static 字段访问&lt;br&gt;
      &lt;code&gt;void bar() { System.out.println(x); }&lt;/code&gt;
    &lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;
      对 static 方法的调用&lt;br&gt;
      &lt;code&gt;void bar() { foo(); }&lt;/code&gt;&lt;br&gt;
      &lt;code&gt;static void baz() { foo(); }&lt;/code&gt;
    &lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
  您还可以将检查配置为仅报告来自非 static 上下文的 static 成员用法。
  在上面的示例中，不会报告 &lt;code&gt;static void baz() { foo(); }&lt;/code&gt;。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SingleStatementInBlock" defaultSeverity="INFORMATION" displayName="代码块包含单条语句" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告代码块中仅有一条语句的控制流语句，并建议移除控制流语句体中的大括号。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (x &gt; 0) {
    System.out.println("x is positive");
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (x &gt; 0) System.out.println("x is positive");
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SimplifiableAnnotation" defaultSeverity="WARNING" displayName="可简化注解" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以简化为其“单个元素”或“标记”速记形式的注解。
&lt;p&gt;还会报告在 @ 符号和注解名称之间包含空格的注解。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @interface Foo { String[] value(); }

  @ Foo({"foo"})
  public String name;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @interface Foo { String[] value(); }

  @Foo("foo")
  public String name;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TypeParameterExtendsObject" defaultSeverity="WARNING" displayName="类型形参显式扩展 'Object'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告显式声明为扩展 &lt;code&gt;java.lang.Object&lt;/code&gt; 的类型形参和通配符类型实参。
&lt;p&gt;此类 'extends' 子句是冗余的，因为 &lt;code&gt;java.lang.Object&lt;/code&gt; 是所有类的父类型。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  class ClassA&amp;lt;T extends Object&amp;gt; {}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  如果由于注解而需保留 'extends Object' 子句，请禁用&lt;b&gt;注解 java.lang.Object 时忽略&lt;/b&gt;选项。
  这可能会有用，例如在您使用空值分析器并且 'extends Object' 子句包含 &lt;code&gt;@Nullable&lt;/code&gt;/&lt;code&gt;@NotNull&lt;/code&gt; 注解时。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  class MyClass&amp;lt;T extends @NotNull Object&amp;gt; {}
&lt;/code&gt;&lt;/pre&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ListIndexOfReplaceableByContains" defaultSeverity="WARNING" displayName="'List.indexOf()' 表达式可被替换为 'contains()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以用 &lt;code&gt;List.contains()&lt;/code&gt; 方法替换的任何 &lt;code&gt;List.indexOf()&lt;/code&gt; 表达式。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean hasEmptyString(List&amp;lt;String&amp;gt; list) {
    // 警告：可以简化
    return list.indexOf("") &amp;gt;= 0;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;提供的快速修复将 &lt;code&gt;indexOf&lt;/code&gt; 调用替换为 &lt;code&gt;contains&lt;/code&gt; 调用：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean hasEmptyString(List&amp;lt;String&amp;gt; list) {
    // 快速修复已应用
    return list.contains("");
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FillPermitsList" defaultSeverity="INFORMATION" displayName="密封类的 permits 子句中缺失同一文件子类" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告其 permits 子句不包含来自同一文件的某些子类的密封类。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  sealed class A {}
  final class B extends A {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  sealed class A permits B {}
  final class B extends A {}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2020.3 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessarilyQualifiedStaticallyImportedElement" defaultSeverity="WARNING" displayName="不必要的限定静态导入元素" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告用其包含类名限定的静态导入成员的用法。
&lt;p&gt;此类限定不必要且可移除，因为可以通过成员名称直接访问静态导入成员。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  import static foo.Test.WIDTH;

  class Bar {
    void bar() {
      System.out.println(Test.WIDTH);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  import static foo.Test.WIDTH;

  class Bar {
    void bar() {
      System.out.println(WIDTH);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CallToStringConcatCanBeReplacedByOperator" defaultSeverity="WARNING" displayName="对 'String.concat()' 的调用可被替换为 '+'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对 &lt;code&gt;java.lang.String.concat()&lt;/code&gt; 的调用。
&lt;p&gt;
  如果在带有常量实参的常量上调用该方法，可以将此类调用替换为 &lt;code&gt;+&lt;/code&gt; 运算符，以提高清晰度和性能。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String foo(String name) {
    return name.concat("foo");
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String foo(String name) {
    return name + "foo";
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessarilyQualifiedStaticUsage" defaultSeverity="WARNING" displayName="不必要的限定静态访问" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告用类名限定的 static 成员的用法。
&lt;p&gt;
  此类限定不必要，并且可以安全移除。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    static void foo() {}
    static int x;

    void bar() {
      Foo.foo();
      System.out.println(Foo.x);
    }

    static void baz() { Foo.foo(); }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    static void foo() {}
    static int x;

    void bar() {
      foo();
      System.out.println(x);
    }

    static void baz() { foo(); }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用检查选项可以切换以下各项的报告：
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;static 字段访问：&lt;br&gt;&lt;code&gt;void bar() { System.out.println(Foo.x); }&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对 static 方法的调用：&lt;br&gt;&lt;code&gt;void bar() { Foo.foo(); }&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
  此外，您可以将检查配置为仅报告 static 上下文中的 static 成员用法。 在这种情况下，只会报告 &lt;code&gt;static void baz() { Foo.foo(); }&lt;/code&gt;。
&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConstantExpression" defaultSeverity="INFORMATION" displayName="可以计算常量表达式" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告编译时常量表达式并建议用它们的实际值替换它们。 例如，系统会提示您将 “2 + 2” 替换为 “4”。

&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2018.1 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ExtendsObject" defaultSeverity="WARNING" displayName="类显式扩展 'Object'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告一个明确声明要扩展&lt;code&gt; java.lang.Object&lt;/code&gt; 的类。
&lt;p&gt;这种声明是冗余的，可以安全地删除。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class MyClass extends Object {
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;快速修复删除了冗余的 &lt;code&gt;extends Object&lt;/code&gt; 子句：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class MyClass {
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConstantOnWrongSideOfComparison" defaultSeverity="WARNING" displayName="常量位于比较的错误一侧" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告常量值在错误一侧的比较运算。
&lt;p&gt;某些编码约定会指定常量应该位于比较的特定一侧，要么左侧，要么右侧。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean compare(int x) {
    return 1 &amp;gt; x; // 位于比较左侧的常量 '1'
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean compare(int x) {
    return x &amp;lt; 1;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用检查设置可以选择比较中的常量一侧，并选择 &lt;code&gt;null&lt;/code&gt; 文字位于错误一侧时是否发出警告。
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;2019.2 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryConstructor" defaultSeverity="WARNING" displayName="冗余无实参构造函数" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告不必要的构造函数。
&lt;p&gt;
  如果构造函数是类的唯一构造函数，没有形参，与其包含类具有相同的访问修饰符，并且除了显式或隐式调用不带实参的超类构造函数外，不执行任何初始化，则不需要构造函数。
  此类构造函数可以安全地移除，因为即使没有指定，它也会由编译器生成。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Foo {
    public Foo() {}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Foo {}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
使用检查设置可以忽略具有注解的不必要的构造函数。
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryFullyQualifiedName" defaultSeverity="INFORMATION" displayName="不必要的完全限定名称" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以缩短的完全限定类名。
&lt;p&gt;快速修复会缩短完全限定名称并在必要时添加导入语句。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class ListWrapper {
    java.util.List&amp;lt;Integer&amp;gt; l;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  import java.util.List;
  class ListWrapper {
    List&amp;lt;Integer&amp;gt; l;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;配置检查：&lt;/p&gt;

&lt;p&gt;
  使用 &lt;b&gt;在 Java 9 模块语句中忽略&lt;/b&gt; 选项忽略 Java 9 &lt;code&gt;provides&lt;/code&gt; 和 &lt;code&gt;uses&lt;/code&gt; 模块语句中的完全限定名称。
&lt;p&gt;
  在&lt;a href="settings://preferences.sourceCode.Java?JavaDoc%20Inner"&gt;设置| 编辑器 | 代码样式 | Java | 导入&lt;/a&gt; 中，请使用以下选项配置检查：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;如果应使用外部类限定对内部类的引用，请使用 &lt;b&gt;为内部类插入导入&lt;/b&gt; 选项。&lt;/li&gt;
  &lt;li&gt;使用&lt;b&gt;在 JavaDoc 中使用完全限定类名&lt;/b&gt; 选项允许在 Javadoc 中使用完全限定名称。&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessarySuperConstructor" defaultSeverity="WARNING" displayName="对 'super()' 的调用不必要" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在对象构造期间对无实参超类构造函数的调用。
&lt;p&gt;此类调用不必要，可以移除。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    Foo() {
      super();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    Foo() {
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReassignedVariable" defaultSeverity="TEXT ATTRIBUTES" displayName="重新分配的变量" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告会使阅读和理解代码变得复杂的重新赋值的变量。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int value = 2 * (height + width);
  System.out.println("perimeter: " + value);

  value = height * width;
  System.out.println("area: " + value);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ArrayCanBeReplacedWithEnumValues" defaultSeverity="INFORMATION" displayName="可以将数组替换为枚举值" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以替换为 &lt;code&gt;EnumType.values()&lt;/code&gt; 调用的枚举常量数组。
&lt;p&gt;通常，在更新这样一个枚举时，您必须同时更新数组。 但是，如果您改用 &lt;code&gt;EnumType.values()&lt;/code&gt;，则无需修改。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  enum States {
     NOT_RUN, IN_PROGRESS, FINISHED;
  }
  
  handleStates(new States[] {NOT_RUN, IN_PROGRESS, FINISHED});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  handleStates(States.values());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;small&gt;2019.1 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnclearBinaryExpression" defaultSeverity="INFORMATION" displayName="具有不同优先级的多个运算符" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告由不带圆括号的不同运算符组成的二元、条件或 &lt;code&gt;instanceof&lt;/code&gt; 表达式。 由于运算符的优先级规则不同，此类表达式的可读性可能较低。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int n = 3 + 9 * 8 + 1;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int n = 3 + (9 * 8) + 1;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessarilyQualifiedInnerClassAccess" defaultSeverity="INFORMATION" displayName="不必要的限定内部类访问" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对不必要地用封闭类的名称进行了限定的内部类的任何引用。
&lt;p&gt;此类限定可以安全地移除，这有时会为内部类添加导入。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class X {
     X.Y foo;
     class Y{}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class X {
     Y foo;
     class Y{}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;使用&lt;b&gt;忽略需要导入的引用&lt;/b&gt;选项可忽略对内部类的引用，其中移除限定会添加导入。
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TryStatementWithMultipleResources" defaultSeverity="INFORMATION" displayName="可以拆分具有多个资源的 'try' 语句" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告带有多个资源的 &lt;code&gt;try&lt;/code&gt; 语句，这些语句可以自动拆分为多条 try-with-resources 语句。
&lt;p&gt;这种转换对于进一步重构很有用 （例如，用于将嵌套的 &lt;code&gt;try&lt;/code&gt; 语句提取到单独的方法中）。 &lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  try (FileInputStream in = new FileInputStream("in.txt");
     FileOutputStream out = new FileOutputStream("out.txt")) {
     /*读取和写入*/
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  try (FileInputStream in = new FileInputStream("in.txt")) {
    try (FileOutputStream out = new FileOutputStream("out.txt")) {
      /*读取和写入*/
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="EscapedSpace" defaultSeverity="WARNING" displayName="'\s' 转义序列的非终止使用" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;"\s"&lt;/code&gt; 转义序列在除文本块行结尾以外的任何位置或在多个空格的序列内的用法。
&lt;code&gt;"\s"&lt;/code&gt; 转义序列用于在文本块行末尾编码一个空格，其中，普通空格将被修剪。
在其他位置，以及在常规字符串文字中，&lt;code&gt;"\s"&lt;/code&gt; 与普通空格字符 (&lt;code&gt;"&amp;nbsp;"&lt;/code&gt;) 相同。
使用 &lt;code&gt;"\s"&lt;/code&gt; 会造成困惑，并且可能出错，尤其是在将字符串解释为正则表达式的情况下。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (str.matches("\s+")) {...}
&lt;/code&gt;&lt;/pre&gt;
在这里，&lt;code&gt;"\\s+"&lt;/code&gt; 可能是有意为之（以匹配任何空白字符）。 如果不是，使用 &lt;code&gt;str.matches("&amp;nbsp;+")&lt;/code&gt; 则不那么容易造成困惑。
&lt;p&gt;
  提供的快速修复只是将 &lt;code&gt;\s&lt;/code&gt; 替换为空格字符。
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;仅当项目或模块的语言级别为 15 或更高时，此检查才会报告。&lt;/p&gt;
&lt;p&gt;&lt;small&gt;2022.3 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryThis" defaultSeverity="WARNING" displayName="不必要的 'this' 限定符" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告不必要的 &lt;code&gt;this&lt;/code&gt; 限定符。
&lt;p&gt;
  使用 &lt;code&gt; this &lt;/code&gt; 来消除代码引用的歧义在许多编码样式中都不受鼓励，并且很容易通过自动重构变得不必要。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    int x;
    void foo() {
      this.x = 2;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    int x;
    void foo() {
      x = 2;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用检查设置可以忽略对字段的赋值。
  例如，&lt;code&gt;this.x = 2;&lt;/code&gt; 不会被报告，但 &lt;code&gt;int y = this.x;&lt;/code&gt; 会被报告。
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessarySuperQualifier" defaultSeverity="WARNING" displayName="不必要的 'super' 限定符" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告方法调用和字段引用中不必要的 &lt;code&gt;super&lt;/code&gt; 限定符。
&lt;p&gt;
  当超类的字段或方法在调用类中未被隐藏/重写时，不需要 &lt;code&gt;super&lt;/code&gt; 限定符。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    void foo() {}
  }

  class Bar extends Foo {
    void bar() {
      super.foo();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    void foo() {}
  }

  class Bar extends Foo {
    void bar() {
      foo();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用检查设置可以忽略有助于区分超类成员访问与外部类的同名成员的限定符。
&lt;p&gt;
&lt;p&gt;
  另请参阅以下检查：
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;i&gt;Java | 可见性 | 继承字段的访问类似于访问周围代码中的元素&lt;/i&gt;&lt;/li&gt;
  &lt;li&gt;&lt;i&gt;Java | 可见性 | 对继承方法的调用类似于对局部方法的调用&lt;/i&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SwitchLabeledRuleCanBeCodeBlock" defaultSeverity="INFORMATION" displayName="标记的 switch 规则可以具有代码块" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;switch&lt;/code&gt; 表达式或带有表达式体的增强 &lt;code&gt;switch&lt;/code&gt; 语句的规则。
这些可以转换为代码块。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String message = switch (errorCode) {
    case 404 -&gt; "Not found!";
    ...
  };
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String message = switch (errorCode) {
    case 404 -&gt; {
                yield "Not found!";
            }
    ...
  };
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;仅当项目或模块的语言级别为 14 或更高时，此检查才会报告。&lt;/p&gt;
&lt;p&gt;&lt;small&gt;2019.1 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConfusingOctalEscape" defaultSeverity="WARNING" displayName="引起混淆的八进制转义序列" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告包含紧跟数字的八进制转义序列的字符串文字。
&lt;p&gt;此类字符串可能令人困惑，并且通常是转义码创建错误的结果。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  System.out.println("\1234"); // 紧跟数字的八进制转义序列 '\123'
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConditionalCanBeOptional" defaultSeverity="INFORMATION" displayName="条件可被替换为 Optional" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 null 检查条件并建议用 &lt;code&gt;Optional&lt;/code&gt; 链替换它们。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  return str == null ? "" : str.trim();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  return Optional.ofNullable(str).map(String::trim).orElse("");
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;虽然替换并不总是更短，但它可能有助于进一步重构（例如，将方法返回值更改为 &lt;code&gt;Optional&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;请注意，当条件的非 null 分支返回 null 值时，相应的映射步骤将产生一个空的 &lt;code&gt;Optional&lt;/code&gt;，可能会改变语义。 如果不能静态证明保留语义，则快速修复操作名称将包含 “（可能更改语义）” 通知，并关闭检查高亮显示。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;仅当项目或模块的语言级别为 8 或更高时，此检查才会报告。&lt;/p&gt;
&lt;p&gt;&lt;small&gt;2018.1 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ImplicitCallToSuper" defaultSeverity="WARNING" displayName="隐式调用 'super()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告不以调用 "super" 构造函数或同一类的另一个构造函数开头的构造函数。
&lt;p&gt;可以认为是此类构造函数隐式地从调用 &lt;code&gt;super()&lt;/code&gt; 开始。 某些编码标准倾向于显式地调用 &lt;code&gt;super()&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    Foo() {}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    Foo() {
      super();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用检查设置可以忽略直接从 &lt;code&gt;Object&lt;/code&gt; 扩展的类。
  例如：
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    Foo() {} // 未报告
  }

  class Bar extends Foo {
    Bar() {} // 对 'super()' 的隐式调用
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryModifier" defaultSeverity="WARNING" displayName="不必要的修饰符" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告冗余的修饰符并建议移除它们。
结果代码会更短，但其行为和含义将保持不变。
&lt;p&gt;&lt;b&gt;示例 1：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  // 在 Java 17 和更高版本下，所有代码都是隐式 strictfp
  strictfp class X {

    // 内部枚举为隐式 static
    static enum Inner {
        A, B, C
    }

    // 内部记录为隐式 static
    static record R() {
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;b&gt;示例 2：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  final record R() {
    // 所有记录均为隐式 final
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;b&gt;示例 3：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  // 所有接口均为隐式 abstract
  abstract interface Printer {

    // 所有接口成员均为隐式 public
    public int size();

    // 接口的所有内部类均为隐式 static
    static class Inner {}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CharsetObjectCanBeUsed" defaultSeverity="WARNING" displayName="可以使用标准 'Charset' 对象" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以用预定义的 &lt;code&gt;StandardCharsets.UTF_8&lt;/code&gt; 代码替换其中常量字符集 &lt;code&gt;String&lt;/code&gt; 文字（例如，&lt;code&gt;"UTF-8"&lt;/code&gt;）的方法和构造函数。
&lt;p&gt;修复后可以加快代码的速度，因为字符集查找变得不必要。
  此外，您可能也不需要捕捉 &lt;code&gt;UnsupportedEncodingException&lt;/code&gt;。 在这种情况下，catch 块将被自动删除。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  try {
    byte[] bytes = "str".getBytes("UTF-8");
  } catch (UnsupportedEncodingException e) {
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  byte[] bytes = "str".getBytes(StandardCharsets.UTF_8);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;该检查在 Java 7 及更高版本中可用。&lt;/p&gt;
&lt;p&gt;&lt;small&gt;2018.2 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryFinalOnLocalVariableOrParameter" defaultSeverity="WARNING" displayName="局部变量或形参上存在不必要的 'final'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告不必要地声明为 &lt;code&gt;final&lt;/code&gt; 的局部变量或形参。
&lt;p&gt;出于简洁的原因，某些编码标准不赞成声明为 &lt;code&gt;final&lt;/code&gt; 的变量。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    Foo(Object o) {}

    void bar(final Object o) {
      new Foo(o);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    Foo(Object o) {}

    void bar(Object o) {
      new Foo(o);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用检查选项可以切换以下各项的报告：
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    局部变量
  &lt;/li&gt;
  &lt;li&gt;
    形参（包括 &lt;code&gt;catch&lt;/code&gt; 块的形参和增强型 &lt;code&gt;for&lt;/code&gt; 语句）
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
  此外，您可以将检查配置为仅报告 &lt;code&gt;abstract&lt;/code&gt; 或接口方法的 &lt;code&gt;final&lt;/code&gt; 形参，这可能被认为是多余的，因为此类标记不会影响这些方法的实现。
&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SimplifiableEqualsExpression" defaultSeverity="WARNING" displayName="'equals()' 调用之前的 'null' 检查不必要" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告与后接使用常量实参调用 &lt;code&gt;equals()&lt;/code&gt; 的 &lt;code&gt;null&lt;/code&gt; 的比较。

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (s != null &amp;&amp; s.equals("literal")) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if ("literal".equals(s)) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
    当 &lt;code&gt;equals()&lt;/code&gt; 的实参被证明不是 &lt;code&gt;null&lt;/code&gt; 时，使用检查设置可以报告带有非常量实参的 &lt;code&gt;equals()&lt;/code&gt; 调用。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="OptionalIsPresent" defaultSeverity="WARNING" displayName="非函数样式 'Optional.isPresent()' 用法" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以用函数样式重写的条件，如 &lt;code&gt;if(Optional.isPresent())&lt;/code&gt; 或 &lt;code&gt;if(Optional.isEmpty())&lt;/code&gt;，因为它更短并更容易阅读。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (str.isPresent()) str.get().trim();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  str.ifPresent(String::trim);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;仅当项目或模块的语言级别为 8 或更高时，此检查才会报告。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryBlockStatement" defaultSeverity="INFORMATION" displayName="不必要的代码块" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对程序的语义冗余的代码块，并且可以用其内容替换。
&lt;p&gt;作为 &lt;code&gt;if&lt;/code&gt;、&lt;code&gt;do&lt;/code&gt;、&lt;code&gt;while&lt;/code&gt; 或 &lt;code&gt;for&lt;/code&gt; 语句主体的代码块将不会被此检查报告。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void foo() {
    { // 不必要
      int result = call();
      analyze(result);
    } // 不必要
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;配置检查：&lt;/p&gt;
&lt;p&gt;
使用 &lt;b&gt;忽略 'switch' 语句的分支&lt;/b&gt; 选项来忽略用作 switch 语句分支的代码块。
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SizeReplaceableByIsEmpty" defaultSeverity="WARNING" displayName="'size() == 0' 可被替换为 'isEmpty()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;0&lt;/code&gt; 文字可以替换为对 &lt;code&gt;.isEmpty()&lt;/code&gt; 的调用的 &lt;code&gt;.size()&lt;/code&gt; 或 &lt;code&gt;.length()&lt;/code&gt; 比较。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean emptyList = list.size() == 0;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean emptyList = list.isEmpty();
  &lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用&lt;b&gt;忽略类&lt;/b&gt;表可以添加不应为之替换任何 &lt;code&gt;.size()&lt;/code&gt; 或 &lt;code&gt;.length()&lt;/code&gt; 比较的类。
&lt;/p&gt;
&lt;p&gt;使用&lt;b&gt;忽略将替换为 &lt;code&gt;'!isEmpty()'&lt;/code&gt; 的表达式&lt;/b&gt;选项可以忽略任何将替换为 &lt;code&gt;!isEmpty()&lt;/code&gt; 的表达式。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AssertMessageNotString" defaultSeverity="WARNING" displayName="'assert' 消息不是字符串" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告非 &lt;code&gt;java.lang.String&lt;/code&gt; 类型的 &lt;code&gt;assert&lt;/code&gt; 消息。
&lt;p&gt;使用字符串可以提供更多信息，有助于诊断失败或断言原因。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void foo(List&amp;lt;Integer&amp;gt; myList) {
    assert myList.isEmpty() : false;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
使用&lt;b&gt;仅当 &lt;code&gt;assert&lt;/code&gt; 消息为 'boolean' 或 'java.lang.Boolean' 时发出警告&lt;/b&gt;选项可以仅在 &lt;code&gt;assert&lt;/code&gt; 消息类型为 &lt;code&gt;boolean&lt;/code&gt; 或 &lt;code&gt;java.lang.Boolean&lt;/code&gt; 时发出警告。
&lt;code&gt;boolean&lt;/code&gt; 详细消息不太可能提供有关断言失败的其他信息，可能是由于错误输入 &lt;code&gt;:&lt;/code&gt; 而不是 &lt;code&gt;&amp;&lt;/code&gt; 所致。
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="MultiCatchCanBeSplit" defaultSeverity="INFORMATION" displayName="多 catch 可拆分为单独的 catch 块" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告多个 &lt;code&gt;catch&lt;/code&gt; 部分并建议将它们拆分为单独的 &lt;code&gt;catch&lt;/code&gt; 块。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  try {
    int i = getIndex();
  } catch (NullPointerException|IndexOutOfBoundsException e) {
    e.printStackTrace();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  try {
    int i = getIndex();
  } catch (NullPointerException e) {
    e.printStackTrace();
  } catch (IndexOutOfBoundsException e) {
    e.printStackTrace();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  &lt;i&gt;多&lt;/i&gt; &lt;code&gt;catch&lt;/code&gt; 在 Java 7 中出现。
  此检查有助于为向后兼容早期 Java 版本而降级。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="EqualsCalledOnEnumConstant" defaultSeverity="WARNING" displayName="对枚举值调用了 'equals()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告枚举常量上的 &lt;code&gt;equals()&lt;/code&gt; 调用。
&lt;p&gt;此类调用可以替换为同一性比较 (&lt;code&gt;==&lt;/code&gt;)，因为只有两个枚举常量具备相同的同一性时，它们才相等。&lt;/p&gt;
&lt;p&gt;可以通过快速修复将该调用更改为比较。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean foo(MyEnum value) {
    return value.equals(MyEnum.FOO);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean foo(MyEnum value) {
    return value == MyEnum.FOO;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LambdaParameterTypeCanBeSpecified" defaultSeverity="INFORMATION" displayName="可以指定 lambda 形参类型" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告未指定其类型的 lambda 形参并建议添加缺少的类型声明。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Function&amp;lt;String, Integer&amp;gt; length = a -&amp;gt; a.length();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Function&amp;lt;String, Integer&amp;gt; length = (String a) -&amp;gt; a.length();
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;仅当项目或模块的语言级别为 8 或更高时，此检查才会报告。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="数据流" path="JavaScript and TypeScript"><inspection shortName="ReuseOfLocalVariableJS" defaultSeverity="WARNING" displayName="局部变量的重用" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告重用局部变量并使用无关
初始变量用法的新值覆盖其值的情况。  以这种方式重用局部变量可能会造成混淆，
因为局部变量的预期语义可能随每种用法而变化。  如果代码更改导致预期被覆盖的值任然存在，那么也可能导致错误。   优良的作法是保持变量生命周期尽可能短，而不要为了简洁重用局部变量。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryLocalVariableJS" defaultSeverity="WARNING" displayName="冗余局部变量" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告不会让函数更易于理解的不必要局部变量： &lt;ul&gt;
&lt;li&gt;立刻返回的局部变量&lt;/li&gt;
&lt;li&gt;立刻赋值给另一个变量并且不再使用的局部变量&lt;/li&gt;
&lt;li&gt;总是与另一个局部变量或形参的值相同的局部变量。&lt;/li&gt;&lt;/ul&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
使用下面的复选框以使该检查忽略立刻返回或抛出的变量。  为清晰起见和易于调试，某些编码样式建议使用此类变量。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Thymeleaf" path=""><inspection shortName="ThymeleafVariablesResolveInspection" defaultSeverity="WEAK WARNING" displayName="Thymeleaf 表达式变量中未解析的引用" enabled="false" language="ThymeleafExpressions" pluginId="com.intellij.thymeleaf" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告未解析的引用和无效的 Thymeleaf 表达式。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
&amp;lt;html xmlns:th="https://www.thymeleaf.org"&amp;gt;
&amp;lt;body&amp;gt;
  &amp;lt;form th:object="${&lt;strong&gt;unknownPet&lt;/strong&gt;}"  &amp;lt;!-- Cannot resolve 'unknownPet'  --&amp;gt;
        class="form-horizontal" method="post"&amp;gt;
    &amp;lt;input type="hidden" name="id" th:value="*{&lt;strong&gt;id&lt;/strong&gt;}" /&amp;gt; &amp;lt;!-- 无法解析 'id'  --&amp;gt;
  &amp;lt;/form&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ThymeleafDialectDomInspection" defaultSeverity="ERROR" displayName="Thymeleaf 方言扩展错误" enabled="false" language="ThymeleafExpressions" pluginId="com.intellij.thymeleaf" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 Thymeleaf Dialect Extension &lt;code&gt;&amp;lt;dialect&amp;gt;&lt;/code&gt; 文件中的不正确元素：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;对不可实例化类的引用&lt;/li&gt;
  &lt;li&gt;对不扩展所需类的类的引用&lt;/li&gt;
  &lt;li&gt;对范围不适当的类的引用&lt;/li&gt;
  &lt;li&gt;空标记和特性值&lt;/li&gt;
  &lt;li&gt;与所需模式不匹配的标记和特性值（例如，Java 标识符）&lt;/li&gt;
  &lt;li&gt;不包含必需子标记或特性的标记&lt;/li&gt;
  &lt;li&gt;定义具有重复名称的对象的标记&lt;/li&gt;
&lt;/ul&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ThymeleafMessagesResolveInspection" defaultSeverity="ERROR" displayName="未解析的消息资源键" enabled="false" language="ThymeleafExpressions" pluginId="com.intellij.thymeleaf" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告未解析的消息资源键。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
&amp;lt;html xmlns:th="https://www.thymeleaf.org"&amp;gt;
 &amp;lt;body&amp;gt;
    &amp;lt;h1 th:text="#{&lt;strong&gt;welcome.unknown&lt;/strong&gt;}"&amp;gt;Hallo, World&amp;lt;/h1&amp;gt; &amp;lt;!-- 无法解析属性键 --&amp;gt;
 &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Android Lint: Compliance" path=""><inspection shortName="AndroidLintQueryAllPackagesPermission" defaultSeverity="ERROR" displayName="Using the QUERY_ALL_PACKAGES permission" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using the QUERY_ALL_PACKAGES permission&lt;br&gt;&lt;br&gt;If you need to query or interact with other installed apps, you should be using a &lt;code&gt;&amp;lt;queries&gt;&lt;/code&gt; declaration in your manifest. Using the QUERY_ALL_PACKAGES permission in order to see all installed apps is rarely necessary, and most apps on Google Play are not allowed to have this permission.&lt;br&gt;&lt;br&gt;Issue id: QueryAllPackagesPermission&lt;br&gt;&lt;br&gt;&lt;a href="https://g.co/dev/packagevisibility"&gt;https://g.co/dev/packagevisibility&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintExpiringTargetSdkVersion" defaultSeverity="ERROR" displayName="TargetSdkVersion Soon Expiring" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;TargetSdkVersion Soon Expiring&lt;br&gt;&lt;br&gt;In the second half of 2018, Google Play will require that new apps and app updates target API level 26 or higher. This will be required for new apps in August 2018, and for updates to existing apps in November 2018.&lt;br/&gt;
&lt;br/&gt;
Configuring your app to target a recent API level ensures that users benefit from significant security and performance improvements, while still allowing your app to run on older Android versions (down to the &lt;code&gt;minSdkVersion&lt;/code&gt;).&lt;br/&gt;
&lt;br/&gt;
This lint check starts warning you some months &lt;b&gt;before&lt;/b&gt; these changes go into effect if your &lt;code&gt;targetSdkVersion&lt;/code&gt; is 25 or lower. This is intended to give you a heads up to update your app, since depending on your current &lt;code&gt;targetSdkVersion&lt;/code&gt; the work can be nontrivial.&lt;br/&gt;
&lt;br/&gt;
To update your &lt;code&gt;targetSdkVersion&lt;/code&gt;, follow the steps from "Meeting Google Play requirements for target API level", &lt;a href="https://developer.android.com/distribute/best-practices/develop/target-sdk.html"&gt;https://developer.android.com/distribute/best-practices/develop/target-sdk.html&lt;/a&gt;&lt;br&gt;&lt;br&gt;Issue id: ExpiringTargetSdkVersion&lt;br&gt;&lt;br&gt;&lt;a href="https://support.google.com/googleplay/android-developer/answer/113469#targetsdk"&gt;https://support.google.com/googleplay/android-developer/answer/113469#targetsdk&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintExpiredTargetSdkVersion" defaultSeverity="ERROR" displayName="TargetSdkVersion No Longer Supported" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;TargetSdkVersion No Longer Supported&lt;br&gt;&lt;br&gt;As of the second half of 2018, Google Play requires that new apps and app updates target API level 26 or higher.&lt;br/&gt;
&lt;br/&gt;
Configuring your app to target a recent API level ensures that users benefit from significant security and performance improvements, while still allowing your app to run on older Android versions (down to the &lt;code&gt;minSdkVersion&lt;/code&gt;).&lt;br/&gt;
&lt;br/&gt;
To update your &lt;code&gt;targetSdkVersion&lt;/code&gt;, follow the steps from "Meeting Google Play requirements for target API level", &lt;a href="https://developer.android.com/distribute/best-practices/develop/target-sdk.html"&gt;https://developer.android.com/distribute/best-practices/develop/target-sdk.html&lt;/a&gt;&lt;br&gt;&lt;br&gt;Issue id: ExpiredTargetSdkVersion&lt;br&gt;&lt;br&gt;&lt;a href="https://support.google.com/googleplay/android-developer/answer/113469#targetsdk"&gt;https://support.google.com/googleplay/android-developer/answer/113469#targetsdk&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintPlaySdkIndexNonCompliant" defaultSeverity="ERROR" displayName="Library has policy issues in SDK Index" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Library has policy issues in SDK Index&lt;br&gt;&lt;br&gt;This library version has policy issues that will block publishing in the Google Play Store.&lt;br&gt;&lt;br&gt;Issue id: PlaySdkIndexNonCompliant&lt;br&gt;&lt;br&gt;&lt;a href="https://play.google.com/sdks"&gt;https://play.google.com/sdks&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintOutdatedLibrary" defaultSeverity="ERROR" displayName="Outdated Library" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Outdated Library&lt;br&gt;&lt;br&gt;Your app is using an outdated version of a library. This may cause violations of Google Play policies (see &lt;a href="https://play.google.com/about/monetization-ads/ads/"&gt;https://play.google.com/about/monetization-ads/ads/&lt;/a&gt;) and/or may affect your app&amp;#8217;s visibility on the Play Store.&lt;br/&gt;
&lt;br/&gt;
Please try updating your app with an updated version of this library, or remove it from your app.&lt;br&gt;&lt;br&gt;Issue id: OutdatedLibrary&lt;br&gt;&lt;br&gt;&lt;a href="https://play.google.com/sdks"&gt;https://play.google.com/sdks&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection></group><group name="Javadoc" path="Java"><inspection shortName="PackageDotHtmlMayBePackageInfo" defaultSeverity="WARNING" displayName="'package.html' 可以转换为 'package-info.java'" enabled="false" language="HTML" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告用于记录软件包的任何 &lt;code&gt;package.html&lt;/code&gt; 文件。
&lt;p&gt;从 JDK 1.5 开始，建议您改用 &lt;code&gt;package-info.java&lt;/code&gt; 文件，因为此类文件还可以包含软件包注解。 这样，package-info.java 就变成了软件包级别注解和文档的唯一仓库。&lt;/p&gt;
&lt;p&gt;示例：&lt;code&gt;package.html&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
&amp;lt;html&amp;gt;
  &amp;lt;body&amp;gt;
    Documentation example.
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;应用该快速修复后：&lt;code&gt;package-info.java&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
/**
 * Documentation example.
 */
package com.sample;
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JavadocDeclaration" defaultSeverity="WARNING" displayName="Javadoc 声明问题" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告具有以下问题的 Javadoc 注释和标记：
&lt;ul&gt;
  &lt;li&gt;标记名称无效&lt;/li&gt;
  &lt;li&gt;标记描述不完整&lt;/li&gt;
  &lt;li&gt;标记重复&lt;/li&gt;
  &lt;li&gt;缺少 Javadoc 描述&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  /**
   * 标记名称无效
   * @poram param description
   */
  public void sample(int param){
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  /**
   * 指向自身 {@link #sample(int)}
   */
  public void sample(int param){
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该快速修复会将未知的 Javadoc 标记添加到用户定义的附加标记列表中。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;使用下面的文本字段可以定义附加 Javadoc 标记。&lt;/p&gt;
&lt;p&gt;使用第一个复选框可以忽略重复的 'throws' 标记。&lt;/p&gt;
&lt;p&gt;使用第二个复选框可以忽略描述中第一句话缺失或不完整的问题。&lt;/p&gt;
&lt;p&gt;使用第三个复选框可以忽略指向自身的引用。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JavadocReference" defaultSeverity="ERROR" displayName="声明在Javadoc引用中有问题" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 Javadoc 注释中未解析的引用。
&lt;p&gt;在以下示例中，由于缺少 &lt;code&gt;someParam&lt;/code&gt; 形参，将高亮显示该形参：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
class A {
    /**
     * @param someParam description
     **/
    void foo() {
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  禁用&lt;b&gt;报告无法访问的符号&lt;/b&gt;选项，可忽略引用缺少的方法形参、类、字段和方法的标记。&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="UnnecessaryJavaDocLink" defaultSeverity="WARNING" displayName="不必要的 Javadoc 链接" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告引用拥有注释的方法、拥有注释的方法的 super 方法或包含注释的类的 Javadoc &lt;code&gt;@see&lt;/code&gt;、&lt;code&gt;{@link}&lt;/code&gt; 和 &lt;code&gt;{@linkplain}&lt;/code&gt; 标记。
&lt;p&gt;此类链接不必要，可以通过此检查的快速修复安全移除。 如果标记是唯一内容，快速修复将移除整个 Javadoc 注释。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Example {
    /**
     * @see Example#method
     */
    public void method() { }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
class Example {
  public void method() { }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
使用下面的复选框可以忽略指向 super 方法的内联链接（&lt;code&gt;{@link}&lt;/code&gt; 和 &lt;code&gt;{@linkplain}&lt;/code&gt;）。 尽管 Javadoc 工具会自动添加指向所有 super 方法的链接，但有时在 Javadoc 注释的文本中可能需要指向 super 方法的内联链接。

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="HtmlTagCanBeJavadocTag" defaultSeverity="WARNING" displayName="'&lt;code&gt;...&lt;/code&gt;' 可被替换为 '{@code ...}'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;&amp;lt;code&amp;gt;&lt;/code&gt; 标记在 Javadoc 注释中的用法。
从 Java 5 起，这些标记可以替换为 &lt;code&gt;{@code ...}&lt;/code&gt; 结构。
这允许在注释中使用尖括号 &lt;code&gt;&amp;lt;&lt;/code&gt; 和 &lt;code&gt;&amp;gt;&lt;/code&gt; 而不是 HTML 字符实体。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  /**
   * @return empty &amp;lt;code&amp;gt;ArrayList&amp;amp;lt;Integer&amp;amp;gt;&amp;lt;/code&amp;gt;
   */
  List&amp;lt;Integer&amp;gt; getList(){ ... }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  /**
   * @return empty {@code ArrayList&amp;lt;Integer&amp;gt;}
   */
  List&amp;lt;Integer&amp;gt; getList(){ ... }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JavadocHtmlLint" defaultSeverity="ERROR" displayName="Javadoc中的HTML问题(DocLint)" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告自 Java 8 以来 DocLint 报告的 Javadoc 注释中的相同 HTML 问题。
&lt;p&gt;该检查发现以下问题：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;自闭合、未闭合、未知、放错位置或空的标记&lt;/li&gt;
  &lt;li&gt;未知或错误的特性&lt;/li&gt;
  &lt;li&gt;放错位置的文本&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
/**
 * 未知标记：List&amp;lt;String&amp;gt;
 * 未闭合标记：error&amp;lt;/b&amp;gt;
 * 放错位置的文本或标记：&amp;lt;ul&amp;gt;&amp;lt;li&amp;gt;one&amp;lt;/li&amp;gt;, &amp;lt;li&amp;gt;two&amp;lt;/li&amp;gt;&amp;lt;/ul&amp;gt;
 * 错误或空的特性：&amp;lt;a href=""&amp;gt;&amp;lt;/a&amp;gt;
 * 自闭合标记：&amp;lt;br/&amp;gt;
 * …
 */
void sample(){ }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JavadocBlankLines" defaultSeverity="WARNING" displayName="空行应替换为 &lt;p&gt; 以换行" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 Javadoc 注释中的空行。
&lt;p&gt;
  Javadoc 中的空行可能表示将文本拆分为不同段落的意图。 但是，Javadoc 工具和 IntelliJ IDEA 在呈现文档注释时会忽略它们。
&lt;/p&gt;
&lt;p&gt;
  该快速修复会建议将空行替换为段落标记 (&amp;lt;p&amp;gt;)。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Main {
    /**
     * 不起作用。
     *
     * 完全不起作用
     */
    void foo() {}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Main {
    /**
     * 不起作用。
     * &amp;lt;p&amp;gt;
     * 完全不起作用
     */
    void foo() {}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2022.1 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="MismatchedJavadocCode" defaultSeverity="WARNING" displayName="Javadoc 和代码不匹配" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告用英语编写的与方法声明冲突的方法规范部分。 这包括：
&lt;ul&gt;
  &lt;li&gt;方法被指定为返回 &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt;，但其返回值类型不是布尔。&lt;/li&gt;
  &lt;li&gt;方法被指定为返回 &lt;code&gt;null&lt;/code&gt;，但被注解为 &lt;code&gt;@NotNull&lt;/code&gt; 或其返回值类型为基元。&lt;/li&gt;
  &lt;li&gt;方法被指定为返回列表，但其返回值类型为集合或数组。&lt;/li&gt;
  &lt;li&gt;以此类推。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  /**
   * @return true if user is found, false otherwise
   */
  User findUser(String name);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  请注意，误报是可能的，因为此检查会试图解释一种人类语言。 然而，如果检查不正确报告，描述仍然可能令人困惑，应该重写。
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  &lt;small&gt;2022.3 最新变化&lt;/small&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReplaceWithJavadoc" defaultSeverity="INFORMATION" displayName="可用 Javadoc 替换的注释" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告属于可被替换为 Javadoc 注释的字段、方法或类的常规注释。

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Main {
    /*
    * Hello,
    */
    // World!
    void f() {
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Main {
    /**
     * Hello,
     * World!
     */
    void f() {
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="MissingPackageInfo" defaultSeverity="WARNING" displayName="缺少 'package-info.java'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
报告包含类但不包含 &lt;code&gt;package-info.java&lt;/code&gt; 或 &lt;code&gt;package.html&lt;/code&gt; 文件并因此缺少软件包文档的软件包。
&lt;p&gt;该快速修复会创建一个初始的 &lt;code&gt;package-info.java&lt;/code&gt; 文件。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryInheritDoc" defaultSeverity="WARNING" displayName="不必要的 '{@inheritDoc}' Javadoc 注释" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告仅包含 &lt;code&gt;{@inheritDoc}&lt;/code&gt; 标记的 Javadoc 注释。 由于 Javadoc 会在没有注释的情况下复制超类的注释，因此仅包含 &lt;code&gt;{@inheritDoc}&lt;/code&gt; 的注释不会添加任何内容。
&lt;p&gt;此外，它还会报告无效位置（例如，字段）中的 &lt;code&gt;{@inheritDoc}&lt;/code&gt; 用法。&lt;/p&gt;
&lt;p&gt;建议移除不必要的 Javadoc 注释。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Example implements Comparable&amp;lt;Example&amp;gt; {
    /**
     * {@inheritDoc}
     */
    @Override
    public int compareTo(Example o) {
      return 0;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Example implements Comparable&amp;lt;Example&amp;gt; {
    @Override
    public int compareTo(Example o) {
      return 0;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PackageInfoWithoutPackage" defaultSeverity="WARNING" displayName="不带 'package' 语句的 'package-info.java'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告没有 &lt;code&gt;package&lt;/code&gt; 语句的 &lt;code&gt;package-info.java&lt;/code&gt; 文件。
&lt;p&gt;
即便该文件位于其他位置，Javadoc 工具也会考虑默认软件包的此类文件。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MissingJavadoc" defaultSeverity="WARNING" displayName="缺少 Javadoc" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告缺少 Javadoc 注释和标记。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  /**
   * 报告缺少 "@param"（如果配置）。
   */
  public void sample(int param){
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该快速修复会添加缺少的标记或缺少的 Javadoc 注释：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  /**
   * 报告缺少 "@param"（如果配置）。
   * @param param
   */
  public void sample(int param){
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
可以将检查配置为忽略弃用的元素或简单的访问器方法，如 &lt;code&gt;getField()&lt;/code&gt; 或 &lt;code&gt;setField()&lt;/code&gt;。
&lt;/p&gt;
您还可以使用以下选项为方法、字段、类、软件包、模块等特定代码元素配置必需标记和最低要求的可见性。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JavadocLinkAsPlainText" defaultSeverity="WARNING" displayName="指定为纯文本的链接" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在 Javadoc 注释中指定为纯文本的链接。
&lt;p&gt;
  该快速修复会建议用 &amp;lt;a&amp;gt; 标记包装链接。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Main {
   /**
    * https://en.wikipedia.org/
    */
    void foo() {}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Main {
   /**
    * &amp;lt;a href="https://en.wikipedia.org/"&amp;gt;https://en.wikipedia.org/&amp;lt;/a&amp;gt;
    */
    void foo() {}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2022.1 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="DanglingJavadoc" defaultSeverity="WARNING" displayName="悬空的 Javadoc 注释" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告不属于任何类、方法或字段的 Javadoc 注释。
Javadoc 工具会忽略悬空的 Javadoc 注释，并且不会将它们包含在其生成的 HTML 文档中。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class A {
    /**
     * Dangling comment
     */
    /**
     * Method javadoc
     */
     public void m(){}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以通过快速修复完全删除此类注释或将它们转换为块注释。 在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class A {
    /*
      Dangling comment
    */
    /**
     * Method javadoc
     */
    public void m(){}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;使用&lt;b&gt;忽略 JavaDoc 格式的文件头注释&lt;/b&gt;选项可以忽略 Java 文件开头的注释。
这些通常是版权消息。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MissingDeprecatedAnnotation" defaultSeverity="WARNING" displayName="缺少 '@Deprecated' 注解" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告具有 &lt;code&gt;@deprecated&lt;/code&gt; Javadoc 标记但没有 &lt;code&gt;@java.lang.Deprecated&lt;/code&gt; 注解的模块声明、类、字段或方法。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  /**
   * @deprecated use {@code example()} instead
   */
  void sample(){ }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  /**
   * @deprecated use {@code example()} instead
   */
  @Deprecated
  void sample(){ }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;仅当项目或模块的语言级别为 5 或更高时，此检查才会报告。&lt;/p&gt;
&lt;p&gt;
使用下面的复选框，对使用 &lt;code&gt;@Deprecated&lt;/code&gt; 注解但在 &lt;code&gt;@deprecated&lt;/code&gt; Javadoc 标记中没有解释的符号发出警告。

&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="简化: 其他" path="Scala，集合"><inspection shortName="ReverseFind" defaultSeverity="WARNING" displayName="反转并查找到 findLast" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;在调用 &lt;code&gt;find&lt;/code&gt; 之前显式反转集合时报告。&lt;/p&gt;

&lt;p&gt; 该快速修复将使用 &lt;code&gt;xs.findLast(f)&lt;/code&gt;，这在某些情况下可能更有效。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Seq(1, 2).reverse.find(_ == 2)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Seq(1, 2).findLast(_ == 2)
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DropTakeToSlice" defaultSeverity="WARNING" displayName="将 Drop 和 take 转换为 slice" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 &lt;code&gt;drop&lt;/code&gt; 和 &lt;code&gt;take&lt;/code&gt; 的组合并将其替换为 &lt;code&gt;slice&lt;/code&gt;。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  var x: Seq[Int]
  x.drop(n).take(m)
  x.take(m).drop(n)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  var x: Seq[Int]
  x.slice(n, n + m)
  x.slice(n, m)
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReplaceToWithUntil" defaultSeverity="WARNING" displayName="将 to 替换为 until" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告包含范围而不是独占范围。&lt;/p&gt;

&lt;p&gt;该快速修复会将包含范围转换为独占范围。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  0 to x - 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  0 until x
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ToSetAndBack" defaultSeverity="WARNING" displayName="转换为 Set，并恢复为 distinct" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告序列到 &lt;code&gt;Set&lt;/code&gt; 和反向的链式转换，并建议将其替换为 &lt;code&gt;.distinct&lt;/code&gt; 调用。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Seq(1).toSet.toSeq
  List(1).toSet.toList
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Seq(1).distinct
  List(1).distinct
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="HeadOrLastOption" defaultSeverity="WARNING" displayName="模拟的 headOption 或 lastOption" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;在模拟 &lt;code&gt;headOption&lt;/code&gt; 或 &lt;code&gt;lastOption&lt;/code&gt; 时报告。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  var seq: Seq[Int]
  if (seq.nonEmpty) Some(seq.head) else None
  seq.lift(0)

  if (seq.size == 0) None else seq.lastOption
  seq.lift(seq.size - 1)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  var seq: Seq[Int]
  seq.headOption
  seq.headOption

  seq.lastOption
  seq.lastOption
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReplaceWithFlatten" defaultSeverity="WARNING" displayName="替换为 flatten" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告在集合的集合上模拟 &lt;code&gt;.flatten&lt;/code&gt; 的代码。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;
&lt;pre&gt;&lt;code&gt;
  Seq(seq1, seq2).flatMap(identity)
  Seq(seq1, seq2).flatMap(x =&gt; identity(x))
  Seq(seq1, seq2).flatMap(x =&gt; x)

  val nestedOption = Option(Some(10))
  nestedOption.getOrElse(None)
  nestedOption.map(_.get)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Seq(seq1, seq2).flatten
  Seq(seq1, seq2).flatten
  Seq(seq1, seq2).flatten

  val nestedOption = Option(Some(10))
  nestedOption.flatten
  nestedOption.flatten
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReverseTakeReverse" defaultSeverity="WARNING" displayName="reverse、take 和 reverse 转换为 takeRight" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 &lt;code&gt;seq.reverse.take(n).reverse&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  seq.reverse.take(n).reverse
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  seq.reverse.take(1).reverse
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MapFlatten" defaultSeverity="WARNING" displayName="map 和 flatten 转换为 flatMap" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 &lt;code&gt;collection.map(f).flatten(m)&lt;/code&gt;，并建议将其替换为 &lt;code&gt;collection.flatMap&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Seq(1, 10).map(i =&gt; Seq(i, i + 10)).flatten
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Seq(1, 10).flatMap(i =&gt; Seq(i, i + 10))
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SortedHeadLast" defaultSeverity="WARNING" displayName="将 Sorted 和 head/last 转换为 max/min" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告排序和使用 &lt;code&gt;head&lt;/code&gt; 或 &lt;code&gt;last&lt;/code&gt; 并建议将其替换为 &lt;code&gt;max&lt;/code&gt; 或 &lt;code&gt;min&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Seq("abc", "defg", "h").sorted.head
  Seq("abc", "defg", "h").sortBy(_.length).last
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Seq("abc", "defg", "h").min
  Seq("abc", "defg", "h").maxBy(_.length)
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CollectHeadOption" defaultSeverity="WARNING" displayName="collect 和 headOption 转换为 collectFirst" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 &lt;code&gt;collection.collect(f).headOption&lt;/code&gt; 并建议在可能的情况下将其替换为 &lt;code&gt;collection.collectFirst(f)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  val x: Set[Int]
  x.collect(f).headOption
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  val x: Set[Int]
  x.collectFirst(f)
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReverseIterator" defaultSeverity="WARNING" displayName="reverse 和 iterator 转换为 reverseIterator" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告何时显式反转集合以获取反向迭代器。&lt;/p&gt;

&lt;p&gt;该快速修复改用 &lt;code&gt;reverseIterator&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  var seq: Seq[Int]
  seq.reverse.iterator
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  var seq: Seq[Int]
  seq.reverseIterator
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="IndexBoundsCheck" defaultSeverity="WARNING" displayName="索引边界检查" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告索引边界的显式检查。&lt;/p&gt;

&lt;p&gt;该快速修复改用 &lt;code&gt;lift&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  var x: Seq[Int]
  if (i &lt; x.length) Some(x(i)) else None
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  var x: Seq[Int]
  x.lift(i)
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SimplifiableFoldOrReduce" defaultSeverity="WARNING" displayName="可简化的 fold 或 reduce 方法" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告可以替换为 &lt;code&gt;sum&lt;/code&gt;、&lt;code&gt;product&lt;/code&gt;、&lt;code&gt;max&lt;/code&gt; 或 &lt;code&gt;min&lt;/code&gt; 的 &lt;code&gt;fold&lt;/code&gt; 和 &lt;code&gt;reduce&lt;/code&gt; 方法。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  List(1, 2, 3).foldLeft(1){(x,y) =&gt; x * y}
  List(1, 2, 3).fold(0)(_ + _)
  List(1, 2, 3).reduce(_ + _)
  List(1, 2, 3).reduceLeft(_ min _)
  List(1, 2, 3).reduce((x, y) =&gt; math.max(x, y))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  List(1, 2, 3).product
  List(1, 2, 3).sum
  List(1, 2, 3).sum
  List(1, 2, 3).min
  List(1, 2, 3).max
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MakeArrayToString" defaultSeverity="WARNING" displayName="将数组转换为字符串" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告传递给 &lt;code&gt;print&lt;/code&gt; 或 &lt;code&gt;println&lt;/code&gt; 的数组，并建议将它们转换为正确的字符串&lt;/p&gt;.
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  var x: Array[Int]
  print(x)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  var x: Array[Int]
  print(x.mkString("Array(", ", ", ")"))
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FoldTrueAnd" defaultSeverity="WARNING" displayName="可简化为 forall 的 fold" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告检查所有元素的条件的 &lt;code&gt;fold&lt;/code&gt; 的用法。&lt;/p&gt;

&lt;p&gt;该快速修复会将 &lt;code&gt;fold&lt;/code&gt; 替换为等效的 &lt;code&gt;forall&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  var x: Seq[Int]
  x.foldLeft(true)((x,y) =&gt; x &amp;&amp; p(y))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  var x: Seq[Int]
  x.forall(y =&gt; p(y))
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="Screen sizes" path="Android/Lint"><inspection shortName="Bounds" defaultSeverity="WARNING" displayName="Bounds" enabled="false" pluginId="com.android.tools.design" pluginVersion="223.8836.41" isGlobalTool="true">&lt;!--
  ~ Copyright (C) 2022 The Android Open Source Project
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  --&gt;
&lt;html&gt;
&lt;body&gt;
检测子视图未完全包含在其父视图边界内的布局。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TextFieldSize" defaultSeverity="WARNING" displayName="Text field size" enabled="false" pluginId="com.android.tools.design" pluginVersion="223.8836.41" isGlobalTool="true">&lt;!--
  ~ Copyright (C) 2022 The Android Open Source Project
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  --&gt;
&lt;html&gt;
&lt;body&gt;
检测文本字段比推荐的 488dp 宽的布局。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LongText" defaultSeverity="WARNING" displayName="Long text" enabled="false" pluginId="com.android.tools.design" pluginVersion="223.8836.41" isGlobalTool="true">&lt;!--
  ~ Copyright (C) 2022 The Android Open Source Project
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  --&gt;
&lt;html&gt;
&lt;body&gt;
检测文本行长度超过 120 个字符的布局。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LocaleText" defaultSeverity="WARNING" displayName="Locale text" enabled="false" pluginId="com.android.tools.design" pluginVersion="223.8836.41" isGlobalTool="true">&lt;!--
  ~ Copyright (C) 2022 The Android Open Source Project
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  --&gt;
&lt;html&gt;
&lt;body&gt;
检测在不同区域设置中行为不同的文本布局。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="WearMargin" defaultSeverity="WARNING" displayName="Wear margins" enabled="false" pluginId="com.android.tools.design" pluginVersion="223.8836.41" isGlobalTool="true">&lt;!--
  ~ Copyright (C) 2022 The Android Open Source Project
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  --&gt;
&lt;html&gt;
&lt;body&gt;
检测视图过于靠近 WearOS 设备一侧的布局。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="BottomNav" defaultSeverity="WARNING" displayName="Bottom nav" enabled="false" pluginId="com.android.tools.design" pluginVersion="223.8836.41" isGlobalTool="true">&lt;!--
  ~ Copyright (C) 2022 The Android Open Source Project
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  --&gt;
&lt;html&gt;
&lt;body&gt;
检测 BottomNavigationView 宽度大于 600dp 的布局。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AccessibilityTestFramework" defaultSeverity="WARNING" displayName="Accessibility" enabled="false" pluginId="com.android.tools.design" pluginVersion="223.8836.41" isGlobalTool="true">&lt;!--
  ~ Copyright (C) 2022 The Android Open Source Project
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  --&gt;
&lt;html&gt;
&lt;body&gt;
检测具有辅助功能问题的布局。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ButtonSize" defaultSeverity="WARNING" displayName="Button size" enabled="false" pluginId="com.android.tools.design" pluginVersion="223.8836.41" isGlobalTool="true">&lt;!--
  ~ Copyright (C) 2022 The Android Open Source Project
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  --&gt;
&lt;html&gt;
&lt;body&gt;
检测按钮宽度超过建议的 320dp 的布局。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="Overlap" defaultSeverity="WARNING" displayName="Overlap" enabled="false" pluginId="com.android.tools.design" pluginVersion="223.8836.41" isGlobalTool="true">&lt;!--
  ~ Copyright (C) 2022 The Android Open Source Project
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  --&gt;
&lt;html&gt;
&lt;body&gt;
检测一个视图至少被另一个同级视图覆盖 50% 的布局。
分析仅限于被覆盖的文本视图，因为它们最有可能被另一个视图错误覆盖。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="BottomAppBar" defaultSeverity="WARNING" displayName="Bottom app bar" enabled="false" pluginId="com.android.tools.design" pluginVersion="223.8836.41" isGlobalTool="true">&lt;!--
  ~ Copyright (C) 2022 The Android Open Source Project
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  --&gt;
&lt;html&gt;
&lt;body&gt;
检测在非紧凑屏幕上使用 BottomAppBar 的布局。
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Async 代码和 promise" path="JavaScript and TypeScript"><inspection shortName="ES6RedundantAwait" defaultSeverity="WEAK WARNING" displayName="冗余 'await' 表达式" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;await&lt;/code&gt; 的冗余用法，例如 &lt;code&gt;await await&lt;/code&gt; 或等待非 promise 结果。
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  选择“报告 promise”选项时，建议在适用时（在 &lt;code&gt;return&lt;/code&gt; 语句中以及包含 &lt;code&gt;Promise.resolve/reject&lt;/code&gt; 时）移除 promise 前面的 &lt;code&gt;await&lt;/code&gt;。
&lt;/p&gt;
&lt;p&gt;在此类上下文中移除 &lt;code&gt;await&lt;/code&gt; 会导致两个问题。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    用 &lt;code&gt;try-catch &lt;/code&gt; 环绕代码并且忘记添加 &lt;code&gt;await&lt;/code&gt; 会改变代码语义，而您可能没有注意到这一点。
  &lt;/li&gt;
  &lt;li&gt;
    采用显式的 &lt;code&gt;await&lt;/code&gt; 可能会阻止 V8 运行时提供&lt;a href="http://bit.ly/v8-zero-cost-async-stack-traces"&gt;异步堆栈跟踪&lt;/a&gt;。
  &lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ES6TopLevelAwaitExpression" defaultSeverity="ERROR" displayName="顶层 'await' 表达式" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告顶层 &lt;code&gt;await&lt;/code&gt; 表达式的用法。
&lt;!-- tooltip end --&gt;
虽然有人在提出新的 'top-level async' 建议，但不允许在 async 函数之外使用 &lt;code&gt;await&lt;/code&gt;。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ES6PossiblyAsyncFunction" defaultSeverity="WEAK WARNING" displayName="非异步函数中的 'await'" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可能想要异步但其实缺少 &lt;code&gt;async&lt;/code&gt; 修饰符的函数中的 &lt;code&gt;await&lt;/code&gt; 用法。
&lt;!-- tooltip end --&gt;
虽然 &lt;code&gt;await&lt;/code&gt; 可以用作标识符，但很可能是打算将其用作运算符，
因此应将包含函数设为 &lt;code&gt;async&lt;/code&gt; 。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSIgnoredPromiseFromCall" defaultSeverity="WEAK WARNING" displayName="返回 promise 的方法调用结果被忽略" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告返回日后不使用的 &lt;code&gt;Promise&lt;/code&gt; 的函数调用。
此类调用通常是无意为之，表明有错误。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ES6MissingAwait" defaultSeverity="WEAK WARNING" displayName="异步函数调用缺少 await" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;async&lt;/code&gt; 函数中没有预期的 &lt;code&gt;await&lt;/code&gt; 前缀的 &lt;code&gt; async&lt;/code&gt; 函数调用。
此类调用返回 &lt;code&gt;Promise&lt;/code&gt;，并且控制流会立即继续。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
async function bar() { /* ... */ }
async function foo() {
    bar(); // 不良
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
应用快速修复后，将添加 &lt;code&gt;await&lt;/code&gt; 前缀：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
async function bar() { /* ... */ }
async function foo() {
    await bar(); // 优良
}
&lt;/code&gt;&lt;/pre&gt;
&lt;br/&gt;
在选中“报告 return 语句中的 promise”复选框的情况下，还建议在 return 语句中添加 &lt;code&gt;await&lt;/code&gt;。&lt;br/&gt;
虽然一般不必这样做，但它有两大好处。&lt;br/&gt;&lt;ul&gt;&lt;li&gt;
使用 &lt;code&gt;try-catch&lt;/code&gt; 环绕代码时，您不会忘记去添加 &lt;code&gt;await&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;显式的 &lt;code&gt;await&lt;/code&gt; 有助于 V8 运行时提供&lt;a href="https://bit.ly/v8-zero-cost-async-stack-traces"&gt;异步堆栈跟踪&lt;/a&gt;。&lt;/li&gt;&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="可能的错误" path="JavaScript and TypeScript"><inspection shortName="JSPotentiallyInvalidTargetOfIndexedPropertyAccess" defaultSeverity="WARNING" displayName="索引的属性访问的目标可能不正确" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可能无效的索引属性访问，例如 &lt;code&gt;Array[1]&lt;/code&gt;。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSVoidFunctionReturnValueUsed" defaultSeverity="WARNING" displayName="使用了 void 函数返回值" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告不返回任何内容的函数的返回值。
调用此类函数总是生成 &lt;code&gt;undefined&lt;/code&gt; 值，此类赋值可能表明有错误。 &lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
let a = console.log('foo');
&lt;/code&gt;&lt;/pre&gt;
&lt;br/&gt;
以下用法将被忽略：
&lt;ul&gt;
  &lt;li&gt;在 return 语句内部&lt;/li&gt;
  &lt;li&gt;在某些二进制运算中&lt;/li&gt;
  &lt;li&gt;对于覆盖的非 void 函数&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSPotentiallyInvalidUsageOfClassThis" defaultSeverity="WARNING" displayName="从闭包对类中 'this' 的引用可能无效" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告试图通过不是 lambda 的嵌套函数中的 &lt;code&gt;this.&lt;/code&gt; 限定符，来引用 ECMAScript 类成员的情况。&lt;br/&gt;
不是 lambda 的嵌套函数中的 &lt;code&gt;this&lt;/code&gt; 是函数自身的 &lt;code&gt; this&lt;/code&gt;，与外部类无关。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="InfiniteLoopJS" defaultSeverity="WARNING" displayName="无限循环语句" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告只能通过抛出异常来退出的 &lt;code&gt;for&lt;/code&gt; 、
&lt;code&gt;while&lt;/code&gt; 或 &lt;code&gt;do&lt;/code&gt; 语句。 此类语句通常表示编码错误。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSEqualityComparisonWithCoercion" defaultSeverity="WARNING" displayName="相等运算符可能导致类型强制" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可能导致意外类型强制的相等运算符的用法。
建议将 &lt;code&gt;==&lt;/code&gt; 和 &lt;code&gt;!=&lt;/code&gt; 替换为类型安全的相等运算符 &lt;code&gt;===&lt;/code&gt; 和 &lt;code&gt;!==&lt;/code&gt;。
&lt;p&gt;根据所选的选项，将报告下面的一种情况：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;code&gt;==&lt;/code&gt; 和 &lt;code&gt;!=&lt;/code&gt; 运算符的所有用法。
  &lt;/li&gt;
  &lt;li&gt;
    除了与 null 比较之外的所有用法。 某些代码样式允许使用 &lt;code&gt;x == null&lt;/code&gt; 替代
    &lt;code&gt;x === null || x === undefined&lt;/code&gt;。
  &lt;/li&gt;
  &lt;li&gt;
    仅可疑的表达式，例如：&lt;code&gt;==&lt;/code&gt; 或 &lt;code&gt;!=&lt;/code&gt; 与
     &lt;code&gt;0&lt;/code&gt;、&lt;code&gt;''&lt;/code&gt;、
    &lt;code&gt;null&lt;/code&gt;、&lt;code&gt;true&lt;/code&gt;、
    &lt;code&gt;false&lt;/code&gt; 或 &lt;code&gt;undefined&lt;/code&gt; 比较。
  &lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSSuspiciousNameCombination" defaultSeverity="WARNING" displayName="可疑的变量/形参名称组合" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;!-- Copied from community/java/java-impl/src/inspectionDescriptions/SuspiciousNameCombination.html --&gt;
&lt;html&gt;
&lt;body&gt;
报告目标变量或函数形参的名称与分配给它的值的名称不匹配的赋值或函数调用。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;var&lt;/b&gt; x = 0;
  &lt;b&gt;var&lt;/b&gt; y = x;
&lt;/code&gt;&lt;/pre&gt;
或
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;var&lt;/b&gt; x = 0, y = 0;
  &lt;b&gt;var&lt;/b&gt; rc = &lt;b&gt;new&lt;/b&gt; Rectangle(y, x, 20, 20);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;指定不应一起使用的名称。 如果形参名称或赋值目标名称包含一个组中的词语，而赋值或传递的变量的名称包含另一个组中的词语，则会报告错误。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSPotentiallyInvalidConstructorUsage" defaultSeverity="WARNING" displayName="可能无效的构造函数用法" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可能无效的构造函数的用法，例如：&lt;code&gt;new&lt;/code&gt; 后面不是构造函数的函数，使用
构造函数的原型或调用构造函数但没有使用 &lt;code&gt;new&lt;/code&gt; 。 假定构造函数的名称采用大写（可选）或有显式的 JSDoc &lt;code&gt;@constructor&lt;/code&gt; 标记。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSComparisonWithNaN" defaultSeverity="WARNING" displayName="与 NaN 比较" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告与 NaN 的比较。 类似于 &lt;code&gt;expr == NaN&lt;/code&gt; 或 &lt;code&gt;expr === NaN&lt;/code&gt; 的比较总是评估为 &lt;code&gt;false&lt;/code&gt;。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSConstructorReturnsPrimitive" defaultSeverity="WARNING" displayName="构造函数返回基元值" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告返回基元值的构造函数。
在通过 &lt;code&gt; new&lt;/code&gt; 调用时，此值将丢失，取而代之的是返回一个对象。 要避免警告，请使用 &lt;code&gt;@return&lt;/code&gt; 标记来指定函数返回。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSIncompatibleTypesComparison" defaultSeverity="WEAK WARNING" displayName="类型不兼容的表达式的比较" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告与不兼容类型的操作数或不含可能公共值的类型的操作数的比较。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ES6BindWithArrowFunction" defaultSeverity="WARNING" displayName="箭头函数 'bind' 用法可疑" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;bind&lt;/code&gt; 与箭头函数一起使用的情况。&lt;br/&gt;
由于箭头函数使用词法 &lt;code&gt;this&lt;/code&gt;，所以 &lt;code&gt;bind&lt;/code&gt; 调用对它们无效。&lt;br/&gt;
有关详细信息，请参阅&lt;a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions#Lexical_this"&gt;此处&lt;/a&gt;。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSConsecutiveCommasInArrayLiteral" defaultSeverity="WARNING" displayName="数组文字中的连续逗号" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告数组文字中的连续逗号。 跳过的元素接受 &lt;code&gt;undefined&lt;/code&gt; 值，
但这可能是无意为之，例如，当逗号位于一行的末尾和下一行的开头时。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSSuspiciousEqPlus" defaultSeverity="WARNING" displayName="可疑的 '=+' 赋值" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;a =+ b&lt;/code&gt; 形式的赋值。
建议替换为 &lt;code&gt;a += b&lt;/code&gt;。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DivideByZeroJS" defaultSeverity="WARNING" displayName="除以零" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告除以 0 或对 0 取余。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSTypeOfValues" defaultSeverity="WARNING" displayName="包含非标准值的 'typeof' 比较" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;typeof&lt;/code&gt; 表达式与不是以下标准类型之一的文字字符串的比较：&lt;code&gt;undefined&lt;/code&gt;、&lt;code&gt;object&lt;/code&gt;、&lt;code&gt;boolean&lt;/code&gt;、&lt;code&gt;number&lt;/code&gt;、&lt;code&gt;string&lt;/code&gt;、&lt;code&gt;function&lt;/code&gt; 或 &lt;code&gt;symbol&lt;/code&gt;。
此类比较始终返回 &lt;code&gt;false&lt;/code&gt;。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="InfiniteRecursionJS" defaultSeverity="WARNING" displayName="无限递归" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告肯定会无限递归或
抛出异常的函数。 此类函数可能无法正常返回。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ObjectAllocationIgnoredJS" defaultSeverity="WARNING" displayName="对象分配的结果已忽略" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告所分配对象的结果被忽略的对象分配，例如 &lt;code&gt;new Error();&lt;/code&gt; 作为不带任何赋值的语句。
此类分配表达式可以指示奇怪的对象初始化策略。 
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ForLoopThatDoesntUseLoopVariableJS" defaultSeverity="WARNING" displayName="'for' 循环中的 update 或 condition 未使用循环变量" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告其中的条件或更新不使用 &lt;code&gt;for&lt;/code&gt; 循环变量的 &lt;code&gt;for&lt;/code&gt; 循环。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSPotentiallyInvalidUsageOfThis" defaultSeverity="WARNING" displayName="从闭包对 'this' 的引用可能无效" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告闭包中的用于引用外部上下文属性的 &lt;code&gt;this&lt;/code&gt;。 &lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
function Outer() {
  this.outerProp = 1;
  function inner() {
    // 不良，因为 Outer 的 'outerProp' 
    // 不会如预期的那样
    // 在调用 'new Outer()' 时在此处进行更新
    this.outerProp = 2;
  }
  inner();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="反射访问" path="Java"><inspection shortName="JavaReflectionMemberAccess" defaultSeverity="WARNING" displayName="反射访问不存在/不可见的类成员" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对不存在或不可见的字段和方法的反射访问。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Field stringHashField() throws NoSuchFieldException {
    return String.class.getField("hash");
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Field stringHashField() throws NoSuchFieldException {
    return String.class.getDeclaredField("hash");
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  对于 &lt;code&gt;final&lt;/code&gt; 类，很清楚该类中是否存在具有指定名称的字段或方法。
&lt;/p&gt;
&lt;p&gt;
  对于非 &lt;code&gt;final&lt;/code&gt; 类，子类中可能有使用该名称的字段或方法，因此可能会出现误报。
  使用该项检查的设置，可消除任何位置或特定类的此类误报。
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;2017.2 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JavaLangInvokeHandleSignature" defaultSeverity="WARNING" displayName="MethodHandle/VarHandle 类型不匹配" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告不匹配任何方法或字段的 &lt;code&gt;MethodHandle&lt;/code&gt; 和 &lt;code&gt;VarHandle&lt;/code&gt; 工厂方法调用。
&lt;p&gt;也报告不匹配 &lt;code&gt;MethodHandle&lt;/code&gt; 签名的 &lt;code&gt;MethodHandle.invoke()&lt;/code&gt; 和类似方法的实参以及不匹配 &lt;code&gt;VarHandle&lt;/code&gt; 类型的 &lt;code&gt;VarHandle.set()&lt;/code&gt; 的实参
  &lt;!-- tooltip end --&gt;

&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;
  MethodHandle mh = MethodHandles.lookup().findVirtual(
      MyClass.class, "foo", MethodType.methodType(void.class, int.class));
  &lt;i&gt;// 此实参应为 &lt;b&gt;int&lt;/b&gt; 值&lt;/i&gt;
  mh.invoke(myObj, "&lt;b&gt;abc&lt;/b&gt;");
&lt;/pre&gt;
&lt;br&gt;
&lt;pre&gt;
  &lt;i&gt;// 此实参应为 &lt;b&gt;String&lt;/b&gt;.class&lt;/i&gt;
  VarHandle vh = MethodHandles.lookup().findVarHandle(
      MyClass.class, "text", &lt;b&gt;int&lt;/b&gt;.class);
&lt;/pre&gt;
&lt;br&gt;
&lt;pre&gt;
  VarHandle vh = MethodHandles.lookup().findVarHandle(
      MyClass.class, "text", String.class);
  &lt;i&gt;// 此实参应为 &lt;b&gt;String&lt;/b&gt; 值&lt;/i&gt;
  vh.set(myObj, &lt;b&gt;42&lt;/b&gt;);
&lt;/pre&gt;
&lt;p&gt;
  &lt;small&gt;2017.2 最新变化&lt;/small&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="Java9ReflectionClassVisibility" defaultSeverity="WARNING" displayName="跨模块问题的反射访问" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;Class.forName()&lt;/code&gt; 和 &lt;code&gt;ClassLoader.loadClass()&lt;/code&gt; 调用，这些调用尝试访问由于 Java 9 模块可访问性规则而在当前范围内不可见的类。
&lt;!-- tooltip end --&gt;
&lt;p&gt;仅当项目或模块的语言级别为 9 或更高时，此检查才会报告。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JavaReflectionInvocation" defaultSeverity="WARNING" displayName="反射调用实参不匹配" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告提供给 &lt;code&gt;Method.invoke()&lt;/code&gt; 和 &lt;code&gt;Constructor.newInstance()&lt;/code&gt; 的实参与 &lt;code&gt;Class.getMethod()&lt;/code&gt; 和 &lt;code&gt;Class.getConstructor()&lt;/code&gt; 中指定的签名不匹配的情况。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Method m = myObj.getClass().getMethod("myMethod", &lt;b&gt;int&lt;/b&gt;.class);
  &lt;i&gt;//此实参应为 &lt;b&gt;int&lt;/b&gt; 值&lt;/i&gt;
  m.invoke(myObj, "&lt;b&gt;abc&lt;/b&gt;");
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2017.2 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="常规" path="Scala"><inspection shortName="NonLocalReturn" defaultSeverity="WARNING" displayName="非本地 return 语句" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;!DOCTYPE html&gt;
&lt;html lang="zh"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;非局部 return 语句&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;p&gt;在匿名函数中使用 &lt;code&gt;return&lt;/code&gt; 关键字可以提早跳出该函数时报告。
    非本地返回值通过抛出和捕获 &lt;code&gt;scala.runtime.NonLocalReturnException&lt;/code&gt;-s 来实现。
    这通常不是程序员的本意。 由于抛出和捕获异常的隐藏性能开销，这可能会带来问题。 &lt;/p&gt;
&lt;p&gt;此外，它是一个有漏洞的实现：一个捕获所有异常的处理程序可以拦截 &lt;code&gt;NonLocalReturnException&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
def foo(numbers: Seq[Int]): Int =
  numbers.map { n =&gt;
    if (n &gt; 5)
      return 0 // highlighted
    n * 2
  }.sum
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MatchToPartialFunction" defaultSeverity="WARNING" displayName="match 语句可转换为模式匹配匿名函数" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告可以转换为模式匹配匿名函数的 match 语句。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  iterable.map(value =&gt; value match {
      case Some(value) =&gt; whenValue(value)
      case None =&gt; whenNothing()
  })
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  iterable.map {
      case Some(value) =&gt; whenValue(value)
      case None =&gt; whenNothing()
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SingleImport" defaultSeverity="WARNING" displayName="import 检查中有不必要的大括号" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 import 表达式中不必要的大括号。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  import scala.math.{max}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  import scala.math.max
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ScalaXmlUnmatchedTag" defaultSeverity="ERROR" displayName="不匹配的标记" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 Scala &lt;code&gt;xml&lt;/code&gt; 表示法中未关闭或未打开的 &lt;code&gt;xml&lt;/code&gt; 标记。&lt;/p&gt;
&lt;p&gt;在以下示例中，&lt;code&gt;open&lt;/code&gt; 被标记为未打开：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  val someXml =
    &amp;lt;xml&amp;gt;
      &amp;lt;/open&amp;gt;
    &amp;lt;/xml&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FieldFromDelayedInit" defaultSeverity="WARNING" displayName="来自于 DelayedInit 的字段" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告在 &lt;code&gt;DelayedInit&lt;/code&gt; 的子类中定义并且仅在执行方法 &lt;code&gt;main&lt;/code&gt; 时初始化的字段。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Test {
    println(MyApp.initializedLater) // 打印 0
  }
  object MyApp extends DelayedInit {
    val initializedLater = 3
    override def delayedInit(body: =&gt; Unit): Unit = {
      new Test
      body
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ScalaFileName" defaultSeverity="WARNING" displayName="类与文件名不相符" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告没有具有相应名称的类型定义的文件。&lt;/p&gt;

&lt;p&gt;该快速修复会建议重命名文件以匹配类型定义的名称，或者重命名类型定义以匹配文件名。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="OverridingAddingTargetName" defaultSeverity="ERROR" displayName="成员具有 @targetName 注解，而被重写的成员没有" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告具有 &lt;code&gt;@targetName&lt;/code&gt; 注解的定义，这些定义重写没有 &lt;code&gt;@targetName&lt;/code&gt; 注解的定义。&lt;/p&gt;

&lt;p&gt;请参阅 &lt;a href="https://docs.scala-lang.org/scala3/reference/other-new-features/targetName.html"&gt;@targetName 注解&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;该快速修复会移除 &lt;code&gt;@targetName&lt;/code&gt; 注解。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class A:
    def foo: Int = 1

  class B extends A:
    @targetName("overriddenFoo")
    override def foo: Int = 2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class A:
    def foo: Int = 1

  class B extends A:
    override def foo: Int = 2
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ReferenceMustBePrefixed" defaultSeverity="WARNING" displayName="引用必须有前缀" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告和修正隐藏常见 Scala 类（例如 &lt;code&gt;List&lt;/code&gt;）的导入名称。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  import java.util.List

  val list: List[Int] = null
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  import java.util
  import java.util.List

  val list: util.List[Int] = null
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ForwardReference" defaultSeverity="WARNING" displayName="可疑的前向引用" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告类级别上前向引用的用法，这可能会导致类初始化期间出现意外行为。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Test {
    val first: Int  = second + 5 // 此处 second 为  0
    val second: Int = 5
    // first 是 5 而不是 10
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="EmptyTargetName" defaultSeverity="ERROR" displayName="空的 @targetName 外部名称" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告具有空外部名称形参的 &lt;code&gt;@targetName&lt;/code&gt; 的用法。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @targetName("")
  val *^*^* = 42
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="KindProjectorUseCorrectLambdaKeyword" defaultSeverity="WARNING" displayName="Kind Projector: 使用正确的 lambda 关键字" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告使用 `λ`。&lt;/p&gt;
&lt;p&gt;使用 &lt;b&gt;Kind Projector&lt;/b&gt; 插件中的函数语法时，请使用 `Lambda` 而不是 `λ`。 您可以在&lt;b&gt;设置 | 编辑器 | 代码样式 | Scala | 其他&lt;/b&gt;中更改代码样式设置以使用 `λ` 而不是 `Lambda`。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;此检查在 Kind Projector 插件启用时运行。&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DangerousCatchAll" defaultSeverity="WARNING" displayName="缺少类型注解" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 &lt;code&gt;catch&lt;/code&gt; 块中匹配所有类型的模式。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  try f() catch {
    case e =&gt; ???
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  try f() catch {
    case e: Throwable =&gt; ???
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LoopVariableNotUpdated" defaultSeverity="WARNING" displayName="循环变量未在循环内更新" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告在循环条件中使用且未在循环内更新的变量。&lt;/p&gt;

&lt;p&gt;如果执行，这些可能会导致无限循环，并且可能不是预期的。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DeprecatedAlphanumericInfixCall" defaultSeverity="WARNING" displayName="用作中缀运算符的字母数字定义未被声明为 `infix`" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告不将 `infix` 修饰符作为中缀运算符的字母数字定义的用法。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;“使用反引号环绕”快速修复会在调用周围添加 &lt;code&gt;`&lt;/code&gt; 符号。&lt;/li&gt;
&lt;li&gt;“从中缀表达式转换”快速修复会将中缀调用转换为方法语法 &lt;code&gt;.method(...)&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;“从中缀类型转换”快速修复会将中缀类型转换为前缀语法 &lt;code&gt;Type[...]&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;“从中缀模式转换”快速修复会将中缀模式转换为前缀语法 &lt;code&gt;pattern(...)&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class C:
    def op(x: Int): Int = ???
  type Or[X, Y]
  case class Pair[T](x: T, y: T)

  val c = C()
  val p = Pair(1, 2)

  c op 2
  val or: Int Or String = ???
  val _ Pair _ = p
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;应用“使用反引号环绕”快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class C:
    def op(x: Int): Int = ???
  type Or[X, Y]
  case class Pair[T](x: T, y: T)

  val c = C()
  val p = Pair(1, 2)

  c `op` 2
  val or: Int `Or` String = ???
  val _ `Pair` _ = p
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在应用“从中缀表达式转换”快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class C:
    def op(x: Int): Int = ???
  type Or[X, Y]
  case class Pair[T](x: T, y: T)

  val c = C()
  val p = Pair(1, 2)

  c.op(2)
  val or: Int Or String = ???
  val _ Pair _ = p
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;应用“从中缀类型转换”快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class C:
    def op(x: Int): Int = ???
  type Or[X, Y]
  case class Pair[T](x: T, y: T)

  val c = C()
  val p = Pair(1, 2)

  c op 2
  val or: Or[Int, String] = ???
  val _ Pair _ = p
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;应用“从中缀模式转换”快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class C:
    def op(x: Int): Int = ???
  type Or[X, Y]
  case class Pair[T](x: T, y: T)

  val c = C()
  val p = Pair(1, 2)

  c op 2
  val or: Int Or String = ???
  val Pair(_, _) = p
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ScalaDeprecatedIdentifier" defaultSeverity="WARNING" displayName="弃用的标识符" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 &lt;code&gt;then&lt;/code&gt; 作为标识符的用法。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;then&lt;/b&gt; 这个词在 Scala 3 中被保留为关键字。 它作为标识符的用法已被弃用。
    查看 &lt;a href="https://docs.scala-lang.org/sips/pending/uncluttering-control.html"&gt;SIP-12&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  val then = "some text"
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="OverridingWithDifferentTargetName" defaultSeverity="ERROR" displayName="定义和被重写的成员具有不同的 @targetName 注解" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告具有 &lt;code&gt;@targetName&lt;/code&gt; 注解的定义，这些定义重写具有 &lt;code&gt;@targetName&lt;/code&gt; 注解的定义，但具有不同的外部名称。&lt;/p&gt;

&lt;p&gt;请参阅 &lt;a href="https://docs.scala-lang.org/scala3/reference/other-new-features/targetName.html"&gt;@targetName 注解&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;该快速修复会将 &lt;code&gt;@targetName&lt;/code&gt; 注解的外部名称替换为被重写定义的外部名称。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  trait A:
    @targetName("multiply")
    def *(i: Int): A

  class B extends A:
    @targetName("times")
    override def *(i: Int): A = ???
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  trait A:
    @targetName("multiply")
    def *(i: Int): A

  class B extends A:
    @targetName("multiply")
    override def *(i: Int): A = ???
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="PostfixMethodCall" defaultSeverity="WARNING" displayName="使用后缀方法调用" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告后缀方法调用。&lt;/p&gt;
&lt;p&gt;它会干扰分号推断。 &lt;a href="https://twitter.com/#!/odersky/status/49882758968905728"&gt;建议&lt;/a&gt;用户改用普通的点表示法。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  "test" length
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  "test".length
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ScalaUnusedSymbol" defaultSeverity="WARNING" displayName="未使用的声明" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告未使用的声明。&lt;/p&gt;

&lt;p&gt;该快速修复会移除未使用的声明。&lt;/p&gt;

&lt;p&gt;在下面的&lt;b&gt;选项&lt;/b&gt;中，您可以控制检查是否适用于 public 声明和/或局部声明。
  在局部声明的情况下，除了启用和禁用检查之外，您还可以使其依赖于三个编译器选项之一的存在：&lt;code&gt;-Wunused:locals&lt;/code&gt;、&lt;code&gt;-Wunused:linted&lt;/code&gt; 或 &lt;code&gt;-Xlint:unused&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  def test(): Int = {
    val unused = 3
    3
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  def test(): Int = {
    3
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SimplifyBoolean" defaultSeverity="WARNING" displayName="简化布尔表达式" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告可以简化的布尔表达式。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  true || false
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  true
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ScalaRedundantCast" defaultSeverity="WARNING" displayName="冗余转换检查" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;&lt;p&gt;报告冗余的 &lt;code&gt;asInstanceOf&lt;/code&gt; 转换并建议将其移除。&lt;/p&gt;
&lt;p&gt;如果表达式的类型与转换类型相同，则转换是冗余的。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  "test".asInstanceOf[String]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  "test"
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MarkInnerCaseObjectsAsFinal" defaultSeverity="WARNING" displayName="将内部 case 对象标记为 final" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告缺少 case 对象的 final 修饰符。&lt;/p&gt;
&lt;p&gt;虽然内部 case 对象在 Scala 中实际上是 final，但它们不能扩展，并且它们并不总是在编译的字节码中被标记为这样。 因此，此检查建议您这样做。
    请参阅&lt;a href="https://nrinaudo.github.io/scala-best-practices/adts/final_case_objects.html"&gt;最佳做法&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  object Outer {
    case object Inner
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  object Outer {
    final case object Inner
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DeprecatedKindProjectorSyntax" defaultSeverity="WARNING" displayName="弃用的 kind-projector 语法" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 kind-projector 语法中 &lt;code&gt;?&lt;/code&gt; 标识符的用法。
&lt;p&gt;&lt;code&gt;?&lt;/code&gt; 标识符将用于 Scala 3 中类型中的通配符实参（请参阅&lt;a href="https://dotty.epfl.ch/docs/reference/changed-features/wildcards.html"&gt;类型中的通配符实参&lt;/a&gt;）。
    它在 kind-projector 类型 lambda 中的用法已被弃用，并将被 &lt;code&gt;*&lt;/code&gt; 取代。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  List[?]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  List[*]
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;此检查在 &lt;b&gt;Kind Projector&lt;/b&gt; 插件启用时运行。&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ScalaMalformedFormatString" defaultSeverity="WARNING" displayName="格式错误的字符串" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告格式字符串中的非法语法、与给定实参不兼容的格式指定符、为格式字符串提供的实参不足等。&lt;/p&gt;
&lt;p&gt;该检查在以下地方运行：&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;&lt;code&gt;"&amp;hellip;".format(&amp;hellip;)&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;value.formatted("&amp;hellip;")&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;String.format("&amp;hellip;", &amp;hellip;)&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;printf("&amp;hellip;", &amp;hellip;)&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;System.out.printf("&amp;hellip;", &amp;hellip;)&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;内插字符串&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AbstractValueInTrait" defaultSeverity="WARNING" displayName="特征中的抽象值" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;&lt;p&gt;报告在初始化期间可能导致错误的特征中的抽象值和变量。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  trait Sample {
    val method: Method
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MultipleTargetsTargetName" defaultSeverity="ERROR" displayName="@targetName 的多个目标" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告在多个目标上使用 &lt;code&gt;@targetName&lt;/code&gt; 注解的情况。&lt;/p&gt;

&lt;p&gt;该快速修复会移除 &lt;code&gt;@targetName&lt;/code&gt; 注解。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  // 1
  val list: List[Int] = (1 to 5).toList
  @targetName("head_and_tail")
  val (head, tail) = (list.head, list.tail)

  // 2
  enum E:
    case A
    @targetName("b_and_c")
    case B, C
    case D
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  // 1
  val list: List[Int] = (1 to 5).toList
  val (head, tail) = (list.head, list.tail)

  // 2
  enum E:
    case A
    case B, C
    case D
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="NotImplementedCode" defaultSeverity="WARNING" displayName="未实现代码" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告未实现的 &lt;code&gt;???&lt;/code&gt; 占位符。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  def foo = &lt;strong&gt;???&lt;/strong&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PrivateShadow" defaultSeverity="WARNING" displayName="类形参会隐藏超类 var" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;!DOCTYPE html&gt;
&lt;html lang="zh"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;类形参会隐藏超类 var&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;p&gt;报告隐藏超类 &lt;code&gt;var&lt;/code&gt; 的类形参。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
class Animal {
  var name: String = ""
}

class Cat(name: String = "") extends Animal {
  // 使 `name` 成为隐藏 var 的 private[this] val
  def usage = name
}
&lt;/pre&gt;
&lt;p&gt;使用非 &lt;code&gt;private&lt;/code&gt; &lt;code&gt;var&lt;/code&gt; 扩展类时，用户可能期望子类的类形参将重写超类中的 &lt;code&gt;var&lt;/code&gt;，但实际上它只会对其进行隐藏。 这有时可能会导致非普通错误。&lt;/p&gt;
&lt;p&gt;请注意，只有在实际使用该值时，才会出现高亮显示。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RedundantFinalOnToplevelObject" defaultSeverity="WARNING" displayName="'final' 修饰符对于顶层对象冗余" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告顶级对象上的 &lt;code&gt;final&lt;/code&gt; 修饰符。&lt;/p&gt;
&lt;p&gt;根据 &lt;a href="https://www.scala-lang.org/files/archive/spec/2.13/05-classes-and-objects.html#final"&gt;Scala 规范&lt;/a&gt;，它们是冗余的。&lt;/p&gt;

&lt;p&gt;该快速修复会移除 &lt;code&gt;final&lt;/code&gt; 修饰符。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  final object Test
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  object Test
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="VarCouldBeVal" defaultSeverity="WARNING" displayName="'var' 可以是 'val'" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告任何从未更新且可能是 &lt;code&gt;val&lt;/code&gt; 的非 public &lt;code&gt;var&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    private var s = 0
    println(s)
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    private val s = 0
    println(s)
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ScalaUnreachableCode" defaultSeverity="WARNING" displayName="无法访问的代码" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告不可到达的代。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  def test(): Unit = {
    throw new Exception()
    println("this will never be reached")
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  def test(): Unit = {
    throw new Exception()
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConvertExpressionToSAM" defaultSeverity="WARNING" displayName="将表达式转换为单一 abstract 方法(SAM)" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告可以转换为 SAM（单一抽象方法）的表达式。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  new Thread(new Runnable {
      override def run() = println()
  })
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  new Thread(() =&gt; println())
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="HashCodeUsesVar" defaultSeverity="WEAK WARNING" displayName="在 'hashCode()' 中访问了非值字段" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;如果 &lt;code&gt;hashCode&lt;/code&gt; 中使用了 &lt;code&gt;var&lt;/code&gt; 字段，则报告这些字段。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Test {
    var value = 3
    override def hashCode(): Int =
      value // 值可能会改变，表明 hashCode() 被误用
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NameBooleanParameters" defaultSeverity="WARNING" displayName="为布尔形参命名" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告并建议命名布尔形参。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  def execute(optionA: Boolean, optionB: Boolean): Unit = ???
  execute(true, false)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  def execute(optionA: Boolean, optionB: Boolean): Unit = ???
  execute(optionA = true, optionB = false)
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ScalaUnusedExpression" defaultSeverity="WEAK WARNING" displayName="未使用的表达式" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告值未被使用的表达式。&lt;/p&gt;

&lt;p&gt;不会报告具有副作用或转移控制流的表达式。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  def test(): Int = {
    3 // 未使用
    3
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  def test(): Int = {
    3
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FloatLiteralEndingWithDecimalPoint" defaultSeverity="WARNING" displayName="以 '.' 结束的浮点文字" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告以小数点 ('.') 结尾的浮点文字。&lt;/p&gt;
&lt;p&gt;建议用户避免使用它们，以免将其误认为是方法调用语法。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  var x = 1.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  var x = 1.0
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryPartialFunction" defaultSeverity="WARNING" displayName="不必要的偏函数" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告可以替换为普通函数的部分函数。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Seq(1).foreach {
    case _ =&gt; 3
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Seq(1).foreach(_ =&gt; 3)
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RelativeImport" defaultSeverity="WARNING" displayName="相对导入" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告不使用完全限定引用的 import 语句。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  package org.something

  import someInnerPackage
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  package org.something

  import org.something.someInnerPackage
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ScalaUnnecessaryParentheses" defaultSeverity="WARNING" displayName="不必要的圆括号" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告表达式、类型和模式中不必要的圆括号。&lt;/p&gt;

&lt;p&gt;如果移除圆括号后程序的语义保持不变，则不需要圆括号。&lt;/p&gt;
&lt;p&gt;使用下面的复选框可以自定义检查的行为。&lt;/p&gt;
&lt;p&gt;如果圆括号将中缀表达式、类型元素或模式作为较大中缀元素的一部分分开，则被认为是澄清圆括号。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  val x = (3)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  val x = 3
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NestedStatefulMonads" defaultSeverity="WARNING" displayName="嵌套的有状态单体" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告可能导致架构错误的嵌套有状态单体。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  import scala.concurrent.Future
  val a = Future { }
  Future { a }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="DeprecatedViewBound" defaultSeverity="WARNING" displayName="视图边界已弃用" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告视图边界的用法并建议将其替换为隐式形参。&lt;/p&gt;
&lt;p&gt;视图边界已被弃用：&lt;a href="https://issues.scala-lang.org/browse/SI-7629"&gt;SI-7629&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Sample[A &lt;% Int]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Sample[A]()
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="VariablePatternShadow" defaultSeverity="WARNING" displayName="变量模式的可疑隐藏" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告隐藏在封闭范围内定义的稳定标识符的变量模式。&lt;/p&gt;
&lt;p&gt;要对该值执行相等测试，请使用反引号。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  val foo = 0
  0 match {
    case foo =&gt;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  val foo = 0
  0 match {
    case `foo` =&gt;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantBlock" defaultSeverity="WARNING" displayName="冗余块" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告内插字符串中的冗余封闭块。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  val name = "Andy"
  s"Do you know ${name}?"
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  val name = "Andy"
  s"Do you know $name?"
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AbsoluteImport" defaultSeverity="WARNING" displayName="绝对导入" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以与基础软件包（&lt;b&gt;设置 | 语言和框架 | Scala | 基础软件包&lt;/b&gt;）相关的完全限定导入。
&lt;p&gt;仅当在&lt;b&gt;设置 | 编辑器 | 代码样式 | Scala | 导入&lt;/b&gt;中启用&lt;b&gt;对基础软件包例外&lt;/b&gt;选项时才适用。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  package org.example.application
  package ui

  import org.example.application.model.Data
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  package org.example.application
  package ui

  import model.Data
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CaseClassParam" defaultSeverity="WARNING" displayName="Case 类形参" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;&lt;p&gt;报告 &lt;code&gt;case class&lt;/code&gt; 形参上的冗余 &lt;code&gt;val&lt;/code&gt; 修饰符。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  case class W (val x: Int)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  case class W (x: Int)
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="KindProjectorSimplifyTypeProjection" defaultSeverity="WARNING" displayName="Kind Projector: 简化类型" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告类型投影并建议将其转换为 &lt;b&gt;Kind Projector&lt;/b&gt; 格式。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  def a: ({type L[A] = (A, A)})#L
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  def a: Lambda[A =&gt; (A, A)]
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;此检查在 Kind Projector 插件启用时运行。&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NoTargetNameAnnotationForOperatorLikeDefinition" defaultSeverity="WEAK WARNING" displayName="具有运算符名称的定义没有 @targetName 注解" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告没有 &lt;code&gt;@targetName&lt;/code&gt; 注解的具有类似运算符（符号）名称的定义。&lt;/p&gt;
&lt;p&gt;建议使用符号名称具有 &lt;code&gt;@targetName&lt;/code&gt; 注解的定义。 这将建立一个更易于搜索的替代名称，并将避免运行时诊断中的灰色编码。&lt;/p&gt;
&lt;p&gt;具有用反引号表示的名称（非合法主机平台名称）的定义也应具有 &lt;code&gt;@targetName&lt;/code&gt; 注解。&lt;/p&gt;

&lt;p&gt;请参阅 &lt;a href="https://docs.scala-lang.org/scala3/reference/other-new-features/targetName.html"&gt;@targetName 注解&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;该快速修复会添加一个具有空外部名称的 &lt;code&gt;@targetName&lt;/code&gt; 注解。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="NoTailRecursionAnnotation" defaultSeverity="WARNING" displayName="无尾递归注解" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告没有 &lt;code&gt;@tailrec&lt;/code&gt; 注解的尾递归方法，该注解验证方法将使用尾调用优化进行编译。&lt;/p&gt;

&lt;p&gt;请注意，方法必须是有效的 &lt;code&gt;final&lt;/code&gt;，此检查才会被显示。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  def factorial(n: Long, acc: Long = 1): Long =
    if (n &lt;= 1) acc else factorial(n - 1, acc * n)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @tailrec
  def factorial(n: Long, acc: Long = 1): Long =
    if (n &lt;= 1) acc else factorial(n - 1, acc * n)
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LanguageFeature" defaultSeverity="WARNING" displayName="高级语言功能" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告当前文件中未启用的高级语言功能的用法。&lt;/p&gt;

&lt;p&gt;高级语言功能需要通过相应的编译器选项或通过在使用它们的文件中导入显式功能标志来启用。&lt;/p&gt;

&lt;p&gt;
    后缀运算符表示法：&lt;br&gt;
    &lt;code&gt;val s = 123 toString&lt;/code&gt;
&lt;/p&gt;

&lt;p&gt;
    反射调用：&lt;br&gt;
    &lt;code&gt;def foo(v: {def bar()}) = v.bar()&lt;/code&gt;
&lt;/p&gt;

&lt;p&gt;
    动态成员选择：&lt;br&gt;
    &lt;code&gt;class Foo extends Dynamic&lt;/code&gt;
&lt;/p&gt;

&lt;p&gt;
    隐式转换：&lt;br&gt;
    &lt;code&gt;implicit def toInt(s: String) = s.toInt&lt;/code&gt;
&lt;/p&gt;

&lt;p&gt;
    高阶类型&lt;small&gt;（自 &lt;em&gt;Scala 2.13.1&lt;/em&gt; 起默认启用）&lt;/small&gt;：&lt;br&gt;
    &lt;code&gt;class Bar[M[A]]&lt;/code&gt;
&lt;/p&gt;

&lt;p&gt;
    存在类型：&lt;br&gt;
    &lt;code&gt;def foo(v: Seq[T] forSome { type T })&lt;/code&gt;
&lt;/p&gt;

&lt;p&gt;
    宏定义：&lt;br&gt;
    &lt;code&gt;def assert(s: String) = macro Asserts.assertImpl&lt;/code&gt;
&lt;/p&gt;
&lt;!-- tooltip end --&gt;

&lt;p&gt;当提供 "-feature" 选项时，Scala 编译器也可能会发出这些警告。 &lt;/p&gt;

&lt;p&gt;有关编译器选项，请参阅：&lt;a href="settings://scala.compiler?Features"&gt;文件 | 设置 | 构建、执行、部署 | 编译器 | Scala 编译器 | 功能&lt;/a&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="OverridingRemovingTargetName" defaultSeverity="ERROR" displayName="定义缺少 @targetName 注解" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告没有 &lt;code&gt;@targetName&lt;/code&gt; 注解的定义，这些定义重写具有 &lt;code&gt;@targetName&lt;/code&gt; 注解的定义。&lt;/p&gt;

&lt;p&gt;请参阅 &lt;a href="https://docs.scala-lang.org/scala3/reference/other-new-features/targetName.html"&gt;@targetName 注解&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;该快速修复会使用被重写定义的外部名称添加 &lt;code&gt;@targetName&lt;/code&gt; 注解。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  trait A:
    @targetName("multiply")
    def *(i: Int): A

  class B extends A:
    override def *(i: Int): A = ???
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  trait A:
    @targetName("multiply")
    def *(i: Int): A

  class B extends A:
    @targetName("multiply")
    override def *(i: Int): A = ???
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="DeprecatedPackageObject" defaultSeverity="WARNING" displayName="弃用的软件包对象" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告软件包对象的用法。&lt;/p&gt;
&lt;p&gt;软件包对象在 Scala 3 中已弃用，将被逐步淘汰。 考虑改用顶级定义或正则对象。
&lt;/p&gt;
&lt;p&gt;请参阅 &lt;a href="https://dotty.epfl.ch/docs/reference/dropped-features/package-objects.html"&gt;Dotty 中的软件包对象&lt;/a&gt;。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ComparingUnrelatedTypes" defaultSeverity="WARNING" displayName="正在比较不相关的类型" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告表达式的比较 (&lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt;)，两者的类型不能相同。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  1 == "test"
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MultipleArgListsInAnnotation" defaultSeverity="WARNING" displayName="注解构造函数中的多个实参列表" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告具有多个实参列表的注解。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @someAnnotation()()
  object Test
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DoubleNegationScala" defaultSeverity="WARNING" displayName="双重求反" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告在布尔表达式中的双重求反。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  !(!b)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  b
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;!-- tooltip end --&gt;
&lt;/html&gt;</inspection><inspection shortName="ScalaWeakerAccess" defaultSeverity="WARNING" displayName="声明访问可能较弱" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告其访问可能较弱的类、方法和变量。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  def foo() {
    onlyUsedInFoo("foo", "foo")
  }
  def onlyUsedInFoo(x: String, y: String): Unit = {} // 可为 private
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ScalaRedundantConversion" defaultSeverity="WARNING" displayName="冗余转换检查" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;&lt;p&gt;报告冗余转换方法调用（&lt;code&gt;toInt&lt;/code&gt;、&lt;code&gt;toString&lt;/code&gt; 等）。&lt;/p&gt;

&lt;p&gt;如果转换不会更改集合的类型，则转换是冗余的。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  "Test".toString
  Seq(1, 2).toSeq
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  "Test".toString
  Seq(1, 2).toSeq
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ChainedPackage" defaultSeverity="WARNING" displayName="基础软件包声明" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告应该在基础软件包中链接的软件包语句。&lt;/p&gt;
&lt;p&gt;仅当在&lt;b&gt;设置 | 语言和框架 | Scala | 基础软件包&lt;/b&gt;中定义基础软件包时才适用。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  package org.example.application.NAME
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  package org.example.application
  package NAME
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SimplifyBooleanMatch" defaultSeverity="WARNING" displayName="可以简化普通 match" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告可以由条件语句替换的布尔表达式上的普通模式匹配。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  val bool: Boolean
  bool match {
    case true =&gt; ???
    case false =&gt; ???
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  val bool: Boolean
  if (bool) {
    ???
  } else {
    ???
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TypeAnnotation" defaultSeverity="WARNING" displayName="需要类型注解" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告没有根据配置的代码样式所需的显式类型注解的属性和方法。&lt;/p&gt;
&lt;p&gt;
    请参见&lt;a href="settings://preferences.sourceCode.Scala?Type%20Annotations"&gt;设置 | 编辑器 | 代码样式 | Scala | 类型注解&lt;/a&gt;。
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="IsInstanceOf" defaultSeverity="WARNING" displayName="isInstanceOf" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告在 &lt;code&gt;isInstanceOf&lt;/code&gt; 检查中缺少的显式类型。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
"abc".isInstanceOf
&lt;/code&gt;
&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="MultipleTargetNameAnnotations" defaultSeverity="WARNING" displayName="多个 @targetName 注解" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告在单个元素上使用多个 &lt;code&gt;@targetName&lt;/code&gt; 注解的情况。&lt;/p&gt;
&lt;p&gt;忽略除最后一个之外的所有 @targetName 注解。 考虑每个定义最多使用一个注解。&lt;/p&gt;

&lt;p&gt;该快速修复会移除所选 &lt;code&gt;@targetName&lt;/code&gt; 注解。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ScalaPackageName" defaultSeverity="WARNING" displayName="错误的 package 语句" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告包含与目录结构不对应的软件包语句的文件。&lt;/p&gt;

&lt;p&gt;该快速修复建议调整软件包语句或将文件移动到正确的目录中。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TypeParameterShadow" defaultSeverity="WARNING" displayName="类型形参的可疑隐藏" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告隐藏在封闭范围内定义的其他类型形参的类型形参。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Test[T] {
    def inner[T]: Int = ???
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LegacyStringFormatting" defaultSeverity="WARNING" displayName="传统字符串格式化" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告可以转换为内插字符串的传统字符串格式化表达式（通过 "format"、"formatted" 或字符串串联）。&lt;/p&gt;
&lt;p&gt;新语法更简洁，提供更多静态检查并提供更好的运行时性能。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  val str = "test"
  "test %s".format(str)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  val str = "test"
  s"test $str"
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ScalaDeprecation" defaultSeverity="WARNING" displayName="Scala 弃用" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告已弃用的符号的用法。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @deprecated("don't use test")
  def test = ???

  test // 使用 test 已被弃用
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TypeCheckCanBeMatch" defaultSeverity="WARNING" displayName="类型检查可以为模式匹配" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告在一系列 if-else 语句中的类型检查和类型转换，并将其替换为模式匹配。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  val value = 0
  if (value.isInstanceOf[Int]) {
    val x = value.asInstanceOf[Int] + 1
    val y = value.asInstanceOf[Int] + 2
  } else if (value.isInstanceOf[Long]) {
    val x = value.asInstanceOf[Long]
    println(x)
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  val value = 0
  value match {
    case i: Int =&gt;
      val x = i + 1
      val y = i + 2
    case x: Long =&gt;
      println(x)
    case _ =&gt;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="代码" path="Spring/Spring Core"><inspection shortName="SpringEventListenerInspection" defaultSeverity="WARNING" displayName="错误配置的 @EventListener 方法" enabled="false" language="UAST" pluginId="com.intellij.spring" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告不正确的 &lt;a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/event/EventListener.html"&gt;@EventListener&lt;/a&gt; 方法。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Configuration @ComponentScan
  open class Config

  data class MyEvent(val string: String)

  @Component
  class LogComponent {
    @EventListener // 使用 @EventListener 注解的方法必须为 public
    private fun logCommands(commandName: MyEvent) {}

    @EventListener // 方法必须最多只有一个形参
    fun processCommand(commandName: MyEvent, text: String) {}
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SpringJavaInjectionPointsAutowiringInspection" defaultSeverity="ERROR" displayName="Spring Bean 组件中的自动装配不正确" enabled="false" language="UAST" pluginId="com.intellij.spring" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 Spring Bean &lt;a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Component.html"&gt;@Component&lt;/a&gt;、&lt;a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Service.html"&gt;@Service&lt;/a&gt; 等的注入点上的自动装配问题。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;不止一种 'concrete' 类型的 Bean&lt;/li&gt;
  &lt;li&gt;没有 'concrete' 类型的 Bean&lt;/li&gt;
  &lt;li&gt;没有带限定符的 Bean&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;@Autowired&lt;/code&gt; 在 Spring Bean 构造函数上的不正确用法&lt;/li&gt;
  &lt;li&gt;在不是有效 Spring Bean 的类中注入或自动装配的字段/方法&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
public interface FooInterface {...}
  @Component public class FooBean implements FooInterface {...}
  @Component public class OtherBean implements FooInterface {...}

@Component
public class MyComponent {
	@Autowired
	FooInterface foo;  // 无法自动装配。 有不止一种 'FooInterface' 类型的 Bean。
                     // Beans: fooBean(FooBean.java), otherBean(OtherBean.java)"
}
&lt;/pre&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
@Component
public class MyComponent {
	@Autowired
	public MyComponent(BarBean bean) {...} // 报告 '只允许一个 @Autowired 构造函数'

	@Autowired
	public MyComponent(FooBean bean) {...} // 报告 '只允许一个 @Autowired 构造函数'
}

@Component
public class MyFactory {  // 报告 '没有匹配的 @Autowired 构造函数'
	public MyFactory(String str) {...}
	public MyFactory(int count) {...}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
public class FooBeanClass {
  @Autowired   // 报告 '必须在有效 Spring Bean 中定义自动装配成员：@Component、@Service 等'
  ServiceBean bean;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SpringLookupInjectionInspection" defaultSeverity="ERROR" displayName="Spring 组件的 @Lookup 注解中错误引用的 Bean" enabled="false" language="JAVA" pluginId="com.intellij.spring" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 &lt;a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/annotation/Lookup.html"&gt;@Lookup&lt;/a&gt; 注解的 &lt;code&gt;value&lt;/code&gt; 形参中不正确的 Bean 引用。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Component public class FooBean {...}
  @Component public class OtherBean {...}

  @Component public class MyComponent {
  @Lookup("fooBean")
  public FooBean fooBean() {...}

  @Lookup("fooBean") // 报告 "Bean 必须为 'OtherBean' 类型"
  public OtherBean otherBean() {...}

  @Lookup("unknown") // 报告 "无法解析 Bean 'unknown'"
  public OtherBean fooBean() {...}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SpringTestingTransactionalInspection" defaultSeverity="WARNING" displayName="无效的事务生命周期方法声明" enabled="false" language="JAVA" pluginId="com.intellij.spring" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告在注解为 &lt;a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/annotation/Transactional.html"&gt;@Transactional&lt;/a&gt; 的测试类中使用 &lt;a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/test/context/transaction/BeforeTransaction.html"&gt;@BeforeTransaction&lt;/a&gt; 和 &lt;a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/test/context/transaction/AfterTransaction.html"&gt;@AfterTransaction&lt;/a&gt; 注解的无效事务生命周期方法声明。&lt;/p&gt;

&lt;p&gt;注解的方法必须没有实参和返回类型。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @ContextConfiguration
  @Transactional
  public class AbstractShowcaseTest {
    @BeforeTransaction // 方法返回类型应为 'void'
    public boolean setupData() {...}

    @AfterTransaction // 实参数量错误
    public void disposeData(boolean a) throws Exception {...}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SpringCacheNamesInspection" defaultSeverity="WARNING" displayName="不正确的所需缓存名称定义" enabled="false" language="UAST" pluginId="com.intellij.spring" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告不正确的 &lt;code&gt;@Cache*&lt;/code&gt; 注解名称。&lt;/p&gt;

&lt;p&gt;每个缓存操作至少应提供一个缓存名称：&lt;code&gt;@Cacheable("cache_name")&lt;/code&gt; 或 &lt;code&gt;@Cacheable(cacheNames ="cache_name")&lt;/code&gt;。
&lt;code&gt;@CacheConfig#cacheNames()&lt;/code&gt; 可用于在类级别共享常见的缓存相关设置。&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SpringTestingSqlInspection" defaultSeverity="WARNING" displayName="无效的 @Sql 和 @SqlGroup 配置" enabled="false" language="UAST" pluginId="com.intellij.spring" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 &lt;a href=https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/test/context/jdbc/Sql.html&gt;@Sql&lt;/a&gt; 注解的 &lt;code&gt;scripts&lt;/code&gt; 特性和 &lt;code&gt;@Sql&lt;/code&gt; 元注解的相应别名特性中未解析的文件引用。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @SqlGroup({
     @Sql("not-found"), // 报告 "无法解析文件 'not-found""
     @Sql("found.sql")
  })
  public class MyTestWithSqlData {...}
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SpringCacheAnnotationsOnInterfaceInspection" defaultSeverity="WARNING" displayName="在接口/接口方法上定义的 Cache* 注解" enabled="false" language="UAST" pluginId="com.intellij.spring" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告接口上的 &lt;code&gt;@Cache*&lt;/code&gt; 注解。&lt;/p&gt;

&lt;p&gt;您应该只使用 &lt;code&gt;@Cache*&lt;/code&gt; 注解具体类（和具体类的方法）。
使用 &lt;code&gt;@Cache*&lt;/code&gt; 注解接口（或接口方法）需要使用基于接口的代理。
由于 Java 注解不是从接口继承的，当使用基于类的代理 (&lt;code&gt;proxy-target-class="true"&lt;/code&gt;) 或基于编织的切面 (&lt;code&gt;mode="aspectj"&lt;/code&gt;) 时，代理和编织基础架构将无法识别缓存设置 。
因此，该对象将不会被包装在缓存代理中。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SpringProfileExpression" defaultSeverity="ERROR" displayName="配置不正确的 @Profile 表达式" enabled="false" language="UAST" pluginId="com.intellij.spring" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告不正确的 &lt;a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Profile.html"&gt;@Profile&lt;/a&gt; 表达式：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Spring 配置文件不得为空&lt;/li&gt;
  &lt;li&gt;在 Spring 配置文件表达式中，'&amp;' 和 '|' 运算符不得在没有圆括号的情况下混用&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;!-- correctly configured --&gt;
  @Configuration
  @Profile("a &amp; (b | c)")
  public class MyConfiguration {...}

  &lt;!-- empty  --&gt;
  @Configuration
  @Profile() // 报告 "配置文件表达式必须包含文本"
  public class MyConfiguration {...}

  &lt;!-- mixed operators without  parentheses --&gt;
  @Configuration
  @Profile("a &amp; b | c") // 报告 "格式不正确的配置文件表达式"
  public class MyConfiguration {...}
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SpringConfigurationProxyMethods" defaultSeverity="ERROR" displayName="@Configuration proxyMethods 用法警告" enabled="false" language="UAST" pluginId="com.intellij.spring" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告有关不正确使用的代理方法的警告。

Spring Framework 5.2 引入了对 @Configuration 类处理的优化，可以通过 @Configuration(proxyBeanMethods = false) 特性启用该优化。
&lt;br&gt;&lt;br&gt;
如果您禁用
&lt;pre&gt;&lt;code&gt;proxyBeanMethods&lt;/code&gt;&lt;/pre&gt;
将不再创建代理实例，调用该方法可以重新启动（每次返回一个新实例）。
因此，您无法保证您确实在上下文中注入相应的 Bean。
&lt;!-- tooltip end --&gt;
&lt;br&gt;&lt;br&gt;
&lt;strong&gt;不正确的 Bean 方法调用示例&lt;/strong&gt;：&lt;br&gt;&lt;br&gt;
&lt;pre&gt;
@Configuration(proxyBeanMethods = false)
class TestConfiguration {
  @Bean
  public FirstBean firstBean() {
    return new FirstBean();
  }

  @Bean
  public SecondBean secondBean() {
    return new SecondBean(firstBean()); // -&gt; &lt;strong&gt;不正确的调用&lt;/strong&gt;
  }
}
&lt;/pre&gt;
&lt;br&gt;

&lt;hr&gt;
&lt;strong&gt;您可以将
  &lt;pre&gt;&lt;code&gt;proxyBeanMethods&lt;/code&gt;&lt;/pre&gt;
  设置为 true 或按如下所示重写代码&lt;/strong&gt;：&lt;br&gt;&lt;br&gt;
&lt;pre&gt;
@Configuration(proxyBeanMethods = false)
class TestConfiguration {
  @Bean
  public FirstBean firstBean() {
    return new FirstBean();
  }

  @Bean
  public SecondBean secondBean(FirstBean someBean) { // -&gt; &lt;strong&gt;正确的注入实例&lt;/strong&gt;
    return new SecondBean(someBean);
  }
}
&lt;/pre&gt;
&lt;br&gt;

&lt;hr&gt;
&lt;strong&gt;此外，该检查还会检查没有 @Configuration 构造型的类中的 @Bean 方法调用（在 "Bean lite mode" 下）&lt;/strong&gt;：&lt;br&gt;&lt;br&gt;
&lt;pre&gt;
@Component
class TestComponent {
  @Bean
  public FirstBean firstBean() {
    return new FirstBean();
  }

  @Bean
  public SecondBean secondBean() {
    return new SecondBean(firstBean()); // -&gt; &lt;strong&gt;不正确的调用&lt;/strong&gt;
  }
}
&lt;/pre&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SpringCacheableAndCachePutInspection" defaultSeverity="WARNING" displayName="对同一方法不正确地使用 @CachePut 和 @Cacheable" enabled="false" language="UAST" pluginId="com.intellij.spring" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告在同一方法上声明的 &lt;a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/cache/annotation/CachePut.html"&gt;@CachePut&lt;/a&gt; 和 &lt;a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/cache/annotation/Cacheable.html"&gt;@Cacheable&lt;/a&gt; 注解。&lt;/p&gt;

&lt;code&gt;@Cacheable&lt;/code&gt; 导致方法跳过使用缓存的执行，&lt;code&gt;@CachePut&lt;/code&gt; 强制执行以更新缓存。
这会导致意外行为，应该避免，除非在非常特殊的情况下注解中的条件将它们排除在外。
请注意，此类条件不应依赖于结果对象（&lt;code&gt;#result&lt;/code&gt; 变量），因为这些条件已预先验证以确认排除。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SpringRequiredAnnotationInspection" defaultSeverity="ERROR" displayName="@Required Spring Bean 属性未注入" enabled="false" language="JAVA" pluginId="com.intellij.spring" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告未注入或自动装配的 &lt;code&gt;@Required&lt;/code&gt; setter Bean 属性。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
&amp;lt;beans&amp;gt;
  &amp;lt;bean class="beans.MyComponent" id="foo"/&amp;gt;
  // 报告 "缺少必需属性: 'port'"
&amp;lt;/beans&amp;gt;

&lt;hr/&gt;

public class MyComponent {
   @Required
   public void setPort(int port) // 报告 "未注入必需属性 'port'"
   {...}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SpringDependsOnUnresolvedBeanInspection" defaultSeverity="ERROR" displayName="@DependsOn 注解中不正确引用的 Bean" enabled="false" language="JAVA" pluginId="com.intellij.spring" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 &lt;a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/DependsOn.html"&gt;@DependsOn&lt;/a&gt; 注解的 &lt;code&gt;value&lt;/code&gt; 形参中不正确的 Bean 引用。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Component
  @DependsOn("unknown")  // 报告 "无法解析 Bean 'unknown'"
  public class MyComponent {
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SpringComponentScan" defaultSeverity="ERROR" displayName="@ComponentScan 或其元注解中无效的软件包" enabled="false" language="UAST" pluginId="com.intellij.spring" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 &lt;a href=https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/ComponentScan.html&gt;@ComponentScan&lt;/a&gt; 注解和 &lt;code&gt;@ComponentScan&lt;/code&gt; 元注解的相应别名特性中的未解析软件包。&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @ComponentScan(basePackages = {
     "com.my.company",
     "com.unknown" // 报告 "无法解析软件包 'unknown'"
  }) +
  @Configuration +
  public class MyConfiguration {}&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ContextJavaBeanUnresolvedMethodsInspection" defaultSeverity="ERROR" displayName="@Bean 注解中未知的 init/destroy 方法" enabled="false" language="UAST" pluginId="com.intellij.spring" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 &lt;a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Bean.html"&gt;@Bean&lt;/a&gt; 注解的 &lt;code&gt;initMethod&lt;/code&gt; 和 &lt;code&gt;destroyMethod&lt;/code&gt; 形参上的未解析方法引用。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
如果 MyBean 类不包含 'public void 'doInit'(){...}' 方法，将在 'doInit' 表达式上报告 "无法解析方法"
&lt;pre&gt;&lt;code&gt;
  public class MyBean {...}

  @Component
  public class MyComponent {
     @Bean(initMethod="doInit" )
     public MyBean myBean() {...}
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在此示例中，如果 &lt;code&gt;MyBean&lt;/code&gt; 不定义 &lt;code&gt;doInit()&lt;/code&gt; 方法，该检查将报告未解析的方法引用。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SpringContextConfigurationInspection" defaultSeverity="ERROR" displayName="无效的 @ContextConfiguration" enabled="false" language="UAST" pluginId="com.intellij.spring" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告不正确的 Spring 上下文配置。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;locations&lt;/code&gt; 特性和 &lt;code&gt;@ContextConfiguration&lt;/code&gt; 元注解的相应别名特性中的未解析文件和目录
  &lt;/li&gt;
  &lt;li&gt;缺少默认应用程序上下文文件&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;有关详细信息，请参阅 &lt;a href=https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/test/context/ContextConfiguration.html&gt;@ContextConfiguration&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @ContextConfiguration(locations = "classpath:META-INF/unknown-context.xml") // 报告 "无法解析文件'unknown-context.xml'"
  class MyTests {...}
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="AsyncMethodInspection" defaultSeverity="WARNING" displayName="不正确的 @Async 方法签名" enabled="false" language="JAVA" pluginId="com.intellij.spring" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 &lt;a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/scheduling/annotation/Async.html"&gt;@Async&lt;/a&gt; 方法的不正确返回类型。&lt;/p&gt;

&lt;p&gt;对于目标方法签名，允许任何形参类型。
  但是，返回类型应该是 &lt;code&gt;void&lt;/code&gt; 或 &lt;a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Future.html"&gt;Future&lt;/a&gt;。
  还可以返回更具体的 &lt;a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/util/concurrent/ListenableFuture.html"&gt;ListenableFuture&lt;/a&gt; 或 &lt;a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html"&gt;CompletableFuture&lt;/a&gt; 类型，它们允许与异步任务进行更丰富的交互，并允许与进一步处理步骤立即组合。&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ScheduledMethodInspection" defaultSeverity="WARNING" displayName="不正确的 @Scheduled 方法签名" enabled="false" language="JAVA" pluginId="com.intellij.spring" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告不正确的 &lt;a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/scheduling/annotation/Scheduled.html"&gt;@Scheduled&lt;/a&gt; 方法。&lt;/p&gt;

&lt;p&gt;根据 Spring 文档，待计划的方法必须返回 void 并且不能预期任何实参。
  如果方法需要与来自应用程序上下文的其他对象进行交互，则应通过依赖项注入提供对象。&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SpringTestingDirtiesContextInspection" defaultSeverity="WARNING" displayName="无效的 @DirtiesContext 'mode' 配置" enabled="false" language="JAVA" pluginId="com.intellij.spring" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 &lt;a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/test/annotation/DirtiesContext.html"&gt;@DirtiesContext&lt;/a&gt; 注解中不正确的 'mode' 配置。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @ContextConfiguration
  @DirtiesContext(methodMode = MethodMode.AFTER_METHOD, // 在注解的测试类上设置方法模式没有意义。 对于类级别控制，请改用 classMode。
                  hierarchyMode = DirtiesContext.HierarchyMode.CURRENT_LEVEL) // 通过 @ContextHierarchy 将上下文配置为层次结构的一部分时，应使用 hierarchyMode
  public class MyTest {
    @DirtiesContext(classMode = DirtiesContext.ClassMode.AFTER_CLASS, // 在注解的测试方法上设置类模式没有意义。 对于方法级别控制，请改用 methodMode。
                     hierarchyMode = DirtiesContext.HierarchyMode.CURRENT_LEVEL) // 通过 @ContextHierarchy 将上下文配置为层次结构的一部分时，应使用 hierarchyMode
    public void testFoo() {...}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SpringTransactionalComponentInspection" defaultSeverity="ERROR" displayName="@Transactional 组件中无效的 'PlatformTransactionManager' 声明" enabled="false" language="JAVA" pluginId="com.intellij.spring" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在当前 &lt;a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/annotation/Transactional.html"&gt;@Transactional&lt;/a&gt; 组件的应用程序上下文中未正确定义的 &lt;a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/PlatformTransactionManager.html"&gt;PlatformTransactionManager&lt;/a&gt; 类。
&lt;/body&gt;
&lt;/html&gt;

</inspection><inspection shortName="SpringJavaAutowiredFieldsWarningInspection" defaultSeverity="WEAK WARNING" displayName="非建议的 'field' 注入" enabled="false" language="JAVA" pluginId="com.intellij.spring" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 Spring 组件中注入或自动装配的字段。&lt;/p&gt;

&lt;p&gt;该快速修复会在 Bean 和断言中为强制字段建议基于构造函数的推荐依赖项注入。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
class MyComponent {
  @Inject MyCollaborator collaborator; // 注入字段

  public void myBusinessMethod() {
    collaborator.doSomething(); // 抛出 NullPointerException
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;

&lt;p&gt;应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
class MyComponent {

  private final MyCollaborator collaborator;

  @Inject
  public MyComponent(MyCollaborator collaborator) {
    Assert.notNull(collaborator, "MyCollaborator must not be null!");
    this.collaborator = collaborator;
  }

  public void myBusinessMethod() {
    collaborator.doSomething(); // 现在这个调用是安全的
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SpringJavaStaticMembersAutowiringInspection" defaultSeverity="WARNING" displayName="对 static 类成员不正确的 Spring 组件自动装配或注入" enabled="false" language="JAVA" pluginId="com.intellij.spring" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 Spring 组件的自动装配和注入的 static 方法/字段。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
@Component
public class MyComponent {
	@Autowired
	static FooInterface foo;  // 报告 "不自动装配 static 成员"
}
&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SpringImportResource" defaultSeverity="WARNING" displayName="@ImportResource 位置中未解析的文件引用" enabled="false" language="UAST" pluginId="com.intellij.spring" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 &lt;a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/ImportResource.html"&gt;@ImportResource&lt;/a&gt; 注解的 &lt;code&gt;locations&lt;/code&gt; 特性和 &lt;code&gt;@ImportResource&lt;/code&gt; 元注解的相应别名特性中的未解析文件和目录。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Configuration
  @ImportResource(locations = "classpath:META-INF/unknown-context.xml") // 报告 "无法解析文件 'unknown-context.xml'"
  public class MyConfiguration {...}
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SpringCacheableComponentsInspection" defaultSeverity="ERROR" displayName="配置不正确的 'caching' 注解" enabled="false" language="JAVA" pluginId="com.intellij.spring" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告错误的“缓存”注解：&lt;code&gt;@Cacheable&lt;/code&gt;、&lt;code&gt;@CacheEvict&lt;/code&gt;、&lt;code&gt;@CachePut&lt;/code&gt;、&lt;code&gt;@CacheConfig&lt;/code&gt; 等。

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
@org.springframework.stereotype.Component
public class MyCacheManager implements CacheManager{... }

public class MyConfiguration {
   @Cacheable(value = "a",
       cacheResolver ="myCacheManager") // 报告 "Bean 必须为 'org.springframework.cache.interceptor.CacheResolver' 类型"
   public String getCache(String isbn) { ...}

   @Cacheable(value = "abc",
   private String getAbc() // 报告 "应在 public 方法上定义缓存注解"
   {...}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SpringPropertySource" defaultSeverity="WARNING" displayName="@PropertySource 和 @TestPropertySource 位置中未解析的文件引用" enabled="false" language="UAST" pluginId="com.intellij.spring" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 &lt;a href=https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/PropertySource.html&gt;@PropertySource&lt;/a&gt; 和 &lt;a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/test/context/TestPropertySource.html"&gt;@TestPropertySource&lt;/a&gt; 注解中的未解析文件或目录。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Configuration
  @PropertySource("classpath:/com/mycompany/unknown.properties") // 报告 "无法解析文件 'unknown.properties'"
  public class AppConfig {...}
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="Room" path="Android"><inspection shortName="AndroidRoomQuestionMarkBindParameter" defaultSeverity="ERROR" displayName="'?' used as parameter in a Room query." enabled="false" language="RoomSql" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告使用未命名的查询形参（如 &lt;code&gt;WHERE id = ?&lt;/code&gt;）的 Room SQL 查询。 Room 查询分析器不支持此做法，它需要已命名的查询形参（如 &lt;code&gt;WHERE id = :id&lt;/code&gt;），这些形参对应于使用 &lt;code&gt;@Query&lt;/code&gt; 注解的方法的实参。
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="AndroidUnresolvedRoomSqlReference" defaultSeverity="ERROR" displayName="Unresolved reference in Room SQL" enabled="false" language="RoomSql" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
检查 Room SQL 查询中是否有未解析的引用。
&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="为 null 性问题" path="Java/可能的错误"><inspection shortName="UnsatisfiedRange" defaultSeverity="WARNING" displayName="返回值超出声明的范围" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告从不符合所声明方法返回范围的方法返回的数值。
您可以使用许多注解声明方法的返回范围：
&lt;ul&gt;
  &lt;li&gt;JetBrains 注解软件包中的 &lt;code&gt;org.jetbrains.annotations.Range&lt;/code&gt;（指定 'from' 和 'to'）&lt;/li&gt;
  &lt;li&gt;Checker Framework 注解软件包中的 &lt;code&gt;org.checkerframework.common.value.qual.IntRange&lt;/code&gt;（指定 'from' 和 'to'）&lt;/li&gt;
  &lt;li&gt;Checker Framework 注解软件包中的 &lt;code&gt;org.checkerframework.checker.index.qual.GTENegativeOne&lt;/code&gt;（范围为 '&gt;= -1'）&lt;/li&gt;
  &lt;li&gt;Checker Framework 注解软件包中的 &lt;code&gt;org.checkerframework.checker.index.qual.NonNegative&lt;/code&gt;（范围为 '&gt;= 0'）&lt;/li&gt;
  &lt;li&gt;Checker Framework 注解软件包中的 &lt;code&gt;org.checkerframework.checker.index.qual.Positive&lt;/code&gt;（范围为 '&gt; 0'）&lt;/li&gt;
  &lt;li&gt;JSR 305 注解软件包中的 &lt;code&gt;javax.annotation.Nonnegative&lt;/code&gt;（范围为 '&gt;= 0'）&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;javax.validation.constraints.Min&lt;/code&gt;（指定最小值）&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;javax.validation.constraints.Max&lt;/code&gt;（指定最大值）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Range(from = 0, to = Integer.MAX_VALUE) int getValue() {
    // 警告：-1 超出声明的范围
    return -1;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2021.2 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ReturnNull" defaultSeverity="WARNING" displayName="返回 'null'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告返回值为 &lt;code&gt;null&lt;/code&gt; 的 &lt;code&gt;return&lt;/code&gt; 语句。
虽然偶尔有用，但此结构可能导致代码因更容易出现 &lt;code&gt;NullPointerException&lt;/code&gt; 而失败。
&lt;p&gt;
  如果方法设计为返回 &lt;code&gt;null&lt;/code&gt;，建议使用 &lt;code&gt;@Nullable&lt;/code&gt; 注解来标记 - 此类方法将被此检查忽略。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Person {
    public String getName () {
      return null;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Person {
    @Nullable
    public String getName () {
      return null;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  如果返回类型为 &lt;code&gt;java.util.Optional&lt;/code&gt;，建议使用另一个快速修复将 &lt;code&gt;null&lt;/code&gt; 转换为 &lt;code&gt;Optional.empty()&lt;/code&gt;。
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用以下选项配置检查：
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    是否忽略 &lt;code&gt;private&lt;/code&gt; 方法。
    这也将忽略从匿名类和 lambda 返回的 &lt;code&gt;null&lt;/code&gt;。
  &lt;/li&gt;
  &lt;li&gt;
    应报告数组返回的 &lt;code&gt;null&lt;/code&gt; 值、集合对象返回的值、普通对象返回的值还是三者的组合。
    总是报告返回类型为 &lt;code&gt;java.util.Optional&lt;/code&gt; 的方法中返回的 &lt;code&gt;null&lt;/code&gt;。
  &lt;/li&gt;
  &lt;li&gt;
    点击&lt;b&gt;配置注解&lt;/b&gt;以指定哪些注解应视为 'nullable'。
  &lt;/li&gt;
&lt;/ul&gt;

&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="NotNullFieldNotInitialized" defaultSeverity="WARNING" displayName="@NotNull 字段未初始化" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告构造函数中未初始化的注解为非 null 的字段。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class MyClass {
  private @NotNull String value;

  public void setValue(@NotNull String value) {
    this.value = value;
  }

  public @NotNull String getValue() {
    return value;
  }
  }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  此类字段可能违反非 null 约束。 在上例中，&lt;code&gt;setValue&lt;/code&gt; 形参注解为非 null，但是如果没有调用 setter，&lt;code&gt;getValue&lt;/code&gt; 可能返回 null。
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;配置检查：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;使用&lt;b&gt;忽略可以隐式初始化的字段&lt;/b&gt;选项，可控制该字段能够隐式初始化（例如通过依赖项注入）时是否应发出警告。&lt;/li&gt;
  &lt;li&gt;使用&lt;b&gt;忽略在 setUp() 方法中初始化的字段&lt;/b&gt;选项，可控制在测试用例 &lt;code&gt;setUp()&lt;/code&gt; 方法中写入该字段时是否应发出警告。&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NullableProblems" defaultSeverity="WARNING" displayName="@NotNull/@Nullable 问题" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告与可 null 性注解相关的问题。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;重写方法未注解：
    &lt;pre&gt;&lt;code&gt;
abstract class A {
  @NotNull abstract String m();
}
class B extends A {
    String m() { return "empty string"; }
}
    &lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;注解的基元类型：&lt;code&gt;@NotNull int myFoo;&lt;/code&gt; &lt;/li&gt;
  &lt;li&gt;&lt;code&gt;@Nullable&lt;/code&gt; 和 &lt;code&gt;@NotNull&lt;/code&gt; 位于同一成员上：&lt;code&gt;@Nullable @NotNull String myFooString;&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;可 null 元素的集合被分配到非 null 元素的集合中：
    &lt;pre&gt;&lt;code&gt;
void testList(List&amp;lt;@Nullable String&gt; nullableList) {
   List&amp;lt;@NotNull String&gt; list2 = nullableList;
}
    &lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;使用&lt;b&gt;配置注解&lt;/b&gt;按钮可指定可 null 性注解，使用复选框可细调该检查提供警告的位置。&lt;/p&gt;
&lt;p&gt;仅当项目或模块的语言级别为 5 或更高，并且类路径上提供可 null 性注解时，此检查才会报告。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="Spring AOP" path="Spring"><inspection shortName="SpringAopErrorsInspection" defaultSeverity="ERROR" displayName="不正确的 Spring AOP 通知或顾问元素" enabled="false" language="XML" pluginId="com.intellij.spring" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;如果没有 &lt;code&gt;pointcut&lt;/code&gt; 或 &lt;code&gt;pointcut-ref&lt;/code&gt; 特性，则报告不正确的建议和顾问元素。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
&amp;lt;beans &amp;gt;
    &amp;lt;aop:config&amp;gt;
      &amp;lt;aop:pointcut id="zzz" expression="args()"/&amp;gt;
        &amp;lt;aop:aspect ref="xxx"&amp;gt;
            &amp;lt;aop:before method="writeArg1" pointcut="execution(* *(String))"/&amp;gt;
            &amp;lt;aop:after method="aaa" pointcut-ref="zzz"/&amp;gt;
            &amp;lt;&lt;strong&gt;aop:after-throwing&lt;/strong&gt; method="aaa"/&amp;gt; &amp;lt;!--应定义 'pointcut' 或 'pointcut-ref' 特性 --&amp;gt;
       &amp;lt;/aop:aspect&amp;gt;
    &amp;lt;/aop:config&amp;gt;
&amp;lt;/beans&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="JdkProxiedBeanTypeInspection" defaultSeverity="ERROR" displayName="不正确的 JDK 代理 Bean 类型" enabled="false" language="XML" pluginId="com.intellij.spring" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告不正确配置的 JDK 代理的 Bean 类型。&lt;/p&gt;

&lt;p&gt;有关详细信息，请参阅&lt;a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-pfb-proxy-types"&gt;基于 JDK 和 CGLIB 的代理&lt;/a&gt;。&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SpringAopWarningsInspection" defaultSeverity="WARNING" displayName="不正确的 Spring AOP 切面或切入点元素" enabled="false" language="XML" pluginId="com.intellij.spring" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告不正确的切面和切入点。
当某些 AOP 建议与切面 Bean 匹配时，可能会导致运行时错误。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;
&lt;pre&gt;&lt;code&gt;
&amp;lt;beans &amp;gt;
  &amp;lt;aop:config&amp;gt;
    &amp;lt;aop:pointcut expression="args()"/&amp;gt; &amp;lt;!-- 切入点应具有 ID --&amp;gt;
    &amp;lt;aop:aspect/&amp;gt; &amp;lt;!-- 应定义 'ref' 特性 --&amp;gt;
  &amp;lt;/aop:config&amp;gt;
&amp;lt;/beans&amp;gt;

&amp;lt;beans&amp;gt;
  &amp;lt;bean id="aspect1" class="Aspect1"/&amp;gt;
  &amp;lt;bean id="aspect2" class="Aspect2"/&amp;gt;
  &amp;lt;aop:config&amp;gt;
    &amp;lt;aop:aspect ref="aspect1"&amp;gt; &amp;lt;!-- 某些建议与此 Bean 匹配 --&amp;gt;
    &amp;lt;aop:before method="xxx" pointcut="execution(* foo())"/&amp;gt;
    &amp;lt;/aop:aspect&amp;gt;
    &amp;lt;aop:aspect ref="aspect2"&amp;gt;
      &amp;lt;aop:before method="xxx" pointcut="execution(* foo())"/&amp;gt;
    &amp;lt;/aop:aspect&amp;gt;
  &amp;lt;/aop:config&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="MissingAspectjAutoproxyInspection" defaultSeverity="WARNING" displayName="缺少 aspectj-autoproxy" enabled="false" language="JAVA" pluginId="com.intellij.spring" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;如果 XML 配置中没有 &lt;strong&gt;&amp;lt;aop:aspectj-autoproxy/&amp;gt;&lt;/strong&gt; 元素，则报告早于 2.5 的 Spring 版本中的 &lt;code&gt;@Aspect&lt;/code&gt; 注解。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
&lt;strong&gt;@Aspect&lt;/strong&gt; // 未启用 '@AspectJ 支持
class MyAspect {
   ...
}

&amp;lt;beans&amp;gt;
   &amp;lt;!-- &amp;lt;aop:aspectj-autoproxy/&amp;gt; --&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SpringAopPointcutExpressionInspection" defaultSeverity="ERROR" displayName="不正确的 Spring AOP 切入点表达式" enabled="false" language="PointcutExpression" pluginId="com.intellij.spring" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 Spring 不支持的 AspectJ 切入点指示符。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
&amp;lt;beans &amp;gt;
  &amp;lt;aop:config &amp;gt;
      &amp;lt;aop:pointcut expression="&lt;strong&gt;@this&lt;/strong&gt;(Anno)  &amp;lt;!-- '@this' pointcut designator isn't supported by Spring --&amp;gt;
                  and &lt;strong&gt;adviceexecution&lt;/strong&gt;()"/&amp;gt; &amp;lt;!--  Spring 不支持 'adviceexecution' 切入点指示符 --&amp;gt;
      &amp;lt;aop:pointcut expression="!@annotation(Anno)"/&amp;gt;
    &amp;lt;/aop:config&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="switch 语句问题" path="JavaScript and TypeScript"><inspection shortName="JSUnreachableSwitchBranches" defaultSeverity="WARNING" displayName="不可到达 'switch' 语句的 'case' 分支" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;switch&lt;/code&gt; 语句不可到达的 &lt;code&gt;case&lt;/code&gt; 分支。 &lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
/**
 * @param {('foo' | 'bar')} p
 */
function foo(p) {
    switch (p) {
        case 'foo': break;
        case 'bar': break;
        case 'baz': break; // 不可到达
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSDuplicateCaseLabel" defaultSeverity="WARNING" displayName="重复的 'case' 标签" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;switch&lt;/code&gt; 语句中重复的 &lt;code&gt;case&lt;/code&gt; 标签，这通常表示有错误。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DefaultNotLastCaseInSwitchJS" defaultSeverity="WARNING" displayName="'default' 不是 'switch' 中的最后一个 case" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告其中的 &lt;code&gt;default&lt;/code&gt; case 位于另一个 case 之前，
而不是作为最后一个 case，因而可能造成混淆的 &lt;code&gt;switch&lt;/code&gt; 语句。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TextLabelInSwitchStatementJS" defaultSeverity="WARNING" displayName="'switch' 语句中的文本标签" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;switch&lt;/code&gt; 语句内部的标签语句，
这通常是由于拼写错误所致。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    &lt;b&gt;switch&lt;/b&gt;(x)
    {
        &lt;b&gt;case&lt;/b&gt; 1:
        case2:   //拼写错误！
        &lt;b&gt;case&lt;/b&gt; 3:
            &lt;b&gt;break&lt;/b&gt;;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NestedSwitchStatementJS" defaultSeverity="WARNING" displayName="嵌套 'switch' 语句" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告嵌套在另一个 &lt;code&gt;switch&lt;/code&gt; 语句中的
&lt;code&gt;switch&lt;/code&gt; 语句。  嵌套的 &lt;code&gt;switch&lt;/code&gt; 语句可能非常令人困惑，尤其在缩进不一致的情况下。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSMissingSwitchDefault" defaultSeverity="INFORMATION" displayName="'switch' 语句没有 'default' 分支" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在未枚举某些可能值的情况下不含 &lt;code&gt;default&lt;/code&gt; 子句的 &lt;code&gt;switch&lt;/code&gt; 语句。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FallThroughInSwitchStatementJS" defaultSeverity="WARNING" displayName="'switch' 语句中的直落" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以将控制从一个分支转到下一个分支的 &lt;code&gt;switch&lt;/code&gt; 语句。  这种“贯穿”通常表示有错误，
例如，缺少 &lt;code&gt;break&lt;/code&gt; 或 &lt;code&gt;return&lt;/code&gt;。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSRedundantSwitchStatement" defaultSeverity="INFORMATION" displayName="'switch' 语句冗余，可以替换" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告语句体为空或仅有一个 &lt;code&gt;case&lt;/code&gt; 分支或仅有一个 &lt;code&gt;default&lt;/code&gt; 分支的 &lt;code&gt;switch&lt;/code&gt; 语句。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSSwitchVariableDeclarationIssue" defaultSeverity="WARNING" displayName="声明了变量并在不同的 'case' 子句中使用" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在 &lt;code&gt;switch&lt;/code&gt; 语句的一个 &lt;code&gt;case&lt;/code&gt; 子句中声明但在同一语句的另一个 &lt;code&gt;case&lt;/code&gt; 子句中使用的变量。
对于块范围的变量，这将导致抛出 &lt;code&gt;ReferenceError&lt;/code&gt;。
对于 &lt;code&gt;var&lt;/code&gt; 变量，它表示可能有错误。 &lt;p&gt;如果有意使用此模式，请禁用 &lt;code&gt;var&lt;/code&gt; 变量检查。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSMissingSwitchBranches" defaultSeverity="INFORMATION" displayName="'switch' 语句缺少分支" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
当 &lt;code&gt;switch&lt;/code&gt; 语句不包含 &lt;code&gt;enum&lt;/code&gt; 或 &lt;code&gt;union&lt;/code&gt; 类型的某些值选项时，报告该类型变量的 switch 语句。
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="SQL" path=""><inspection shortName="SqlCheckUsingColumnsInspection" defaultSeverity="WARNING" displayName="检查 using 子句列" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告两个表中都不存在的 USING 子句中的列。
&lt;p&gt;示例（MySQL）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE t1 (i INT, j INT);
CREATE TABLE t2 (k INT, l INT);
SELECT * FROM t1 JOIN t2 USING (j);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 USING 子句中，列名必须存在于两个表中，SELECT 查询将使用给定的列名自动连接这些表。 由于我们在 &lt;code&gt;t2&lt;/code&gt; 中没有 &lt;code&gt;j&lt;/code&gt; 列，我们可以使用 ON 重写查询。 ON 子句可以连接两个表中列名不匹配的表。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT * FROM t1 JOIN t2 ON t1.j = t2.l;&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlDropIndexedColumnInspection" defaultSeverity="WARNING" displayName="索引依赖于列" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告尝试从索引表中删除列的情况。 此检查在 Microsoft SQL Server 和 Sybase ASE 中可用。
&lt;p&gt;示例（Microsoft SQL 服务器）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE test_index
(
col  INT NOT NULL,
col2 INT NOT NULL,
col3 INT NOT NULL UNIQUE,
col4 VARCHAR(200)
);

CREATE UNIQUE INDEX aaaa ON test_index (col, col2);

ALTER TABLE test_index
DROP COLUMN col;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;您不能删除 &lt;code&gt;col&lt;/code&gt; 列，因为它在索引表中。 要删除该列，您需要先删除 &lt;code&gt;aaaa&lt;/code&gt; 索引（例如 DROP INDEX aaaa）。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SqlInsertValuesInspection" defaultSeverity="WARNING" displayName="VALUE 子句基数" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 VALUES 中的形参数目与目标表中的列数不匹配的情况。
&lt;p&gt;示例（MySQL）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE foo(a INT, b INT, c INT);

INSERT INTO foo VALUES (1,2,3,4)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;foo&lt;/code&gt; 表有三列，但在 INSERT INTO 语句中我们传递了四列。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlRedundantLimitInspection" defaultSeverity="WARNING" displayName="查询中的冗余行限制" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告查询中限制行的冗余子句，例如 FETCH 和 LIMIT。
&lt;p&gt;示例（PostgreSQL）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE foo(a INT);

SELECT * FROM foo WHERE EXISTS(SELECT * FROM foo LIMIT 2);
SELECT * FROM foo WHERE EXISTS(SELECT * FROM foo FETCH FIRST 2 ROWS ONLY);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;要修复警告，您可以将 OFFSET 添加到限制子句。 如果缺少 OFFSET，则 LIMIT 是多余的，因为 LIMIT 的用法不会影响 EXISTS 的运算结果。 在 OFFSET 的情况下，我们跳过前 &lt;code&gt;N&lt;/code&gt; 行，这将影响输出。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT * FROM foo WHERE EXISTS(SELECT * FROM foo OFFSET 1 ROW LIMIT 2);
SELECT * FROM foo WHERE EXISTS(SELECT * FROM foo OFFSET 1 ROW FETCH FIRST 2 ROWS ONLY);&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlStorageInspection" defaultSeverity="WARNING" displayName="SQL 源修改检测" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告数据库对象的源代码已更改的情况。
  &lt;p&gt;执行数据库或对象内省时会触发检查。 当您打开对象的源代码、运行语句和执行代码重构时，就会运行内省。
  此外，您可以通过右键点击对象并选择&lt;b&gt;刷新&lt;/b&gt;来运行内省。&lt;/p&gt;

&lt;p&gt;检查包括以下几种情况：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;数据库中的对象源代码已更改，但编辑器中的代码未更新。 适用于 PostgreSQL、Microsoft SQL Server、Oracle 和 Sybase ASE。&lt;/li&gt;
  &lt;li&gt;您更改了对象源代码，内省了数据库，但源代码已被其他人更改。&lt;/li&gt;
  &lt;li&gt;IDE 中的数据库内省器已更新，您需要下载先前内省器版本中缺少的新对象属性。&lt;/li&gt;
&lt;/ul&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlRedundantAliasInspection" defaultSeverity="WARNING" displayName="冗余别名表达式" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可能与表中的列名重叠并且可能是冗余的别名表达式。
&lt;p&gt;示例（PostgreSQL）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE foo(a INT, b INT);

SELECT * FROM foo foo(a, b);
SELECT * FROM foo foo(a);
SELECT * FROM foo foo(x);
SELECT * FROM foo foo(x, y);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;前两个别名使用与 &lt;code&gt;foo&lt;/code&gt; 表中相同的列名。 这些被认为是冗余的，因为列具有相同的名称。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlInsertIntoGeneratedColumnInspection" defaultSeverity="WARNING" displayName="插入到生成的列中" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告将值赋给生成的列的 INSERT 语句。 可以读取生成的列，但不能直接写入其值。
&lt;p&gt;示例（PostgreSQL）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE foo
(
   col1 INT,
   col2 INT GENERATED ALWAYS AS (col1 + 1) STORED
);
INSERT INTO foo(col1, col2) VALUES (1, 2);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;您不能将 &lt;code&gt;2&lt;/code&gt; 插入到 &lt;code&gt;col2&lt;/code&gt; 列中，因为此列已生成。
  要使此脚本正常工作，您可以将 &lt;code&gt;2&lt;/code&gt; 更改为 DEFAULT。&lt;/p&gt;
&lt;code&gt;INSERT INTO foo(col1, col2) VALUES (1, DEFAULT);&lt;/code&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlInsertNullIntoNotNullInspection" defaultSeverity="WARNING" displayName="将 NULL 插入 NOT NULL 列" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告将 NULL 值插入仅接受 NOT NULL 值的列的情况。
&lt;p&gt;示例（Microsoft SQL 服务器）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE br2 (
id INT NOT NULL,
col1 NVARCHAR (20) NOT NULL,
col2 NVARCHAR (20) NOT NULL,
);
--
INSERT INTO br2 (id, col1, col2)
VALUES (1, NULL, NULL);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;您不能在 &lt;code&gt;col1&lt;/code&gt; 和 &lt;code&gt;col2&lt;/code&gt; 中插入 NULL 值，因为它们被定义为 NOT NULL。 如果按原样运行脚本，则会收到错误消息。 要修复此代码，请将 VALUES 部分中的 NULL 替换为值（例如，&lt;code&gt;42&lt;/code&gt; 和 &lt;code&gt;'bird'&lt;/code&gt;）。&lt;/p&gt;
&lt;pre&gt;INSERT INTO br2 (id, col1, col2)
VALUES (1, 42, 'bird');&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlMultipleLimitClausesInspection" defaultSeverity="WARNING" displayName="查询中的多个行限制/偏移子句" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告单个查询中多个行限制子句的使用情况。

&lt;p&gt;示例（Microsoft SQL 服务器）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;create table foo(a int);
select top 1 * from foo order by a offset 10 rows fetch next 20 rows only;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SELECT TOP 子句用于指定必须只返回 1 条记录。 FETCH 子句指定在处理完 OFFSET 子句后要返回的行数。 但是因为我们已经有了 SELECT TOP 限制子句，所以 FETCH 子句可能是冗余的。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlJoinWithoutOnInspection" defaultSeverity="WARNING" displayName="'delete' 语句中的 'join' 子句不安全" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可能更改整个数据库的语句的缺失条件检查。
&lt;p&gt;例如，在没有 ON 或 WHERE 的 DELETE 语句中使用 JOIN 子句。 如果不对 JOIN 进行条件检查，DELETE 将删除整个表的内容。&lt;/p&gt;
&lt;p&gt;示例（MySQL）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE foo (a INT,b INT,c INT);
CREATE TABLE bar (a INT,b INT,c INT);

DELETE table1 FROM foo table1  INNER JOIN bar table2;&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SqlMisleadingReferenceInspection" defaultSeverity="WARNING" displayName="误导性引用" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 SQL 代码中不明确的引用。
&lt;p&gt;例如，当名称同时引用表列和例程形参时。 由于违反直观的解析逻辑，此类代码的执行可能会导致错误或意外结果。 通常，范围更局部的名称具有更高的优先级。&lt;/p&gt;
    &lt;p&gt;示例（PostgreSQL）：&lt;/p&gt;
    &lt;pre&gt;&lt;code&gt;CREATE TABLE foo
(
    id   INT,
    name VARCHAR(5)
);
CREATE FUNCTION func(name VARCHAR(5)) RETURNS INT AS
$$
DECLARE
    b INT;
BEGIN
      -- `name` 不明确，因为它被用作列名和形参
    SELECT COUNT(*) INTO b FROM foo t WHERE t.name = name;
    RETURN b;
END;
$$ LANGUAGE plpgsql;&lt;/code&gt;&lt;/pre&gt;
  &lt;p&gt;在 PostgreSQL 中，您可以使用 &lt;code&gt;#variable_conflict&lt;/code&gt; 指令来明确指定正确的引用。 例如，使用 &lt;code&gt;#variable_conflict use_column&lt;/code&gt; 引用列名，或使用 &lt;code&gt;#variable_conflict use_variable&lt;/code&gt; 引用形参。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE foo
(
    id   INT,
    name VARCHAR(5)
);
CREATE FUNCTION func(name VARCHAR(5)) RETURNS INT AS
$$
    #variable_conflict use_column
DECLARE
    b INT;
BEGIN
    SELECT COUNT(*) INTO b FROM foo t WHERE t.name = name;
    RETURN b;
END;
$$ LANGUAGE plpgsql;&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SqlConstantExpressionInspection" defaultSeverity="WARNING" displayName="常量表达式" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告始终为 true、false 或 null 的条件和表达式。
&lt;p&gt;示例（MySQL）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE t1 (a TEXT, b INT, c BOOLEAN);
SELECT a FROM t1 WHERE 'Cat' = 'Cat';
SELECT a FROM t1 WHERE 'Cat' = null;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;'Cat' = 'Cat'&lt;/code&gt; 始终为 true，将被报告。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;'Cat' = null&lt;/code&gt; 始终为 null，将被报告。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlDtInspection" defaultSeverity="WARNING" displayName="格式错误的日期/时间文字" enabled="false" language="SQLDateTime" pluginId="com.intellij.database" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告日期和时间文字中的错误。 此检查在 MySQL、Oracle、Db2 和 H2 中可用。
&lt;p&gt;示例（MySQL）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT TIME '10 -12:13:14' FROM dual;
SELECT TIME ' 12 : 13 : 14 ' FROM dual;
SELECT TIME '12 13 14' FROM dual;
SELECT TIME '12-13-14' FROM dual;
SELECT TIME '12.13.14' FROM dual;
SELECT TIME '12:13:' FROM dual;
SELECT TIME '12:13' FROM dual;
SELECT TIME '12:' FROM dual;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在此示例中，日期会忽略 MySQL 日期文字和时间文字标准。 因此，这些将高亮显示。
  有关 MySQL 中日期和时间文字的详细信息，请参阅 &lt;a
    href="https://dev.mysql.com/doc/refman/8.0/en/date-and-time-literals.html"&gt;dev.mysql.com 上的“日期和时间文字”&lt;/a&gt;页面。&lt;/p&gt;
&lt;p&gt;以下日期和时间文字对 MySQL 有效。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT TIME '12:13:14' FROM dual;
SELECT TIME '12:13:14.555' FROM dual;
SELECT TIME '12:13:14.' FROM dual;
SELECT TIME '-12:13:14' FROM dual;
SELECT TIME '10 12:13:14' FROM dual;
SELECT TIME '-10 12:13:14' FROM dual;&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlMissingColumnAliasesInspection" defaultSeverity="WARNING" displayName="缺少列别名" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在输出表达式中没有显式别名的查询（例如，在 SELECT 语句中）。
&lt;p&gt;示例（PostgreSQL）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE foo(a INT, b INT);

SELECT 1, a + 1 AS A2, MAX(b) AS M
FROM foo;&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlIdentifierInspection" defaultSeverity="WARNING" displayName="标识符应加引号" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在查询中使用 SQL 预留关键字作为标识符名称时的情况。
&lt;p&gt;示例（Microsoft SQL 服务器）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE select (identity INT IDENTITY NOT NULL, order INT NOT NULL);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们使用 &lt;code&gt;select&lt;/code&gt;、&lt;code&gt;identity&lt;/code&gt; 和&lt;code&gt;order&lt;/code&gt; 作为表名和列名。
  但它们也是 Microsoft SQL Server 中的保留关键字。
  因此，为了将它们用作查询中的对象名称，您必须用引号引用这些标识符。 要用引号引用它们，您可以使用&lt;b&gt;为标识符加引号&lt;/b&gt; 快速修复。&lt;/p&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE [select] ([identity] INT IDENTITY NOT NULL, [order] INT NOT NULL);&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlTransactionStatementInTriggerInspection" defaultSeverity="WARNING" displayName="在触发器中使用事务管理语句" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告触发器主体中事务管理语句（如 COMMIT 或 ROLLBACK）的用法。
&lt;p&gt;在触发器主体中使用 COMMIT 或 ROLLBACK 语句时，触发器将不会编译。
  发生错误是因为触发器在事务中间触发。 当触发器启动时，当前事务仍未完成。 因为 COMMIT 会终止事务，这两个语句（COMMIT 和 ROLLBACK）都会导致异常。
  在触发器中执行的更改应该由启动触发器的所属事务提交（或回滚）。&lt;/p&gt;
&lt;p&gt;示例（Oracle）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE employee_audit
(
    id          INT  NOT NULL,
    update_date DATE NOT NULL,
    old_name    VARCHAR2(100),
    new_name    VARCHAR2(100)
);

CREATE TABLE employees
(
    id   INT           NOT NULL,
    name VARCHAR2(100) NOT NULL
);

CREATE OR REPLACE TRIGGER trig_commit
    AFTER UPDATE OF name
    ON employees
    FOR EACH ROW
BEGIN
    INSERT INTO employee_audit VALUES (:old.id, SYSDATE, :old.name, :new.name);
    COMMIT;
END;

CREATE OR REPLACE TRIGGER trig_rollback
    AFTER UPDATE OF name
    ON employees
    FOR EACH ROW
BEGIN
    INSERT INTO employee_audit VALUES (:old.id, SYSDATE, :old.name, :new.name);
    ROLLBACK;
END;&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlCaseVsIfInspection" defaultSeverity="WARNING" displayName="使用 CASE 代替条件函数，反之亦然" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 CASE 和 IF 可互换的情况。
&lt;p&gt;示例（MySQL）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT CASE
WHEN C1 IS NULL THEN 1
ELSE 0
END
FROM dual;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;您可以通过用 IF 替换 CASE 结构来缩短代码。 为此，请应用 &lt;b&gt; 替换为 'IF' 调用 &lt;/b&gt; 意图操作。 示例代码如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT IF(C1 IS NULL, 1, 0)
FROM dual;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;要将 IF 恢复为 CASE，请点击 IF 并应用&lt;b&gt;替换为 CASE 表达式&lt;/b&gt; 意图操作。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlUnusedVariableInspection" defaultSeverity="WARNING" displayName="未使用的变量" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告未使用的实参、变量或形参。
&lt;p&gt;示例（PostgreSQL）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE FUNCTION foo(PARAMUSED INT, PARAMUNUSED INT) RETURNS INT AS
$$
BEGIN
    RETURN PARAMUSED;
END
$$ LANGUAGE plpgsql;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;PARAMUNUSED&lt;/code&gt; 形参未在函数中使用，可能会被删除。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlStringLengthExceededInspection" defaultSeverity="WARNING" displayName="隐式字符串截断" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告超过定义的字符长度的变量。
&lt;p&gt;示例（Microsoft SQL 服务器）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE PROCEDURE test() AS
BEGIN
DECLARE myVarOk VARCHAR(5) = 'abcde';
DECLARE myVarExceeded VARCHAR(5) = 'abcde12345';

SET myVarOk = 'xyz';
SET myVarExceeded = '123456789';
END;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;myVarExceeded&lt;/code&gt; 变量被定义为 &lt;code&gt;VARCHAR(5)&lt;/code&gt; 但两个分配的值（&lt;code&gt;'abcde12345'&lt;/code&gt; 和 &lt;code&gt;'123456789'&lt;/code&gt;) 都超出了此限制。 您可以截断指定的值或增加定义的长度。
  要增加长度，请使用&lt;b&gt;增加类型长度&lt;/b&gt; 快速修复。
&lt;/p&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE PROCEDURE test() AS
BEGIN
DECLARE myVarOk VARCHAR(5) = 'abcde';
DECLARE myVarExceeded VARCHAR(10) = 'abcde12345';

SET myVarOk = 'xyz';
SET myVarExceeded = '123456789';
END;&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlAggregatesInspection" defaultSeverity="WARNING" displayName="与聚合相关的问题" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 SQL 聚合函数的无效用法。
&lt;p&gt;即以下情况：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;p&gt;在 HAVING 和 ORDER BY 子句中使用但在 GROUP BY 子句中遗漏的列。&lt;/p&gt;
    &lt;pre&gt;&lt;code&gt;CREATE TABLE foo(id INT PRIMARY KEY, a INT, b INT);
SELECT a, MAX(b) FROM foo GROUP BY a HAVING b &gt; 0;
SELECT * FROM foo GROUP BY a ORDER BY b;&lt;/code&gt;&lt;/pre&gt;
    &lt;p&gt;当按主键进行分组时，此规则不适用。&lt;/p&gt;
    &lt;pre&gt;&lt;code&gt;SELECT * FROM foo GROUP BY id ORDER BY b;&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;p&gt;在错误的上下文中聚合函数。 通常，您可以在以下上下文中使用聚合函数： SELECT 中的表达式列表； 在 HAVING 和 ORDER BY 部分； 和其他特定于方言的案例。 以下查询将显示错误。&lt;/p&gt;
    &lt;pre&gt;&lt;code&gt;SELECT a FROM foo WHERE MAX(b) &gt; 0;
SELECT a FROM foo GROUP BY MAX(a);&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;p&gt;聚合函数的嵌套调用。&lt;/p&gt;
    &lt;pre&gt;&lt;code&gt;SELECT MAX(SUM(a)) FROM foo GROUP BY a;&lt;/code&gt;&lt;/pre&gt;
    &lt;p&gt;此规则不适用于解析函数。 以下查询有效且正确。&lt;/p&gt;
    &lt;pre&gt;&lt;code&gt;SELECT MAX(SUM(a) OVER ()) FROM foo;&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;p&gt;没有聚合函数的 HAVING 的用法。 在这种情况下，请考虑使用 WHERE 部分重写您的代码。&lt;/p&gt;
    &lt;pre&gt;&lt;code&gt;SELECT a, MAX(b) FROM foo GROUP BY a HAVING a &gt; 0;&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlWithoutWhereInspection" defaultSeverity="WARNING" displayName="不带 where 子句的删除或更新语句" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告不带 WHERE 子句的 DELETE 或 UPDATE 语句的用法。
  &lt;p&gt;如果没有 WHERE 子句，DELETE 会删除表中的所有数据，而 UPDATE 会覆盖所有表行的值。&lt;/p&gt;
&lt;p&gt;示例（MySQL）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE t1 (a TEXT, b INT, c BOOLEAN);
update t1 set  a = 'Smith';
delete from t1;&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SqlNoDataSourceInspection" defaultSeverity="WARNING" displayName="未配置数据源" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告&lt;b&gt;数据库&lt;/b&gt;工具窗口中缺少数据源（&lt;b&gt;视图 | 工具窗口 | 数据库&lt;/b&gt;）。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlAutoIncrementDuplicateInspection" defaultSeverity="WARNING" displayName="自动增量重复" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告包含两个具有自动增量的列的表。 在 MySQL、Microsoft SQL Server 和 Db2 方言中，一个表只能有一个带有自动增量选项的字段，并且此字段必须是键。
&lt;p&gt;示例（MySQL）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE my_table
(
    id INT AUTO_INCREMENT,
    c2 INT AUTO_INCREMENT,
);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;c2&lt;/code&gt; 的 AUTO_INCREMENT 约束将被高亮显示，因为 &lt;code&gt;c1&lt;/code&gt; 已经具有此约束。 要修正警告，您可以将 &lt;code&gt;id&lt;/code&gt; 设为主键并删除 &lt;code&gt;c2&lt;/code&gt; 的 AUTO_INCREMENT。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE my_table
(
    id INT AUTO_INCREMENT PRIMARY KEY,
    c2 INT,
);&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SqlShadowingAliasInspection" defaultSeverity="WARNING" displayName="列被别名隐藏" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 SELECT 中别名名称与 FROM 子句中的列名称匹配。
&lt;p&gt;示例（MySQL）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE foo (a INT, b INT, c INT);
SELECT a b, c FROM foo;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;a&lt;/code&gt; 列使用 &lt;code&gt;b&lt;/code&gt; 别名，但 &lt;code&gt;b&lt;/code&gt; 名称也被 &lt;code&gt;foo&lt;/code&gt; 表中的列使用。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlTypeInspection" defaultSeverity="WARNING" displayName="类型兼容性" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告与类型相关的错误。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlDialectInspection" defaultSeverity="WARNING" displayName="SQL 方言检测" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告未将方言分配给 SQL 文件的情况。
&lt;p&gt;例如，当您打开一个新的 SQL 文件而没有为其分配方言时，您会看到一条通知，其中建议了最匹配的方言。 点击 &lt;b&gt;使用&amp;lt;dialect&amp;gt;&lt;/b&gt; 链接以使用建议的方言。 或者，点击&lt;b&gt;将方言更改为&lt;/b&gt;链接以选择其他方言。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlResolveInspection" defaultSeverity="ERROR" displayName="未解析的引用" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告未解析的 SQL 引用。
&lt;p&gt;示例（MySQL）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE users(id INT, name VARCHAR(40));
CREATE TABLE admins(id INT, col1 INT);

SELECT users.id, admins.id FROM admins WHERE admins.id &gt; 1;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;users.id&lt;/code&gt; 列未解析，因为 FROM 子句中缺少 &lt;code&gt;users&lt;/code&gt; 表。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlNamedArgumentsInspection" defaultSeverity="WARNING" displayName="应使用命名实参" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在例程调用中不带名称使用的实参。 默认情况下，此检查处于禁用状态。
&lt;p&gt;有关命名形参和未命名形参之间差异的详细信息，请参阅 &lt;a
    href="https://docs.microsoft.com/en-us/sql/odbc/reference/develop-app/binding-parameters-by-name-named-parameters"&gt;docs.microsoft.com 上的 Binding Parameters by Name (Named Parameters) &lt;/a&gt; 页面。&lt;/p&gt;
&lt;p&gt;示例（Microsoft SQL 服务器）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE FUNCTION foo(n INT, m INT) RETURNS INT AS
BEGIN
    RETURN n + m;
END;

CREATE PROCEDURE test AS
BEGIN
    foo n = 1, m = 2;

--- 以下调用缺少形参名称，会被高亮显示
    foo 1, 2;
END;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;foo 1, 2;&lt;/code&gt; 调用中的形参 &lt;code&gt;1, 2&lt;/code&gt; 突出显示，因为它们缺少名称。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlNullComparisonInspection" defaultSeverity="WARNING" displayName="null 比较" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告与可以替换为 IS NULL 或 IS NOT NULL 运算符的 NULL 的比较。
&lt;p&gt;示例（Microsoft SQL 服务器）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE foo ( id int );

SELECT * FROM foo WHERE NULL = NULL;
SELECT * FROM foo WHERE NULL != NULL;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;NULL = NULL&lt;/code&gt; 可以替换为 &lt;code&gt;IS NULL&lt;/code&gt;，&lt;code&gt;NULL != NULL&lt;/code&gt; 比较可以替换为 &lt;code&gt;IS NOT NULL&lt;/code&gt;。 要进行此替换，您可以使用&lt;b&gt;使用 IS NULL 运算符&lt;/b&gt;或&lt;b&gt;使用 IS NOT NULL 运算符&lt;/b&gt;快速修复。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT * FROM foo WHERE NULL IS NULL;
SELECT * FROM foo WHERE NULL IS NOT NULL;&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlConstantConditionInspection" defaultSeverity="WARNING" displayName="恒定条件" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 WHERE 或 JOIN 子句中始终为 TRUE 或始终为 FALSE 的条件。
&lt;p&gt;示例（MySQL）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE t1 (a TEXT, b INT, c BOOLEAN);
SELECT a FROM t1 WHERE 'Cat' = 'Cat';&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;'Cat' = 'Cat'&lt;/code&gt; 始终为 true，将被报告。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SqlDeprecateTypeInspection" defaultSeverity="WARNING" displayName="弃用的类型" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告已弃用并且可能在 DBMS 的未来版本中消失的类型的用法。
&lt;p&gt;报告的类型：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Oracle 中的 LONG（请参阅 &lt;a href="https://docs.oracle.com/cd/A91202_01/901_doc/server.901/a90120/ch4_dep.htm#6690" target="_blank"&gt;docs.oracle.com 上的 Deprecated and Desupported Features&lt;/a&gt; 页面）。
  &lt;/li&gt;
  &lt;li&gt;Microsoft SQL Server 中的 TEXT、NTEXT 和 IMAGE（请参阅 &lt;a
      href="https://docs.microsoft.com/en-us/sql/database-engine/deprecated-database-engine-features-in-sql-server-2016?view=sql-server-ver15"
      target="_blank"&gt;docs.microsoft.com 上的 Deprecated Database Engine Features in SQL Server 2016&lt;/a&gt; 页面）。
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;示例（Oracle）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE ot.foo(
a NUMBER GENERATED BY DEFAULT AS IDENTITY,
b LONG NOT NULL
);&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlTriggerTransitionInspection" defaultSeverity="WARNING" displayName="触发器中的可疑代码" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告触发器中转换表变量的不正确用法。
&lt;p&gt;示例 (HSQLDB)：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE foo(a INT);

CREATE TRIGGER trg
 AFTER DELETE ON foo
BEGIN
   SELECT * FROM NEW;
END;

CREATE TRIGGER trig AFTER INSERT ON foo
   REFERENCING OLD ROW AS newrow
   FOR EACH ROW WHEN (a &gt; 1)
   INSERT INTO foo VALUES (1)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 HSQLDB 中，DELETE 触发器只能用于 OLD 状态，而 INSERT 触发器只能用于 NEW 状态。 因此，在前面的示例中，&lt;code&gt;SELECT * FROM NEW;&lt;/code&gt; 中的 NEW 和 &lt;code&gt;REFERENCING OLD ROW AS newrow&lt;/code&gt; 中的 OLD 将被高亮显示。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlUnicodeStringLiteralInspection" defaultSeverity="WARNING" displayName="SQL 中的 Unicode 用法" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告使用没有 &lt;code&gt;N&lt;/code&gt; 前缀的国家字符的字符串文字。
&lt;p&gt;如果没有 N 前缀，字符串将被转换为数据库的默认代码页面。 此默认代码页面可能无法识别某些字符。 有关更多信息，请参阅 &lt;a href="https://docs.microsoft.com/en-us/sql/t-sql/data-types/nchar-and-nvarchar-transact-sql" target="_blank"&gt;docs.microsoft.com 上的“nchar 和 nvarchar”(Transact-SQL)&lt;/a&gt; 页面。&lt;/p&gt;
&lt;p&gt;示例（Microsoft SQL 服务器）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT 'abcde' AS a;
SELECT N'abcde' AS b;
SELECT 'абвгд' AS c;
SELECT N'абвгд' AS d;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;SELECT 'абвгд' AS c;&lt;/code&gt; 没有 &lt;code&gt;N&lt;/code&gt; 前缀，&lt;code&gt;'абвгд'&lt;/code&gt; 部分将被高亮显示。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlCallNotationInspection" defaultSeverity="ERROR" displayName="使用命名实参和位置实参" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告位置实参在命名实参之后的调用。 适用于 PostgreSQL、Oracle 和 Db2。
&lt;p&gt;示例（PostgreSQL 中）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE FUNCTION foo(a int, b int, c int) RETURNS int
    LANGUAGE plpgsql AS
$$
BEGIN
    RETURN a + b + c;
END
$$;
SELECT foo(a =&gt; 1, b =&gt; 2, c =&gt; 3);
  -- `3` 在命名实参之后
SELECT foo(1, b =&gt; 2, 3);
  -- `1` 和 `3` 在命名实参之后
SELECT foo(b =&gt; 2, 1, 3);&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlSignatureInspection" defaultSeverity="WARNING" displayName="函数签名" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告内置函数的签名问题。
&lt;p&gt;检查将报告错误数量的实参、无效的关键字、错误的数据类型和其他问题。&lt;/p&gt;
&lt;p&gt;示例（MySQL）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE foo (a INT, b INT, c INT)

SELECT IFNULL() FROM foo; -- 错误
SELECT IFNULL(a) FROM foo; -- 错误
SELECT IFNULL(a, b) FROM foo; -- 正确
SELECT IFNULL(a, b, c) FROM foo; -- 错误&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 MySQL 中，&lt;code&gt;IFNULL()&lt;/code&gt; 函数严格接受两个实参。 因此，只有 &lt;code&gt;SELECT IFNULL(a, b) FROM foo;&lt;/code&gt; 查询是正确的。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlShouldBeInGroupByInspection" defaultSeverity="WARNING" displayName="列应在 group by 子句中" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告不在 GROUP BY 子句或聚合函数调用中的列。
&lt;p&gt;示例（Microsoft SQL 服务器）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE t1 (a INT, b INT);
SELECT a, b FROM t1 GROUP BY a;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果您运行 SELECT 查询，您将收到一个错误，因为 Microsoft SQL Server 需要 &lt;code&gt;b&lt;/code&gt; 列在 GROUP BY 中或在聚合函数内使用。 以下两个示例将修复该错误。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT a, b FROM t1 GROUP BY a, b;
SELECT a, max(b) max_b FROM t1 GROUP BY a;&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlCaseVsCoalesceInspection" defaultSeverity="WARNING" displayName="使用 CASE 代替 COALESCE 函数，反之亦然" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 CASE 和 COALESCE 调用可以互换的情况。 此检查具有以下意图操作：&lt;b&gt;替换为 'COALESCE' 调用&lt;/b&gt;和相反的 &lt;b&gt;替换为 CASE 表达式&lt;/b&gt;。
&lt;p&gt;示例（MySQL）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT
  -- this CASE may be replaced by COALESCE
	CASE
		WHEN C1 IS NOT NULL THEN C1
		ELSE 0
		END
FROM dual;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在该示例中，CASE 语句可以替换为 &lt;code&gt;SELECT COALESCE(C1, 0)&lt;/code&gt;，这会产生相同的结果。&lt;/p&gt;
&lt;p&gt;如果您更喜欢使用 CASE 表达式，请在检查页面上选择 &lt;b&gt;CASE 表达式优先于 COALESCE 函数&lt;/b&gt;选项。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlDerivedTableAliasInspection" defaultSeverity="WARNING" displayName="每个派生表都应具有别名" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告没有别名的派生表。
&lt;p&gt;示例（MySQL）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE table1 (id INT, name VARCHAR(20), cats FLOAT);
CREATE TABLE table2 (id INT, age INTEGER);

SELECT id AS ID, name, cats, age
FROM (SELECT table1.id, name, cats, age
FROM table1
JOIN table2 ON table1.id = table2.id);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;根据 &lt;a href="https://dev.mysql.com/doc/refman/8.0/en/derived-tables.html"&gt;dev.mysql.com 上的 Derived Tables&lt;/a&gt; 页面，别名是强制的。 您可以使用&lt;b&gt;引入别名&lt;/b&gt;快速修复来添加别名。&lt;/p&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT id AS ID, name, cats, age
FROM (SELECT table1.id, name, cats, age
FROM table1
JOIN table2 ON table1.id = table2.id);&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlAddNotNullColumnInspection" defaultSeverity="WARNING" displayName="添加没有默认值的非 null 列" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告创建没有 DEFAULT 值的 NOT NULL 列的尝试。
&lt;p&gt;示例（Microsoft SQL 服务器）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE foo (a INT, b  INT)

ALTER TABLE foo ADD c INT NOT NULL;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;默认情况下，列包含 NULL 值。 在示例中，我们使用 NOT NULL 约束强制列不接受 NULL 值。
  如果我们禁止使用 NULL 值，则必须设置 SQL 在创建新记录时可以使用的 DEFAULT 值。
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ALTER TABLE foo ADD c INT NOT NULL DEFAULT 42;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;您可以使用&lt;b&gt;添加 DEFAULT 值&lt;/b&gt;快速修复快速添加 DEFAULT 值。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlUnusedSubqueryItemInspection" defaultSeverity="WARNING" displayName="未使用的子查询项" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告外部查询表达式中未引用的列、别名和其他子查询项。
&lt;p&gt;示例（PostgreSQL）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE for_subquery(id INT);
SELECT a, q FROM (SELECT 1 AS a, 10 AS b, 2 + 3 AS q, id
      FROM for_subquery) x;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们引用子查询中的别名 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;q&lt;/code&gt;。 但是 &lt;code&gt;b&lt;/code&gt; 别名和 &lt;code&gt;id&lt;/code&gt; 列在外部 SELECT 语句中没有被引用。 因此，&lt;code&gt;b&lt;/code&gt; 和 &lt;code&gt;id&lt;/code&gt; 将显示为灰色。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlSideEffectsInspection" defaultSeverity="WARNING" displayName="具有副作用的语句" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在只读连接期间可能会修改数据库的语句。 &lt;p&gt;要为连接启用只读模式，请在&lt;b&gt;数据库&lt;/b&gt;工具窗口（&lt;b&gt;视图 | 工具窗口 | 数据库&lt;/b&gt;）中右键点击数据源，然后选择&lt;b&gt;属性&lt;/b&gt;。
  在&lt;b&gt;数据源和驱动程序&lt;/b&gt;对话框中，点击&lt;b&gt;选项&lt;/b&gt;选项卡并选中&lt;b&gt;只读&lt;/b&gt;复选框。&lt;/p&gt;
&lt;p&gt;示例（MySQL）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE foo(a INT);
INSERT INTO foo VALUES (1);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由于 &lt;code&gt;CREATE TABLE&lt;/code&gt; 和&lt;code&gt;INSERT INTO&lt;/code&gt; 语句会导致数据库修改，因此这些语句将在只读连接模式中高亮显示。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlRedundantElseNullInspection" defaultSeverity="WARNING" displayName="冗余 ELSE NULL 子句" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告冗余的 ELSE NULL 子句。
&lt;p&gt;示例（MySQL）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT CASE WHEN 2 &gt; 1 THEN 'OK' ELSE NULL END AS alias FROM foo;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;ELSE NULL&lt;/code&gt; 部分永远不会被执行，可以省略。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlRedundantCodeInCoalesceInspection" defaultSeverity="WARNING" displayName="COALESCE 调用中的冗余代码" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告除 COALESCE 函数中第一个不评估为 NULL 的表达式之外的所有实参。
&lt;p&gt;示例（MySQL）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT COALESCE(NULL, NULL, NULL, 42, NULL, 'string') as a;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第一个 NOT NULL 实参是 &lt;code&gt;42&lt;/code&gt;，所有其他实参将显示为灰色。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlAmbiguousColumnInspection" defaultSeverity="WARNING" displayName="不明确的引用" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告名称相同但属于不同表的列。
&lt;p&gt;示例（MySQL）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE foo(id INT PRIMARY KEY);
CREATE TABLE bar(id INT PRIMARY KEY);

SELECT foo.id, bar.id FROM foo, bar WHERE id &gt; 0;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;id&lt;/code&gt; 列出现在 &lt;code&gt;foo&lt;/code&gt; 和 &lt;code&gt;bar&lt;/code&gt; 表中。 您需要限定列名以使查询正确。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT foo.id, bar.id FROM foo, bar WHERE foo.id &gt; 0;&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlDuplicateColumnInspection" defaultSeverity="WARNING" displayName="SELECT 中的重复列名" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 SELECT 列表中列别名的重复名称。
&lt;p&gt;示例（Sybase ASE）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE t1 (a TEXT, b INT, c INT);

SELECT a AS x, b AS x FROM t1;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;x&lt;/code&gt; 别名用于 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 列。 这些分配高亮显示为错误，因为您不能对 Sybase ASE 中的列使用相同的别名。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlRedundantOrderingDirectionInspection" defaultSeverity="WARNING" displayName="冗余排序方向" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
在 ORDER BY 子句中报告冗余的排序方向，如 ASC 和 DESC。
&lt;p&gt;示例（MySQL）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE foo(a INT, b INT, c INT);
SELECT * FROM foo ORDER BY a ASC, b DESC, c ASC;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ORDER BY 关键字默认按升序对记录进行排序。 因此，&lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;c&lt;/code&gt; 列的 &lt;code&gt;ASC&lt;/code&gt; 关键字是冗余的。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlCurrentSchemaInspection" defaultSeverity="WARNING" displayName="已内省当前控制台架构" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告当前会话中未自省的架构和数据库。
&lt;p&gt;例如，当您尝试在未内省的架构中创建表时，可能会出现此警告。&lt;/p&gt;
&lt;p&gt;内省是一种检查数据源的方法。 执行内省时，将从数据库中检索结构信息以检测各种对象及其特性。例如，可能是表、列、函数和其他元素。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlUnreachableCodeInspection" defaultSeverity="WARNING" displayName="无法访问的代码" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 SQL 例程中不可到达的语句。
&lt;p&gt;示例（Microsoft SQL 服务器）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE FUNCTION foo() RETURNS INT AS
BEGIN
    THROW;
    RETURN 1;
END;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 Microsoft SQL Server 中，&lt;code&gt;THROW&lt;/code&gt; 语句会抛出异常并将执行转移到 TRY...CATCH 结构的 CATCH 块。 因此，&lt;code&gt;RETURN 1;&lt;/code&gt; 部分将永远不会被执行。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlGotoInspection" defaultSeverity="WARNING" displayName="使用 GOTO 语句" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告后向 GOTO 语句和用于退出循环的 GOTO 语句的用法。
&lt;p&gt;通常不推荐大量使用 GOTO 语句。 有关详细信息，请参阅 &lt;a href="https://www.ibm.com/docs/no/db2/11.5?topic=procedures-goto-statement-in-sql"&gt;ibm.com 上的 GOTO statement in SQL procedures&lt;/a&gt; 页面。&lt;/p&gt;

&lt;p&gt;考虑使用循环而不是使用 GOTO 返回到上一条语句。&lt;/p&gt;
&lt;p&gt;考虑使用另一个流控制语句，例如 RETURN 或 BREAK，而不是使用 GOTO 退出 WHILE 循环。&lt;/p&gt;
&lt;p&gt;示例（Oracle）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE PROCEDURE test(n INT) AS
DECLARE
    x INT;
BEGIN
    x := 0;
    GOTO a;
    &amp;lt;&amp;lt;a&amp;gt;&amp;gt; x := 1;
    IF (n = 0) THEN
        GOTO a;
    END IF;
    WHILE TRUE
        LOOP
            GOTO b;
        END LOOP;
    &amp;lt;&amp;lt;b&amp;gt;&amp;gt; x := 3;
END;&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlMissingReturnInspection" defaultSeverity="ERROR" displayName="缺少 return 语句" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告没有 RETURN 语句的函数。

&lt;p&gt;示例（Oracle）：&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;CREATE FUNCTION foo RETURN int AS
BEGIN
END;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;foo&lt;/code&gt; 函数必须返回整数值，但函数体不返回任何内容。 要修正错误，请添加 RETURN 语句（例如，&lt;code&gt;RETURN 1;&lt;/code&gt;）。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CREATE FUNCTION foo RETURN int AS
BEGIN
 RETURN 1;
END;&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlUnusedCteInspection" defaultSeverity="WARNING" displayName="未使用的通用表表达式" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告查询中未使用的通用表表达式 (CTE)。
&lt;p&gt;示例（PostgreSQL）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE foo(a INT);

WITH a AS (SELECT 1 AS x FROM foo)
SELECT 1 + 2 FROM foo;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过使用 WITH，我们创建了一个名为 &lt;code&gt;a&lt;/code&gt; 的临时命名结果集，也称为通用表表达式 (CTE)。 但是，我们稍后不会在代码中使用此 CTE。 未使用的 CTE 显示为灰色。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlIllegalCursorStateInspection" defaultSeverity="WARNING" displayName="非法光标状态" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 SQL 例程中的非法光标状态。
&lt;ul&gt;
  &lt;li&gt;例程具有 CLOSE 或 FETCH 语句，但光标可能已被关闭。&lt;/li&gt;
  &lt;li&gt;例程具有 OPEN 语句，但光标可能已被打开。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;示例（Microsoft SQL 服务器）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE t(col INT);

CREATE PROCEDURE foo() AS
BEGIN
DECLARE my_cursor CURSOR FOR SELECT * FROM t;
DECLARE a INT;
FETCH my_cursor INTO a;
CLOSE my_cursor;
END;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;根据 &lt;a href="https://docs.microsoft.com/en-us/sql/t-sql/language-elements/close-transact-sql"&gt;docs.microsoft.com 上的 CLOSE (Transact-SQL)&lt;/a&gt; 页面，必须为打开的光标执行 CLOSE，并且不允许对仅声明或已经关闭的光标执行 CLOSE。 因此，我们需要打开光标来修正警告。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE PROCEDURE foo() AS
BEGIN
DECLARE my_cursor CURSOR FOR SELECT * FROM t;
DECLARE a INT;
OPEN my_cursor;
FETCH my_cursor INTO a;
CLOSE my_cursor;
END;&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="方法指标" path="Java"><inspection shortName="ParametersPerConstructor" defaultSeverity="WARNING" displayName="形参过多的构造函数" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告形参数量超过指定最大值的构造函数。
此类对象很难实例化，特别是在某些形参是可选形参的情况下。
构造函数的形参过多可能表明有必要重构。
例如，请考虑应用构建器模式。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public BankAccount(long accountNumber,
                     String owner,
                     double balance,
                     double interestRate) {
    // fields initialization
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;配置检查：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;使用&lt;b&gt;形参限制&lt;/b&gt;字段可以指定构造函数中允许的最大形参数量。&lt;/li&gt;
  &lt;li&gt;使用&lt;b&gt;忽略具有以下可见性的构造函数&lt;/b&gt;列表可指定检查是否应忽略具有特定可见性的构造函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NonCommentSourceStatements" defaultSeverity="WARNING" displayName="过长的方法" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告语句数超过指定最大值的方法。
&lt;p&gt;语句过多的方法可能令人困惑，并且表明可能有必要重构。&lt;/p&gt;
&lt;p&gt;以下语句不计算在内：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;空语句（分号）&lt;/li&gt;
  &lt;li&gt;块语句&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;for&lt;/code&gt; 循环初始化语句，即 &lt;code&gt;for(int i = ...;...)&lt;/code&gt; 语句内的 &lt;code&gt;int i = ...&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;for&lt;/code&gt; 循环 update 语句，即 &lt;code&gt;for(int i = ...;...; i += 2)&lt;/code&gt; 语句内的 &lt;code&gt;i += 2&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;使用&lt;b&gt;每个方法的最大语句数&lt;/b&gt;字段可指定方法中允许的最大语句数。&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CyclomaticComplexity" defaultSeverity="WARNING" displayName="过度复杂的方法" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告分支点过多的方法。
&lt;p&gt;分支点是以下选项之一：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;循环语句&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;if&lt;/code&gt; 语句&lt;/li&gt;
  &lt;li&gt;三元表达式&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;catch&lt;/code&gt; 部分&lt;/li&gt;
  &lt;li&gt;包含一个或多个 &lt;code&gt;&amp;&amp;&lt;/code&gt; 或 &lt;code&gt;||&lt;/code&gt; 运算符的表达式&lt;/li&gt;
  &lt;li&gt;具有非默认分支的 &lt;code&gt;switch&lt;/code&gt; 块&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;循环复杂度过高的方法可能令人困惑且难以测试。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;使用&lt;b&gt;方法复杂度限制&lt;/b&gt;字段可指定一个方法允许的最大循环复杂度。&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MethodCoupling" defaultSeverity="WARNING" displayName="过度耦合的方法" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告引用过多其他类的方法。
耦合度过高的方法可能非常脆弱，应该被拆分为较小的方法。
&lt;p&gt;无论被引用多少次，每个被引用的类都只被计算一次。&lt;/p&gt;
  &lt;!-- tooltip end --&gt;
&lt;p&gt;配置检查：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;使用&lt;b&gt;方法耦合限制&lt;/b&gt;字段可指定方法允许的最大耦合度。&lt;/li&gt;
  &lt;li&gt;使用&lt;b&gt;包括与 Java 系统类的耦合&lt;/b&gt;选项可计算对 &lt;code&gt;java&lt;/code&gt; 或 &lt;code&gt;javax&lt;/code&gt; 软件包中的类的引用。&lt;/li&gt;
  &lt;li&gt;使用&lt;b&gt;包括与库类的耦合&lt;/b&gt;选项可计算对第三方库类的引用。&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="OverlyLongLambda" defaultSeverity="WARNING" displayName="过长的 lambda 表达式" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告语句数超过指定最大值的 lambda 表达式。
&lt;p&gt;过长的 lambda 表达式可能令人困惑，将语句提取到单独的方法中通常会更好。&lt;p&gt;
&lt;p&gt;以下语句不计算在内：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;空语句（分号）&lt;/li&gt;
  &lt;li&gt;块语句&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;for&lt;/code&gt; 循环初始化语句，即 &lt;code&gt;for(int i = ...;...)&lt;/code&gt; 语句内的 &lt;code&gt;int i = ...&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;for&lt;/code&gt; 循环 update 语句，即 &lt;code&gt;for(int i = ...;...; i += 2)&lt;/code&gt; 语句内的 &lt;code&gt;i += 2&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;使用&lt;b&gt;非注释源语句限制&lt;/b&gt;字段可指定 lambda 表达式中允许的最大语句数。&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NestingDepth" defaultSeverity="WARNING" displayName="过度嵌套的方法" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告主体包含嵌套过深语句的方法。
&lt;p&gt;语句嵌套过深的方法可能令人困惑，并且表明可能有必要重构。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;使用&lt;b&gt;嵌套深度限制&lt;/b&gt;字段可指定方法允许的最大嵌套深度。&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MethodWithMultipleLoops" defaultSeverity="WARNING" displayName="具有多个循环的方法" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告包含多个循环语句的方法。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;以下方法将被报告，因为它包含两个循环：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void methodWithTwoLoops(int n1, int n2) {
    for (int i = 0; i &amp;lt; n1; i++) {
      System.out.println(i);
    }

    int j = 0;
    while (j &amp;lt; n2) {
      System.out.println(j);
      j++;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以下方法也会被报告，因为它包含嵌套循环：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void methodWithNestedLoop(int n1, int n2) {
    for (int i = 0; i &amp;lt; n1; i++) {
      for (int j = 0; j &amp;lt; n2; j++) {
        System.out.println(i + j);
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MultipleReturnPointsPerMethod" defaultSeverity="WARNING" displayName="具有多个返回点的方法" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;return&lt;/code&gt; 点数超过指定最大值的方法。
具有太多 &lt;code&gt;return&lt;/code&gt; 点的方法可能令人困惑且难以重构。
&lt;p&gt;一个 &lt;code&gt;return&lt;/code&gt; 点可以是 &lt;code&gt;return&lt;/code&gt; 语句，也可以是从 &lt;code&gt;void&lt;/code&gt; 方法或构造函数底部的直落。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;如果只允许两个 &lt;code&gt;return&lt;/code&gt; 语句，则报告以下方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void doSmth(User[] users) {
    for (User user : users) {
      if (cond1(user)) {
        user.setId(getId());
        return;
      } else if (cond2(user)) {
        if (cond3(user)) {
          user.setId(getId());
          return;
        }
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;请考虑重写该方法，使其更容易理解：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void doSmth(User[] users) {
    for (User user : users) {
      if (cond1(user) || cond2(user) &amp;&amp; cond3(user)) {
        user.setId(getId());
        return;
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;配置检查：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;使用 &lt;b&gt;return 点限制&lt;/b&gt;字段可指定方法允许的最大 &lt;code&gt;return&lt;/code&gt; 点数。&lt;/li&gt;
  &lt;li&gt;使用&lt;b&gt;忽略临界子句&lt;/b&gt;选项可忽略临界子句。
    临界子句是只包含 &lt;code&gt;return&lt;/code&gt; 语句的 &lt;code&gt;if&lt;/code&gt; 语句&lt;/li&gt;
  &lt;li&gt;使用&lt;b&gt;对 'equals()' 方法忽略&lt;/b&gt;选项可忽略 &lt;code&gt;equals()&lt;/code&gt; 方法中的 &lt;code&gt;return&lt;/code&gt; 点。&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ThreeNegationsPerMethod" defaultSeverity="WARNING" displayName="具有三个以上否定的方法" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告有三个或更多否定的方法。
此类方法可能令人困惑。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void doSmth(int a, int b, boolean flag1, boolean flag2) {
    if (!flag &amp;&amp; !flag2) {
      if (a != b) {
        doOther();
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;没有否定，该方法变得更容易理解：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void doSmth(int a, int b, boolean flag1, boolean flag2) {
    if (flag1 || flag2 || a == b) return;
    doOther();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;配置检查：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;使用&lt;b&gt;忽略 'equals()' 方法中的否定&lt;/b&gt;选项可禁用 &lt;code&gt;equals()&lt;/code&gt; 方法中的检查。&lt;/li&gt;
  &lt;li&gt;使用&lt;b&gt;忽略 'assert' 语句中的否定&lt;/b&gt;可禁用 &lt;code&gt;assert&lt;/code&gt; 语句中的检查。&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ParametersPerMethod" defaultSeverity="WARNING" displayName="形参过多的方法" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告形参数量超过指定最大值的方法。
方法的形参过多可能表明有必要重构。
&lt;p&gt;不报告具有 super 方法的方法。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;使用&lt;b&gt;形参限制&lt;/b&gt;字段可以指定方法允许的最大形参数量。&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ThrownExceptionsPerMethod" defaultSeverity="WARNING" displayName="方法声明的异常过多" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在 &lt;code&gt;throws&lt;/code&gt; 列表中具有过多异常类型的方法。
&lt;p&gt;声明了太多异常的方法是错误处理代码变得过于复杂的标志。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;使用&lt;b&gt;异常抛出限制&lt;/b&gt;字段可指定方法在其 &lt;code&gt;throws&lt;/code&gt; 列表中允许的最大异常类型数。&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="EL" path=""><inspection shortName="ELValidationInspection" defaultSeverity="WARNING" displayName="EL 验证" enabled="false" language="EL" pluginId="com.intellij.javaee.el" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可能的 EL 问题，例如未解析的引用和无效的 EL 位置。
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="无效元素" path="CSS"><inspection shortName="CssUnknownProperty" defaultSeverity="WARNING" displayName="未知属性" enabled="false" language="CSS" pluginId="com.intellij.css" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告未知的 CSS 属性或在错误的上下文中使用的属性。
&lt;!-- tooltip end --&gt;
&lt;p&gt;将未知属性添加到“自定义 CSS 属性”列表以跳过验证。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CssInvalidPseudoSelector" defaultSeverity="ERROR" displayName="无效的伪选择器" enabled="false" language="CSS" pluginId="com.intellij.css" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告不正确的 CSS &lt;a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-classes"&gt;pseudo-class&lt;/a&gt;
&lt;a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-elements"&gt;pseudo-element&lt;/a&gt;。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CssInvalidPropertyValue" defaultSeverity="ERROR" displayName="无效的属性值" enabled="false" language="CSS" pluginId="com.intellij.css" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告不正确的 CSS 属性值。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CssInvalidMediaFeature" defaultSeverity="ERROR" displayName="无效媒体特性" enabled="false" language="CSS" pluginId="com.intellij.css" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告未知 &lt;a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Media_Queries/Using_media_queries"&gt;CSS 媒体特性&lt;/a&gt;或不正确的媒体特性值。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CssInvalidHtmlTagReference" defaultSeverity="WARNING" displayName="无效类型选择器" enabled="false" language="CSS" pluginId="com.intellij.css" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告与未知 HTML 元素匹配的 CSS &lt;a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Type_selectors"&gt;类型选择器&lt;/a&gt;。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CssInvalidAtRule" defaultSeverity="ERROR" displayName="未知 @ 规则" enabled="false" language="CSS" pluginId="com.intellij.css" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告未知的 &lt;a href="https://developer.mozilla.org/en-US/docs/Web/CSS/At-rule"&gt;CSS @ 规则&lt;/a&gt;。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CssUnknownTarget" defaultSeverity="ERROR" displayName="未解析的文件引用" enabled="false" language="CSS" pluginId="com.intellij.css" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告未解析的文件引用，例如 &lt;code&gt;@import&lt;/code&gt; 语句中的不正确路径。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CssInvalidCharsetRule" defaultSeverity="WARNING" displayName="@charset 位置错误或不正确" enabled="false" language="CSS" pluginId="com.intellij.css" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告位置错误的 &lt;code&gt;@charset&lt;/code&gt; @ 规则或不正确的字符集值。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CssNegativeValue" defaultSeverity="ERROR" displayName="负属性值" enabled="false" language="CSS" pluginId="com.intellij.css" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告应不小于零的 CSS 负值属性（例如对象的宽度或高度）。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CssUnresolvedCustomProperty" defaultSeverity="ERROR" displayName="未解析的自定义属性" enabled="false" language="CSS" pluginId="com.intellij.css" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对 &lt;code&gt;var()&lt;/code&gt; 函数实参中的&lt;a href="https://developer.mozilla.org/en-US/docs/Web/CSS/--*"&gt;自定义属性&lt;/a&gt;的未解析引用。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CssInvalidFunction" defaultSeverity="ERROR" displayName="无效函数" enabled="false" language="CSS" pluginId="com.intellij.css" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告未知的 &lt;a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Functions"&gt;CSS 函数&lt;/a&gt;或不正确的函数形参。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CssInvalidImport" defaultSeverity="WARNING" displayName="@import 位置错误" enabled="false" language="CSS" pluginId="com.intellij.css" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告位置错误的 &lt;code&gt;@import&lt;/code&gt; 语句。
&lt;p&gt;
  根据&lt;a href="https://developer.mozilla.org/en-US/docs/Web/CSS/@import"&gt;规范&lt;/a&gt;，
&lt;code&gt;@import&lt;/code&gt; 规则必须优先于其他所有类型的规则，但 &lt;code&gt;@charset&lt;/code&gt; 规则除外。
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CssUnresolvedClassInComposesRule" defaultSeverity="ERROR" displayName="'composes' 规则中的未解析类" enabled="false" language="CSS" pluginId="com.intellij.css" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;a href="https://github.com/css-modules/css-modules#composition"&gt;'composes'&lt;/a&gt; 规则中无法解析为任何有效目标的 CSS 类引用。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  .className {/* ... */}

  .otherClassName {
    composes: className;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="类指标" path="Java"><inspection shortName="MethodCount" defaultSeverity="WARNING" displayName="方法过多的类" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告方法数超过指定最大值的类。
&lt;p&gt;具有太多方法的类通常会试图“进行过多处理”。 请考虑将这种类拆分为多个较小的类。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;配置检查：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;使用&lt;b&gt;方法计数限制&lt;/b&gt;字段可指定类中允许的最大方法数。&lt;/li&gt;
  &lt;li&gt;使用&lt;b&gt;忽略简单的 getter 和 setter 方法&lt;/b&gt;选项可忽略方法计数中的简单 getter 和 setter。&lt;/li&gt;
  &lt;li&gt;使用&lt;b&gt;忽略重写/实现 super 方法的方法&lt;/b&gt;可忽略重写或实现 super 类方法的方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AnonymousClassMethodCount" defaultSeverity="WARNING" displayName="具有太多方法的匿名内部类" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告方法数超过指定最大值的匿名内部类。
&lt;p&gt;具有大量方法的匿名类可能难以理解，应该提升为命名内部类。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;使用&lt;b&gt;方法计数限制&lt;/b&gt;字段可指定匿名内部类中允许的最大方法数。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FieldCount" defaultSeverity="WARNING" displayName="字段过多的类" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告字段数超过指定最大值的类。
&lt;p&gt;具有大量字段的类通常会试图进行过多处理。 请考虑将这种类拆分为多个较小的类。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;配置检查：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;使用&lt;b&gt;字段计数限制&lt;/b&gt;字段可指定类中允许的最大字段数。&lt;/li&gt;
  &lt;li&gt;使用&lt;b&gt;在计数中包含常量字段&lt;/b&gt;选项可指示是否应计算常量字段。&lt;/li&gt;
  &lt;li&gt;默认情况下，只有不可变的 &lt;code&gt;static final&lt;/code&gt; 对象会被计为常量。 使用&lt;b&gt;将 'static final' 字段计为常量&lt;/b&gt;选项可将任何 &lt;code&gt;static final&lt;/code&gt; 字段计为常量。&lt;/li&gt;
  &lt;li&gt;使用&lt;b&gt;在计数中包含枚举常量&lt;/b&gt;选项可指定是否应计算 &lt;code&gt;enum&lt;/code&gt; 类中的 &lt;code&gt;enum&lt;/code&gt; 常量。&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ClassInheritanceDepth" defaultSeverity="WARNING" displayName="类在继承树中太深" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告继承层次结构过深的类。
&lt;p&gt;继承太深的类可能令人困惑，并表明有必要重构。&lt;/p&gt;
&lt;p&gt;库中的所有超类都被视为单个超类，库被认为不可修改。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;使用&lt;b&gt;继承深度限制&lt;/b&gt;字段可指定类的最大继承深度。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConstructorCount" defaultSeverity="WARNING" displayName="构造函数过多的类" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告构造函数数量超过指定最大值的类。
&lt;p&gt;具有太多构造函数的类容易出现初始化错误，通常建议将这种类建模为多个子类。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;配置检查：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;使用&lt;b&gt;构造函数计数限制&lt;/b&gt;字段可指定类中允许的构造函数的最大数量。&lt;/li&gt;
  &lt;li&gt;使用&lt;b&gt;忽略弃用的构造函数&lt;/b&gt;选项可避免将已弃用的构造函数添加到总计数中。&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AnonymousClassComplexity" defaultSeverity="WARNING" displayName="过度复杂的匿名类" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告总复杂度超过指定最大值的匿名内部类。
&lt;p&gt;类的总复杂度是该类声明的所有方法和初始值设定项的循环复杂度的总和。 继承的方法和初始值设定项不计入总复杂度。&lt;/p&gt;
&lt;p&gt;匿名类应该具有非常低的复杂度，否则它们会难以理解并且应提升为命名的内部类。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;使用&lt;b&gt;循环复杂度限制&lt;/b&gt;字段可指定类允许的最大复杂度。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ClassNestingDepth" defaultSeverity="WARNING" displayName="内部类嵌套太深" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告嵌套内部类的数量超过指定最大值的类。
&lt;p&gt;将内部类嵌套在其他内部类中令人困惑，并表明可能有必要重构。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;使用&lt;b&gt;嵌套限制&lt;/b&gt;字段可指定类允许的最大嵌套深度。&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ClassCoupling" defaultSeverity="WARNING" displayName="过度耦合的类" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告引用过多其他类的类。
&lt;p&gt;耦合度过高的类可能非常脆弱，应该被拆分为较小的类。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;配置检查：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;使用&lt;b&gt;类耦合限制&lt;/b&gt;字段可指定类允许的最大耦合度。&lt;/li&gt;
  &lt;li&gt;使用&lt;b&gt;包括与 Java 系统类的耦合&lt;/b&gt;选项可指定是否应计算对系统类（&lt;code&gt;java.&lt;/code&gt; 或 &lt;code&gt;javax.&lt;/code&gt; 软件包中的那些类）的引用。&lt;/li&gt;
  &lt;li&gt;使用&lt;b&gt;包括与库类的耦合&lt;/b&gt;选项可指定是否应该计算对任何库类的引用。&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ClassComplexity" defaultSeverity="WARNING" displayName="过度复杂的类" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告总复杂度超过指定最大值的类。
&lt;p&gt;类的总复杂度是该类声明的所有方法和初始值设定项的循环复杂度的总和。 继承的方法和初始值设定项不计入总复杂度。&lt;/p&gt;
&lt;p&gt;过高的复杂度表明该类应该被重构为几个更小的类。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;使用下面的&lt;b&gt;循环复杂度限制&lt;/b&gt;字段可指定类允许的最大复杂度。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="AOP" path=""><inspection shortName="DeclareParentsInspection" defaultSeverity="ERROR" displayName="引入(声明父级)错误" enabled="false" pluginId="com.intellij.aop" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;@AspectJ&lt;/code&gt; 引入不一致：检查 &lt;code&gt;defaultImpl&lt;/code&gt; 是否必需，如果是，它是否实现给定接口。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AroundAdviceStyleInspection" defaultSeverity="WARNING" displayName="Around 建议样式检查" enabled="false" pluginId="com.intellij.aop" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;在使用 &lt;code&gt;@Around&lt;/code&gt; 建议时，请记住两点：
&lt;ul&gt;
  &lt;li&gt;需要调用 &lt;code&gt;org.aspectj.lang.ProceedingJoinPoint#proceed&lt;/code&gt;，否则调用将无法到达目标。&lt;/li&gt;
  &lt;li&gt;需要返回该调用的结果值（类型化 &lt;code&gt;java.lang.Object&lt;/code&gt;），否则返回值永远不会到达原始调用方。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不过，以下两种状况几乎始终表明存在编码错误：&lt;p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;@Around&lt;/code&gt; 方法的签名未使用 &lt;code&gt;ProceedingJoinPoint&lt;/code&gt; 作为第一个实参：在这种情况下，调用无法到达目标。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;@Around&lt;/code&gt; 方法的签名未使用 &lt;code&gt;Object&lt;/code&gt; 作为返回类型：在这种情况下，目标方法的返回值总是丢失。&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PointcutMethodStyleInspection" defaultSeverity="WARNING" displayName="切入点方法样式" enabled="false" pluginId="com.intellij.aop" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
验证 &lt;code&gt;@Pointcut&lt;/code&gt; 方法： 返回类型是否为 &lt;code&gt;void&lt;/code&gt;，有无 &lt;code&gt;throws&lt;/code&gt; 子句以及方法体是否为空。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ArgNamesErrorsInspection" defaultSeverity="ERROR" displayName="建议参数(argNames, returning, throwing)一致性检查" enabled="false" pluginId="com.intellij.aop" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
如果 &lt;code&gt;@AspectJ&lt;/code&gt; &lt;code&gt;argNames&lt;/code&gt; 特性值与实际方法形参名称不一致，则报告。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ArgNamesWarningsInspection" defaultSeverity="WARNING" displayName="警告: 未定义 argNames" enabled="false" pluginId="com.intellij.aop" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
如果未在 &lt;code&gt;@AspectJ&lt;/code&gt; 注解中定义 &lt;code&gt;argNames&lt;/code&gt; 特性，则报告。
&lt;p&gt;建议在 &lt;code&gt;@AspectJ&lt;/code&gt; 注解中定义 &lt;code&gt;argNames&lt;/code&gt; 特性，因为方法形参名称在运行时可能不可用。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="方法" path="Java/命名约定"><inspection shortName="OverloadedVarargsMethod" defaultSeverity="WARNING" displayName="重载 vararg 方法" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告与类或超类中的其他方法同名的 vararg 方法。
采用可变数量实参的重载方法可能非常令人困惑，因为通常不清楚调用的是哪个重载。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    public void execute(Runnable... r) {} // 警告
    public void execute(Runnable r1, Runnable r2) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="BooleanMethodNameMustStartWithQuestion" defaultSeverity="WARNING" displayName="布尔方法名称必须以疑问词开头" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告名称不以疑问词开头的布尔方法。
&lt;p&gt;此检查将忽略重写库方法的布尔方法。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;boolean empty(List&amp;lt;String&amp;gt; list) {
  return list.isEmpty();
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;只能在编辑器中使用重命名此类方法的快速修复。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;配置检查：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;使用&lt;b&gt;布尔方法名称前缀&lt;/b&gt;列表可指定布尔方法名称开头可以接受的疑问词。&lt;/li&gt;
  &lt;li&gt;使用&lt;b&gt;忽略具有 'java.lang.Boolean' 返回类型的方法&lt;/b&gt;选项，可忽略返回类型为 &lt;code&gt;java.lang.Boolean&lt;/code&gt; 的方法。 &lt;/li&gt;
  &lt;li&gt;使用&lt;b&gt;忽略 @&amp;interface 中的布尔方法&lt;/b&gt;选项，可忽略注解返回类型 (&lt;code&gt;@interface&lt;/code&gt;) 的布尔方法。&lt;/li&gt;
  &lt;li&gt;使用&lt;b&gt;忽略重写/实现 super 方法的方法&lt;/b&gt;选项，可忽略具有 super 方法的方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NewMethodNamingConvention" defaultSeverity="WARNING" displayName="方法命名约定" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告名称太短、太长或不遵循指定正则表达式模式的方法。
&lt;p&gt;此检查将忽略重写库方法和构造函数的实例方法。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例&lt;/b&gt;：如果对 static 方法启用检查，并且指定的方法名称的最小长度为 4（默认值），则以下 static 方法会产生警告，因为其名称长度为 3，即小于 4：&lt;code&gt;public static int max(int a, int b)&lt;/code&gt;。
&lt;p&gt;只能在编辑器中使用重命名此类方法的快速修复。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;配置检查：&lt;/p&gt;
&lt;p&gt;使用&lt;b&gt;选项&lt;/b&gt;部分中的列表可指定应检查哪些方法。 取消选中要跳过检查的方法类型的复选框。 在长度字段中指定 &lt;b&gt;0&lt;/b&gt; 可跳过相应检查。&lt;/p&gt;
&lt;p&gt;正则表达式应以标准 &lt;code&gt;java.util.regex&lt;/code&gt; 格式指定。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MethodNameSameAsClassName" defaultSeverity="WARNING" displayName="方法名称与类名相同" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告与其类同名的方法。
虽然 Java 语言允许此类命名，但按照约定，它被保留用于定义构造函数。
将它用于方法可能是一种错误或不好的做法。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class MyClass {
    int val;

    // 方法 MyClass 的名称与其包含类相同。
    // 可能是错误添加了 'void'。
    void MyClass(int val) {
      this.val = val;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在适当的情况下，可以通过快速修复将方法转换为构造函数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class MyClass {
    int val;

    MyClass(int val) {
      this.val = val;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以通过另一种快速修复重命名该方法。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MisspelledMethodName" defaultSeverity="WARNING" displayName="方法名称仅大小写不同" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告一个类的多个方法的名称仅大小写不同的情况。 此类名称可能非常令人困惑。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;
&lt;pre&gt;&lt;code&gt;
  public int hashcode() { // 已报告，可能应为 hashCode？
    return 0;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;只能在编辑器中使用重命名此类方法的快速修复。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;使用&lt;b&gt;忽略方法重写/实现 super 方法&lt;/b&gt;选项，可以忽略重写或实现超类中方法的方法。
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MethodNameSameAsParentName" defaultSeverity="WARNING" displayName="方法名称与父类名相同" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告与此方法的类的超类同名的方法，因为此类方法名称可能令人困惑。
&lt;p&gt;此检查不会检查层次结构深处的接口或超类。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;
&lt;pre&gt;&lt;code&gt;
  class Parent {}
  class Child extends Parent {
     public Parent Parent() {
       return null;
     }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;只能在编辑器中使用重命名此类方法的快速修复。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="OverloadedMethodsWithSameNumberOfParameters" defaultSeverity="WARNING" displayName="具有相同形参数量的重载方法" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在同一类中声明、具有相同名称和相同数量形参的方法。
此类重载可能非常令人困惑，因为可能不清楚调用的是哪个重载。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Main {
    public static void execute(Runnable r) {}
    public static &amp;lt;T&amp;gt; void execute(RunnableFuture&amp;lt;T&amp;gt; c) {}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用该选项可以忽略形参类型绝对不兼容的重载方法。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NonBooleanMethodNameMayNotStartWithQuestion" defaultSeverity="WARNING" displayName="非布尔方法名称不能以疑问词开头" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告名称以疑问词开头的非布尔方法。 此类方法名称可能令人困惑。
&lt;p&gt;此检查将忽略重写库方法的非布尔方法。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;
&lt;pre&gt;&lt;code&gt;
  public void hasName(String name) {
    assert names.contains(name);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;只能在编辑器中使用重命名此类方法的快速修复。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;配置检查：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;使用&lt;b&gt;布尔方法名称前缀&lt;/b&gt;列表可指定应仅用于布尔方法的疑问词。&lt;/li&gt;
  &lt;li&gt;使用&lt;b&gt;忽略具有 'java.lang.Boolean' 返回类型的方法&lt;/b&gt;选项可忽略返回类型为 &lt;code&gt;java.lang.Boolean&lt;/code&gt; 的方法。&lt;/li&gt;
  &lt;li&gt;使用&lt;b&gt;忽略重写/实现 super 方法的方法&lt;/b&gt;选项可忽略具有 super 方法的方法。 &lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LambdaUnfriendlyMethodOverload" defaultSeverity="WARNING" displayName="方法重载对 lambda 不友好" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告采用的函数接口存在抽象方法签名冲突的重载方法。
&lt;p&gt;此类重载会引入歧义，并要求调用方将 lambda 转换为特定类型或显式指定 lambda 形参类型。
  最好为重载方法赋予不同的名称，以消除歧义。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  interface MyExecutor {
    void execute(Supplier&amp;lt;?&amp;gt; supplier);
    void execute(Callable&amp;lt;?&amp;gt; callable);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
这里的 &lt;code&gt;Supplier&lt;/code&gt; 和 &lt;code&gt;Callable&lt;/code&gt; 为函数接口，其单抽象方法不接受任何形参并返回非 void 值。
因此，除非使用显式转换，否则无法在调用点推断 lambda 的类型。
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="样式" path="Groovy"><inspection shortName="GrUnnecessaryFinalModifier" defaultSeverity="WARNING" displayName="不必要的 'final'" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告与记录定义一起使用时不必要的 &lt;code&gt;final&lt;/code&gt; 修饰符。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;final&lt;/b&gt; record R(int a) {} // 不需要修饰符
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GrStringStyleViolation" defaultSeverity="WEAK WARNING" displayName="字符串样式违规" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告具有不符合代码样式的引号的字符串。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  def hw = "Hello, world!"
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  def hw = 'Hello, world!'
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;使用下面提供的字段可为不同种类的字符串指定代码样式。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyConditional" defaultSeverity="WARNING" displayName="三元表达式" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告三元表达式。
&lt;p&gt;某些编码标准禁止使用条件运算符，而是支持 &lt;code&gt;if&lt;/code&gt; 语句。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="JavaStylePropertiesInvocation" defaultSeverity="INFORMATION" displayName="Java 风格的属性访问" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告通过方法调用访问的属性。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
      int foo
  }

  def bar = new Foo()
  print(&lt;b&gt;bar.getFoo()&lt;/b&gt;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
      int foo
  }

  def bar = new Foo()
  print(&lt;b&gt;bar.foo&lt;/b&gt;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GrUnnecessaryDefModifier" defaultSeverity="WARNING" displayName="不必要的 'def'" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告与显式类型声明一起使用时不必要的 &lt;code&gt;def&lt;/code&gt; 修饰符。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;def&lt;/b&gt; boolean foo() {} // 修饰符不必要
  &lt;b&gt;def&lt;/b&gt; Object bar // 修饰符不必要

  // 修饰符是必要的，因此未高亮显示
  &lt;b&gt;def&lt;/b&gt; (int a, String b) = []
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GrUnnecessaryNonSealedModifier" defaultSeverity="WARNING" displayName="不必要的 'non-sealed' 修饰符" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告在方法、字段或变量上使用的不必要的 &lt;code&gt;non-sealed&lt;/code&gt; 修饰符。&lt;/p&gt;
&lt;p&gt;此修饰符仅对类、接口和特征有效。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;non-sealed&lt;/b&gt; boolean foo() {} // 修饰符不必要
  &lt;b&gt;non-sealed&lt;/b&gt; Object bar // 修饰符不必要

  // 修饰符为必选项，因此未高亮显示
  &lt;b&gt;non-sealed&lt;/b&gt; class A {}
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GrUnnecessarySealedModifier" defaultSeverity="WARNING" displayName="不必要的 'sealed' 修饰符" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告在方法、字段或变量上使用的不必要的 &lt;code&gt;sealed&lt;/code&gt; 修饰符。&lt;/p&gt;
&lt;p&gt;此修饰符仅对类、接口和特征有效。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;sealed&lt;/b&gt; boolean foo() {} // 修饰符不必要
  &lt;b&gt;sealed&lt;/b&gt; Object bar // 修饰符不必要

  // 修饰符为必选项，因此未高亮显示
  &lt;b&gt;sealed&lt;/b&gt; class A {}
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GrUnnecessaryPublicModifier" defaultSeverity="WARNING" displayName="不必要的 'public'" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告不必要的 &lt;code&gt;public&lt;/code&gt; 修饰符，因为 Groovy 类和方法默认为 &lt;code&gt;public&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Foo{
      public void bar(){
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo{
      void bar(){
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GrUnnecessarySemicolon" defaultSeverity="WARNING" displayName="不必要的分号" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告不必要的分号。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  print 2; print 3 // 分号是必要的
  print 2; // 分号不必要
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GrUnnecessaryAlias" defaultSeverity="WEAK WARNING" displayName="不必要的导入别名" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告不必要的导入别名。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  import com.foo.Bar as Bar
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  import com.foo.Bar
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ChangeToOperator" defaultSeverity="WEAK WARNING" displayName="方法调用可被替换为运算符调用" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以替换为运算符调用的方法调用。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  a.plus(b)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  a + b
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ChangeToMethod" defaultSeverity="INFORMATION" displayName="运算符调用可被替换为方法调用" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可替换为方法调用的运算符调用。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  a + b
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  a.plus(b)
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="冗余结构" path="Kotlin"><inspection shortName="RemoveSetterParameterType" defaultSeverity="WARNING" displayName="冗余 setter 形参类型" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在属性 setter 中明确指定的形参类型。
&lt;p&gt;
    setter 形参类型始终与属性类型匹配，因此不要求为显式。
    “移除显式类型规范”快速修复允许相应地修改代码。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun process(x: Int) {}

  var x: Int = 0
      set(value: Int) = process(value) // &amp;lt;== 'Int' 规格可以安全忽略
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun process(x: Int) {}

  var x: Int = 0
      set(value) = process(value)
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="KotlinRedundantDiagnosticSuppress" defaultSeverity="WARNING" displayName="冗余的诊断禁止" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告由于其影响的编译器诊断在此上下文中不再适用而可以安全移除的 &lt;code&gt;@Suppress&lt;/code&gt; 注解。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun doSmth(@Suppress("UNUSED_PARAMETER") used: Int) {
    println(used)
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun doSmth(used: Int) {
    println(used)
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RemoveSingleExpressionStringTemplate" defaultSeverity="WARNING" displayName="冗余字符串模板" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以安全移除的单表达式字符串模板。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  val x = "Hello"
  val y = "$x"
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  val x = "Hello"
  val y = x // &amp;lt;== 已更新
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SimplifyWhenWithBooleanConstantCondition" defaultSeverity="WEAK WARNING" displayName="可简化的 'when'" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告带有常量 &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt; 分支的 &lt;code&gt;when&lt;/code&gt; 表达式。
&lt;p&gt;&lt;b&gt;简化 "when"&lt;/b&gt; 快速修复可用于自动修正代码。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun redundant() {
      when { // &amp;lt;== 冗余，快速修复会将 when 表达式简化为 "println("true")"
          true -&gt; println("true")
          else -&gt; println("false")
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RedundantModalityModifier" defaultSeverity="WARNING" displayName="冗余形式修饰符" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告与元素的默认模态匹配的模态修饰符（对于大多数元素来说是 &lt;code&gt;final&lt;/code&gt;，对于具有 &lt;code&gt;override&lt;/code&gt; 的成员来说是 &lt;code&gt;open&lt;/code&gt;）。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;final&lt;/b&gt; class Foo

  open class Bar : Comparable&amp;lt;Bar&amp;gt; {
      &lt;b&gt;open&lt;/b&gt; override fun compareTo(other: Bar): Int = 0
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo

  open class Bar : Comparable&amp;lt;Bar&amp;gt; {
      override fun compareTo(other: Bar): Int = 0
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RemoveRedundantSpreadOperator" defaultSeverity="WARNING" displayName="冗余展开运算符" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告针对一系列 &lt;code&gt;arrayOf&lt;/code&gt; 函数调用而使用冗余展开运算符的情况。
&lt;p&gt;使用“移除冗余展开运算符”快速修复可清理代码。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(vararg s: String) { }

  fun bar(ss: Array&amp;lt;String&amp;gt;) {
      foo(*arrayOf("abc"))       // 对于 'foo' 的两次调用，数组创建
      foo(*arrayOf(*ss, "zzz"))  // 及其后续分配均冗余
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(vararg s: String) { }

  fun bar(ss: Array&amp;lt;String&amp;gt;) {
      foo("abc")
      foo(*ss, "zzz")
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RedundantUnitReturnType" defaultSeverity="WARNING" displayName="冗余 'Unit' 返回值类型" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以省略的冗余 &lt;code&gt;Unit&lt;/code&gt; 返回类型。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantReturnLabel" defaultSeverity="WEAK WARNING" displayName="冗余 'return' 标签" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 lambda 表达式之外的冗余返回标签。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test() {
      return@test
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test() {
      return
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RedundantSuspendModifier" defaultSeverity="WARNING" displayName="冗余 'suspend' 修饰符" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
如果内部没有调用其他挂起函数，报告 &lt;code&gt;suspend&lt;/code&gt; 修饰符为冗余。
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RemoveRedundantBackticks" defaultSeverity="WARNING" displayName="冗余反引号" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告引用中的冗余反引号。
&lt;p&gt;
    一些 Kotlin 关键字在 Java 中是有效的标识符，例如：&lt;code&gt;in&lt;/code&gt;、&lt;code&gt;object&lt;/code&gt;、&lt;code&gt;is&lt;/code&gt;。
    如果 Java 库将 Kotlin 关键字用于方法，您仍然可以调用该方法并使用反引号字符 (&lt;code&gt;`&lt;/code&gt;) 对其进行转义，例如 &lt;code&gt;foo.`is`(bar)&lt;/code&gt;。
    有时这种转义是冗余的，可以安全地省略。 该检查会发现并报告此类情况，并与“移除冗余反引号”快速修复配对，允许您修改高亮显示的代码。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun `is`(x: String) {}
  fun foo() {
      `is`("bar") // 'is' 是一个关键字，反引号为必选项
  }

  fun `test that smth works as designed`() {} // 可以，复杂标识符有助于改进可读性

  val `a` = 1  // 不需要反引号
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantInnerClassModifier" defaultSeverity="WARNING" displayName="冗余 'inner' 修饰符" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
如果类没有引用其外部类的成员，则将类上的 &lt;code&gt;inner&lt;/code&gt; 修饰符报告为冗余。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
      &lt;b&gt;inner&lt;/b&gt; class InnerClass { // 冗余 `inner` 修饰符
          fun hello() {
              println("Hi!")
          }
      }
  }

  class List {
      val objects = Array&amp;lt;Any&amp;gt;(42) { Any() }

      &lt;b&gt;inner&lt;/b&gt; class Iterator { // 非冗余 `inner` 修饰符
          fun next(): Any {
              return objects[0]
          }
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
      class InnerClass { // 冗余 `inner` 修饰符
          fun hello() {
              println("Hi!")
          }
      }
  }

  class List {
      val objects = Array&amp;lt;Any&amp;gt;(42) { Any() }

      &lt;b&gt;inner&lt;/b&gt; class Iterator { // 非冗余 `inner` 修饰符
          fun next(): Any {
              return objects[0]
          }
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RedundantWith" defaultSeverity="WEAK WARNING" displayName="冗余 'with' 调用" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告不从接收器访问任何内容的冗余 &lt;code&gt;with&lt;/code&gt; 函数调用。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class MyClass {
      fun f(): String = ""
  }

  fun testRedundant() {
      with(c) { // &amp;lt;== 'with' 冗余，因为 'c' 未使用
          println("1")
      }
  }

  fun testOk() {
      val c = MyClass()
      with(c) { // &amp;lt;== 可以，因为 'f()' 是有效的 'c.f()'
          println(f())
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CanBeParameter" defaultSeverity="WARNING" displayName="构造函数形参从未被用作属性" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;val&lt;/code&gt; 或 &lt;code&gt;var&lt;/code&gt; 可被移除的主构造函数形参。
&lt;p&gt;
    在构造函数中声明的类属性会增加内存消耗。
    如果形参值仅在构造函数中使用，则可以省略它们。
&lt;/p&gt;
&lt;p&gt;请注意，引用的对象可能是之前被垃圾回收。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Task(val name: String) {
      init {
          print("Task created: $name")
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该快速修复会移除额外的 &lt;code&gt;val&lt;/code&gt; 或 &lt;code&gt;var&lt;/code&gt; 关键字：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Task(name: String) {
      init {
          print("Task created: $name")
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="UnusedReceiverParameter" defaultSeverity="WARNING" displayName="未使用的接收器形参" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告扩展函数和属性的未使用接收器形参。
&lt;p&gt;&lt;b&gt;移除冗余的接收器形参&lt;/b&gt;可用于自动修正代码。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RemoveExplicitSuperQualifier" defaultSeverity="WEAK WARNING" displayName="不必要的父类型限定" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告具有冗余父类型限定的 &lt;code&gt;super&lt;/code&gt; 成员调用。
&lt;p&gt;
    派生类中的代码可以使用 &lt;code&gt;super&lt;/code&gt; 关键字调用其父类函数和属性访问器实现。
    要指定从中获取继承实现的父类型，可以通过尖括号中的父类型名称来限定 &lt;code&gt;super&lt;/code&gt; ，例如 &lt;code&gt;super&amp;lt;Base&amp;gt;&lt;/code&gt;。 有时这种限定是冗余的，可以省略。
    使用“移除显式父类型限定”快速修复可清理代码。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  open class B {
      open fun foo(){}
  }

  class A : B() {
      override fun foo() {
         super&amp;lt;B&amp;gt;.foo() // &amp;lt;== 冗余，因为 'B' 是唯一父类型
      }
  }

  interface I {
      fun foo() {}
  }

  class C : B(), I {
      override fun foo() {
          super&amp;lt;B&amp;gt;.foo() // &amp;lt;== 在这里，需要 &amp;lt;B&amp;gt; 限定符以将 'B.foo()' 与 'I.foo()' 区分
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  open class B {
      open fun foo(){}
  }

  class A : B() {
      override fun foo() {
         super.foo() // &amp;lt;== 已更新
      }
  }

  interface I {
      fun foo() {}
  }

  class C : B(), I {
      override fun foo() {
          super&amp;lt;B&amp;gt;.foo()
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="KotlinUnusedImport" defaultSeverity="WARNING" displayName="未使用的 import 指令" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告冗余的 &lt;code&gt;import&lt;/code&gt; 语句。

&lt;p&gt;可以安全地移除默认和未使用的导入。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  import kotlin.*
  import kotlin.collections.*
  import kotlin.comparisons.*
  import kotlin.io.*
  import kotlin.ranges.*
  import kotlin.sequences.*
  import kotlin.text.*

  // 特定于 jvm
  import java.lang.*
  import kotlin.jvm.*

  // 特定于 js
  import kotlin.js.*

  import java.io.* // 此导入未使用，可以移除
  import java.util.*

  fun foo(list: ArrayList&amp;lt;String&amp;gt;) {
      list.add("")
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConstantConditionIf" defaultSeverity="WEAK WARNING" displayName="'if' 表达式的条件为常量" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告具有 &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt; 常量文字条件且可以简化的 &lt;code&gt;if&lt;/code&gt; 表达式。
&lt;p&gt;虽然偶尔是有意为之，但此结构令人困惑，并且通常是由拼写错误或之前的重构所致。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun example() {
      if (true) {
          throw IllegalStateException("Unexpected state")
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该快速修复会移除 &lt;code&gt;if&lt;/code&gt; 条件：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun example() {
      throw IllegalStateException("Unexpected state")
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RemoveForLoopIndices" defaultSeverity="WARNING" displayName="未使用的循环索引" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告使用 &lt;code&gt;withIndex()&lt;/code&gt; 函数而非索引变量迭代集合的 &lt;code&gt;for&lt;/code&gt; 循环。
&lt;p&gt;使用“移除 'for' 循环中的索引”快速修复可清理代码。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(bar: List&amp;lt;String&amp;gt;) {
     for ((index : Int, value: String) in bar.withIndex()) { // &amp;lt;== 'index' 未使用
         println(value)
     }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(bar: List&amp;lt;String&amp;gt;) {
      for (value: String in bar) { // &amp;lt;== '.withIndex()' 和 'index' 已被移除
          println(value)
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RemoveEmptyParenthesesFromLambdaCall" defaultSeverity="WEAK WARNING" displayName="从带 lambda 的函数调用中移除不必要的圆括号" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告函数调用的冗余空圆括号，其中唯一的形参是圆括号外的 lambda。
&lt;p&gt;使用“从带 lambda 的函数调用中移除不必要的圆括号”快速修复可清理代码。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo() {
      listOf(1).forEach() {  }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo() {
      listOf(1).forEach {  }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RedundantNullableReturnType" defaultSeverity="WARNING" displayName="冗余可 null 返回值类型" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告具有可为 null 的返回类型的函数和变量，这些函数和变量永远不会返回或变为 &lt;code&gt;null&lt;/code&gt;。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun greeting(user: String): String? = "Hello, $user!"
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun greeting(user: String): String = "Hello, $user!"
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RemoveRedundantQualifierName" defaultSeverity="WARNING" displayName="冗余限定符名称" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告关于类名、函数和属性的冗余限定符（或其部分）。
&lt;p&gt;
    完全限定名称是一种明确的标识符，用于指定调用所引用的对象、函数或属性。
    在可以缩短名称的上下文中，检查会告知机会，关联的“移除冗余限定符名称”快速修复可以修改代码。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  package my.simple.name
  import kotlin.Int.Companion.MAX_VALUE

  class Foo

  fun main() {
      val a = my.simple.name.Foo()    // 'Foo' 位于声明的 'my.simple.name' 软件包中，限定符冗余
      val b = kotlin.Int.MAX_VALUE    // 可以替换为 'MAX_VALUE'，因为它已被导入
      val c = kotlin.Double.MAX_VALUE // 可以替换为 'Double.MAX_VALUE'，因为内置类型会被自动导入
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  package my.simple.name
  import kotlin.Int.Companion.MAX_VALUE

  class Foo

  fun main() {
      val a = Foo()
      val b = MAX_VALUE
      val c = Double.MAX_VALUE
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantVisibilityModifier" defaultSeverity="WARNING" displayName="冗余可见性修饰符" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告与元素的默认可见性匹配的可见性修饰符（对于大多数元素来说是 &lt;code&gt;public&lt;/code&gt;，对于重写受保护成员的成员来说是 &lt;code&gt;protected&lt;/code&gt;）。
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RedundantExplicitType" defaultSeverity="WARNING" displayName="明显的显式类型" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告局部变量的显式给定类型，这些类型显而易见且冗余，例如 &lt;code&gt;val f: Foo = Foo()&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Point(val x: Int, val y: Int)

  fun foo() {
      val t: &lt;b&gt;Boolean&lt;/b&gt; = true
      val p: &lt;b&gt;Point&lt;/b&gt; = Point(1, 2)
      val i: &lt;b&gt;Int&lt;/b&gt; = 42
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Point(val x: Int, val y: Int)

  fun foo() {
      val t = true
      val p = Point(1, 2)
      val i = 42
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RedundantElvisReturnNull" defaultSeverity="WARNING" displayName="冗余 '?: return null'" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告冗余的 &lt;code&gt;?: return null&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(): Int? {
      ...
  }

  fun test() : Int? {
      return foo() &lt;b&gt;?: return null&lt;/b&gt;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(): Int? {
      ...
  }

  fun test() : Int? {
      return foo()
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RemoveExplicitTypeArguments" defaultSeverity="WEAK WARNING" displayName="不必要的类型实参" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告具有可自动推断的类型实参的函数调用。 这种类型实参是冗余的，可以安全地省略。
&lt;p&gt;使用“移除显式类型实参”快速修复可清理代码。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  // 在这里可以推断 'String' 类型
  fun foo(): MutableList&amp;lt;String&amp;gt; = mutableListOf&amp;lt;String&amp;gt;()

  // 在这里无法推断 'String'，类型实参为必选项。
  fun bar() = mutableListOf&amp;lt;String&amp;gt;()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(): MutableList&amp;lt;String&amp;gt; = mutableListOf() &amp;lt;== 已更新

  fun bar() = mutableListOf&amp;lt;String&amp;gt;()
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="KotlinDoubleNegation" defaultSeverity="WEAK WARNING" displayName="冗余双重求反" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告冗余双重否定。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  val truth = !!true&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RedundantEnumConstructorInvocation" defaultSeverity="WEAK WARNING" displayName="冗余枚举构造函数调用" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告枚举条目上的冗余构造函数调用。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  enum class Baz(i: Int = 0) {
      A(1),
      B&lt;b&gt;()&lt;/b&gt;,
      C&lt;b&gt;()&lt;/b&gt;,
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  enum class Baz(i: Int = 0) {
      A(1),
      B,
      C,
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RedundantIf" defaultSeverity="WEAK WARNING" displayName="冗余的 'if' 语句" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告可以简化为单个语句的 &lt;code&gt;if&lt;/code&gt; 语句。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test() {
      if (foo()) {
         return true
      } else {
         return false
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test() {
      return foo()
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RemoveCurlyBracesFromTemplate" defaultSeverity="WEAK WARNING" displayName="字符串模板中的冗余大括号" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告字符串模板中用于括简单标识符的大括号的用法。
&lt;p&gt;使用“移除大括号”快速修复可移除冗余的大括号。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun redundant() {
     val x = 4
     val y = "${x}" // &amp;lt;== 冗余
  }

  fun correctUsage() {
      val x = "x"
      val y = "${x.length}" // &amp;lt;== 可以
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun redundant() {
     val x = 4
     val y = "$x"
  }

  fun correctUsage() {
      val x = "x" &amp;lt;== 已更新
      val y = "${x.length}"
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RedundantGetter" defaultSeverity="WEAK WARNING" displayName="冗余属性 getter" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告冗余属性 getter。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Test {
      val a = 1
          &lt;b&gt;get&lt;/b&gt;
      val b = 1
          &lt;b&gt;get() = field&lt;/b&gt;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Test {
      val a = 1
      val b = 1
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="CanBePrimaryConstructorProperty" defaultSeverity="WARNING" displayName="属性已明确分配给构造函数形参" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告显式分配给主构造函数形参的属性。
&lt;p&gt;可以直接在主构造函数中声明属性，从而减少代码量并提高代码可读性。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class User(name: String) {
      val name = name
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;快速修复会将形参和属性声明联接到主构造函数形参中：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class User(val name: String) {
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SimpleRedundantLet" defaultSeverity="WARNING" displayName="基于接收器的冗余 'let' 调用" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告基于接收器的冗余 &lt;code&gt;let&lt;/code&gt; 调用。
&lt;p&gt;该快速修复会移除冗余 &lt;code&gt;let&lt;/code&gt; 调用。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(s: String?): Int? = s?.let { it.length }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(s: String?): Int? = s?.length
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RemoveEmptySecondaryConstructorBody" defaultSeverity="WEAK WARNING" displayName="冗余构造函数体" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告辅助构造函数的空主体。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReplaceWithIgnoreCaseEquals" defaultSeverity="WEAK WARNING" displayName="应替换为 'equals(..., ignoreCase = true)'" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以替换为 &lt;code&gt;equals(..., ignoreCase = true)&lt;/code&gt; 的不区分大小写的比较。
&lt;p&gt;使用 &lt;code&gt;equals()&lt;/code&gt;，无需分配具有 &lt;code&gt;toLowerCase()&lt;/code&gt; 或 &lt;code&gt;toUpperCase()&lt;/code&gt; 的额外字符串即可比较字符串。&lt;/p&gt;
&lt;p&gt;该快速修复会将使用 &lt;code&gt;toLowerCase()&lt;/code&gt; 或 &lt;code&gt;toUpperCase()&lt;/code&gt; 的不区分大小写的比较替换为 &lt;code&gt;equals(..., ignoreCase = true)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;注意&lt;/b&gt;：可能会更改某些区域设置的语义。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun main() {
      val a = &amp;quot;KoTliN&amp;quot;
      val b = &amp;quot;KOTLIN&amp;quot;
      println(a.toLowerCase() == b.toLowerCase())
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun main() {
      val a = &amp;quot;KoTliN&amp;quot;
      val b = &amp;quot;KOTLIN&amp;quot;
      println(a.equals(b, ignoreCase = true))
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantSamConstructor" defaultSeverity="WARNING" displayName="冗余 SAM 构造函数" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以替换为 lambda 的 SAM（单一抽象方法）构造函数用法。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun main() {
      foo(&lt;b&gt;Runnable&lt;/b&gt; { println("Hi!") })
  }

  fun foo(other: Runnable) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun main() {
      foo( { println("Hi!") })
  }

  fun foo(other: Runnable) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RemoveRedundantCallsOfConversionMethods" defaultSeverity="WARNING" displayName="转换方法的冗余调用" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对转换方法的冗余调用（例如，&lt;code&gt;String&lt;/code&gt; 上的 &lt;code&gt;toString()&lt;/code&gt; 或 &lt;code&gt;Double&lt;/code&gt; 上的 &lt;code&gt;toDouble()&lt;/code&gt;）。
&lt;p&gt;使用“移除转换方法的冗余调用”快速修复可清理代码。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="NullChecksToSafeCall" defaultSeverity="WEAK WARNING" displayName="null 检查可被替换为安全调用" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以替换为安全调用的链式 null 检查。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(my: My?) {
      if (my != null &amp;&amp; my.foo() != null) {}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(my: My?) {
      if (my?.foo() != null) {}
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RemoveEmptyClassBody" defaultSeverity="WEAK WARNING" displayName="替换空类主体" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告具有空主体的类和对象的声明。
&lt;p&gt;使用“移除冗余的空类主体”快速修复可清理代码。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class EmptyA() {} // &amp;lt;== 空主体

  class EmptyB {
      companion object {} // &amp;lt;== 空主体
  }

  fun emptyC() {
     object {} // &amp;lt;== 匿名对象，可以（未报告）
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class EmptyA()

  class EmptyB {
      companion object
  }

  fun emptyC() {
     object {}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RedundantCompanionReference" defaultSeverity="WARNING" displayName="冗余 'Companion' 引用" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告冗余的 &lt;code&gt;Companion&lt;/code&gt; 引用。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class A {
      &lt;b&gt;companion object&lt;/b&gt; {
          fun create() = A()
      }
  }
  fun test() {
      val s = A.&lt;b&gt;Companion&lt;/b&gt;.create()
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class A {
      &lt;b&gt;companion object&lt;/b&gt; {
          fun create() = A()
      }
  }
  fun test() {
      val s = A.create()
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ComplexRedundantLet" defaultSeverity="WEAK WARNING" displayName="基于实参的冗余 'let' 调用" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告基于实参的冗余 &lt;code&gt;let&lt;/code&gt; 调用。
&lt;p&gt;当 lambda 形参仅用作调用表达式中的限定符时，&lt;code&gt;let&lt;/code&gt; 冗余。&lt;/p&gt;
&lt;p&gt;如果需要为限定表达式命名，请声明一个局部变量。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun splitNumbers() {
      "1,2,3".let { it.split(',') }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该快速修复会移除额外的 &lt;code&gt;let()&lt;/code&gt; 调用：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun example() {
      "1,2,3".split(',')
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun splitNumbers() {
      val numbers = "1,2,3"
      numbers.split(',')
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RedundantLambdaArrow" defaultSeverity="WEAK WARNING" displayName="冗余 lambda 箭头" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告没有形参的 lambda 中的冗余 lambda 箭头。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(f: () -&gt; Unit) = f()

  fun bar() {
      foo { &lt;b&gt;-&gt;&lt;/b&gt; println("Hi!") }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(f: () -&gt; Unit) = f()

  fun bar() {
      foo { println("Hi!") }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="KotlinRedundantOverride" defaultSeverity="WEAK WARNING" displayName="冗余重写方法" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告冗余重写声明。
&lt;p&gt;
    如果重写不修改继承的签名语义，则可以省略重写，例如，通过更改可见性。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;open class&lt;/b&gt; Foo {
      open fun singleExpression() {
      }
  }

  class Bar : Foo() {
      &lt;b&gt;override&lt;/b&gt; fun singleExpression() = super.singleExpression()
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Bar : Foo() {
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantSetter" defaultSeverity="WEAK WARNING" displayName="冗余属性 setter" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告冗余属性 setter。
&lt;p&gt;
在以下情况之一中，setter 被认为是冗余的：
&lt;/p&gt;
&lt;ol&gt;
    &lt;li&gt;
        setter 没有主体。 访问器可见性未更改，声明不是 &lt;code&gt;external&lt;/code&gt; 并且没有注解。
        &lt;pre&gt;&lt;code&gt;
  var myPropWithRedundantSetter: Int = 0
      set // redundant

  var myPropA: Int = 0
      private set // 可以 - 属性可见性被更改为 private

  var myPropB: Int = 0
      external set // 可以 - 未在 Kotlin 中实现（外部）

  var myPropC: Int = 0
      @Inject set // 可以 - 访问器被注解
        &lt;/code&gt;&lt;/pre&gt;
    &lt;/li&gt;
    &lt;li&gt;
        setter 主体是一个具有单语句的块，其将形参分配给支持字段。
        &lt;pre&gt;&lt;code&gt;
  var prop: Int = 0
      set(value) { // 冗余
          field = value
      }
       &lt;/code&gt;&lt;/pre&gt;
    &lt;/li&gt;
&lt;/ol&gt;

&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="UnusedSymbol" defaultSeverity="WARNING" displayName="未使用的符号" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告入口点中未使用或不可到达的符号。
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RedundantUnitExpression" defaultSeverity="WARNING" displayName="冗余 'Unit'" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告冗余的 &lt;code&gt;Unit&lt;/code&gt; 表达式。
&lt;p&gt;
    Kotlin 中的 &lt;code&gt;Unit&lt;/code&gt; 可以用作不返回任何有意义的函数的返回类型。
    &lt;code&gt;Unit&lt;/code&gt; 类型只有一个可能的值，即 &lt;code&gt;Unit&lt;/code&gt; 对象。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun redundantA(): Unit {
      return Unit // 冗余，'Unit' 默认返回并与预期返回类型匹配
  }

  fun requiredA(condition: Boolean): Any {
      if (condition) return "hello"
      return Unit // 显式 'Unit' 为必选项，因为预期类型为 'Any'
  }

  fun redundantB(condition: Boolean): Any = if (condition) {
      fun ancillary(): Int = 1
      println("${ancillary()}")
      Unit // 冗余，因为上一个表达式已经为 'Unit' 类型
  } else {
      println("else")
  }

  fun requiredB(condition: Boolean): Any = if (condition) {
      1024
      Unit // 必选项，否则 '1024' (Int) 将为返回值
  } else {
      println("else")
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantRequireNotNullCall" defaultSeverity="WEAK WARNING" displayName="冗余 'requireNotNull' 或 'checkNotNull' 调用" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告对不可为 null 表达式的冗余 &lt;code&gt;requireNotNull&lt;/code&gt; 或 &lt;code&gt;checkNotNull&lt;/code&gt; 调用。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(i: Int) {
      requireNotNull(i) //此 'i' 始终不为 null，因此该 'requireNotNull' 为冗余调用。
      ...
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(i: Int) {
      ...
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="WhenWithOnlyElse" defaultSeverity="WEAK WARNING" displayName="'when' 仅包含 'else' 分支且可以简化" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告只有一个 &lt;code&gt;else&lt;/code&gt; 分支且可以简化的 &lt;code&gt;when&lt;/code&gt; 表达式。
&lt;p&gt;&lt;b&gt;简化表达式&lt;/b&gt;快速修复可用于自动修正代码。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun redundant() {
      val x = when { // &amp;lt;== 冗余，快速修复会将 when 表达式简化为 "val x = 1"
          else -&gt; 1
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RemoveToStringInStringTemplate" defaultSeverity="WEAK WARNING" displayName="字符串模板中的冗余 'toString()' 调用" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对可以安全移除的字符串模板中的 &lt;code&gt;toString()&lt;/code&gt; 的调用。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  fun foo(a: Int, b: Int) = a + b

  fun test(): String {
      return "Foo: ${foo(0, 4).toString()}" // 'toString()' 冗余
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  fun foo(a: Int, b: Int) = a + b

  fun test(): String {
      return "Foo: ${foo(0, 4)}"
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RedundantLambdaOrAnonymousFunction" defaultSeverity="WEAK WARNING" displayName="创建冗余 lambda 或匿名函数" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告立即创建和使用的 lambda 或匿名函数。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;fun&lt;/b&gt; test() {
      ({ println() })() // 冗余
      (&lt;b&gt;fun&lt;/b&gt;() { println() })() // 冗余
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantSemicolon" defaultSeverity="WARNING" displayName="冗余分号" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
    报告可以安全移除的冗余分号 (&lt;code&gt;;&lt;/code&gt;)。
&lt;p&gt;
    Kotlin 不要求在每个语句或表达式的末尾使用分号。
    建议使用快速修复移除冗余的分号。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  val myMap = mapOf("one" to 1, "two" to 2);
  myMap.forEach { (key, value) -&gt;  print("$key -&gt; $value")};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  val myMap = mapOf("one" to 1, "two" to 2)
  myMap.forEach { (key, value) -&gt;  print("$key -&gt; $value")}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有两种情况需要使用分号：&lt;/p&gt;
&lt;ol&gt;
    &lt;li&gt;
        放在一个行里的多个语句需要用分号隔开：
&lt;pre&gt;&lt;code&gt;
  map.forEach { val (key, value) = it; println("$key -&gt; $value") }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/li&gt;
    &lt;li&gt;
        同时声明了属性或函数的 &lt;code&gt;enum&lt;/code&gt; 类要求在枚举常量列表后加一个分号：
        &lt;pre&gt;&lt;code&gt;
  enum class Mode {
      SILENT, VERBOSE;

      fun isSilent(): Boolean = this == SILENT
  }
        &lt;/code&gt;&lt;/pre&gt;
    &lt;/li&gt;
&lt;/ol&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryOptInAnnotation" defaultSeverity="WEAK WARNING" displayName="不必要的 '@OptIn' 注解" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告不必要并可以安全删除的选择加入注解。

&lt;p&gt;使用实验性 API 的代码需要 &lt;code&gt;@OptIn&lt;/code&gt; 注解，因为这些 API 将来随时都可能更改。 如果此类 API 未使用（例如，当实验性 API 稳定后，就不再要求选择加入了），此注解将变得没有意义，且可能具有误导性。
&lt;/p&gt;
&lt;p&gt;
    &lt;b&gt;移除注解&lt;/b&gt;快速修复可用于移除不必要的 &lt;code&gt;@OptIn&lt;/code&gt; 注解。
&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @OptIn(ExperimentalApi::class)
  fun foo(x: Bar) {
      x.baz()
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(x: Bar) {
      x.baz()
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryVariable" defaultSeverity="WEAK WARNING" displayName="不必要的局部变量" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告仅恰好在下一个 &lt;code&gt;return&lt;/code&gt; 语句或其他变量的确切副本中使用的局部变量。
&lt;p&gt;可以安全地内联此类变量，以使代码更加清晰易懂。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ExplicitThis" defaultSeverity="INFORMATION" displayName="冗余显式 'this'" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以省略的显式 &lt;code&gt;this&lt;/code&gt;。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class C {
      private val i = 1
      fun f() = this.i
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该快速修复会移除冗余的 &lt;code&gt;this&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class C {
      private val i = 1
      fun f() = i
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RemoveEmptyPrimaryConstructor" defaultSeverity="WEAK WARNING" displayName="冗余空主构造函数" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
当主构造函数隐式可用时，报告其中为空的主构造函数。
&lt;p&gt;
    主构造函数冗余，当其没有任何注解或可见性修饰符时可以安全地省略。
    使用“移除空主构造函数”快速修复可清理代码。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class MyClassA constructor() //  冗余，可以替换为 'class MyClassA'

  annotation class MyAnnotation
  class MyClassB @MyAnnotation constructor() //  由于注解而必选

  class MyClassC private constructor() // 由于可见性修饰符而必选
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="toString() 问题" path="Java"><inspection shortName="FieldNotUsedInToString" defaultSeverity="WARNING" displayName="字段未在 'toString()' 方法中使用" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在类的 &lt;code&gt;toString()&lt;/code&gt; 方法中未使用的任何字段。
&lt;p&gt;此检查对于查找在 &lt;code&gt; toString() &lt;/code&gt; 方法创建后添加且 &lt;code&gt;toString()&lt;/code&gt; 方法未更新的字段很有用。 该快速修复会重新生成 &lt;code&gt;toString()&lt;/code&gt; 方法。&lt;/p&gt;
&lt;p&gt;
在 &lt;b&gt;生成 | toString()&lt;/b&gt; 对话框中，可以从此检查中排除字段。
如果&lt;em&gt;在代码生成中启用 getter&lt;/em&gt; 选项，则此检查还将检查 getter 方法是否存在问题。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;public class&lt;/b&gt; Relevant {
    &lt;b&gt;private&lt;/b&gt; String name; // 未在 toString() 中使用
    &lt;b&gt;private int&lt;/b&gt; index;
    &lt;b&gt;private int&lt;/b&gt; length;

    @Override
    &lt;b&gt;public&lt;/b&gt; String toString() {
        &lt;b&gt;return&lt;/b&gt; "Relevant{" + "index=" + index +
          ", length=" + length + '}';
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;public class&lt;/b&gt; Relevant {
    &lt;b&gt;private&lt;/b&gt; String name;
    &lt;b&gt;private int&lt;/b&gt; index;
    &lt;b&gt;private int&lt;/b&gt; length;

    @Override
    &lt;b&gt;public&lt;/b&gt; String toString() {
        &lt;b&gt;return&lt;/b&gt; "Relevant{" + "name='" + name + '\'' +
          ", index=" + index + ", length=" + length + '}';
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ClassHasNoToStringMethod" defaultSeverity="WARNING" displayName="类不会重写 'toString()' 方法" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告没有 &lt;code&gt;toString()&lt;/code&gt; 方法的类。
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Zeppelin" path=""><inspection shortName="ZeppelinScalaResUsageFilter" defaultSeverity="WARNING" displayName="ResN usage" enabled="false" language="Scala" pluginId="com.intellij.bigdatatools" pluginVersion="223.8836.7" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;使用 resN 引用被认为是一种不好的做法，应该避免
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="代码质量工具" path="JavaScript and TypeScript"><inspection shortName="Eslint" defaultSeverity="WARNING" displayName="ESLint" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;a href="https://eslint.org"&gt;ESLint&lt;/a&gt; linter 检测到的差异。
&lt;!-- tooltip end --&gt;
&lt;br/&gt;&lt;br/&gt;
高亮显示基于 &lt;a href="https://eslint.org/docs/user-guide/configuring"&gt;ESLint 配置文件&lt;/a&gt;中为每条规则指定的规则严重性。
&lt;br/&gt;&lt;br/&gt;
清除“使用配置文件中的规则严重性”复选框，对所有 ESLint 规则使用该项检查中配置的严重性。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TsLint" defaultSeverity="WARNING" displayName="TSLint" enabled="false" language="TypeScript" pluginId="tslint" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;a href="https://github.com/palantir/tslint"&gt;TSLint&lt;/a&gt; linter 检测到的差异。
&lt;!-- tooltip end --&gt;
&lt;br/&gt;&lt;br/&gt;
高亮显示基于 &lt;a href="https://palantir.github.io/tslint/usage/configuration/"&gt;TSLint 配置文件&lt;/a&gt;中为每条规则指定的规则严重性。
&lt;br/&gt;&lt;br/&gt;
清除“使用配置文件中的规则严重性”复选框，对所有 TSLint 规则使用该项检查中配置的严重性。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSHint" defaultSeverity="ERROR" displayName="JSHint" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;a href="https://jshint.com/"&gt;JSHint&lt;/a&gt; linter 检测到的问题。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StandardJS" defaultSeverity="ERROR" displayName="标准代码样式" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;a href="https://standardjs.com/"&gt;JavaScript Standard Style&lt;/a&gt; linter 检测到的差异。
&lt;!-- tooltip end --&gt;
&lt;br/&gt;&lt;br/&gt;
编辑器中高亮显示的严重性基于 linter 报告的严重性级别。
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="结构搜索" path=""><inspection shortName="SSBasedInspection" defaultSeverity="WARNING" displayName="结构搜索检查" enabled="false" pluginId="com.intellij" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;允许配置可以应用于您正在编辑的文件的&lt;b&gt;结构搜索/结构替换&lt;/b&gt;模板。
&lt;/p&gt;
&lt;p&gt;所有匹配项都将高亮显示并使用您配置的模板名称标记。
如果您还配置了&lt;b&gt;结构替换&lt;/b&gt;模式，相应的替换选项将作为快速修复提供。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="封装" path="Java"><inspection shortName="ProtectedField" defaultSeverity="WARNING" displayName="protected 字段" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;protected&lt;/code&gt; 字段。
&lt;p&gt;不报告常量（即标记为 &lt;code&gt;static&lt;/code&gt; 或 &lt;code&gt;final&lt;/code&gt; 的变量）。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class A {
    protected Object object;              // 警告
    protected final static int MODE = 0;  // 常量，无警告
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AssignmentOrReturnOfFieldWithMutableType" defaultSeverity="WARNING" displayName="具有可变类型的字段的赋值或返回" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告从方法形参到数组或可变类型（如 &lt;code&gt;Collection&lt;/code&gt;、&lt;code&gt;Date&lt;/code&gt;、&lt;code&gt;Map&lt;/code&gt;、&lt;code&gt;Calendar&lt;/code&gt; 等）的返回或赋值
&lt;p&gt;由于这种类型是可变的，此结构可能会导致来自所属类之外的对象状态发生意外修改。 尽管出于性能原因，此结构可能很有用，但它本质上很容易出现错误。&lt;/p&gt;
&lt;p&gt;报告了以下可变类型：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;java.util.Date&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;java.util.Calendar&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;java.util.Collection&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;java.util.Map&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;com.google.common.collect.Multimap&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;com.google.common.collect.Table&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;该快速修复会添加对字段的 &lt;code&gt;.clone()&lt;/code&gt; 方法的调用。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Log {
    String[] messages;
    ...

    String[] getMessages() {
      return messages; // 警告：返回 String[] 字段 'messages'
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Log {
    String[] messages;
    ...

    String[] getMessages() {
      return messages.clone();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;使用&lt;b&gt;忽略 private 方法中的赋值和返回值&lt;/b&gt;选项可忽略 &lt;code&gt;private&lt;/code&gt;方法中的赋值和返回值。

  &lt;!--&lt;p&gt;&lt;small&gt;New in 2017.3&lt;/small&gt;--&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PublicInnerClass" defaultSeverity="WARNING" displayName="'public' 嵌套类" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;public&lt;/code&gt; 嵌套类。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Outer {
    public static class Nested {} // 警告
    public class Inner {}         // 警告
    public enum Mode {}           // 警告取决于设置
    public interface I {}         // 警告取决于设置
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;配置检查：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;使用&lt;b&gt;忽略 'public' 内部枚举&lt;/b&gt;选项可忽略 &lt;code&gt;public&lt;/code&gt; 内部枚举。&lt;/li&gt;
  &lt;li&gt;使用&lt;b&gt;忽略 'public' 内部接口&lt;/b&gt;选项可忽略 &lt;code&gt;public&lt;/code&gt; 内部接口。&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ProtectedInnerClass" defaultSeverity="WARNING" displayName="protected 嵌套类" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;protected&lt;/code&gt; 嵌套类。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Outer {
    protected static class Nested {} // 警告
    protected class Inner {}         // 警告
    protected enum Mode {}           // 警告取决于设置
    protected interface I {}         // 警告取决于设置
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;配置检查：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;使用&lt;b&gt;忽略 'protected' 内部枚举&lt;/b&gt;选项可忽略 &lt;code&gt;protected&lt;/code&gt; 内部枚举。&lt;/li&gt;
  &lt;li&gt;使用&lt;b&gt;忽略 'protected' 内部接口&lt;/b&gt;选项可忽略 &lt;code&gt;protected&lt;/code&gt; 内部接口。&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PackageVisibleInnerClass" defaultSeverity="WARNING" displayName="软件包可见的嵌套类" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在没有任何访问修饰符（也称为 package-private）的情况下声明的嵌套类。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Outer {
    static class Nested {}  // 警告
    class Inner {}          // 警告
    enum Mode {}            // 警告取决于设置
    interface I {}          // 警告取决于设置
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;配置检查：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;使用&lt;b&gt;忽略软件包可见的内部枚举&lt;/b&gt;选项可忽略 package-private 内部枚举。&lt;/li&gt;
  &lt;li&gt;使用&lt;b&gt;忽略软件包可见的内部接口&lt;/b&gt;选项可忽略 package-private 内部接口。&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PublicField" defaultSeverity="INFORMATION" displayName="'public' 字段" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;public&lt;/code&gt; 字段。
不报告常量（标记 &lt;code&gt;static&lt;/code&gt; 和 &lt;code&gt;final&lt;/code&gt; 的字段）。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Main {
    public String name;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Main {
    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;配置检查：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;使用&lt;b&gt;有注解时忽略&lt;/b&gt;列表可指定要忽略的注解。 该检查将忽略包含其中任何注解的字段。&lt;/li&gt;
  &lt;li&gt;使用&lt;b&gt;忽略枚举的 'public final' 字段&lt;/b&gt;选项，可以忽略 &lt;code&gt;enum&lt;/code&gt; 类型的 &lt;code&gt;public final&lt;/code&gt; 字段。&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UseOfAnotherObjectsPrivateField" defaultSeverity="WARNING" displayName="访问另一个对象的非 public 字段" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对另一个对象的 &lt;code&gt;private&lt;/code&gt; 或 &lt;code&gt;protected&lt;/code&gt; 字段的访问。
Java 允许访问与当前对象属于同一类的对象的此类字段，但某些编码样式不鼓励这种用法。 此外，这种对 &lt;code&gt;private&lt;/code&gt; 字段的直接访问在面向组件的架构（例如 Spring 或 Hibernate）中可能会失败，它们期望对其他对象的所有访问都通过方法调用进行，以便框架可以使用代理调解访问。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Base {
    protected int bar;

    void increment(Base base) {
      bar++;
      base.bar++; // warning: direct access to another object's non-public field
    }
  }
&lt;/code&gt;&lt;/pre&gt;
可以通过快速修复封装该字段。
&lt;!-- tooltip end --&gt;
&lt;p&gt;配置检查：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;使用&lt;b&gt;忽略来自同一类的访问&lt;/b&gt;选项可忽略来自同一类的访问，只报告来自内部或外部类的访问。
    &lt;p&gt;要忽略来自内部类的访问，请使用嵌套的&lt;b&gt;忽略来自内部类的访问&lt;/b&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;使用&lt;b&gt;忽略来自 'equals()' 方法的访问&lt;/b&gt;可忽略来自 &lt;code&gt;equals()&lt;/code&gt; 方法的访问。&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PackageVisibleField" defaultSeverity="WARNING" displayName="软件包可见字段" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在没有任何访问修饰符（也称为 package-private）的情况下声明的字段。
&lt;p&gt;不报告常量（即标记为 &lt;code&gt;static&lt;/code&gt; 和 &lt;code&gt;final&lt;/code&gt; 的字段）。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class A {
    Object object;             // 警告
    final static int MODE = 0; // 常量，无警告
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="RESTful Web 服务(JAX-RS)" path=""><inspection shortName="WadlDomInspection" defaultSeverity="ERROR" displayName="不正确的 WADL 配置" enabled="false" language="XML" pluginId="com.jetbrains.restWebServices" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 WADL 文件中的配置错误。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="VoidMethodAnnotatedWithGET" defaultSeverity="WARNING" displayName="@GET 注解方法返回 void 值" enabled="false" language="JAVA" pluginId="com.jetbrains.restWebServices" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告使用 &lt;code&gt;@GET&lt;/code&gt; 注解的不返回任何内容的方法。
  使用 &lt;code&gt;@GET&lt;/code&gt; 注解的方法必须具有非 void 返回类型。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="UnresolvedRestParam" defaultSeverity="ERROR" displayName="未解析的 @PathParam 引用" enabled="false" language="UAST" pluginId="com.jetbrains.restWebServices" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告在方法签名中声明但在 URL 路径中缺失或者在 URL 路径中声明但在方法签名中缺失的 &lt;code&gt;@PathParam&lt;/code&gt; 形参。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Get("/path/{myVariable}/")
  public String handler(@PathParam("&lt;b&gt;name_is_not_equal_to_myVariable&lt;/b&gt;") String myVariable) { // 错误
    return "...";
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RestWrongDefaultValueInspection" defaultSeverity="ERROR" displayName="不正确的 @DefaultValue 形参值" enabled="false" language="JAVA" pluginId="com.jetbrains.restWebServices" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;如果 &lt;code&gt;@DefaultValue&lt;/code&gt; 的值无法转换为指定类型的形参，则报告该值。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @GET
  @Path("/{n}")
  public String get(@PathParam("n") @DefaultValue("&lt;b&gt;III&lt;/b&gt;") int n) { // 错误：无法将 'III' 转换为 int
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RestResourceMethodInspection" defaultSeverity="ERROR" displayName="没有资源方法的 @Path 类" enabled="false" language="JAVA" pluginId="com.jetbrains.restWebServices" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告使用 &lt;code&gt;@Path&lt;/code&gt; 注解的没有资源方法的类。
  根资源类必须至少有一个使用 &lt;code&gt;@Path&lt;/code&gt; 或任何 &lt;code&gt;@HttpMethod&lt;/code&gt;（&lt;code&gt;@GET&lt;/code&gt;、&lt;code&gt; @POST&lt;/code&gt;等）注解的资源方法。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MultipleMethodDesignatorsInspection" defaultSeverity="ERROR" displayName="有多个 HTTP 方法注解的资源方法" enabled="false" language="JAVA" pluginId="com.jetbrains.restWebServices" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告具有多个 HTTP 方法注解（&lt;code&gt;@GET&lt;/code&gt;、&lt;code&gt;@POST&lt;/code&gt;、&lt;code&gt;@PUT&lt;/code&gt; 等）的资源方法。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RestParamTypeInspection" defaultSeverity="ERROR" displayName="资源方法的形参类型不正确" enabled="false" language="JAVA" pluginId="com.jetbrains.restWebServices" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告具有不受支持类型的资源方法形参（使用 &lt;code&gt;@PathParam&lt;/code&gt;、&lt;code&gt;@QueryParam&lt;/code&gt; 等注解）。&lt;/p&gt;
&lt;p&gt;注解的形参、字段或属性的类型必须满足以下要求之一：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;为基元类型&lt;/li&gt;
  &lt;li&gt;有一个接受单个 &lt;code&gt;String&lt;/code&gt; 实参的构造函数&lt;/li&gt;
  &lt;li&gt;有一个名为 &lt;code&gt;valueOf()&lt;/code&gt; 或 &lt;code&gt;fromString()&lt;/code&gt; 的 static 方法，它接受单个 &lt;code&gt;String&lt;/code&gt; 实参，例如 &lt;code&gt;Integer.valueOf(String)&lt;/code&gt;。
  &lt;/li&gt;
  &lt;li&gt;拥有 &lt;code&gt;ParamConverterProvider&lt;/code&gt; JAX-RS 扩展 SPI 的注册实现，它返回一个能够将字符串转换为特定类型的 &lt;code&gt;ParamConverter&lt;/code&gt; 实例。
  &lt;/li&gt;
  &lt;li&gt;为 &lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt;、&lt;code&gt;Set&amp;lt;T&amp;gt;&lt;/code&gt; 或 &lt;code&gt;SortedSet&amp;lt;T&amp;gt;&lt;/code&gt;，其中 T 为 2、3 或 4 以上。 生成的集合为只读。&lt;/li&gt;
&lt;/ol&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PathAnnotation" defaultSeverity="WARNING" displayName="不正确的 @Path URI 模板" enabled="false" language="JAVA" pluginId="com.jetbrains.restWebServices" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 &lt;code&gt;@Path&lt;/code&gt; 注解中的语法错误和未使用的 URI 模板。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @GET
  @Path("/&lt;b&gt;{unused}&lt;/b&gt;") // 从未使用过 'unused' 模板
  public String get() {
    return "";
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="类结构" path="Java"><inspection shortName="NoopMethodInAbstractClass" defaultSeverity="WARNING" displayName="'abstract' 类中的无运算方法" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;abstract&lt;/code&gt; 类中的 no-op（表示“无运算”）方法。
&lt;p&gt;更好的设计通常是将此类方法设为 &lt;code&gt;abstract&lt;/code&gt;，以便继承这些方法的类提供实现。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  abstract class Test {
    protected void doTest() {
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="Singleton" defaultSeverity="WARNING" displayName="单例" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告单例类。
&lt;p&gt;单例类按照只能实例化该类一个实例的方式进行声明。 单例类导致测试复杂化，存在这种情况可能表明欠缺面向对象的设计。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Singleton {
    private static final Singleton ourInstance = new Singleton();

    private Singleton() {
    }

    public Singleton getInstance() {
        return ourInstance;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ListenerMayUseAdapter" defaultSeverity="WARNING" displayName="类可以扩展适配器而不是实现侦听器" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告实现侦听器而不是扩展相应适配器的类。
&lt;p&gt;在将侦听器实现替换为适配器扩展后，可以通过快速修复来移除任何冗余的空方法。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用&lt;b&gt;仅在找到空实现方法时发出警告&lt;/b&gt;选项可将检查配置为即便未发现空方法也发出警告。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UtilityClassWithoutPrivateConstructor" defaultSeverity="WARNING" displayName="实用程序类没有 'private' 构造函数" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告不包含 &lt;code&gt;private&lt;/code&gt; 构造函数的实用程序类。
&lt;p&gt;实用程序类将所有字段和方法声明为 &lt;code&gt;static&lt;/code&gt;。 在实用程序类中创建 &lt;code&gt;private&lt;/code&gt; 构造函数可防止它们被意外实例化。
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用&lt;b&gt;有注解时忽略&lt;/b&gt;选项可以指定特殊注解。 该检查将忽略使用其中一种注解进行标记的类。
&lt;p&gt;
使用&lt;b&gt;忽略仅具有主方法的类&lt;/b&gt;选项，可以忽略除主方法外再无其他方法的类。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ClassWithOnlyPrivateConstructors" defaultSeverity="WARNING" displayName="仅包含 'private' 构造函数的类应被声明为 'final'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告仅包含 &lt;code&gt;private&lt;/code&gt; 构造函数的类。
&lt;p&gt;只有 &lt;code&gt;private&lt;/code&gt; 构造函数的类不能在文件外扩展，应声明为 &lt;code&gt;final&lt;/code&gt;。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UtilityClassWithPublicConstructor" defaultSeverity="WARNING" displayName="实用程序类具有 'public' 构造函数" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告包含 &lt;code&gt;public&lt;/code&gt; 构造函数的实用程序类。
&lt;p&gt;实用程序类将所有字段和方法声明为 &lt;code&gt;static&lt;/code&gt;。 在这种类中创建 &lt;code&gt;public&lt;/code&gt; 构造函数令人困惑，并且可能导致类意外实例化。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConstantDeclaredInAbstractClass" defaultSeverity="WARNING" displayName="在 'abstract' 类中声明的常量" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在 abstract 类中声明的常量（&lt;code&gt;public static final&lt;/code&gt; 字段）。
&lt;p&gt;有些编码标准要求在接口中声明常量。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MethodReturnAlwaysConstant" defaultSeverity="WARNING" displayName="方法返回类特定的常量" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
报告仅返回常量（继承者不同，常量也可能不同）的方法。
&lt;p&gt;仅适用于&lt;b&gt;代码 | 检查代码&lt;/b&gt;或&lt;b&gt;代码 | 分析代码 | 通过名称运行检查&lt;/b&gt;，并且不会在编辑器中报告。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FinalClass" defaultSeverity="WARNING" displayName="类禁止继承" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告被声明为 &lt;code&gt;final&lt;/code&gt; 的类。
不报告扩展 &lt;code&gt;sealed&lt;/code&gt; 类或接口的 final 类。
这种类不能被继承，并且可能表明缺乏面向对象的设计。
某些编码标准不鼓励 &lt;code&gt;final&lt;/code&gt; 类。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;public final class&lt;/b&gt; Main {
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;public class&lt;/b&gt; Main {
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LimitedScopeInnerClass" defaultSeverity="WARNING" displayName="局部类" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告本地类。
&lt;p&gt;本地类是指在代码块中声明的命名嵌套类。
本地类不常见，因此可能令人困惑。
  此外，有些代码标准不建议使用本地类。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void test() {
    class Local { // 局部类
    }
    new Local();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FinalPrivateMethod" defaultSeverity="WARNING" displayName="'private' 方法被声明为 'final'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告同时标有 &lt;code&gt;final&lt;/code&gt; 和 &lt;code&gt;private&lt;/code&gt; 关键字的方法。
&lt;p&gt;由于 &lt;code&gt;private&lt;/code&gt; 方法因其可见性而无法被有意义地重写，因此将它们声明为 &lt;code&gt;final&lt;/code&gt; 是冗余的。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ClassInitializer" defaultSeverity="WARNING" displayName="非 'static' 初始值设定项" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告类中的非 &lt;code&gt;static&lt;/code&gt; 初始值设定项。
&lt;p&gt;某些编码标准禁止实例初始值设定项，建议使用构造函数或字段初始值设定项进行初始化。
  此外，删除 &lt;code&gt;static&lt;/code&gt; 关键字可能会导致意外创建非 &lt;code&gt;static&lt;/code&gt; 初始值设定项，造成模糊不清的错误。
&lt;/p&gt;
&lt;p&gt;此检查不报告匿名类中的实例初始值设定项。
  &lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用&lt;b&gt;仅在类具有一个或多个构造函数时警告&lt;/b&gt;选项，可忽略没有任何构造函数的类中的实例初始值设定项。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ClassMayBeInterface" defaultSeverity="INFORMATION" displayName="'abstract' 类可以是 'interface'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以转换为接口的 &lt;code&gt;abstract&lt;/code&gt; 类。
&lt;p&gt;最好使用接口而不是类，因为 Java 不支持多类继承，而一个类可以实现多个接口。&lt;/p&gt;
&lt;p&gt;如果一个类没有超类（Object 以外）、只有 &lt;code&gt;public static final&lt;/code&gt; 字段、&lt;code&gt;public abstract&lt;/code&gt; 方法和 &lt;code&gt;public&lt;/code&gt; 内部类，则可以将其转换为接口。
&lt;!-- tooltip end --&gt;

&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
abstract class Example {
    public static final int MY_CONST = 42;
    public abstract void foo();
}

class Inheritor extends Example {
    @Override
    public void foo() {
        System.out.println(MY_CONST);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在应用快速修复后：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
interface Example {
    int MY_CONST = 42;
    void foo();
}

class Inheritor implements Example {
    @Override
    public void foo() {
        System.out.println(MY_CONST);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;配置检查：&lt;/p&gt;
&lt;p&gt;
  &lt;b&gt;使用 Java 8 时报告包含非 abstract 方法的类&lt;/b&gt; 选项可用于仅报告其 &lt;code&gt;static&lt;/code&gt; 和非 abstract 方法可以转换为 &lt;code&gt;default&lt;/code&gt; 方法的类（仅适用于语言级别为 8 或更高时）。
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="EmptyClass" defaultSeverity="WARNING" displayName="冗余空类" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告空类和没有任何定义类的 Java 文件。
&lt;p&gt;如果一个类不包含任何字段、方法、构造函数或初始值设定项，则为空类。 在进行重大变更或重构后，空类通常会保留下来。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;配置检查：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    使用&lt;b&gt;有注解时忽略&lt;/b&gt;选项可以指定特殊注解。 该检查将忽略用这些注解标记的类。
  &lt;/li&gt;
  &lt;li&gt;&lt;p&gt;
    使用&lt;b&gt;如果类是父类型的形参化，则将其忽略&lt;/b&gt;选项，可以忽略形参化超类的类。 示例：
  &lt;/p&gt;
    &lt;pre&gt;&lt;code&gt;class MyList extends ArrayList&amp;lt;String&amp;gt; {}&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    使用&lt;b&gt;忽略 java.lang.Throwable 的子类&lt;/b&gt;，可以忽略扩展 &lt;code&gt;java.lang.Throwable&lt;/code&gt; 的类。
  &lt;/li&gt;
  &lt;li&gt;
    使用&lt;b&gt;注释计为内容&lt;/b&gt;选项可忽略包含注释的类。
  &lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConstantDeclaredInInterface" defaultSeverity="WARNING" displayName="在接口中声明的常量" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在接口中声明的常量（&lt;code&gt;public static final&lt;/code&gt; 字段）。
&lt;p&gt;有些编码标准要求在 abstract 类中声明常量。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FinalStaticMethod" defaultSeverity="WARNING" displayName="'static' 方法被声明为 'final'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告标记为 &lt;code&gt;final&lt;/code&gt; 的 static 方法。
&lt;p&gt;此类代码可能表示错误或关于 &lt;code&gt;final&lt;/code&gt; 关键字效果的不正确的假设。
由于 static 方法不受运行时多态性影响，因此与 static 方法一起使用的 &lt;code&gt;final&lt;/code&gt; 关键字的唯一目的是确保该方法不会在子类中被隐藏。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NonFinalUtilityClass" defaultSeverity="WARNING" displayName="实用程序类不为 'final'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告非 &lt;code&gt;final&lt;/code&gt; 的实用程序类。
&lt;p&gt;实用程序类将所有字段和方法声明为 &lt;code&gt;static&lt;/code&gt;。
  使之为 &lt;code&gt;final&lt;/code&gt; 可防止意外地被子类化。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MarkerInterface" defaultSeverity="WARNING" displayName="标记接口" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告不含任何方法或字段的标记接口。
&lt;p&gt;此类接口可能令人困惑，通常表明设计失败。&lt;/p&gt;
&lt;p&gt;该检查将忽略扩展两个或多个接口的接口以及指定其超接口泛型类型的接口。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AnonymousInnerClass" defaultSeverity="WARNING" displayName="匿名内部类可被替换为内部类" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告匿名内部类。
&lt;p&gt;在某些情况下，将匿名内部类替换为内部类可以提高代码的可读性和可维护性。
  另外，有些代码标准不建议使用匿名内部类。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FinalMethod" defaultSeverity="WARNING" displayName="不能重写方法" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告被声明为 &lt;code&gt;final&lt;/code&gt; 的方法。
此类方法不能被重写，并且可能表明缺乏面向对象的设计。
  某些编码标准不鼓励 &lt;code&gt;final&lt;/code&gt; 方法。
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ClassNameDiffersFromFileName" defaultSeverity="WARNING" displayName="类名与文件名不同" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告所属的文件名与其不匹配的顶层类名。
&lt;p&gt;虽然 Java 规范允许以这种方式命名非 &lt;code&gt;public&lt;/code&gt; 类，但名称不匹配的文件可能令人困惑，并降低各种软件工具的实用性。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="InterfaceMayBeAnnotatedFunctional" defaultSeverity="WARNING" displayName="接口可以注解为 '@FunctionalInterface'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以用 &lt;code&gt;@FunctionalInterface&lt;/code&gt; 注解的接口（自 JDK 1.8 起提供）。
&lt;p&gt;使用 &lt;code&gt;@FunctionalInterface&lt;/code&gt; 对接口进行注解会指示该接口为函数式接口，不能再向其添加其他 &lt;code&gt;abstract&lt;/code&gt; 方法。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  interface FileProcessor {
    void execute(File file);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @FunctionalInterface
  interface FileProcessor {
    void execute(File file);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;仅当项目或模块的语言级别为 8 或更高时，此检查才会报告。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UtilityClass" defaultSeverity="WARNING" displayName="实用程序类" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告实用程序类。
&lt;p&gt;实用程序类将所有字段和方法声明为 &lt;code&gt;static&lt;/code&gt;，存在这样的情况可能表明欠缺面向对象的设计。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
使用&lt;b&gt;有注解时忽略&lt;/b&gt;选项可以指定特殊注解。 该检查将忽略使用其中一种注解进行注解的类。&lt;/p&gt;
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FieldCanBeLocal" defaultSeverity="WARNING" displayName="可以为本地字段" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以用局部变量替换的冗余类字段。
&lt;p&gt;如果一个字段的所有局部用法都紧跟对该字段的赋值，则可以删除该字段，并且可以将其用法替换为局部变量。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="UtilityClassCanBeEnum" defaultSeverity="WARNING" displayName="实用程序类可以是 'enum'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可转换为枚举的实用程序类。
&lt;p&gt;某些编码样式准则要求将实用程序类作为枚举实现，以避免 &lt;code&gt;private&lt;/code&gt; 构造函数中的代码覆盖率问题。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class StringUtils {
    public static final String EMPTY = "";
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  enum StringUtils {
    ;
    public static final String EMPTY = "";
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StaticNonFinalField" defaultSeverity="WARNING" displayName="'static' 非 'final' 字段" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告非 &lt;code&gt;final&lt;/code&gt; &lt;code&gt;static&lt;/code&gt; 字段。
&lt;p&gt;可以通过快速修复将 &lt;code&gt;final&lt;/code&gt; 修饰符添加到非 &lt;code&gt;final&lt;/code&gt; &lt;code&gt;static&lt;/code&gt; 字段中。&lt;/p&gt;
&lt;p&gt;此检查不检查字段的可变性。 例如，将 &lt;code&gt;final&lt;/code&gt; 修饰符添加到在某个位置设置了值的字段，将导致编译错误。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用&lt;b&gt;仅报告 'public' 字段&lt;/b&gt;选项，使该检查只报告 &lt;code&gt;public&lt;/code&gt; 字段。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NonFinalFieldInEnum" defaultSeverity="WARNING" displayName="'enum' 中的非 final 字段" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告枚举类型中的非 final 字段，因为很少需要它们，且提供全局可变状态。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  enum Enum {
    FIRST("first"),
    SECOND("second");

    public String str;

    Enum(String str) {
        this.str = str;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  enum Enum {
    FIRST("first"),
    SECOND("second");

    public final String str;

    Enum(String str) {
        this.str = str;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
配置“在快速修复不可用时忽略字段”复选框以仅高亮显示可通过该快速修复设为 final 的字段。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MultipleTopLevelClassesInFile" defaultSeverity="WARNING" displayName="单个文件中的多个顶级类" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告单个 Java 文件中的多个顶层类。
&lt;p&gt;将多个顶层类放在一个文件中可能令人困惑，并且会降低各种软件工具的实用性。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="InnerClassOnInterface" defaultSeverity="WARNING" displayName="接口的内部类" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;interface&lt;/code&gt; 类中的内部类。
&lt;p&gt;有些编码标准不建议使用这种类。 该检查不报告枚举类和注解接口。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
使用&lt;b&gt;忽略接口的内部接口&lt;/b&gt;选项，可以忽略内部接口。 示例：
&lt;pre&gt;&lt;code&gt;
  interface I {
    interface Inner {
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ParameterCanBeLocal" defaultSeverity="WARNING" displayName="从不读取作为形参传递的值" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以用局部变量替换的冗余方法形参。
&lt;p&gt;如果一个形参的所有局部用法都紧跟对该形参的赋值，则可以移除该形参，并且将其用法替换为局部变量。
拥有此类形参是没有意义的，因为传递给它的值会被重写。
  此问题通常是重构的结果。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void test(int p) {
    p = 1;
    System.out.print(p);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void test() {
    int p = 1;
    System.out.print(p);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="PublicConstructor" defaultSeverity="WARNING" displayName="'public' 构造函数可被替换为工厂方法" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;public&lt;/code&gt; 构造函数。
&lt;p&gt;有些编码标准不建议使用 &lt;code&gt;public&lt;/code&gt; 构造函数，而是建议使用 &lt;code&gt;static&lt;/code&gt; 工厂方法。
这样就可以在不影响调用点的情况下交换实现。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Test {
    private String name;

    public Test(String name) {
        this.name = name;
    }

    public void test() {
        System.out.println(name);
    }

    public static void main(String[] args) {
        new Test("str").test();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Test {
    private String name;

    private Test(String name) {
        this.name = name;
    }

    public static Test getInstance(String name) {
        return new Test(name);
    }

    public void test() {
        System.out.println(name);
    }

    public static void main(String[] args) {
        getInstance("str").test();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="代码样式问题" path="JavaScript and TypeScript"><inspection shortName="ChainedFunctionCallJS" defaultSeverity="WARNING" displayName="链式函数调用" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告目标为另一个函数调用的函数调用，例如 &lt;code&gt;foo().bar()&lt;/code&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSArrowFunctionBracesCanBeRemoved" defaultSeverity="INFORMATION" displayName="箭头函数体周围的大括号冗余" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告其函数体仅由大括号和恰好一条语句组成的箭头函数。
建议转换为不带大括号的简洁语法。
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  &lt;code&gt;
    let incrementer = (x) =&gt; {return x + 1};
  &lt;/code&gt;
&lt;/p&gt;
&lt;p&gt;应用快速修复后，代码段如下所示：&lt;/p&gt;
&lt;p&gt;
  &lt;code&gt;
    let incrementer = (x) =&gt; x + 1;
  &lt;/code&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSDeclarationsAtScopeStart" defaultSeverity="WEAK WARNING" displayName="'var' 未在函数开头声明" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
检查使用 &lt;b&gt;var&lt;/b&gt; 声明的局部变量的声明是否位于函数范围的顶部。
&lt;br/&gt;&lt;br/&gt;
默认情况下，在执行代码时，变量声明总是被隐形地移动（“提升”）到它所包含的范围的顶部。
因此，在范围顶部声明有助于在代码中表现出这种行为。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ChainedEqualityJS" defaultSeverity="WARNING" displayName="链式相等" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告链式相等比较（即 &lt;code&gt;a==b==c&lt;/code&gt;）。  此类比较令人困惑。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConstantOnRHSOfComparisonJS" defaultSeverity="WARNING" displayName="常量位于比较的右侧" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;!-- Copied from community/plugins/InspectionGadgets/src/inspectionDescriptions/ConstantOnWrongSideOfComparison.html --&gt;
&lt;html&gt;
&lt;body&gt;
报告右侧有常量的比较运算。 根据 
编码约定，常量应当只位于比较的左侧。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnterminatedStatementJS" defaultSeverity="WARNING" displayName="未终止的语句" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告结尾不带分号或换行符的语句。
&lt;p&gt;在&lt;i&gt;编辑器 | 代码样式 | JavaScript 或 TypeScript - 标点符号&lt;/i&gt;中选择“用分号结束语句”选项，报告任何不以分号结尾的语句，即使末尾使用了换行符时也报告。
根据某些编码样式，为了与其他语言相一致，分号比换行符更可取。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NonBlockStatementBodyJS" defaultSeverity="WARNING" displayName="没有大括号的语句体" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告其语句体不是块语句的 &lt;code&gt;if&lt;/code&gt;、&lt;code&gt;while&lt;/code&gt;、&lt;code&gt;for&lt;/code&gt; 或 &lt;code&gt;with&lt;/code&gt; 语句。  在语句体中使用代码块通常对下游维护更安全。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConstantOnLHSOfComparisonJS" defaultSeverity="WARNING" displayName="常量位于比较的左侧" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;!-- Copied from community/plugins/InspectionGadgets/src/inspectionDescriptions/ConstantOnWrongSideOfComparison.html --&gt;
&lt;html&gt;
&lt;body&gt;
报告左侧有常量的比较运算。 根据 
编码约定，常量应当位于比较的右侧。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NestedFunctionCallJS" defaultSeverity="WARNING" displayName="嵌套函数调用" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在另一个函数调用中用作实参的函数调用，例如 &lt;code&gt;foo(bar())&lt;/code&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSRemoveUnnecessaryParentheses" defaultSeverity="INFORMATION" displayName="不必要的圆括号" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告冗余圆括号。
&lt;!-- tooltip end --&gt;
&lt;p&gt;在表达式中：&lt;/p&gt;
&lt;code&gt;var x = ((1) + 2) + 3&lt;/code&gt;
&lt;p&gt;在箭头函数实参列表中：&lt;/p&gt;
&lt;code&gt;var incrementer = (x) =&gt; x + 1&lt;/code&gt;

&lt;p&gt;在 TypeScript 和 Flow 类型声明中：&lt;/p&gt;
&lt;code&gt;type Card = (Suit &amp; Rank) | (Suit &amp; Number)&lt;/code&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSUndefinedPropertyAssignment" defaultSeverity="WEAK WARNING" displayName="未定义的属性赋值" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对未在变量类型中定义的属性的赋值。 &lt;p&gt;示例： &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
/**
 * @type {{ property1: string, property2: number }}
 */
let myVariable = create();

myVariable.newProperty = 3; // 不良
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Java 15" path="Java/Java 语言级别迁移帮助"><inspection shortName="TextBlockMigration" defaultSeverity="WARNING" displayName="可以使用文本块" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可通过替换为文本块来简化的 &lt;code&gt;String&lt;/code&gt; 串联。
&lt;p&gt;要求：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;\n&lt;/code&gt; 发生两次或多次。&lt;/li&gt;
  &lt;li&gt;文本块未串联。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
使用&lt;b&gt;应用于单字符串文字&lt;/b&gt;选项，可建议修正包含换行符的单一文字。
&lt;p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String html = "&amp;lt;html&amp;gt;\n" +
                "    &amp;lt;body&amp;gt;\n" +
                "        &amp;lt;p&amp;gt;Hello, world&amp;lt;/p&amp;gt;\n" +
                "    &amp;lt;/body&amp;gt;\n" +
                "&amp;lt;/html&amp;gt;\n";
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String html = """
                &amp;lt;html&amp;gt;
                    &amp;lt;body&amp;gt;
                        &amp;lt;p&amp;gt;Hello, world&amp;lt;/p&amp;gt;
                    &amp;lt;/body&amp;gt;
                &amp;lt;/html&amp;gt;
                """;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;仅当项目或模块的语言级别为 15 或更高时，此检查才会报告。&lt;/p&gt;
&lt;p&gt;&lt;small&gt;2019.3 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TextBlockBackwardMigration" defaultSeverity="INFORMATION" displayName="文本块可被替换为正则字符串文字" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以替换为常规字符串文字的文本块。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Object obj = engine.eval("""
                           function hello() {
                             print('"Hello, world"');
                           }

                           hello();
                           """);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Object obj = engine.eval("function hello() {\n" +
                           "  print('\"Hello, world\"');\n" +
                           "}\n" +
                           "\n" +
                           "hello();\n");
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  &lt;i&gt;文本块&lt;/i&gt;在 Java 15 中出现。
  此检查有助于为向后兼容早期 Java 版本而降级。
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;2019.3 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="可能的错误" path="Java/Java 语言级别迁移帮助"><inspection shortName="InconsistentTextBlockIndent" defaultSeverity="WARNING" displayName="文本块中的空格缩进不一致" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告同时使用空格和制表符缩进的文本块。
由于空格和制表符会被文本块处理同等对待，此类情况会产生意外的结果。
&lt;p&gt;在下面的示例中，空格和制表符被分别呈现为 &lt;code&gt;·&lt;/code&gt; 和 &lt;code&gt;␉&lt;/code&gt;，在编辑器中，一个制表符相当于 4 个空格。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
String colors = """
········red
␉   ␉   green
········blue""";
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;打印此类字符串后，结果为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
······red
green
······blue
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在编译器从每一行的开头移除相同数量的空格或制表符后，某些行将保留前导空格。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;仅当配置的语言级别为 15 或更高时，此检查才会报告。&lt;/p&gt;
&lt;p&gt;&lt;small&gt;2021.1 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Compose 预览" path=""><inspection shortName="UpdateTransitionLabel" defaultSeverity="WARNING" displayName="未设置过渡标签形参" enabled="false" language="kotlin" pluginId="com.android.tools.design" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;&lt;body&gt;
检查是否为创建 Compose 传递动画的 updateTransition 调用设置了 &lt;code&gt;label&lt;/code&gt; 形参。
&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="PreviewDimensionRespectsLimit" defaultSeverity="WARNING" displayName="预览尺寸有最大限制" enabled="false" language="kotlin" pluginId="com.android.tools.design" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;&lt;body&gt;
检查 Preview 尺寸（宽度和高度）是否有最大限制。
&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="PreviewNeedsComposableAnnotation" defaultSeverity="ERROR" displayName="在非 Composable 函数上使用的预览" enabled="false" language="kotlin" pluginId="com.android.tools.design" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;&lt;body&gt;
检查 Preview 是否仅和 Composable 函数结合使用。
&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="PreviewNotSupportedInUnitTestFiles" defaultSeverity="ERROR" displayName="单元测试文件中不支持预览。" enabled="false" language="kotlin" pluginId="com.android.tools.design" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
检查单元测试文件中是否未使用预览。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PreviewFontScaleMustBeGreaterThanZero" defaultSeverity="ERROR" displayName="非正 fontScale 形参" enabled="false" language="kotlin" pluginId="com.android.tools.design" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
检查预览 &lt;code&gt;fontScale&lt;/code&gt; 值是否大于零。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TransitionPropertiesLabel" defaultSeverity="WARNING" displayName="未设置过渡属性标签形参" enabled="false" language="kotlin" pluginId="com.android.tools.design" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;&lt;body&gt;
检查是否为创建 Compose 传递属性的 &lt;code&gt;animate*&lt;/code&gt;（例如 &lt;code&gt;animateFloat&lt;/code&gt;、&lt;code&gt;animateColor&lt;/code&gt;）调用设置了标签形参。
&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="PreviewPickerAnnotation" defaultSeverity="ERROR" displayName="预览设备形参必须具有有效的语法" enabled="false" language="kotlin" pluginId="com.android.tools.design" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
检查预览设备形参是否具有有效语法。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PreviewMultipleParameterProviders" defaultSeverity="ERROR" displayName="不允许多个 @PreviewParameter。" enabled="false" language="kotlin" pluginId="com.android.tools.design" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
检测多个 @PreviewParameter 注解。 不允许多个 @PreviewParameter。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PreviewAnnotationInFunctionWithParameters" defaultSeverity="ERROR" displayName="带参数的 Composable 函数中使用的预览" enabled="false" language="kotlin" pluginId="com.android.tools.design" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;&lt;body&gt;
检查 Preview 是否未和带形参的 Composable 函数结合使用。 Preview 不支持带形参的 Composable 函数。
&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="PreviewApiLevelMustBeValid" defaultSeverity="ERROR" displayName="预览 apiLevel 必须与支持的 API 级别对应" enabled="false" language="kotlin" pluginId="com.android.tools.design" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
检查预览 &lt;code&gt;apiLevel&lt;/code&gt; 是否与支持的 API 级别对应。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PreviewMustBeTopLevelFunction" defaultSeverity="ERROR" displayName="预览必须是顶层声明，或是具有默认构造函数的顶层类。" enabled="false" language="kotlin" pluginId="com.android.tools.design" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;&lt;body&gt;
检查 Preview 是否仅与顶层声明结合使用，或在具有默认构造函数的顶层类中使用。
&lt;/body&gt;&lt;/html&gt;</inspection></group><group name="数据流" path="Java"><inspection shortName="ReuseOfLocalVariable" defaultSeverity="INFORMATION" displayName="局部变量的重用" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告使用与其原始用途无关的新值覆盖其值而进行“重用”的局部变量。
&lt;p&gt;此类局部变量重用可能令人困惑，因为局部变量的预期语义可能随每种用法而异。 如果由于代码变更，视为被覆盖的值实际看似处于活动状态，它也可能容易出现错误。 保持变量生命周期尽可能短不失为一种好做法，不要为了简洁而重用局部变量。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    void x() {
        String s = "one";
        System.out.println("s = " + s);
        s = "two"; //重用局部变量 's'
        System.out.println("s = " + s);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="BooleanVariableAlwaysNegated" defaultSeverity="WARNING" displayName="布尔变量始终反转" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告使用其值时总是否定的布尔变量或字段。
&lt;!-- tooltip end --&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
      void m() {
        boolean b = true; //始终反转布尔变量 'b'
        System.out.println(!b);
      }
&lt;/code&gt;&lt;/pre&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryLocalVariable" defaultSeverity="WARNING" displayName="冗余局部变量" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告不必要的、不会增加方法的可理解性的局部变量，包括：
&lt;ul&gt;
  &lt;li&gt;立即返回的局部变量。&lt;/li&gt;
  &lt;li&gt;立刻赋值给另一个变量并且不再使用的局部变量。&lt;/li&gt;
  &lt;li&gt;始终与另一个局部变量或形参具有相同值的局部变量。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean yes() {
    boolean b = true;
    return b;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean yes() {
    return true;
  }
  &lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;配置检查：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;使用&lt;b&gt;忽略立即返回或抛出的变量&lt;/b&gt;选项可以忽略立即返回或抛出的变量。
    为清晰起见和易于调试，某些编码样式建议使用此类变量。&lt;/li&gt;
  &lt;li&gt;使用&lt;b&gt;忽略具有注解的变量&lt;/b&gt;选项可以忽略注解的变量。&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NegativelyNamedBooleanVariable" defaultSeverity="WARNING" displayName="否定命名的布尔变量" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告否定命名的变量，例如：&lt;code&gt;disabled&lt;/code&gt;、&lt;code&gt;hidden&lt;/code&gt; 或 &lt;code&gt;isNotChanged&lt;/code&gt;。
&lt;p&gt;反转 &lt;code&gt;boolean&lt;/code&gt; 值并从名称中移除否定通常有助于使代码更容易理解。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    boolean disabled = false;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LawOfDemeter" defaultSeverity="WARNING" displayName="方法调用违反迪米特法则" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告违反&lt;a href="https://en.wikipedia.org/wiki/Law_of_Demeter"&gt;迪米特法则&lt;/a&gt;的情况。
&lt;p&gt;迪米特法则并非真正的法则，但它指定了一种样式准则：绝不调用从另一个调用中获取的对象的方法。
遵循此准则的代码更容易维护、调整和重构，方法之间的耦合更少，重复更少，信息隐藏得更好。 另一方面，您可能需要编写许多包装器方法才能满足这一准则。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean pay(Customer c, Invoice invoice) {
    int dollars = c.getWallet().getDollars(); // 违规
    if (dollars &gt;= invoice.getAmount()) {
      Wallet w = c.getWallet();
      w.subtract(invoice.getAmount()); // 违规
      return true;
    }
    return false;
  }
&lt;/code&gt;&lt;/pre&gt;
上面的示例可以更好地实现为 &lt;code&gt;Customer&lt;/code&gt; 中的 &lt;code&gt;payInvoice(Invoice invoice)&lt;/code&gt; 方法。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Engine engine = car.getEngine();
  int cylinders = engine.getNumberOfCylinders();
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="BooleanMethodIsAlwaysInverted" defaultSeverity="WARNING" displayName="布尔方法总是反向的" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
报告一个返回类型为 &lt;code&gt; boolean &lt;/code&gt; 的方法，该方法仅在否定上下文中使用。
&lt;p&gt;您可以使用快速修复来重命名方法和反转方法。
  由于性能原因，某些方法可能不会在编辑器中高亮显示。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class C {
    boolean alwaysTrue() {
      return true;
    }

    void f() {
      if (!alwaysTrue()) {
        return;
      }
    }
    boolean member = !alwaysTrue();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class C {
    boolean alwaysFalse() {
      return false;
    }

    void f() {
      if (alwaysFalse()) {
        return;
      }
    }
    boolean member = alwaysFalse();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="TooBroadScope" defaultSeverity="INFORMATION" displayName="变量范围过宽" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告任何可以移动到更小范围的变量声明。
&lt;p&gt;这种检查对于方法开头的 &lt;i&gt;Pascal 样式&lt;/i&gt;声明特别有用。 此外，范围太广的变量在重构后也通常会被留下。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  StringBuilder sb = new StringBuilder();
  System.out.println();
  sb.append(1);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  System.out.println();
  StringBuilder sb = new StringBuilder();
  sb.append(1);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;配置检查：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;使用&lt;b&gt;仅报告可移入内部块的变量&lt;/b&gt;选项可只报告那些可以移动到更深代码块中的变量。
    例如，启用该选项时，将不建议对上面的 &lt;code&gt;sb&lt;/code&gt; 变量进行移动。
    但是，建议将其用于以下代码：
&lt;pre&gt;&lt;code&gt;
  StringBuilder sb = new StringBuilder(a);
  if (flag) {
    sb.append(1);
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
  &lt;li&gt;使用&lt;b&gt;报告使用新表达式作为初始值设定项的变量(可能不安全)&lt;/b&gt; 选项可以报告使用新表达式初始化的变量。 这使得当构造函数具有非本地副作用时，检查可能会不安全。 例如，启用该选项时，将建议对 &lt;code&gt;foo&lt;/code&gt; 变量进行移动：
&lt;pre&gt;&lt;code&gt;
  class Foo {
    static List&amp;lt;Foo&amp;gt; fooList = new ArrayList&amp;lt;&amp;gt;();
    String bar;

    Foo(String bar) {
        this.bar = bar;
        fooList.add(this);
    }

    public static void main(String[] args) {
      // 虽不安全，但也可以移动
      Foo foo = new Foo("bar");
      System.out.println(fooList.size());
      System.out.println(foo.bar);
    }
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConstantValueVariableUse" defaultSeverity="WARNING" displayName="使用已知值为常量的变量" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告已知为常量的变量的所有用法。
&lt;p&gt;如果（读取）使用的变量被 &lt;code&gt;if&lt;/code&gt;、&lt;code&gt;while&lt;/code&gt; 或 &lt;code&gt;for&lt;/code&gt; 语句包围，且存在该变量与常量相比较的 &lt;code&gt;==&lt;/code&gt; 条件时，就会发生这种情况。
  在这种情况下，使用的已知为常量的变量可以替换为实际常量。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    private static void foo(double number) {
        if (number == 1.0) {
            f(number);
        }
    }
    private static void f(double number) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    private static void foo(double number) {
        if (number == 1.0) {
            f(1.0);
        }
    }
    private static void f(double number) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="JUnit" path="Java"><inspection shortName="MultipleExceptionsDeclaredOnTestMethod" defaultSeverity="WARNING" displayName="在测试方法上声明的多个异常" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告具有多个异常的 JUnit 测试方法的 &lt;code&gt;throws&lt;/code&gt; 子句。
此类子句会造成不必要的冗余。
不会从其他项目代码调用测试方法，因此无需单独处理这些异常。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Test
  &lt;b&gt;public void&lt;/b&gt; testReflection() &lt;b&gt;throws&lt;/b&gt; NoSuchMethodException,
      InvocationTargetException, IllegalAccessException {
    String result = (String) String.class.getMethod("trim")
        .invoke(" hello ");
    assertEquals("hello", result);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过快速修复将异常声明替换为单个异常：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Test
  &lt;b&gt;public void&lt;/b&gt; testReflection() &lt;b&gt;throws&lt;/b&gt; Exception {
    String result = (String) String.class.getMethod("trim")
        .invoke(" hello ");
    assertEquals("hello", result);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ParameterizedParametersStaticCollection" defaultSeverity="WARNING" displayName="没有数据提供程序方法的形参化测试类" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告使用 &lt;code&gt;@RunWith(Parameterized.class)&lt;/code&gt; 注解，但要么不包括使用 &lt;code&gt;@Parameterized.Parameters&lt;/code&gt; 注解的数据提供程序方法，要么此方法的签名不正确的 JUnit 4 &lt;a href="https://github.com/junit-team/junit4/wiki/parameterized-tests"&gt;形参化测试&lt;/a&gt;类。 这种测试类无法运行。
数据提供程序方法应为 &lt;code&gt;public&lt;/code&gt; 和 &lt;code&gt;static&lt;/code&gt; 并具有 &lt;code&gt;Iterable&lt;/code&gt; 或 &lt;code&gt;Object[]&lt;/code&gt; 的返回类型。
&lt;p&gt;建议创建一个空的形参提供程序方法或更改不正确的数据提供程序方法的签名。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;p&gt;
&lt;pre&gt;&lt;code&gt;
  @RunWith(Parameterized.class)
  &lt;b&gt;public class&lt;/b&gt; ImportantTest {
    &lt;b&gt;private int&lt;/b&gt; input;
    &lt;b&gt;private int&lt;/b&gt; expected;

    ImportantTest(&lt;b&gt;int&lt;/b&gt; input, &lt;b&gt;int&lt;/b&gt; expected) {
      &lt;b&gt;this&lt;/b&gt;.input = input;
      &lt;b&gt;this&lt;/b&gt;.expected = expected;
    }

    // …测试用例
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @RunWith(Parameterized.class)
  &lt;b&gt;public class&lt;/b&gt; ImportantTest {
    &lt;b&gt;private int&lt;/b&gt; input;
    &lt;b&gt;private int&lt;/b&gt; expected;

    ImportantTest(&lt;b&gt;int&lt;/b&gt; input, &lt;b&gt;int&lt;/b&gt; expected) {
      &lt;b&gt;this&lt;/b&gt;.input = input;
      &lt;b&gt;this&lt;/b&gt;.expected = expected;
    }

    @Parameters
    &lt;b&gt;public static&lt;/b&gt; Iterable&amp;lt;Object[]&gt; parameters() {
      &lt;b&gt;return null&lt;/b&gt;;
    }

    // …测试用例
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="Junit4Converter" defaultSeverity="INFORMATION" displayName="JUnit 3 测试可以是 JUnit 4" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以转换为 JUnit 4 测试类的 JUnit 3 测试类。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class MainTestCase extends junit.framework.TestCase {
    public void test() {
      Assert.assertTrue(true);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class MainTestCase {
    @org.junit.Test
    public void test() {
      Assert.assertTrue(true);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;当项目或模块的语言级别为 5 或更高级别并且在类路径上可以使用 JUnit 4 时，此检查才会报告。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JUnit4AnnotatedMethodInJUnit3TestCase" defaultSeverity="WARNING" displayName="扩展 JUnit 3 TestCase 中的 JUnit 4 测试方法" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;junit.framework.TestCase&lt;/code&gt; 继承者中的 JUnit 4 &lt;code&gt;@Test&lt;/code&gt; 注解方法。 混合 JUnit 的 API 会导致运行测试出现问题。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class MyTest extends TestCase {
      @Test //名称不是以 "test" 开头，因此将被忽略
      public void wouldBeIgnored() {}
  
      @Test   //名称以 "test" 开头
      @Ignore //因此即便有 @Ignore 注解也会执行
      public void testWouldBeExecuted() {}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;b&gt;提供的修正：&lt;/b&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;移除 &lt;code&gt;@Ignore&lt;/code&gt; 注解并重命名测试方法，使名称不以“test”开头。&lt;/li&gt;
  &lt;li&gt;将 JUnit 3 测试类转换为 JUnit 4。&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UseOfObsoleteAssert" defaultSeverity="WARNING" displayName="使用废弃的 'junit.framework.Assert' 方法" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对 &lt;code&gt;junit.framework.Assert&lt;/code&gt; 类中方法的任何调用。 此类已废弃，这些调用可以替换为对 &lt;code&gt;org.junit.Assert&lt;/code&gt; 类中方法的调用。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;import&lt;/b&gt; org.junit.*;
  &lt;b&gt;public class&lt;/b&gt; NecessaryTest {
    @Test
    &lt;b&gt;public void&lt;/b&gt; testIt() {
      junit.framework.Assert.assertEquals("expected", "actual");
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;应用快速修复后，结果如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;import&lt;/b&gt; org.junit;
  &lt;b&gt;public class&lt;/b&gt; NecessaryTest {

    &lt;b&gt;public void&lt;/b&gt; testIt() {
      Assert.assertEquals("expected", "actual");
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MetaAnnotationWithoutRuntimeRetention" defaultSeverity="WARNING" displayName="不含 '@Retention(RUNTIME)' 注解的测试注解" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 JUnit 5 应当使用的包含 &lt;code&gt;SOURCE&lt;/code&gt; 或 &lt;code&gt;CLASS&lt;/code&gt; 保留策略的注解。
此类注解在运行时不可用，很可能应当修正其保留策略，才能通过反射进行访问。
&lt;p&gt;请注意，如果未指定保留策略，则使用默认保留策略 &lt;code&gt;CLASS&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Testable
  public @interface UnitTest {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Retention(RetentionPolicy.RUNTIME)
  @Testable
  public @interface UnitTest {}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;!--&lt;p&gt;&lt;small&gt;New in 2017.2&lt;/small&gt;&lt;/p&gt;--&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ExpectedExceptionNeverThrown" defaultSeverity="WARNING" displayName="从未在测试方法正文中抛出预期异常" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 JUnit 4 测试方法预期但从未在方法体内抛出的已检查的异常。
此类测试方法永远不会成功。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Test(expected = CloneNotSupportedException.class)
  &lt;b&gt;public void&lt;/b&gt; testIt() {
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JUnit3StyleTestMethodInJUnit4Class" defaultSeverity="WARNING" displayName="JUnit 4 类中的旧样式 JUnit 测试方法" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告位于不扩展 JUnit 3 &lt;code&gt;TestCase&lt;/code&gt; 类并包含 JUnit 4 或 JUnit 5 &lt;code&gt;@Test&lt;/code&gt; 注解方法的类中的 JUnit 3 样式测试方法。
无法运行此类测试方法。
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TestCaseWithNoTestMethods" defaultSeverity="WARNING" displayName="没有测试的测试类" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告没有任何测试方法的非 &lt;code&gt;abstract&lt;/code&gt; 测试用例。
&lt;p&gt;此类测试用例通常表示未完成的代码，或者可能是应该移除的重构剩余部分。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;public class&lt;/b&gt; CrucialTest {
    @Before
    &lt;b&gt;public void&lt;/b&gt; setUp() {
      System.out.println("setting up");
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;使用&lt;b&gt;忽略具有带测试方法的超类的测试用例&lt;/b&gt;选项可忽略具有带测试方法的超类的测试用例。&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="有效性问题" path="JavaScript and TypeScript"><inspection shortName="StringLiteralBreaksHTMLJS" defaultSeverity="WARNING" displayName="中断 HTML 解析的字符串文字" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告包含 &lt;code&gt;&amp;lt;/&lt;/code&gt; 序列的字符串文字。  此类字符串可能会导致错误解析在其中嵌入 JavaScript 代码的任何 HTML。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="BadExpressionStatementJS" defaultSeverity="WEAK WARNING" displayName="非赋值或调用的表达式语句" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告既非赋值也非调用的表达式语句。
此类语句通常表明有错误。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ThisExpressionReferencesGlobalObjectJS" defaultSeverity="WARNING" displayName="引用全局对象的 'this' 表达式" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对象文字或构造函数体之外的 &lt;code&gt; this&lt;/code&gt; 表达式。  此类 &lt;code&gt;this&lt;/code&gt; 表达式引用顶级“全局”JavaScript 对象，但大多是无用的。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FunctionWithInconsistentReturnsJS" defaultSeverity="WARNING" displayName="函数的返回不一致" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在某些情况下返回值但在其他情况下不返回值的函数。 这通常表明有错误。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
function foo() {
  if (true)
    return 3;
  return;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSConstantReassignment" defaultSeverity="ERROR" displayName="尝试分配给常量或只读变量" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告将值重新赋给常量或只读变量的情况。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReservedWordUsedAsNameJS" defaultSeverity="WARNING" displayName="保留词用作名称" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告用作名称的 JavaScript 保留字。  JavaScript 规范
保留了许多当前未用作关键字的词语。  如果后续版本的 JavaScript 开始使用这些词语作为关键字，
使用这些词语作为标识符可能会破坏代码。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSOctalInteger" defaultSeverity="ERROR" displayName="八进制整数" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告已弃用的前缀为 &lt;code&gt;0&lt;/code&gt; 而不是 &lt;code&gt;0o&lt;/code&gt; 的八进制整数文字。&lt;br/&gt;
现代 ECMAScript 代码中不允许使用此类文字，在 strict 模式下使用它们会导致错误。&lt;br/&gt;
要针对 ES5 和 ES3 语言级别强制执行此检查，请选中下面的“对 ES5 代码中过时的八进制文字发出警告”复选框。
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="代码质量工具" path="CSS"><inspection shortName="Stylelint" defaultSeverity="ERROR" displayName="Stylelint" enabled="false" language="CSS" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;a href="http://stylelint.io"&gt;Stylelint&lt;/a&gt; linter 检测到的差异。
&lt;!-- tooltip end --&gt;
&lt;br/&gt;&lt;br/&gt;
高亮显示基于 &lt;a href="https://stylelint.io/user-guide/configure"&gt;Stylelint 配置文件&lt;/a&gt;中为每条规则指定的规则严重性。
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="赋值问题" path="Groovy"><inspection shortName="GroovyUncheckedAssignmentOfMemberOfRawType" defaultSeverity="WARNING" displayName="原始类型成员中的未检查的赋值" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告原始类型成员中的未检查的赋值。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  List list = new ArrayList()
  List&amp;ltString&amp;gt a = &lt;b&gt;list.get(0)&lt;/b&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyResultOfAssignmentUsed" defaultSeverity="WARNING" displayName="使用的赋值的结果" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告嵌套在其他表达式中以立即使用所赋值的赋值表达式。
&lt;p&gt;
  此类表达式可能令人困惑，并违反一般设计原则，即给定结构只应发挥一种作用。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyNestedAssignment" defaultSeverity="WARNING" displayName="嵌套赋值" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告嵌套在其他表达式中的赋值表达式。
虽然极其简洁，但此类表达式可能令人困惑，并违反一般设计原则，即给定结构只应发挥一种作用。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
a = b = 1
&lt;/code&gt;
&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovySillyAssignment" defaultSeverity="WARNING" displayName="不实用的赋值" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告变量对自身的赋值。
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyAssignmentCanBeOperatorAssignment" defaultSeverity="INFORMATION" displayName="赋值可被替换为运算符赋值" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可替换为运算符赋值的赋值。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  a = a + b
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  a += b
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;配置检查：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;使用&lt;b&gt;忽略条件运算符&lt;/b&gt;选项可忽略 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 和 &lt;code&gt;||&lt;/code&gt; 运算符。&lt;/li&gt;
  &lt;li&gt;使用&lt;b&gt;忽略模糊运算符&lt;/b&gt;选项可忽略 &lt;code&gt;^&lt;/code&gt; 和 &lt;code&gt;%&lt;/code&gt; 运算符。&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyAssignmentToMethodParameter" defaultSeverity="WARNING" displayName="赋值给方法形参" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告方法形参的赋值。
&lt;p&gt;虽然偶尔是有意为之，但此结构可能格外令人困惑，并且通常是由拼写错误所致。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  def m(a, b, c) {
      a = [] // 警告
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyAssignabilityCheck" defaultSeverity="WARNING" displayName="不兼容的类型赋值" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告具有不兼容类型的赋值。
&lt;p&gt;此类赋值可能导致各种运行时异常。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class A {}
  class B {}

  // 不兼容的赋值
  A a = new B()
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyAssignmentToForLoopParameter" defaultSeverity="WARNING" displayName="赋值给 'for' 循环形参" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对 &lt;b&gt;for&lt;/b&gt; 循环体中的 &lt;b&gt;for&lt;/b&gt; 循环形参的赋值。
&lt;p&gt;虽然偶尔是有意为之，但此结构可能格外令人困惑，并且通常是由拼写错误所致。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  for (value in [1, 2, 3]) {
      value = 4 // 警告
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="可能的错误" path="Groovy"><inspection shortName="GrSwitchExhaustivenessCheck" defaultSeverity="WEAK WARNING" displayName="switch 表达式的详尽性检查" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告未覆盖匹配表达式的所有可能结果的 switch 表达式。&lt;p&gt;
&lt;p&gt;Groovy 不要求 switch 表达式必须详尽。 它的作用就像插入了隐式 &lt;code&gt;default -&gt; null&lt;/code&gt; 分支。
  如果开发者忘记插入必要的 &lt;code&gt;case&lt;/code&gt; 分支，可能会导致意外的 null。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  enum A { X, Y }

  def foo(A a) {
    def x = switch (a) { // reports switch
      case A.X -&gt; ...
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyResultOfObjectAllocationIgnored" defaultSeverity="WARNING" displayName="被忽略的对象分配结果" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告忽略运算结果的对象分配。
&lt;p&gt;
  此类分配表达式虽然在 Groovy 中合法，但通常要么是无意为之，要么表明存在复杂的对象初始化策略。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyInfiniteLoopStatement" defaultSeverity="WARNING" displayName="无限循环语句" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告只能通过抛出异常来退出的 &lt;code&gt;for&lt;/code&gt;、
&lt;code&gt;while&lt;/code&gt; 或 &lt;code&gt;do&lt;/code&gt; 语句。 虽然此类语句可能是正确的，但它们通常是由错误所致。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
while(true) {
  Thread.sleep(1000)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GrPermitsClause" defaultSeverity="ERROR" displayName="不可扩展的允许的子类" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告不扩展密封基类的允许类。&lt;p&gt;
&lt;p&gt;Groovy 不要求所有的允许类都应在编译时可用并与基类一起编译。 编译器不会在处理非扩展允许子类时警告用户，但这与密封类的性质相矛盾。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class A permits B {} // 报告 B
  class B {}
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyAccessibility" defaultSeverity="WARNING" displayName="不可访问的元素" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告超出访问权限的引用。
&lt;p&gt;对 private 成员的访问会破坏封装。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GrEqualsBetweenInconvertibleTypes" defaultSeverity="WARNING" displayName="'equals()' 位于不可转换类型的对象之间" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对目标和实参的类型不兼容的 &lt;code&gt;equals()&lt;/code&gt; 的调用。
&lt;p&gt;虽然此类调用理论上可能有用，但很可能是错误。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    new HashSet&amp;lt;String&amp;gt;() == new TreeSet&amp;lt;Integer&amp;gt;())
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyRangeTypeCheck" defaultSeverity="WARNING" displayName="不正确的范围实参" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在没有 &lt;code&gt;next()&lt;/code&gt; 或 &lt;code&gt;previous()&lt;/code&gt; 方法
或者在没有实现 &lt;code&gt;java.lang.Comparable&lt;/code&gt; 接口的范围中使用的类型。
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyUntypedAccess" defaultSeverity="WARNING" displayName="无类型引用表达式" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告无法确定类型的引用表达式。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SecondUnsafeCall" defaultSeverity="WARNING" displayName="第二次不安全的调用" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告链方法或属性调用过程中可能产生的 &lt;b&gt;NullPointerException&lt;/b&gt;。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  domain?.getZone().getName()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  domain?.getZone()?.getName()
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyInfiniteRecursion" defaultSeverity="WARNING" displayName="无限递归" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告肯定会无限递归或抛出异常的方法。
此检查报告的方法无法正确结束。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
// 此函数会使循环越来越深
def fibonacci(int n) {
  return fibonacci(n-1) + fibonacci(n-2)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyDivideByZero" defaultSeverity="WARNING" displayName="除以零" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告除以 0 或对 0 取余。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  def a = 42
  a / 0 // 警告
  a % 0.0 // 警告
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyConstructorNamedArguments" defaultSeverity="WARNING" displayName="构造函数调用的命名实参" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告与此类的属性不对应的默认类构造函数调用的命名实参。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Person {
      def name
      def age
  }

  // 'firstName' 属性不存在
  new Person(firstName: "John")
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GrUnresolvedAccess" defaultSeverity="WEAK WARNING" displayName="未解析的引用表达式" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告无法解析的引用表达式。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyLabeledStatement" defaultSeverity="WARNING" displayName="标签化语句检查" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告已在父工作流中使用的标签。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
def list = ["foo"]
cycle:
for (element in list) {
  cycle: // 令人困惑的标签重复
  element.chars().forEach {
  }
}
&lt;/code&gt;
&lt;/pre&gt;


&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyInArgumentCheck" defaultSeverity="WARNING" displayName="不兼容的 'in' 实参类型" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告具有不兼容类型的条目和容器的成员运算符 &lt;code&gt;in&lt;/code&gt; 的用法。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
def list = [1, 2]
if ("foo" in list) {} // 整数列表不能包含字符串
&lt;/code&gt;
&lt;/pre&gt;

&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyDocCheck" defaultSeverity="ERROR" displayName="未解析的 GroovyDoc 引用" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 GroovyDoc 注释的中未解析引用。
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyNonShortCircuitBoolean" defaultSeverity="WARNING" displayName="非短路布尔" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告布尔运算符 'and' 和 'or' 的非短路形式（&lt;code&gt;&amp;&lt;/code&gt;
和 &lt;code&gt;|&lt;/code&gt;）。
&lt;p&gt;
  非短路版本偶尔有用，但是，它们通常是由非短路形式（&lt;code&gt;&amp;&amp;&lt;/code&gt;
  和 &lt;code&gt;||&lt;/code&gt;）拼写错误导致的，并且可能产生难以捉摸的错误。
&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
if (a &amp; b) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
if (a &amp;&amp; b) {}
&lt;/code&gt;&lt;/pre&gt;

&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="Shell 脚本" path=""><inspection shortName="ShellCheck" defaultSeverity="ERROR" displayName="ShellCheck" enabled="false" language="Shell Script" pluginId="com.jetbrains.sh" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告由集成的 &lt;a href="https://github.com/koalaman/shellcheck"&gt;ShellCheck&lt;/a&gt; 静态分析工具检测到的 shell 脚本错误。
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="CSS" path=""><inspection shortName="CssOverwrittenProperties" defaultSeverity="WARNING" displayName="覆盖的属性" enabled="false" language="CSS" pluginId="com.intellij.css" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告规则集中重复的 CSS 属性。 遵循速记属性。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
.foo {
  margin-bottom: 1px;
  margin-bottom: 1px; /* duplicates margin-bottom */
  margin: 0; /* overrides margin-bottom */
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CssConvertColorToHexInspection" defaultSeverity="WARNING" displayName="颜色可被替换为 #-hex" enabled="false" language="CSS" pluginId="com.intellij.css" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;rgb()&lt;/code&gt;、&lt;code&gt;hsl()&lt;/code&gt; 或其他颜色函数。
&lt;p&gt;建议用等效的十六进制表示法代替颜色函数。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rgb(12, 15, 255)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#0c0fff&lt;/code&gt;.&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CssReplaceWithShorthandUnsafely" defaultSeverity="INFORMATION" displayName="属性或许可被替换为速记形式" enabled="false" language="CSS" pluginId="com.intellij.css" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告一组 CSS 常规属性，并建议将不完整的一组 CSS 常规属性替换为速记形式，但在本例中，速记形式并非 100% 等效。
&lt;p&gt;
  例如，&lt;code&gt;outline-color&lt;/code&gt; 和 &lt;code&gt;outline-style&lt;/code&gt; 这 2 个属性可以替换为单个 &lt;code&gt;outline&lt;/code&gt;。
  此类替换不是 100% 等效，因为速记形式会将所有忽略的子值重置为其初始状态。
  在本例中，切换到 &lt;code&gt;outling&lt;/code&gt; 简写形式意味着 &lt;code&gt;outling-width&lt;/code&gt; 也将设置为其初始值，即 &lt;code&gt;medium&lt;/code&gt;。
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  此检查不会处理整组常规属性（在切换到速记形式 100% 安全时）。
  对于此类情况，请参阅“属性可以安全替换为速记形式”检查。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CssBrowserCompatibilityForProperties" defaultSeverity="WARNING" displayName="属性与所选浏览器不兼容" enabled="false" language="CSS" pluginId="com.intellij.css" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告不受指定浏览器支持的 CSS 属性。
基于 &lt;a href="https://github.com/mdn/browser-compat-data"&gt;MDN 兼容性数据&lt;/a&gt;。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CssReplaceWithShorthandSafely" defaultSeverity="WEAK WARNING" displayName="属性可以安全地替换为速记形式" enabled="false" language="CSS" pluginId="com.intellij.css" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告一组普通属性。 建议将整组 CSS 常规属性替换为等效的速记形式。
&lt;p&gt;
  例如，&lt;code&gt;padding-top&lt;/code&gt;、&lt;code&gt;padding-right&lt;/code&gt;、&lt;code&gt;padding-bottom&lt;/code&gt; 和 &lt;code&gt;padding-left&lt;/code&gt;
这 4 个属性可以安全地替换为单个 &lt;code&gt;padding&lt;/code&gt; 属性。
&lt;/p&gt;
&lt;p&gt;
  注意，如果这组常规属性不完整（例如，规则集中只有 3 个 &lt;code&gt;padding-xxx&lt;/code&gt; 属性），则不会显示此检查，因为切换到速记形式可能会改变结果。
  对于此类情况，可以考虑执行“属性可能已被替换为速记形式”检查。
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CssUnusedSymbol" defaultSeverity="WARNING" displayName="未使用的选择器" enabled="false" language="CSS" pluginId="com.intellij.css" pluginVersion="223.8836.41" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
报告出现在选择器中但未在 HTML 中使用的 CSS 类或元素 ID。
&lt;p&gt;
  请注意，只有通过&lt;b&gt;代码 | 检查代码&lt;/b&gt;或&lt;b&gt;代码 | 分析代码 | 按名称运行检查&lt;/b&gt;运行时，才能获得完整的检查结果。
  由于性能原因，不实时检查样式表文件。
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CssConvertColorToRgbInspection" defaultSeverity="WARNING" displayName="颜色可被替换为 rgb()" enabled="false" language="CSS" pluginId="com.intellij.css" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;hsl()&lt;/code&gt; 或 &lt;code&gt;hwb()&lt;/code&gt; 颜色函数或十六进制的颜色表示法。
&lt;p&gt;建议将此类颜色值替换为等效的 &lt;code&gt;rgb()&lt;/code&gt; 或 &lt;code&gt;rgba()&lt;/code&gt; 颜色函数。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#0c0fff&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rgb(12, 15, 255)&lt;/code&gt;.&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Node.js" path="JavaScript and TypeScript"><inspection shortName="NodeCoreCodingAssistance" defaultSeverity="WARNING" displayName="未解析的 Node.js API" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
建议为 Node.js 配置编码辅助，例如 &lt;code&gt;require&lt;/code&gt; 和/或核心模块（'path'、'http'、'fs' 等）。
&lt;p&gt;
有关完整列表，请参阅 &lt;a href="https://nodejs.org/api/"&gt;https://nodejs.org/api/&lt;/a&gt;。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="XSLT" path=""><inspection shortName="XsltUnusedDeclaration" defaultSeverity="WARNING" displayName="未使用的变量或形参" enabled="false" language="XML" pluginId="XPathView" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告从未被使用的局部变量和形参。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="XsltVariableShadowing" defaultSeverity="WARNING" displayName="隐藏的变量" enabled="false" language="XML" pluginId="XPathView" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告隐藏的 XSLT 变量。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="XsltDeclarations" defaultSeverity="ERROR" displayName="不正确的声明" enabled="false" language="XML" pluginId="XPathView" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 XSLT 变量、形参和命名模板中的重复声明和非法标识符：
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="XsltTemplateInvocation" defaultSeverity="ERROR" displayName="不正确的模板调用" enabled="false" language="XML" pluginId="XPathView" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告缺少实参、传递未被声明的实参，以及在命名 XSLT 模板调用中多次传递形参的实参。

&lt;p&gt;
使用默认值声明的形参是可选形参，不会被报告为缺失。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="集合" path="Scala"><inspection shortName="SideEffectsInMonadicTransformation" defaultSeverity="WARNING" displayName="单体转换的副作用" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告在单体转换（&lt;code&gt;map&lt;/code&gt;、&lt;code&gt;flatMap&lt;/code&gt; 和 &lt;code&gt;filter&lt;/code&gt;）中有副作用的表达式。&lt;/p&gt;
&lt;p&gt;考虑将单体转换移动到单独的 &lt;code&gt;foreach&lt;/code&gt; 通道。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  var a = 0
  Seq(1, 2).map(a += _)
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantCollectionConversion" defaultSeverity="WARNING" displayName="冗余的集合转换" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告冗余集合转换。&lt;/p&gt;

&lt;p&gt;该快速修复将移除冗余转换。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  List(1, 2).toList
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  List(1, 2)
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Spring Cloud" path="Spring"><inspection shortName="SpringBootBootstrapConfigurationInspection" defaultSeverity="WEAK WARNING" displayName="应用程序上下文中包含 Bootstrap 配置" enabled="false" language="UAST" pluginId="com.intellij.spring.cloud" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告通过组件扫描包含在 Spring Boot 应用程序的上下文中但在该上下文中可能不需要的 &lt;code&gt;BootstrapConfiguration&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;有关详细信息，请参阅 &lt;a href="https://docs.spring.io/spring-cloud-commons/docs/current/reference/html/#customizing-the-bootstrap-configuration"&gt;Spring Cloud Commons 文档&lt;/a&gt;。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="语法说明" path="Scala"><inspection shortName="ConvertNullInitializerToUnderscore" defaultSeverity="WARNING" displayName="Null 初始值设定项可被替换为 _" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告使用 &lt;code&gt;null&lt;/code&gt; 显式初始化的变量定义。&lt;/p&gt;
&lt;p&gt;&lt;code&gt; var v: T = null &lt;/code&gt; 共有三种不同类型：&lt;/p&gt;
&lt;ol&gt;
    &lt;li&gt;&lt;code&gt;v&lt;/code&gt; 是一个 &lt;em&gt;可选&lt;/em&gt;值&lt;br&gt;
        &amp;rarr; 使用 &lt;code&gt;Option[T]&lt;/code&gt; 类型，这是习惯用法并且类型安全&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;v&lt;/code&gt; 是一个 &lt;em&gt;未初始化的&lt;/em&gt;值（必须分配一个值）&lt;br&gt;
        &amp;rarr; 使用清晰、简洁且与平台无关的 &lt;code&gt;_&lt;/code&gt; (Scala 2) 或 &lt;code&gt;scala.compiletime.uninitialized&lt;/code&gt; (Scala 3)
          作为初始化器&lt;/li&gt;
    &lt;li&gt;这是一种性能&lt;em&gt;优化&lt;/em&gt;（您实际上使用的是 &lt;code&gt;null&lt;/code&gt; 值）&lt;br&gt;
         &amp;rarr; 明确禁止对不安全代码的检查&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;将提供两个快速修复：&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;&lt;em&gt;使用 _ 初始值设定项&lt;/em&gt;会将 &lt;code&gt;null&lt;/code&gt; 替换为 &lt;code&gt;_&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;&lt;em&gt;使用 Option 类型&lt;/em&gt;会将变量的类型替换为 &lt;code&gt;Option&lt;/code&gt; 并使用 &lt;code&gt;None&lt;/code&gt; 初始化&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Test {
    var optional: String = null
    var uninit: String = null

    uninit = "initialized later"
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Test {
    var optional: Option[String] = None
    var uninit: String = _

    uninit = "initialized later"
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AutoTupling" defaultSeverity="WARNING" displayName="自动元组化" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告可以转换为元组的逗号分隔实参。&lt;/p&gt;
&lt;p&gt;如果没有合适的多实参方法但有一个合适的单实参方法，Scala 编译器会尝试将逗号分隔的实参转换为元组。 这种转换可能会破坏类型安全并导致意外结果。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  def foo(a: Any) = {}
  foo(1, 2)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  def foo(a: Any) = {}
  foo((1, 2))
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="模块化问题" path="Java"><inspection shortName="ModuleWithTooFewClasses" defaultSeverity="WARNING" displayName="类过少的模块" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
报告包含的类太少的模块。 模块过小可能表明设计过于分散。
Java、Kotlin 和 Groovy 类均计算在内。
&lt;!-- tooltip end --&gt;
&lt;p&gt;仅适用于&lt;b&gt;代码 | 检查代码&lt;/b&gt;或&lt;b&gt;代码 | 分析代码 | 通过名称运行检查&lt;/b&gt;，并且不会在编辑器中报告。&lt;/p&gt;
&lt;p&gt;使用&lt;b&gt;最小类数&lt;/b&gt;字段可指定模块可能拥有的最小类数。&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ClassIndependentOfModule" defaultSeverity="WARNING" displayName="独立于其模块的类" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
报告符合以下情况的类：
&lt;ul&gt;
  &lt;li&gt;不依赖于其模块中的任何其他类&lt;/li&gt;
  &lt;li&gt;不是其模块中任何其他类的依赖项&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这种类表示临时或不连贯的模块化策略，并且通常可以有利地移动。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;仅适用于&lt;b&gt;代码 | 检查代码&lt;/b&gt;或&lt;b&gt;代码 | 分析代码 | 通过名称运行检查&lt;/b&gt;，并且不会在编辑器中报告。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="InconsistentLanguageLevel" defaultSeverity="WARNING" displayName="语言级别设置不一致" enabled="false" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
报告依赖于具有更高语言级别的其他模块的模块。 
&lt;p&gt;应该移除此类依赖项或提高模块的语言级别。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;仅适用于&lt;b&gt;代码 | 检查代码&lt;/b&gt;或&lt;b&gt;代码 | 分析代码 | 通过名称运行检查&lt;/b&gt;，并且不会在编辑器中报告。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ModuleWithTooManyClasses" defaultSeverity="WARNING" displayName="类过多的模块" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
报告包含的类太多的模块。 模块过大可能表明缺乏设计清晰度。
Java、Kotlin 和 Groovy 类均计算在内。
&lt;!-- tooltip end --&gt;
&lt;p&gt;仅适用于&lt;b&gt;代码 | 检查代码&lt;/b&gt;或&lt;b&gt;代码 | 分析代码 | 通过名称运行检查&lt;/b&gt;，并且不会在编辑器中报告。&lt;/p&gt;
&lt;p&gt;使用&lt;b&gt;最大类数&lt;/b&gt;字段可指定模块可以拥有的最大类数。&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ClassOnlyUsedInOneModule" defaultSeverity="WARNING" displayName="仅在其他模块中使用的类" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
报告符合以下情况的类：
&lt;ul&gt;
  &lt;li&gt;不依赖于其模块中的任何其他类&lt;/li&gt;
  &lt;li&gt;依赖于来自不同模块的类&lt;/li&gt;
  &lt;li&gt;仅是来自该其他模块的类的依赖项&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这种类可以移动到它们所依赖的模块中。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;仅适用于&lt;b&gt;代码 | 检查代码&lt;/b&gt;或&lt;b&gt;代码 | 分析代码 | 通过名称运行检查&lt;/b&gt;，并且不会在编辑器中报告。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="代码成熟度" path="Java"><inspection shortName="CommentedOutCode" defaultSeverity="WEAK WARNING" displayName="注释掉的代码" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告包含 Java 代码的注释。
&lt;p&gt;通常，被注释掉的代码很快就会过时并且会引起误解。
由于大多数项目使用某种版本控制系统，因此最好完全删除注释掉的代码并改用 VCS 历史记录。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2020.3 最新变化&lt;/small&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ThrowablePrintStackTrace" defaultSeverity="WARNING" displayName="调用 'printStackTrace()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对无实参的 &lt;code&gt;Throwable.printStackTrace()&lt;/code&gt; 的调用。
&lt;p&gt;此类语句通常用于临时调试，应当从生产代码中移除，或者替换为更稳健的日志记录工具。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ThreadDumpStack" defaultSeverity="WARNING" displayName="调用 'Thread.dumpStack()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;Thread.dumpStack()&lt;/code&gt; 的用法。
&lt;p&gt;此类语句通常用于临时调试，应当从生产代码中移除，或者替换为更稳健的日志记录工具。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="OptionalAssignedToNull" defaultSeverity="WARNING" displayName="Optional 类型的 null 值" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;null&lt;/code&gt; 分配给 &lt;code&gt;Optional&lt;/code&gt; 变量或从返回 &lt;code&gt;Optional&lt;/code&gt; 的方法返回。
&lt;p&gt;建议您使用 &lt;code&gt;Optional.empty()&lt;/code&gt;（或 &lt;code&gt;Optional.absent()&lt;/code&gt; 用于 Guava）来表示空值。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Optional&amp;lt;Integer&amp;gt; foo(boolean flag) {
    return flag ? Optional.of(42) : null;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Optional&amp;lt;Integer&amp;gt; foo(boolean flag) {
    return flag ? Optional.of(42) : Optional.empty();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;配置检查：&lt;/p&gt;
&lt;p&gt;
  使用 &lt;b&gt;报告 Optional 与 null 的比较&lt;/b&gt; 选项还可以报告&lt;code&gt;optional == null&lt;/code&gt; 之类的比较。 虽然在极少数情况下（例如延迟初始化的可选字段）这可能是正确的，但可选变量通常不会为 null，并且可能应为  &lt;code&gt;optional.isPresent()&lt;/code&gt;。
&lt;/p&gt;
&lt;p&gt;仅当项目或模块的语言级别为 8 或更高时，此检查才会报告。&lt;/p&gt;
&lt;p&gt;&lt;small&gt;2017.2 最新变化&lt;/small&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SystemOutErr" defaultSeverity="WARNING" displayName="使用 'System.out' 或 'System.err'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;System.out&lt;/code&gt; 或 &lt;code&gt;System.err&lt;/code&gt; 的用法。
&lt;p&gt;此类语句通常用于临时调试，应当从生产代码中移除，或者替换为更稳健的日志记录工具。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="Deprecation" defaultSeverity="WARNING" displayName="弃用的 API 用法" enabled="false" language="UAST" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告已弃用的 API（类、字段和方法）的用法，例如：&lt;code&gt;new Thread().stop();&lt;/code&gt;。
&lt;p&gt;默认情况下，如果不可能或很难避免，则检查不会发出警告。  比如下面的代码就不会被报告：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  abstract class A { //库代码
     @Deprecated
     abstract void m();
  }
  class B extends A { //项目代码
     @Override
     void m() {
        //doSmth;
     }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;配置检查：&lt;/p&gt;
&lt;p&gt;
  您可以使用检查选项在弃用的成员、覆盖弃用的 abstract 方法、非 static 导入语句、弃用的类的方法或相同的顶级类中禁用此检查。
&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MarkedForRemoval" defaultSeverity="ERROR" displayName="使用API标记为删除" enabled="false" language="UAST" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告已用 &lt;code&gt;@Deprecated(&lt;b&gt;forRemoval&lt;/b&gt;=true)&lt;/code&gt; 标记为移除的已弃用的 API（类、字段和方法）的用法。
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用标记为移除的 API 的代码可能会导致未来版本的 API 出现运行时错误。 这就是为什么此检查的推荐严重性为 &lt;i&gt;Error&lt;/i&gt;。&lt;/p&gt;
&lt;p&gt;
  如果您想使用与普通弃用相同的代码高亮显示，您可以将严重性更改为 &lt;i&gt;警告&lt;/i&gt;。&lt;/p&gt;
&lt;p&gt;&lt;small&gt;2017.3 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SuppressionAnnotation" defaultSeverity="WARNING" displayName="检查禁止注解" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告禁止检查的注释或注解。
&lt;p&gt;当有意保留禁止以供进一步检查时，此检查可能有用。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    @SuppressWarnings("unused")
    static Stream&amp;lt;String&amp;gt; stringProvider() {
        return Stream.of("foo", "bar");
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantScheduledForRemovalAnnotation" defaultSeverity="WARNING" displayName="冗余的 @ScheduledForRemoval 注解" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告无 &lt;code&gt;inVersion&lt;/code&gt; 特性的 &lt;code&gt;@ApiStatus.ScheduledForRemoval&lt;/code&gt; 注解在以 Java 9 或更高版本为目标的代码中的用法。
&lt;p&gt;
此类用法可以用 &lt;code&gt;@Deprecated&lt;/code&gt; 注解中的 &lt;code&gt;forRemoval&lt;/code&gt; 特性代替以简化代码。
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2022.1 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ThrowablePrintedToSystemOut" defaultSeverity="WARNING" displayName="'Throwable' 打印到 'System.out'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告以异常作为实参的 &lt;code&gt;System.out.println()&lt;/code&gt; 调用。
&lt;p&gt;使用 print 语句记录异常会隐藏堆栈跟踪，这可能会使问题的调查变得复杂。
  建议您改用记录器。&lt;/p&gt;
&lt;p&gt;也会报告以异常作为实参的 &lt;code&gt;System.out.print()&lt;/code&gt;、&lt;code&gt;System.err.println()&lt;/code&gt; 和 &lt;code&gt;System.err.print()&lt;/code&gt; 调用。 建议使用记录器来记录异常。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;例如，不建议使用：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  try {
      foo();
  } catch (Exception e) {
      System.out.println(e);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用以下代码代替：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  try {
      foo();
  } catch (Exception e) {
      logger.warn(e); // 记录器调用可能有所不同
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ObsoleteCollection" defaultSeverity="WARNING" displayName="使用废弃的集合类型" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;java.util.Vector&lt;/code&gt;、&lt;code&gt;java.util.Hashtable&lt;/code&gt; 和 &lt;code&gt;java.util.Stack&lt;/code&gt; 的用法。
&lt;p&gt;这些类的用法通常可以分别替换为 &lt;code&gt;java.util.ArrayList&lt;/code&gt;、&lt;code&gt;java.util.HashMap&lt;/code&gt; 和 &lt;code&gt;java.util.ArrayDeque&lt;/code&gt; 的用法。
虽然仍受支持，但以前的类已被 JDK1.2 集合类废弃，在新开发中或许不宜使用。
&lt;!-- tooltip end --&gt;
&lt;p&gt;
使用&lt;b&gt;在需要的位置忽略废弃的集合类型&lt;/b&gt;选项可以忽略任何将废弃的集合用作方法实参或分配给需要废弃类型的变量的情况。
启用此选项可能会消耗大量处理器资源。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UseOfObsoleteDateTimeApi" defaultSeverity="WARNING" displayName="使用废弃的日期时间 API" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;java.util.Date&lt;/code&gt;、&lt;code&gt;java.util.Calendar&lt;/code&gt;、&lt;code&gt;java.util.GregorianCalendar&lt;/code&gt;、&lt;code&gt;java.util.TimeZone&lt;/code&gt;、&lt;code&gt;java.util.SimpleTimeZone&lt;/code&gt; 的用法。
&lt;p&gt;虽然仍受支持，但 JDK8 Date-Time API 中已废弃这些类，或许不宜在新开发中使用。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DeprecatedIsStillUsed" defaultSeverity="WARNING" displayName="弃用的成员仍在使用" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告代码中使用的已弃用的类、方法和字段。
&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
  class MyCode {
  @Deprecated
  void oldMethod() {}// 警告："弃用的成员仍在使用"

  void newMethod() {
    oldMethod(); // 被遗忘的用法
  }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;已弃用的元素中的用法将被忽略。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;注意&lt;/b&gt;：由于性能原因，仅当非 private 成员的名称很少出现在项目中时，才会对其进行检查。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="可见性" path="Java"><inspection shortName="PublicConstructorInNonPublicClass" defaultSeverity="WARNING" displayName="'public' 构造函数位于非 public 类中" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告非 &lt;code&gt;public&lt;/code&gt; 类中的所有 &lt;code&gt;public&lt;/code&gt; 构造函数。
&lt;p&gt;在访问级别较低的类中，通常没有理由创建 &lt;code&gt;public&lt;/code&gt; 构造函数。
  但请注意，此检查会改变某些反射调用的行为。 特别是，&lt;code&gt;Class.getConstructor()&lt;/code&gt; 将无法找到更新的构造函数（应改为使用 &lt;code&gt;Class.getDeclaredConstructor()&lt;/code&gt;）。 如果您的代码或某些已使用的框架的代码通过 &lt;code&gt;getConstructor()&lt;/code&gt; 依赖于构造函数的可访问性，请不要使用该检查。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class House {
    public House() {}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class House {
    House() {}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AmbiguousMethodCall" defaultSeverity="WARNING" displayName="对继承方法的调用类似于对本地方法的调用" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
如果在类周围的代码中存在具有相同签名的方法，则报告从匿名类、内部类或局部类对超类方法的调用。
在这种情况下，看似调用了来自周围代码的方法，而实际上调用的是来自超类的方法。
&lt;p&gt;
  为了阐明代码的意图，建议对方法调用添加显式的 &lt;code&gt; super &lt;/code&gt; 限定符。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Parent {
    void ambiguous(){}
  }

  class Example {
    void ambiguous(){}

    class Inner extends Parent {
      void example(){
        ambiguous(); //警告
      }
    }
  }
  &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Parent {
    void ambiguous(){}
  }

  class Example {
    void ambiguous(){}

    class Inner extends Parent {
      void example(){
        super.ambiguous();
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ClassEscapesItsScope" defaultSeverity="WARNING" displayName="不可访问的类公开" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
当签名中类的可见性不如成员本身的可见性时，报告类在字段或方法签名中的用法。
虽然是合法的 Java，但此类成员在可见性范围之外是无用的。
&lt;p&gt;示例：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;返回 &lt;code&gt;private&lt;/code&gt; 内部 &lt;code&gt;class&lt;/code&gt; 的 &lt;code&gt;public&lt;/code&gt; 方法。&lt;/li&gt;
  &lt;li&gt;类型为 package-local &lt;code&gt;class&lt;/code&gt; 的 &lt;code&gt;protected&lt;/code&gt; 字段。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
在 Java 9 中，模块可能会通过将其软件包排除在导出之外来隐藏某些类。
因此，如果导出的 API 的签名包含非导出类，此类 API 在模块之外就是无用的。
&lt;!-- tooltip end --&gt;
&lt;p&gt;配置检查：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;使用&lt;b&gt;模块的 API 公开未导出的类(Java 9+)&lt;/b&gt; 选项可以报告公开未导出类的模块 API。&lt;br&gt;请注意，项目或模块的语言级别为 9 或更高时，该选项才有效。&lt;/li&gt;
  &lt;li&gt;使用&lt;b&gt;公共 API 公开不可访问的类&lt;/b&gt;选项可以报告公开不可访问类的公共 API。&lt;/li&gt;
  &lt;li&gt;使用 &lt;b&gt;Package-local API 公开 private 类&lt;/b&gt;选项可以以报告公开 &lt;code&gt;private&lt;/code&gt; 类的 package-local API。&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PatternVariableHidesField" defaultSeverity="WARNING" displayName="模式变量隐藏字段" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告与周围类的字段同名的模式变量。
由于此类命名，在有意使用同名字段的情况下，您可能会误用该模式变量。
&lt;p&gt;
  建议通过快速修复重命名该变量。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Pointless {
    Point p = new Point();

    public void test(Object a) {
      if (a instanceof Point p) {
        System.out.print("a is a point (" + p.x + ", " + p.y + ')');
      } else {
        System.out.print("p is a point (" + p.x + ", " + p.y + ')');
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2022.2 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MethodOverridesStaticMethod" defaultSeverity="WARNING" displayName="方法尝试重写超类的 'static' 方法" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告签名与超类的 &lt;code&gt;static&lt;/code&gt; 方法相同的 &lt;code&gt;static&lt;/code&gt; 方法。
此类方法可能看似重写，但实则它对超类隐藏了该方法，因为 Java 中的 &lt;code&gt;static&lt;/code&gt; 方法不能被重写。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Parent {
    static void method(){}
  }

  class Example extends Parent {
    static void method(){} //警告
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AmbiguousFieldAccess" defaultSeverity="WARNING" displayName="对继承字段的访问类似于对周围代码中元素的访问" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
如果在类周围的代码中存在同名的局部变量、形参或字段，则报告从匿名类、内部类或局部类对超类字段的访问。
在这种情况下，看似访问了来自周围代码的元素，而实际上访问的是来自超类的字段。
&lt;p&gt;
  为阐明代码的意图，建议对字段访问添加显式 &lt;code&gt;super&lt;/code&gt; 限定符。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    class First {
      protected String ambiguous;
    }
    class Second {
      void foo(String ambiguous) {
        new First() {
          {
            System.out.println(ambiguous); // 访问的是字段，而不是形参
          }
        };
      }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    class First {
      protected String ambiguous;
    }
    class Second {
      void foo(String ambiguous) {
        new First() {
          {
            System.out.println(super.ambiguous);
          }
        };
      }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FieldHidesSuperclassField" defaultSeverity="WARNING" displayName="子类字段隐藏超类字段" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告派生类中与超类的字段同名的字段。
Java 字段无法在派生类中重写，因此派生类中的字段将对超类隐藏该字段。
&lt;p&gt;
  由于进行此类命名，在基类有意使用同名字段的情况下，您可能会误用派生类的字段。
&lt;/p&gt;
&lt;p&gt;建议通过快速修复重命名派生类中的字段。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Parent {
  Parent parent;
}
class Child extends Parent {
  Child parent;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  您可以为此检查配置以下选项：
&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;strong&gt;忽略不可访问字段&lt;/strong&gt; - 指示此检查应报告所有名称冲突，还是只报告与子类可见的字段的冲突。
  &lt;/li&gt;
  &lt;li&gt;
    &lt;strong&gt;忽略隐藏 static 字段的 static 字段&lt;/strong&gt; - 忽略隐藏基类中的 &lt;code&gt;static&lt;/code&gt; 字段的 &lt;code&gt;static&lt;/code&gt; 字段。
  &lt;/li&gt;
&lt;/ol&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="Java9ModuleExportsPackageToItself" defaultSeverity="WARNING" displayName="模块将软件包导出/打开到本身" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告导出到定义它们的同一 Java 9 模块或在该模块中打开的软件包。
该快速修复会从 &lt;code&gt;module-info.java&lt;/code&gt; 中移除此类指令。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  module com.mycomp {
    exports com.mycomp.main to com.mycomp;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  module main {
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;仅当项目或模块的语言级别为 9 或更高时，此检查才会报告。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ParameterHidingMemberVariable" defaultSeverity="WARNING" displayName="形参隐藏字段" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告与周围类的字段同名的方法形参。
由于进行此类命名，在有意使用同名字段的情况下，您可能会误用该形参。
&lt;p&gt;建议通过快速修复重命名该形参。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Main {
    private String value;

    public Main(String value) {
      value = value.toUpperCase();
    }
  }
  &lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  您可以为此检查配置以下选项：
&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;strong&gt;对属性 setter 忽略&lt;/strong&gt; - 忽略简单 setter 的形参。
  &lt;/li&gt;
  &lt;li&gt;
    &lt;strong&gt;忽略从子类不可见的超类字段&lt;/strong&gt; - 忽略超类中对此方法不可见的 &lt;code&gt;private&lt;/code&gt; 字段。
  &lt;/li&gt;
  &lt;li&gt;
    &lt;strong&gt;对构造函数忽略&lt;/strong&gt; - 忽略构造函数的形参。
  &lt;/li&gt;
  &lt;li&gt;
    &lt;strong&gt;对 abstract 方法忽略&lt;/strong&gt; - 忽略 abstract 方法的形参。
  &lt;/li&gt;
  &lt;li&gt;
    &lt;strong&gt;对隐藏实例字段的 static 方法形参忽略&lt;/strong&gt; - 忽略隐藏实例字段的 &lt;code&gt;static&lt;/code&gt; 方法的形参，并忽略隐藏外部类实例字段的 static 内部类中实例方法的形参。 虽然不是严格意义上的隐藏，但此类形参仍然令人困惑。
  &lt;/li&gt;
&lt;/ol&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="Java9UndeclaredServiceUsage" defaultSeverity="WARNING" displayName="服务的使用未在 'module-info' 中声明" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告使用 &lt;code&gt;java.util.ServiceLoader&lt;/code&gt; 加载服务但未使用 &lt;code&gt;module-info.java&lt;/code&gt; 文件中的 &lt;code&gt;uses&lt;/code&gt; 子句声明的情况，并建议插入它。
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2018.1 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MethodOverridesInaccessibleMethodOfSuper" defaultSeverity="WARNING" displayName="方法重写了超类不可访问的方法" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告与超类的不可访问方法包含相同签名的方法，
例如，另一个软件包中的超类的 private 方法或 package-private 方法。
&lt;p&gt;
  此类方法名称可能令人困惑，因为子类中的方法看似重写，实则隐藏了超类不可访问的方法。
  此外，如果此方法在超类中的可见性日后发生变化，可能会静默地更改子类的语义，否则会导致编译错误。
&lt;/p&gt;
&lt;p&gt;建议通过快速修复重命名该方法。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Super {
    private void test() {
    }
  }

  public class Sub extends Super {
    void test() { // 将 'Super.test()' 设为 public 将导致编译错误
                  // 将 'Super.test()' 设为 package-private 会使 'Sub.test()' 变成重写
    }
  }&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AnonymousClassVariableHidesContainingMethodVariable" defaultSeverity="WARNING" displayName="匿名类变量隐藏包含方法中的变量" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告匿名类中名称与包含方法或 lambda 表达式的局部变量或形参相同的字段。
&lt;p&gt;
  由于进行此类命名，在包含方法中有意使用同名变量或形参的情况下，您可能会误用匿名类字段。
&lt;/p&gt;
&lt;p&gt;建议通过快速修复重命名该字段。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Test {
    public Test(String value) {
      Object foo = new Object() {
        private String value = "TEST";
        public void foo() {
          System.out.println(value); //访问的是字段，而不是形参
        }
      };
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LocalVariableHidingMemberVariable" defaultSeverity="WARNING" displayName="局部变量隐藏字段" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告与周围类的字段同名的局部变量。
由于进行此类命名，在有意使用同名字段的情况下，您可能会误用该变量。
&lt;p&gt;建议通过快速修复重命名该变量。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Foo {
    public Object foo;

    void bar() {
      Object o = new Object() {
        void baz() {
          Object foo; // 局部变量 'foo' 隐藏类 'Foo' 中的字段
        }
      };
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  您可以为此检查配置以下选项：
&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;忽略不可访问字段&lt;/strong&gt; - 忽略与不可见的超类字段同名的局部变量（例如，由于这些字段是 private 字段）。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;忽略隐藏非 static 字段的 static 上下文中的局部变量&lt;/strong&gt; - 
例如，当局部变量位于 static 方法内部或位于 static 内部类中的方法内部时。
  &lt;/li&gt;
&lt;/ol&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="InnerClassVariableHidesOuterClassVariable" defaultSeverity="WARNING" displayName="内部类字段隐藏外部类字段" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告与周围类的字段同名的内部类字段。
由于进行此类命名，在周围类有意使用同名字段的情况下，您可能会误用内部类的字段。
&lt;p&gt;建议通过快速修复重命名该内部类字段。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Outer {
    private String name;

    class Inner {
      private String name;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用此选项可选择此检查应报告所有名称冲突，还是只报告与内部类可见的字段的冲突。
&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TypeParameterHidesVisibleType" defaultSeverity="WARNING" displayName="类型形参隐藏可见类型" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告与当前范围中的可见类型名称相同的类型形参。 此类形参名称可能令人困惑。
&lt;!-- tooltip end --&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  abstract class MyList&amp;lt;T&amp;gt; extends AbstractList&amp;lt;T&amp;gt; {
    private List&amp;lt;T&amp;gt; elements;
    // 类型形参 'T' 隐藏类型形参 'T'
    public &amp;lt;T&amp;gt; T[] toArray(T[] array) {
        return elements.toArray(array);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LambdaParameterHidingMemberVariable" defaultSeverity="WARNING" displayName="lambda 形参隐藏字段" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告与周围类的字段同名的 lambda 形参。
由于进行此类命名，在有意使用同名字段的情况下，您可能会误用 lambda 形参。
&lt;p&gt;建议通过快速修复重命名该 lambda 形参。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class MyClass {
    public Object foo;

    void sort(List&amp;lt;Integer&amp;gt; list) {
      list.sort((foo, bar) -&gt; foo - bar);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用此选项可选择是否忽略对 lambda 表达式不可见的字段。
  例如，超类的 private 字段。
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MethodOverloadsParentMethod" defaultSeverity="WARNING" displayName="可能是超类方法意外重载" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告形参名称和数量与超类中的方法相同，但其中至少一个形参为不同的不兼容类型的实例方法。
&lt;p&gt;
  在本例中，子类中的方法将重载而不是重写超类中的方法。 如果不是有意为之，可能会导致潜在错误。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Foo {
    void foo(int x) {}
  }

  public class Bar extends Foo {
    void foo(Number x) {} // 在重写可能是有意为之的情况下，
                          // 方法 'foo()' 重载超类的兼容方法
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用此选项可选择该检查是否也应报告形参类型不兼容的情况。
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="工作区模型" path="Plugin DevKit"><inspection shortName="WorkspaceImplObsolete" defaultSeverity="WARNING" displayName="过时的实体实现版本" enabled="false" language="kotlin" pluginId="DevKit" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告实体存在的过时实现。
&lt;p&gt;
  验证实体的现有实现是否具有与依赖项中的 &lt;code&gt;com.intellij.workspaceModel.storage.CodeGeneratorVersions&lt;/code&gt; 描述的相同 API 版本。
&lt;/p&gt;
&lt;p&gt;
  建议为当前模块中的所有实体重新生成实现。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="WorkspaceImplAbsent" defaultSeverity="WARNING" displayName="实体实现不存在" enabled="false" language="kotlin" pluginId="DevKit" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告实体缺少实现的情况。
&lt;p&gt;
  验证项目中的每个实体是否都有实现。
&lt;/p&gt;
&lt;p&gt;
  建议为当前模块中的所有实体生成实现。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="可能的错误" path="CSS"><inspection shortName="CssMissingComma" defaultSeverity="WARNING" displayName="选择器列表中缺少逗号" enabled="false" language="CSS" pluginId="com.intellij.css" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告多行选择器。 这很可能表明实际上要使用多个单行选择器，但有一行或几行的末尾缺少逗号。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
input /* comma has probably been forgotten */
.button {
  margin: 1px;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CssNonIntegerLengthInPixels" defaultSeverity="WEAK WARNING" displayName="非整数长度(像素)" enabled="false" language="CSS" pluginId="com.intellij.css" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告以像素为单位的非整数长度。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; width: 3.14px&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CssNoGenericFontName" defaultSeverity="WARNING" displayName="缺少通用字体系列名称" enabled="false" language="CSS" pluginId="com.intellij.css" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
验证 &lt;code&gt;&lt;a href="https://developer.mozilla.org/en-US/docs/Web/CSS/font-family"&gt;font-family&lt;/a&gt;&lt;/code&gt; 属性是否包含通用的字体系列名称作为回退备选项。
&lt;p&gt;
  通用字体系列名称包括：&lt;code&gt;serif&lt;/code&gt;、&lt;code&gt;sans-serif&lt;/code&gt;、&lt;code&gt;cursive&lt;/code&gt;、&lt;code&gt;fantasy&lt;/code&gt; 和 &lt;code&gt;monospace&lt;/code&gt;。
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Lombok" path="Java"><inspection shortName="DeprecatedLombok" defaultSeverity="WARNING" displayName="已弃用的 Lombok 注解" enabled="false" language="JAVA" pluginId="Lombook Plugin" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告已弃用的 Lombok 注解并建议快速修复以将它们替换为提升到主软件包的注解。
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SpringQualifierCopyableLombok" defaultSeverity="WARNING" displayName="@Qualifier 不可通过 lombok 复制" enabled="false" language="JAVA" pluginId="Lombook Plugin" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告类字段上被相应的 Lombok &lt;code&gt;@RequiredArgsConstructor&lt;/code&gt; 和 &lt;code&gt;@AllArgsConstructor&lt;/code&gt; 注解忽略的 Spring &lt;code&gt;@Qualifier&lt;/code&gt; 注解。
如果 &lt;code&gt;lombok.config&lt;/code&gt; 文件中没有 &lt;code&gt;lombok.copyableAnnotations&lt;/code&gt; 定义，生成的构造函数将不会收到 &lt;code&gt;@Qualifier&lt;/code&gt; 注解。
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="Lombok" defaultSeverity="WARNING" displayName="Lombok 注解" enabled="false" language="JAVA" pluginId="Lombook Plugin" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
提供 Lombok 注解的一般检查。
&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="Java 14" path="Java/Java 语言级别迁移帮助"><inspection shortName="EnhancedSwitchMigration" defaultSeverity="WARNING" displayName="语句可被替换为增强的 'switch'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以自动替换为增强型 &lt;code&gt;switch&lt;/code&gt; 语句或表达式的 &lt;code&gt;switch&lt;/code&gt; 语句。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  double getPrice(String fruit) {
    // Switch 语句可以替换为增强型 'switch'
    switch (fruit) {
      case "Apple":
        return 1.0;
      case "Orange":
        return 1.5;
      case "Mango":
        return 2.0;
      default:
        throw new IllegalArgumentException();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  double getPrice(String fruit) {
    return switch (fruit) {
      case "Apple" -&gt; 1.0;
      case "Orange" -&gt; 1.5;
      case "Mango" -&gt; 2.0;
      default -&gt; throw new IllegalArgumentException();
    };
  }
  &lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;仅当项目或模块的语言级别为 14 或更高时，此检查才会报告。&lt;/p&gt;
&lt;p&gt;&lt;small&gt;2019.1 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="EnhancedSwitchBackwardMigration" defaultSeverity="INFORMATION" displayName="增强的 'switch'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告增强型 &lt;code&gt;switch&lt;/code&gt; 语句和表达式。 建议将它们替换为常规的 &lt;code&gt;switch&lt;/code&gt; 语句。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean even = switch (condition) {
    case 1, 3, 5, 7, 9 -&gt; false;
    default -&gt; true;
  };
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean even;
  switch (condition) {
    case 1:
    case 3:
    case 5:
    case 7:
    case 9:
      even = false;
      break;
    default:
      even = true;
      break;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  &lt;i&gt;增强型&lt;/i&gt; &lt;code&gt;switch&lt;/code&gt; 在 Java 14 中出现。
  此检查有助于为向后兼容早期 Java 版本而降级。
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;2019.1 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="RELAX NG" path=""><inspection shortName="UnusedDefine" defaultSeverity="WARNING" displayName="未使用的定义" enabled="false" pluginId="com.intellij" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 RELAX-NG 文件 (XML 或 Compact 语法) 中未使用的命名模式 (&lt;code&gt;define&lt;/code&gt;)。
通过另一个文件中的 include 使用的 &lt;code&gt;define&lt;/code&gt; 元素将被忽略。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnresolvedReference" defaultSeverity="ERROR" displayName="未解析的引用" enabled="false" pluginId="com.intellij" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告使用 XML 语法的 RELAX-NG 文件中对命名模式 (&lt;code&gt;define&lt;/code&gt;) 的未解析引用。
建议创建引用的 &lt;code&gt;define&lt;/code&gt; 元素。
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="设置" path="Spring/Spring Core"><inspection shortName="SpringFacetCodeInspection" defaultSeverity="WARNING" displayName="Spring facet 中不正确的 @Configuration 类设置" enabled="false" language="UAST" pluginId="com.intellij.spring" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告在 Spring facet 中未配置的 &lt;a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Configuration.html"&gt;@Configuration&lt;/a&gt; 类。&lt;/p&gt;

&lt;p&gt;当 &lt;code&gt;@Configuration&lt;/code&gt; 类被扫描（使用&lt;a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/ComponentScan.html"&gt;@ComponentScan&lt;/a&gt; 或 &amp;lt;component-scan .../&amp;gt;）、导入（&lt;a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Import.html"&gt;@Import&lt;/a&gt;）或者在 Spring facet 中定义的应用程序上下文中以任何其他方式使用（例如，在 &lt;code&gt;spring.factories&lt;/code&gt; 文件中配置）时，不会触发检查。&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SpringFacetInspection" defaultSeverity="WARNING" displayName="Spring facet 中不正确的 XML 应用程序上下文设置" enabled="false" language="XML" pluginId="com.intellij.spring" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告未在 Spring facet 中配置且未使用 &lt;a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/ImportResource.html"&gt;@ImportResource&lt;/a&gt;(locations="...")
或 &lt;code&gt;&amp;lt;import .../&amp;gt;&lt;/code&gt; 从 Spring facet 中定义的其他应用程序上下文导入的 XML 应用程序上下文。
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SpringFacetProgrammaticInspection" defaultSeverity="WEAK WARNING" displayName="Spring facet 编程配置" enabled="false" language="JAVA" pluginId="com.intellij.spring" pluginVersion="223.8836.41" isGlobalTool="false">检查 Spring facet 中的编程 Spring 上下文代码设置。</inspection></group><group name="迁移" path="Kotlin"><inspection shortName="AddConversionCallMigration" defaultSeverity="WARNING" displayName="自 1.9 起需要从 `Int` 显式转换" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告将为 &lt;code&gt;Int&lt;/code&gt; 类型，从而在 Kotlin 1.9 及更高版本中导致编译错误的表达式。&lt;/p&gt;

&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun takeByte(x: Byte) {}

  fun foo() {
      takeByte(1 + 1) // 将在 1.9 版中解析为 Int
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun takeByte(x: Byte) {}

  fun foo() {
      takeByte((1 + 1).toByte()) // 将在 1.9 版中解析为 Int
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从 1.7 版开始，可对 Kotlin 语言级别进行检查。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="OverrideDeprecatedMigration" defaultSeverity="ERROR" displayName="自 1.9 起不得通过重写传播方法描述" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告从 1.9 版开始会导致编译错误的由 &lt;code&gt;@Deprecated&lt;/code&gt; 注解传播的声明。
&lt;p&gt;动机类型：&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;
        出于实现设计/架构原因，需要对实现进行更改
    &lt;/li&gt;
    &lt;li&gt;
        设计中的不一致（在不同的上下文中存在不同的处理方式）
    &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;b&gt;更多详细信息&lt;/b&gt;：&lt;a href="https://youtrack.jetbrains.com/issue/KT-47902"&gt;KT-47902：不要通过重写传播方法弃用&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;该快速修复会复制父声明中的 &lt;code&gt;@Deprecated&lt;/code&gt; 注解。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  open class &lt;b&gt;Base&lt;/b&gt; {
      @Deprecated("Don't use")
      open fun foo() {}
  }

  class &lt;b&gt;Derived&lt;/b&gt; : &lt;b&gt;Base&lt;/b&gt;() {
      override fun foo() {}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  open class &lt;b&gt;Base&lt;/b&gt; {
      @Deprecated("Don't use")
      open fun foo() {}
  }

  class &lt;b&gt;Derived&lt;/b&gt; : &lt;b&gt;Base&lt;/b&gt;() {
      @Deprecated("Don't use")
      override fun foo() {}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;仅当项目或模块的 Kotlin 语言级别为 1.6 或更高时，此检查才会报告。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NoConstructorMigration" defaultSeverity="ERROR" displayName="禁止的构造函数调用" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告从 1.9 版开始会导致编译错误的函数父类型上的构造函数调用。
&lt;p&gt;动机类型：&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;
        该实现不遵守已发布的规范或文档
    &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;b&gt;更多详细信息&lt;/b&gt;：&lt;a href="https://youtrack.jetbrains.com/issue/KT-46344"&gt;KT-46344：在父类型列表中的函数接口上调用超类构造函数没有错误&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;该快速修复会移除构造函数调用。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  abstract class A : () -&gt; Int()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  abstract class A : () -&gt; Int
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;仅当项目或模块的 Kotlin 语言级别为 1.7 或更高时，此检查才会报告。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ProhibitTypeParametersForLocalVariablesMigration" defaultSeverity="ERROR" displayName="带类型形参的局部变量" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告带有类型形参的局部变量。&lt;/p&gt;
&lt;p&gt;局部变量的类型形参没有意义，因为它不能被专门化。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun main() {
      val &amp;lt;T&amp;gt; x = ""
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun main() {
      val x = ""
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;仅当项目或模块的 Kotlin 语言级别为 1.4 或更高时，此检查才会报告。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="WarningOnMainUnusedParameterMigration" defaultSeverity="WEAK WARNING" displayName="从 1.4 起，'main' 上不再使用 'args'" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告带有单个未使用形参的 &lt;code&gt;main&lt;/code&gt; 函数。
&lt;p&gt;从 Kotlin 1.4 开始，可以使用不带形参的 &lt;code&gt;main&lt;/code&gt; 函数作为 Kotlin 程序的入口点。
编译器会报告具有未使用形参的 &lt;code&gt;main&lt;/code&gt; 函数的警告。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ObsoleteKotlinJsPackages" defaultSeverity="ERROR" displayName="'kotlin.browser' 和 'kotlin.dom' 软件包自 1.4 起已弃用" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;kotlin.dom&lt;/code&gt; 和 &lt;code&gt;kotlin.browser&lt;/code&gt; 软件包的用法。
&lt;p&gt;在 Kotlin 1.4+ 中，这些软件包分别移至 &lt;code&gt;kotlinx.dom&lt;/code&gt; 和 &lt;code&gt;kotlinx.browser&lt;/code&gt;。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ProhibitJvmOverloadsOnConstructorsOfAnnotationClassesMigration" defaultSeverity="ERROR" displayName="从 1.4 起，'@JvmOverloads' 注解无法用于注解类的构造函数" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告注解类的构造函数的 &lt;code&gt;@JvmOverloads&lt;/code&gt;，因为其毫无意义。&lt;/p&gt;
&lt;p&gt;
    生成的字节码和 Kotlin 元数据中没有 &lt;code&gt;@JvmOverloads&lt;/code&gt; 的占用空间，因此 &lt;code&gt;@JvmOverloads&lt;/code&gt; 不会影响生成的字节码和代码行为。
&lt;/p&gt;
&lt;p&gt;自 Kotlin 1.4 起，注解类构造函数上的 &lt;code&gt;@JvmOverloads&lt;/code&gt; 会导致编译错误。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  annotation class A &lt;b&gt;@JvmOverloads&lt;/b&gt; constructor(val x: Int = 1)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  annotation class A constructor(val x: Int = 1)
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="AmbiguousExpressionInWhenBranchMigration" defaultSeverity="WARNING" displayName="自 1.7 起 'when' 分支中不明确的逻辑表达式" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告会在 Kotlin 1.8 及更高版本中导致编译错误的 &lt;code&gt;when&lt;/code&gt; 分支中的模糊逻辑表达式。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun Int.matches(strict: Boolean): Boolean = when (strict) {
      true -&gt; this == 6
      this in (4..7) -&gt; true // 不明确
      else -&gt; false
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun Int.matches(strict: Boolean): Boolean = when (strict) {
      true -&gt; this == 6
      (this in (4..7)) -&gt; true // 包装在圆括号中
      else -&gt; false
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从 1.7 版开始，可对 Kotlin 语言级别进行检查。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RedundantLabelMigration" defaultSeverity="WEAK WARNING" displayName="冗余标签" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;从 Kotlin 1.4 开始，报告导致编译错误的冗余标签。&lt;/p&gt;
&lt;p&gt;从 Kotlin 1.0 开始，可以用标签标记任何语句：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo() {
    L1@ val x = L2@bar()
  }
&lt;/code&gt;&lt;/pre&gt;
但是，这些标签仅能以有限的几种方式引用：
&lt;ul&gt;
    &lt;li&gt;中断/继续循环&lt;/li&gt;
    &lt;li&gt;从内联 lambda 或内联匿名函数的非本地返回&lt;/li&gt;sssss
&lt;/ul&gt;
&lt;p&gt;从 Kotlin 1.4 开始禁止使用此类标签。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;仅当项目或模块的 Kotlin 语言级别为 1.4 或更高时，此检查才会报告。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RestrictReturnStatementTargetMigration" defaultSeverity="ERROR" displayName="从 1.4 起，目标标签不表示函数" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告未指向函数的标签。
&lt;p&gt;禁止声明不表示函数的目标标签。&lt;/p&gt;
&lt;p&gt;该快速修复会移除标签。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun testValLabelInReturn() {
      L@ val fn = { return@L }
      fn()
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun testValLabelInReturn() {
      L@ val fn = { return }
      fn()
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;仅当项目或模块的语言级别为 1.4 或更高时，此检查才会报告。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NonExhaustiveWhenStatementMigration" defaultSeverity="WARNING" displayName="将从 1.7 开始禁止非穷举的 'when' 语句" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告从 1.7 版开始会导致编译错误的非详尽 &lt;code&gt;when&lt;/code&gt; 语句。
&lt;p&gt;动机类型：&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;
        需要劝阻/阻止的有问题/无意义的用法模式（例如反直觉的行为）
        &lt;ul&gt;
            &lt;li&gt;
                代码容易出错
            &lt;/li&gt;
        &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;
        设计中的不一致（在不同的上下文中存在不同的处理方式）
    &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;影响类型：&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;
        编译。 一些过去可以编译的代码将无法编译
        &lt;ul&gt;
            &lt;li&gt;
                在某些情况下，此类代码可以无异常地工作
                &lt;ul&gt;
                    &lt;li&gt;
                        某些此类代码可以在没有任何警告的情况下编译
                    &lt;/li&gt;
                &lt;/ul&gt;
            &lt;/li&gt;
        &lt;/ul&gt;
    &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;b&gt;更多详细信息&lt;/b&gt;：&lt;a href="https://youtrack.jetbrains.com/issue/KT-47709"&gt;KT-47709：默认情况下使带有枚举、sealed 和布尔主体的 when 语句详尽&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;快速修复会添加缺少的 &lt;code&gt;else -&gt; {}&lt;/code&gt; 分支。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  sealed class &lt;b&gt;Base&lt;/b&gt; {
      class &lt;b&gt;A&lt;/b&gt; : &lt;b&gt;Base&lt;/b&gt;()
      class &lt;b&gt;B&lt;/b&gt; : &lt;b&gt;Base&lt;/b&gt;()
  }

  fun test(base: &lt;b&gt;Base&lt;/b&gt;) {
      when (base) {
          is &lt;b&gt;Base&lt;/b&gt;.&lt;b&gt;A&lt;/b&gt; -&gt; ""
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  sealed class &lt;b&gt;Base&lt;/b&gt; {
      class &lt;b&gt;A&lt;/b&gt; : &lt;b&gt;Base&lt;/b&gt;()
      class &lt;b&gt;B&lt;/b&gt; : &lt;b&gt;Base&lt;/b&gt;()
  }

  fun test(base: &lt;b&gt;Base&lt;/b&gt;) {
      when (base) {
          is &lt;b&gt;Base&lt;/b&gt;.&lt;b&gt;A&lt;/b&gt; -&gt; ""
          else -&gt; {}
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;仅当项目或模块的 Kotlin 语言级别为 1.6 或更高时，此检查才会报告。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="KotlinDeprecation" defaultSeverity="WARNING" displayName="使用了冗余或弃用的语法或弃用的符号" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
在代码清理操作（&lt;b&gt;代码 | 代码清理&lt;/b&gt;）期间报告过时的语言功能和不必要的冗长代码结构。
&lt;p&gt;
该快速修复会自动用紧凑和最新的语法替换过时的语言功能或不必要的冗长代码结构。
&lt;p&gt;
还会将弃用的符号替换为建议的替换项。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ProhibitUseSiteTargetAnnotationsOnSuperTypesMigration" defaultSeverity="ERROR" displayName="超类上的无意义注解目标" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;从 Kotlin 1.4 开始，报告超类的无意义注解目标。&lt;/p&gt;
&lt;p&gt;诸如 &lt;code&gt;@get:&lt;/code&gt; 之类的注解目标在超类中毫无意义并且被禁止。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  interface Foo

  annotation class Ann

  class E : @field:Ann @get:Ann @set:Ann @setparam:Ann Foo
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  interface Foo

  annotation class Ann

  class E : Foo
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;仅当项目或模块的 Kotlin 语言级别为 1.4 或更高时，此检查才会报告。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ProhibitRepeatedUseSiteTargetAnnotationsMigration" defaultSeverity="ERROR" displayName="未被标记为 '@Repeatable' 的重复注解" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告在属性访问器上重复使用非 &lt;code&gt;@Repeatable&lt;/code&gt; 注解的情况。&lt;/p&gt;
&lt;p&gt;
    由于多次使用非 &lt;code&gt;@Repeatable&lt;/code&gt; 注解，这两种注解的使用都会出现在字节码中，从而导致反射调用中的歧义。
&lt;/p&gt;
&lt;p&gt;
    从 Kotlin 1.4 开始，必须将注解标记为 &lt;code&gt;@Repeatable&lt;/code&gt; 或不重复注解，否则会导致编译错误。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  annotation class Foo(val x: Int)

  @get:&lt;b&gt;Foo&lt;/b&gt;(10)
  val a: String
      @&lt;b&gt;Foo&lt;/b&gt;(20) get() = "foo" // 注解重复两次，但未被标记为 @Repeatable
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;仅当项目或模块的 Kotlin 语言级别为 1.4 或更高时，此检查才会报告。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ObsoleteExperimentalCoroutines" defaultSeverity="ERROR" displayName="从 1.3 起，实验性协同程序用法遭到废弃" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告使用实验性协同程序的代码。
&lt;p&gt;此类用法与 Kotlin 1.3+ 不兼容，应更新。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="InlineClassDeprecatedMigration" defaultSeverity="WARNING" displayName="从 1.5 版本开始，内联类已弃用。" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;
    报告在 Kotlin 1.5 和更高版本中已弃用并会导致编译警告的内联类。
    请参阅 &lt;a href="https://kotlinlang.org/docs/whatsnew15.html#inline-classes"&gt;Kotlin 1.5.0 最新变化&lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  inline class Password(val s: String)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @JvmInline
  value class Password(val s: String)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从 1.5 版开始，可对 Kotlin 语言级别进行检查。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FromClosedRangeMigration" defaultSeverity="WEAK WARNING" displayName="从 1.3 起，fromClosedRange() 中存在 MIN_VALUE 步骤" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告带 &lt;code&gt;MIN_VALUE&lt;/code&gt; 步骤的 &lt;code&gt;IntProgression.fromClosedRange()&lt;/code&gt; 和 &lt;code&gt;LongProgression.fromClosedRange()&lt;/code&gt;。
&lt;p&gt;
禁止调用带有 &lt;code&gt;MIN_VALUE&lt;/code&gt; 步骤的 &lt;code&gt;IntProgression.fromClosedRange()&lt;/code&gt; 和 &lt;code&gt;LongProgression.fromClosedRange()&lt;/code&gt;。 在迁移到 Kotlin 1.3+ 期间，应检查所有此类调用。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  IntProgression.fromClosedRange(12, 143, Int.MIN_VALUE)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;要修正此问题，请更改进程的步骤。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="DeclaringClassMigration" defaultSeverity="WARNING" displayName="弃用的 'Enum.declaringClass' 属性" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告从 1.9 版开始会导致编译错误的 Enum 上的 'declaringClass' 属性调用。
&lt;p&gt;'Enum.getDeclaringClass' 是一种 "hidden" Java 函数，通常无法通过解析可见。 然而，它可通过合成属性可见，这是一个前端错误。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;更多详细信息：&lt;/b&gt;&lt;a href="https://youtrack.jetbrains.com/issue/KT-49653"&gt;KT-49653 弃用并移除 Enum.declaringClass 合成属性&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;快速修复会将调用替换为 'declaringJavaClass'。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun &amp;lt;E: Enum&amp;lt;E&amp;gt;&amp;gt; foo(values: Array&amp;lt;E&amp;gt;) {
    EnumSet.noneOf(values.first().declaringClass)
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun &amp;lt;E: Enum&amp;lt;E&amp;gt;&amp;gt; foo(values: Array&amp;lt;E&amp;gt;) {
    EnumSet.noneOf(values.first().declaringJavaClass)
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;仅当项目或模块的 Kotlin 语言级别为 1.7 或更高时，此检查才会报告。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CastDueToProgressionResolutionChangeMigration" defaultSeverity="WARNING" displayName="自 1.9 起的进度分辨率变更" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;
    报告实参需要显式转换才能解析为正确声明的重载函数调用。
    当前的编译器警告（从 Kotlin 1.6.20 开始提供）将成为 Kotlin 1.8 中的错误。
&lt;/p&gt;
&lt;p&gt;
    进度和范围类型 (&lt;code&gt;kotlin.ranges&lt;/code&gt;) 将在 1.9 及更高版本中开始实现 &lt;code&gt;Collection&lt;/code&gt; 接口。 此更新将导致重载函数的解析发生变化。 例如，在下面的示例中，&lt;code&gt;test(1..5)&lt;/code&gt; 调用将在 Kotlin 1.8 及更早版本中被解析为 &lt;code&gt;test(t: Any)&lt;/code&gt;，而在 Kotlin 1.9 及更高版本中被解析为 &lt;code&gt;test(t: Collection&amp;lt;*&amp;gt;)&lt;/code&gt;。
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(t: Any) { }
  fun test(t: Collection&amp;lt;*&amp;gt;) { }
  fun invoke() {
    test(1..5) // 在 1.9 版中 IntRange 会变成 Collection
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;提供的快速修复会捕获 1.8 版及更早版本的编译器特有的行为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(t: Any) { }
  fun test(t: Collection&amp;lt;*&amp;gt;) { }

  fun invoke() {
    test(1..5) // 在 Kotlin 1.9 之前的版本中解析为 'test(t: T)'
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(t: Any) { }
  fun test(t: Collection&amp;lt;*&amp;gt;) { }

  fun invoke() {
    test((1..5) as Iterable&amp;lt;Int&amp;gt;) // 在 Kotlin 1.9 版中解析为 'test(t: T)'
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从 1.6 版开始，可对 Kotlin 语言级别进行检查。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Akka" path="Scala"><inspection shortName="SimplifyFactoryMethod" defaultSeverity="WARNING" displayName="动态调用可被替换为构造函数调用" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告可将动态调用替换为构造函数调用的情况。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;    
&lt;pre&gt;&lt;code&gt;
  import akka.actor._
  
  class Foo(foo: String, bar: Int) extends AbstractActor
  
  object Foo {
    def props(foo: String, bar: Int): Props = Props(classOf[Foo], foo, bar)
  }
  
  Foo.props("foo", 42)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;    
&lt;pre&gt;&lt;code&gt;
  import akka.actor._
  
  class Foo(foo: String, bar: Int) extends AbstractActor
  
  object Foo {
    def props(foo: String, bar: Int): Props = Props(new Foo(foo, bar))
  }
  
  Foo.props("foo", 42)
&lt;/code&gt;&lt;/pre&gt;  
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PropsFactoryMethodExists" defaultSeverity="WARNING" displayName="可被替换为工厂方法调用" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告可将动态构造函数调用安全替换为工厂方法调用的情况。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  import akka.actor._
  
  class Foo extends AbstractActor
  
  object Foo {
    def props(): Props = Props(new Foo())
  }
  
  Props(classOf[Foo])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;    
&lt;pre&gt;&lt;code&gt;
  import akka.actor._
  
  class Foo extends AbstractActor
  
  object Foo {
    def props(): Props = Props(new Foo())
  }
  
  Foo.props()
&lt;/code&gt;&lt;/pre&gt;  
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AppropriateActorConstructorNotFound" defaultSeverity="WARNING" displayName="找不到合适的 Actor 构造函数" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告缺少合适的 actor 构造函数的情况。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;    
&lt;pre&gt;&lt;code&gt;
  import akka.actor._
  
  Props(classOf[ActorImpl])
&lt;/code&gt;&lt;/pre&gt;  
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ActorMutableStateInspection" defaultSeverity="WARNING" displayName="Actor 可变状态" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 actor 具有可变状态的情况。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  import akka.actor._

  class ActorImpl(private var counter: Int = 0) extends AbstractActor {
    override def receive = {
      case _ =&gt; counter += 1
    }
  }    
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;  
&lt;pre&gt;&lt;code&gt;
  import akka.actor._
  
  class ActorImpl(private val counter: Int = 0) extends AbstractActor {
    override def receive = onMessage(counter)
  
    private def onMessage(counter: Int): Receive = {
      case _ =&gt; context.become(onMessage(counter + 1))
    }
  }
&lt;/code&gt;&lt;/pre&gt;  
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="方法指标" path="Groovy"><inspection shortName="GroovyOverlyComplexMethod" defaultSeverity="WARNING" displayName="过于复杂的方法" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告具有过高循环复杂度的方法。
&lt;p&gt;
  循环复杂度基本上是方法中分支点数量的度量。 循环复杂度过高的方法可能令人困惑且难以测试。
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
 使用&lt;b&gt;方法复杂度限制&lt;/b&gt;字段可指定方法的最大可接受循环复杂度。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyMethodParameterCount" defaultSeverity="WARNING" displayName="形参过多的方法" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告形参过多的方法。 方法的形参过多可能表明有必要重构。 此检查会忽略从库类继承签名的方法。
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用&lt;b&gt;最大形参数量:&lt;/b&gt; 字段可指定方法的最大可接受形参数量。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyOverlyLongMethod" defaultSeverity="WARNING" displayName="过长的方法" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告过长的方法。
&lt;p&gt;
  过长的方法可能令人困惑，并且表明可能有必要重构。
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用&lt;b&gt;每个方法的最大语句数&lt;/b&gt;字段可指定方法的最大可接受非注释源代码语句数量。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyOverlyNestedMethod" defaultSeverity="WARNING" displayName="过度嵌套的方法" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告方法体嵌套过深的方法。
&lt;p&gt;
  语句嵌套过深的方法可能令人困惑，并且表明可能有必要重构。
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
 使用&lt;b&gt;最大嵌套深度&lt;/b&gt;字段可指定方法的最大可接受嵌套深度。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyMethodWithMoreThanThreeNegations" defaultSeverity="WARNING" displayName="具有三个以上否定的方法" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告具有三个或更多求反运算（&lt;code&gt;!&lt;/code&gt; 或 &lt;code&gt;!=&lt;/code&gt;）的方法。
此类方法可能造成不必要的困惑。
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyMultipleReturnPointsPerMethod" defaultSeverity="WARNING" displayName="具有多个返回点的方法" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告返回点过多的方法。 返回点过多的方法可能令人困惑且难以重构。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
  int foo(int a) {
    if (a &gt; 0) {
      return a
    }
    if (a &amp;lt; 0) return -a
    return 0
  }
&lt;/code&gt;
&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用下面提供的字段可指定方法的最大可接受返回点数量。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="测试框架" path="Java"><inspection shortName="AssertWithoutMessage" defaultSeverity="WARNING" displayName="断言上缺少消息" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对没有错误消息字符串实参的 &lt;code&gt;assertXXX()&lt;/code&gt; 或 &lt;code&gt;fail()&lt;/code&gt; 的调用。
有关断言失败的错误消息可能有助于澄清测试用例的意图。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  assertTrue(checkValid());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;assertTrue(checkValid(), "|");&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  消息实参根据所使用的断言框架添加到现有实参前面或后面。
&lt;/p&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MaskedAssertion" defaultSeverity="WARNING" displayName="断言通过 'catch' 禁止" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告被周围的 catch 块禁止的 &lt;code&gt;assert&lt;/code&gt; 语句和测试框架断言。
此类断言永远不会失败，因为将捕获并无提示地忽略抛出的 &lt;code&gt;AssertionError&lt;/code&gt;。
&lt;p&gt;&lt;b&gt;示例 1：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void javaAssertion() {
    try {
      ...
      assert 1 == 2;
    } catch (AssertionError e) {
      // 该断言被无提示地忽略
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;b&gt;示例 2：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Test
  void testWithAssertJ() {
    try {
      ...
      assertThat(1).as("test").isEqualTo(2);
    } catch (AssertionError e) {
      // 该断言被无提示地忽略
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;b&gt;示例 3：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Test
  void testWithJunit() {
    try {
      ...
      assertEquals(1, 2);
    } catch (AssertionError e) {
      // 该断言被无提示地忽略
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2020.3 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MisorderedAssertEqualsArguments" defaultSeverity="WARNING" displayName="顺序错误的 'assertEquals()' 实参" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对预期实参和实际实参的顺序错误的 &lt;code&gt;assertEquals()&lt;/code&gt; 的调用。
&lt;p&gt;
  对于 JUnit 3、4 和 5，正确的顺序是&lt;code&gt;(expected, actual)&lt;/code&gt;。
  对于 TestNG，正确的顺序是&lt;code&gt;(actual, expected)&lt;/code&gt;。
&lt;/p&gt;
&lt;p&gt;
  对于通过的断言，此类调用没有问题，但可能会在失败时给出令人困惑的错误报告。
  使用该快速修复可以翻转实参顺序。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例 (JUnit)：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  assertEquals(actual, expected)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  assertEquals(expected, actual)
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConstantAssertArgument" defaultSeverity="WARNING" displayName="常量断言实参" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;assertTrue()&lt;/code&gt;、&lt;code&gt;assertFalse()&lt;/code&gt;、&lt;code&gt;assertNull()&lt;/code&gt; 和 &lt;code&gt;assertNotNull()&lt;/code&gt; 调用中的常量实参。
&lt;p&gt;
  对这些包含常量实参的方法的调用要么总是成功，要么总是失败。
  此类语句很容易在重构后遗留下来，并且可能并非有意为之。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  assertNotNull("foo");
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SimplifiableAssertion" defaultSeverity="WARNING" displayName="可简化断言" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告任何可以替换为更简单的等效调用的 &lt;code&gt;assert&lt;/code&gt; 调用。
&lt;table&gt;
  &lt;tr&gt;&lt;th&gt;示例&lt;/th&gt;&lt;th&gt;&amp;rarr;&lt;/th&gt;&lt;th&gt;替换&lt;/th&gt;&lt;/tr&gt;

  &lt;tr&gt;
    &lt;td&gt;&lt;code&gt;assertEquals(&lt;b&gt;true&lt;/b&gt;, x());&lt;/code&gt;&lt;/td&gt;
    &lt;td&gt;&lt;/td&gt;
    &lt;td&gt;&lt;code&gt;assertTrue(x());&lt;/code&gt;&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;&lt;code&gt;assertTrue(y() != null);&lt;/code&gt;&lt;/td&gt;
    &lt;td&gt;&lt;/td&gt;
    &lt;td&gt;&lt;code&gt;assertNotNull(y());&lt;/code&gt;&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;&lt;code&gt;assertTrue(z == z());&lt;/code&gt;&lt;/td&gt;
    &lt;td&gt;&lt;/td&gt;
    &lt;td&gt;&lt;code&gt;assertSame(z, z());&lt;/code&gt;&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;&lt;code&gt;assertTrue(a.equals(a()));&lt;/code&gt;&lt;/td&gt;
    &lt;td&gt;&lt;/td&gt;
    &lt;td&gt;&lt;code&gt;assertEquals(a, a());&lt;/code&gt;&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;&lt;code&gt;assertTrue(&lt;b&gt;false&lt;/b&gt;);&lt;/code&gt;&lt;/td&gt;
    &lt;td&gt;&lt;/td&gt;
    &lt;td&gt;&lt;code&gt;fail();&lt;/code&gt;&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name=" Android Lint: Correctness" path=""><inspection shortName="AndroidLintScrollViewSize" defaultSeverity="WARNING" displayName="ScrollView size validation" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;ScrollView size validation&lt;br&gt;&lt;br&gt;ScrollView children must set their &lt;code&gt;layout_width&lt;/code&gt; or &lt;code&gt;layout_height&lt;/code&gt; attributes to &lt;code&gt;wrap_content&lt;/code&gt; rather than &lt;code&gt;fill_parent&lt;/code&gt; or &lt;code&gt;match_parent&lt;/code&gt; in the scrolling dimension&lt;br&gt;&lt;br&gt;Issue id: ScrollViewSize&lt;/body&gt;&lt;/html&gt;</inspection></group><group name="简化: filter 和 exists" path="Scala，集合"><inspection shortName="FilterHeadOption" defaultSeverity="WARNING" displayName="将 Filter 和 headOption 转换为 find" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 &lt;code&gt;filter&lt;/code&gt; 和 &lt;code&gt;headOption&lt;/code&gt; 的用法，并将其替换为 &lt;code&gt;find&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  var x: Seq[Int]
  x.filter(p).headOption
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  var x: Seq[Int]
  x.find(p)
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="FilterSize" defaultSeverity="WARNING" displayName="filter 和 size 转换为 count" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 &lt;code&gt;filter&lt;/code&gt; 和 &lt;code&gt;size&lt;/code&gt;（或 &lt;code&gt;length&lt;/code&gt;）的用法，并建议将其替换为 &lt;code&gt;count&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  var x: Seq[Int]
  x.filter(p).size
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  var x: Seq[Int]
  x.count(p)
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FilterEmptyCheck" defaultSeverity="WARNING" displayName="filter 和空性检查转换为 exists/forall" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告已筛选集合上的空性检查。&lt;/p&gt;

&lt;p&gt;该快速修复使用 &lt;code&gt;exists&lt;/code&gt; 或 &lt;code&gt;forall&lt;/code&gt; 检查是否为空。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  var x: Seq[Int]
  x.filter(p).size == 0
  x.filter(p).length &gt; 0
  x.filterNot(p).isEmpty
  x.filterNot(p).nonEmpty
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  var x: Seq[Int]
  !x.exists(p)
  x.exists(p)
  x.forall(p)
  !x.forall(p)
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ExistsEquals" defaultSeverity="WARNING" displayName="exists 可简化为 contains" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告搜索特定元素的 &lt;code&gt;exists&lt;/code&gt; 或 &lt;code&gt;forall&lt;/code&gt; 的用法。&lt;/p&gt;


&lt;p&gt;该快速修复改用 &lt;code&gt;contains&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  set.exists(x =&gt; x == "a")
  set.forall(x =&gt; x != "a")
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  set.contains("a")
  !set.contains("a")
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MapToBooleanContains" defaultSeverity="WARNING" displayName="map 和 contains(true/false) 转换为 exists 或 !forall" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告将集合映射到布尔值并在它上面使用 &lt;code&gt;contains&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;该快速修复改用 &lt;code&gt;.exists()&lt;/code&gt; 或 &lt;code&gt;!.forall()&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  def p(x: Int): Boolean = ???
  var seq: Seq[Int]
  seq.map(p).contains(true)
  seq.map(p).contains(false)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  def p(x: Int): Boolean = ???
  var seq: Seq[Int]
  seq.exists(p)
  !seq.forall(p)
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FilterOtherContains" defaultSeverity="WARNING" displayName="将 filter 和 contains 转换为 intersect 或 diff" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 &lt;code&gt;Set&lt;/code&gt; 上的 &lt;code&gt;filter&lt;/code&gt; 或 &lt;code&gt;filterNot&lt;/code&gt; 并建议改用 &lt;code&gt;intersect&lt;/code&gt; 或 &lt;code&gt;diff&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  val set = Set(1, 2)
  val others = Set(2, 3)
  set.filter(others.contains(_))
  set.filterNot(others.contains)
  set.filter(x =&gt; !others.contains(x))
  set.filterNot(x =&gt; !others.contains(x))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  val set = Set(1, 2)
  val others = Set(2, 3)
  set.intersect(others)
  set.diff(others)
  set.diff(others)
  set.intersect(others)
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FindEmptyCheck" defaultSeverity="WARNING" displayName="find 和空性检查转换为 exists" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 &lt;code&gt;find&lt;/code&gt; 和空性检查，并建议改用 &lt;code&gt;exists&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  var x: Seq[Int]
  x.find(p).isDefined
  x.find(p) != None
  x.find(p).isEmpty
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  var x: Seq[Int]
  x.exists(p)
  x.exists(p)
  !x.exists(p)
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FilterSetContains" defaultSeverity="WARNING" displayName="filter 中的冗余 contains" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 &lt;code&gt;filter&lt;/code&gt; 中的冗余 &lt;code&gt;contains&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Seq(1, 2, 3).filter(Set(1, 3).contains)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Seq(1, 2, 3).filter(Set(1, 3))
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="并发注解问题" path="Java"><inspection shortName="FieldAccessNotGuarded" defaultSeverity="WARNING" displayName="不受保护的字段访问或方法调用" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对声明为 &lt;code&gt;@GuardedBy&lt;/code&gt; 且不受适当同步结构保护的字段的访问。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    @GuardedBy("this")
    void x() {
        notify();
    }
    void y() {
        x(); // 不受保护的方法调用
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;支持的 &lt;code&gt;@GuardedBy&lt;/code&gt; 注解是：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;net.jcip.annotations.GuardedBy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;javax.annotation.concurrent.GuardedBy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;org.apache.http.annotation.GuardedBy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;com.android.annotations.concurrency.GuardedBy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;androidx.annotation.GuardedBy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;com.google.errorprone.annotations.concurrent.GuardedBy&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="InstanceGuardedByStatic" defaultSeverity="WARNING" displayName="由 static 字段保护的实例成员" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告保护符是 &lt;code&gt;static&lt;/code&gt; 字段的实例字段或方法上的 &lt;code&gt;@GuardedBy&lt;/code&gt; 注解。 用 static 来保护非 static 可能会导致过度的锁争用，因为访问任何对象实例中的每个锁定字段均将阻止同时访问每个对象实例中的字段。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    private static ReadWriteLock lock = new ReentrantReadWriteLock(); //static 保护字段
    private Object state;

    @GuardedBy("lock")
    public void bar() {
        state = new Object();
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;支持的 &lt;code&gt;@GuardedBy&lt;/code&gt; 注解是：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;net.jcip.annotations.GuardedBy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;javax.annotation.concurrent.GuardedBy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;org.apache.http.annotation.GuardedBy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;com.android.annotations.concurrency.GuardedBy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;androidx.annotation.GuardedBy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;com.google.errorprone.annotations.concurrent.GuardedBy&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StaticGuardedByInstance" defaultSeverity="WARNING" displayName="由实例字段或 this 防护的 static 成员" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告其中的保护符为非 static 字段或 &lt;code&gt;this&lt;/code&gt; 的 &lt;code&gt;static&lt;/code&gt; 字段或方法上的 &lt;code&gt;@GuardedBy&lt;/code&gt; 注解。
&lt;p&gt;使用非 static 元素保护 static 元素可能会导致过度并发，多个线程可能在不同的对象上下文中锁定，以同时访问保护字段。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    private ReadWriteLock lock = new ReentrantReadWriteLock();

    @GuardedBy("lock")
    public static void bar() {
        // ...
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;支持的 &lt;code&gt;@GuardedBy&lt;/code&gt; 注解是：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;net.jcip.annotations.GuardedBy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;javax.annotation.concurrent.GuardedBy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;org.apache.http.annotation.GuardedBy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;com.android.annotations.concurrency.GuardedBy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;androidx.annotation.GuardedBy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;com.google.errorprone.annotations.concurrent.GuardedBy&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnknownGuard" defaultSeverity="WARNING" displayName="未知 '@GuardedBy' 字段" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告其中指定的保护字段未知的 &lt;code&gt;@GuardedBy&lt;/code&gt; 注解。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    private Object state;

    @GuardedBy("lock") //未知的保护引用
    public void bar() {
        state = new Object();
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;支持的 &lt;code&gt;@GuardedBy&lt;/code&gt; 注解是：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;net.jcip.annotations.GuardedBy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;javax.annotation.concurrent.GuardedBy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;org.apache.http.annotation.GuardedBy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;com.android.annotations.concurrency.GuardedBy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;androidx.annotation.GuardedBy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;com.google.errorprone.annotations.concurrent.GuardedBy&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NonFinalGuard" defaultSeverity="WARNING" displayName="非 final '@GuardedBy' 字段" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告其中的保护字段不是 &lt;code&gt;final&lt;/code&gt; 的 &lt;code&gt;@GuardedBy&lt;/code&gt; 注解。
&lt;p&gt;在非 final 字段上进行保护可能会导致意外的竞争条件，因为该字段的值会被锁定（可能会变化），而不是锁定字段本身。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    private ReadWriteLock lock = new ReentrantReadWriteLock(); //非 final 保护字段
    private Object state;

    @GuardedBy("lock")
    public void bar() {
        state = new Object();
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;支持的 &lt;code&gt;@GuardedBy&lt;/code&gt; 注解是：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;net.jcip.annotations.GuardedBy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;javax.annotation.concurrent.GuardedBy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;org.apache.http.annotation.GuardedBy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;com.android.annotations.concurrency.GuardedBy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;androidx.annotation.GuardedBy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;com.google.errorprone.annotations.concurrent.GuardedBy&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NonFinalFieldInImmutable" defaultSeverity="WARNING" displayName="'@Immutable' 类中有非 final 字段" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告包含 &lt;code&gt;@Immutable&lt;/code&gt; 注解的类中的任何非 final 字段。
这违反了 &lt;code&gt;@Immutable&lt;/code&gt; 注解的约定。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  import javax.annotation.concurrent.Immutable;
  @Immutable
  class Foo {
    String bar = "foo";
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;支持的 &lt;code&gt;@GuardedBy&lt;/code&gt; 注解是：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;net.jcip.annotations.GuardedBy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;javax.annotation.concurrent.GuardedBy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;org.apache.http.annotation.GuardedBy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;com.android.annotations.concurrency.GuardedBy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;androidx.annotation.GuardedBy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;com.google.errorprone.annotations.concurrent.GuardedBy&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Hibernate" path=""><inspection shortName="HibernateMappingDatasourceDomInspection" defaultSeverity="ERROR" displayName="无效的 Hibernate DB 相关的 XML 映射" enabled="false" language="XML" pluginId="com.intellij.hibernate" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 Hibernate XML 配置数据库相关的映射错误，包括：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;对无法识别的目录/架构/表的引用&lt;/li&gt;
  &lt;li&gt;对无法识别的列的引用&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CriteriaApiResolveInspection" defaultSeverity="ERROR" displayName="Hibernate Criteria API 无法识别的属性" enabled="false" language="JAVA" pluginId="com.intellij.hibernate" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 Hibernate Criteria API 用法中无法识别的属性&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="HibernateConfigDomFacetInspection" defaultSeverity="WARNING" displayName="Hibernate 配置 XML 未添加到 facet" enabled="false" language="XML" pluginId="com.intellij.hibernate" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告缺失的 Hibernate XML 配置文件。&lt;/p&gt;
&lt;p&gt;如有必要，该快速修复会创建一个 facet 并向其添加一个配置文件。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="HibernateConfigDomInspection" defaultSeverity="ERROR" displayName="无效的 Hibernate XML 配置" enabled="false" language="XML" pluginId="com.intellij.hibernate" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 Hibernate XML 配置错误，包括：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;对不可实例化类的引用&lt;/li&gt;
  &lt;li&gt;对不扩展所需类的类的引用&lt;/li&gt;
  &lt;li&gt;对范围不适当的类的引用&lt;/li&gt;
  &lt;li&gt;空标记和特性值&lt;/li&gt;
  &lt;li&gt;与所需模式不匹配的标记和特性值（例如，Java 标识符）&lt;/li&gt;
  &lt;li&gt;不包含必需子标记或特性的标记&lt;/li&gt;
  &lt;li&gt;定义具有重复名称的对象的标记&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="HibernateMappingDomInspection" defaultSeverity="ERROR" displayName="无效的 Hibernate XML 映射" enabled="false" language="XML" pluginId="com.intellij.hibernate" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 Hibernate XML 配置映射错误，包括：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;对不可实例化类的引用&lt;/li&gt;
  &lt;li&gt;对不扩展所需类的类的引用&lt;/li&gt;
  &lt;li&gt;对范围不适当的类的引用&lt;/li&gt;
  &lt;li&gt;空标记和特性值&lt;/li&gt;
  &lt;li&gt;与所需模式不匹配的标记和特性值（例如，Java 标识符）&lt;/li&gt;
  &lt;li&gt;不包含必需子标记或特性的标记&lt;/li&gt;
  &lt;li&gt;定义具有重复名称的对象的标记&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Checkstyle" path=""><inspection shortName="CheckStyle" defaultSeverity="WARNING" displayName="Checkstyle real-time scan" enabled="true" language="" pluginId="CheckStyle-IDEA" pluginVersion="5.77.0" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
    This inspection integrates CheckStyle and reports in real-time
    on problems against the current CheckStyle profile.
&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="应用程序服务器" path=""><inspection shortName="JBoss" defaultSeverity="ERROR" displayName="JBoss/WildFly" enabled="false" language="XML" pluginId="JBoss" pluginVersion="223.8836.41" isGlobalTool="false">&lt;!-- Copyright (c) 2004 - 2009 by Fuhrer Engineering AG, CH-2504 Biel/Bienne, Switzerland --&gt;
&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告不正确的 JBoss 特定的 XML 部署描述符：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;jboss-web.xml&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;jboss-app.xml&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;jboss.xml&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一些报告的问题：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;对不可实例化类的引用&lt;/li&gt;
  &lt;li&gt;对不扩展所需类的类的引用&lt;/li&gt;
  &lt;li&gt;空标记和特性值&lt;/li&gt;
  &lt;li&gt;不包含必需子标记或特性的标记&lt;/li&gt;
  &lt;li&gt;定义具有重复名称的对象的标记&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="Glassfish" defaultSeverity="ERROR" displayName="GlassFish" enabled="false" language="XML" pluginId="GlassFish" pluginVersion="223.8836.41" isGlobalTool="false">&lt;!-- Copyright (c) 2004 - 2009 by Fuhrer Engineering AG, CH-2504 Biel/Bienne, Switzerland --&gt;
&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告不正确的 GlassFish 特定的 XML 部署描述符。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://docs.oracle.com/cd/E26576_01/doc.312/e24929/dd-files.htm#GSDPG00078"&gt;glassfish-web.xml&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://docs.oracle.com/cd/E26576_01/doc.312/e24929/dd-files.htm#GSDPG00077"&gt;glassfish-application.xml&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://docs.oracle.com/cd/E26576_01/doc.312/e24929/dd-files.htm#GSDPG00079"&gt;glassfish-ejb-jar.xml&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一些报告的问题：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;对不可实例化类的引用&lt;/li&gt;
  &lt;li&gt;对不扩展所需类的类的引用&lt;/li&gt;
  &lt;li&gt;空标记和特性值&lt;/li&gt;
  &lt;li&gt;不包含必需子标记或特性的标记&lt;/li&gt;
  &lt;li&gt;定义具有重复名称的对象的标记&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="Android Lint: Performance" path=""><inspection shortName="AndroidLintRecycle" defaultSeverity="WARNING" displayName="Missing recycle() calls" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing &lt;code&gt;recycle()&lt;/code&gt; calls&lt;br&gt;&lt;br&gt;Many resources, such as TypedArrays, VelocityTrackers, etc., should be recycled (with a &lt;code&gt;recycle()&lt;/code&gt; call) after use. This lint check looks for missing &lt;code&gt;recycle()&lt;/code&gt; calls.&lt;br&gt;&lt;br&gt;Issue id: Recycle&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintTestAppLink" defaultSeverity="ERROR" displayName="Unmatched URLs" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Unmatched URLs&lt;br&gt;&lt;br&gt;Using one or more &lt;code&gt;tools:validation testUrl="some url"/&gt;&lt;/code&gt; elements in your manifest allows the link attributes in your intent filter to be checked for matches.&lt;br&gt;&lt;br&gt;Issue id: TestAppLink&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintViewHolder" defaultSeverity="WARNING" displayName="View Holder Candidates" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;View Holder Candidates&lt;br&gt;&lt;br&gt;When implementing a view Adapter, you should avoid unconditionally inflating a new layout; if an available item is passed in for reuse, you should try to use that one instead. This helps make for example &lt;code&gt;ListView&lt;/code&gt; scrolling much smoother.&lt;br&gt;&lt;br&gt;Issue id: ViewHolder&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/topics/ui/layout/recyclerview#ViewHolder"&gt;https://developer.android.com/guide/topics/ui/layout/recyclerview#ViewHolder&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUseCompoundDrawables" defaultSeverity="WARNING" displayName="Node can be replaced by a TextView with compound drawables" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Node can be replaced by a &lt;code&gt;TextView&lt;/code&gt; with compound drawables&lt;br&gt;&lt;br&gt;A &lt;code&gt;LinearLayout&lt;/code&gt; which contains an &lt;code&gt;ImageView&lt;/code&gt; and a &lt;code&gt;TextView&lt;/code&gt; can be more efficiently handled as a compound drawable (a single TextView, using the &lt;code&gt;drawableTop&lt;/code&gt;, &lt;code&gt;drawableLeft&lt;/code&gt;, &lt;code&gt;drawableRight&lt;/code&gt; and/or &lt;code&gt;drawableBottom&lt;/code&gt; attributes to draw one or more images adjacent to the text).&lt;br/&gt;
&lt;br/&gt;
If the two widgets are offset from each other with margins, this can be replaced with a &lt;code&gt;drawablePadding&lt;/code&gt; attribute.&lt;br/&gt;
&lt;br/&gt;
There's a lint quickfix to perform this conversion in the Eclipse plugin.&lt;br&gt;&lt;br&gt;Issue id: UseCompoundDrawables&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintObsoleteLayoutParam" defaultSeverity="WARNING" displayName="Obsolete layout params" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Obsolete layout params&lt;br&gt;&lt;br&gt;The given layout_param is not defined for the given layout, meaning it has no effect. This usually happens when you change the parent layout or move view code around without updating the layout params. This will cause useless attribute processing at runtime, and is misleading for others reading the layout so the parameter should be removed.&lt;br&gt;&lt;br&gt;Issue id: ObsoleteLayoutParam&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintExpensiveAssertion" defaultSeverity="WARNING" displayName="Expensive Assertions" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Expensive Assertions&lt;br&gt;&lt;br&gt;In Kotlin, assertions are not handled the same way as from the Java programming language. In particular, they're just implemented as a library call, and inside the library call the error is only thrown if assertions are enabled.&lt;br/&gt;
&lt;br/&gt;
This means that the arguments to the &lt;code&gt;assert&lt;/code&gt; call will &lt;b&gt;always&lt;/b&gt; be evaluated. If you're doing any computation in the expression being asserted, that computation will unconditionally be performed whether or not assertions are turned on. This typically turns into wasted work in release builds.&lt;br/&gt;
&lt;br/&gt;
This check looks for cases where the assertion condition is nontrivial, e.g. it is performing method calls or doing more work than simple comparisons on local variables or fields.&lt;br/&gt;
&lt;br/&gt;
You can work around this by writing your own inline assert method instead:&lt;br/&gt;

&lt;pre&gt;
@Suppress("INVISIBLE_REFERENCE", "INVISIBLE_MEMBER")
inline fun assert(condition: () -&gt; Boolean) {
    if (_Assertions.ENABLED &amp;amp;&amp;amp; !condition()) {
        throw AssertionError()
    }
}
&lt;/pre&gt;
&lt;br/&gt;
In Android, because assertions are not enforced at runtime, instead use this:&lt;br/&gt;

&lt;pre&gt;
inline fun assert(condition: () -&gt; Boolean) {
    if (BuildConfig.DEBUG &amp;amp;&amp;amp; !condition()) {
        throw AssertionError()
    }
}
&lt;/pre&gt;
&lt;br&gt;&lt;br&gt;Issue id: ExpensiveAssertion&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUselessParent" defaultSeverity="WARNING" displayName="Useless parent layout" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Unnecessary parent layout&lt;br&gt;&lt;br&gt;A layout with children that has no siblings, is not a scrollview or a root layout, and does not have a background, can be removed and have its children moved directly into the parent for a flatter and more efficient layout hierarchy.&lt;br&gt;&lt;br&gt;Issue id: UselessParent&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUnusedIds" defaultSeverity="WARNING" displayName="Unused id" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Unused id&lt;br&gt;&lt;br&gt;This resource id definition appears not to be needed since it is not referenced from anywhere. Having id definitions, even if unused, is not necessarily a bad idea since they make working on layouts and menus easier, so there is not a strong reason to delete these.&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
The unused resource check can ignore tests. If you want to include resources that are only referenced from tests, consider packaging them in a test source set instead.&lt;br/&gt;
&lt;br/&gt;
You can include test sources in the unused resource check by setting the system property lint.unused-resources.include-tests =true, and to exclude them (usually for performance reasons), use lint.unused-resources.exclude-tests =true.&lt;br/&gt;
&lt;br&gt;&lt;br&gt;Issue id: UnusedIds&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUseValueOf" defaultSeverity="WARNING" displayName="Should use valueOf instead of new" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Should use &lt;code&gt;valueOf&lt;/code&gt; instead of &lt;code&gt;new&lt;/code&gt;&lt;br&gt;&lt;br&gt;You should not call the constructor for wrapper classes directly, such as`new Integer(42)`. Instead, call the &lt;code&gt;valueOf&lt;/code&gt; factory method, such as &lt;code&gt;Integer.valueOf(42)&lt;/code&gt;. This will typically use less memory because common integers such as 0 and 1 will share a single instance.&lt;br&gt;&lt;br&gt;Issue id: UseValueOf&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintHandlerLeak" defaultSeverity="WARNING" displayName="Handler reference leaks" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Handler reference leaks&lt;br&gt;&lt;br&gt;Since this Handler is declared as an inner class, it may prevent the outer class from being garbage collected. If the Handler is using a &lt;code&gt;Looper&lt;/code&gt; or &lt;code&gt;MessageQueue&lt;/code&gt; for a thread other than the main thread, then there is no issue. If the &lt;code&gt;Handler&lt;/code&gt; is using the &lt;code&gt;Looper&lt;/code&gt; or &lt;code&gt;MessageQueue&lt;/code&gt; of the main thread, you need to fix your &lt;code&gt;Handler&lt;/code&gt; declaration, as follows: Declare the &lt;code&gt;Handler&lt;/code&gt; as a static class; In the outer class, instantiate a &lt;code&gt;WeakReference&lt;/code&gt; to the outer class and pass this object to your &lt;code&gt;Handler&lt;/code&gt; when you instantiate the &lt;code&gt;Handler&lt;/code&gt;; Make all references to members of the outer class using the &lt;code&gt;WeakReference&lt;/code&gt; object.&lt;br&gt;&lt;br&gt;Issue id: HandlerLeak&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintAnimatorKeep" defaultSeverity="WARNING" displayName="Missing @Keep for Animated Properties" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing @Keep for Animated Properties&lt;br&gt;&lt;br&gt;When you use property animators, properties can be accessed via reflection. Those methods should be annotated with @Keep to ensure that during release builds, the methods are not potentially treated as unused and removed, or treated as internal only and get renamed to something shorter.&lt;br/&gt;
&lt;br/&gt;
This check will also flag other potential reflection problems it encounters, such as a missing property, wrong argument types, etc.&lt;br&gt;&lt;br&gt;Issue id: AnimatorKeep&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintNestedWeights" defaultSeverity="WARNING" displayName="Nested layout weights" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Nested layout weights&lt;br&gt;&lt;br&gt;Layout weights require a widget to be measured twice. When a &lt;code&gt;LinearLayout&lt;/code&gt; with non-zero weights is nested inside another &lt;code&gt;LinearLayout&lt;/code&gt; with non-zero weights, then the number of measurements increase exponentially.&lt;br&gt;&lt;br&gt;Issue id: NestedWeights&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUseOfBundledGooglePlayServices" defaultSeverity="WARNING" displayName="Use of bundled version of Google Play services" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Use of bundled version of Google Play services&lt;br&gt;&lt;br&gt;Google Play services SDK's can be selectively included, which enables a smaller APK size. Consider declaring dependencies on individual Google Play services SDK's. If you are using Firebase API's (&lt;a href="https://firebase.google.com/docs/android/setup"&gt;https://firebase.google.com/docs/android/setup&lt;/a&gt;), Android Studio's Tools &amp;#8594; Firebase assistant window can automatically add just the dependencies needed for each feature.&lt;br&gt;&lt;br&gt;Issue id: UseOfBundledGooglePlayServices&lt;br&gt;&lt;br&gt;&lt;a href="https://developers.google.com/android/guides/setup#split"&gt;https://developers.google.com/android/guides/setup#split&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintNotifyDataSetChanged" defaultSeverity="WARNING" displayName="Invalidating All RecyclerView Data" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Invalidating All RecyclerView Data&lt;br&gt;&lt;br&gt;The &lt;code&gt;RecyclerView&lt;/code&gt; adapter's &lt;code&gt;onNotifyDataSetChanged&lt;/code&gt; method does not specify what about the data set has changed, forcing any observers to assume that all existing items and structure may no longer be valid. `LayoutManager`s will be forced to fully rebind and relayout all visible views.&lt;br&gt;&lt;br&gt;Issue id: NotifyDataSetChanged&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMergeRootFrame" defaultSeverity="WARNING" displayName="FrameLayout can be replaced with &lt;merge&gt; tag" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;FrameLayout can be replaced with &lt;code&gt;&amp;lt;merge&gt;&lt;/code&gt; tag&lt;br&gt;&lt;br&gt;If a &lt;code&gt;&amp;lt;FrameLayout&gt;&lt;/code&gt; is the root of a layout and does not provide background or padding etc, it can often be replaced with a &lt;code&gt;&amp;lt;merge&gt;&lt;/code&gt; tag which is slightly more efficient. Note that this depends on context, so make sure you understand how the &lt;code&gt;&amp;lt;merge&gt;&lt;/code&gt; tag works before proceeding.&lt;br&gt;&lt;br&gt;Issue id: MergeRootFrame&lt;br&gt;&lt;br&gt;&lt;a href="https://android-developers.googleblog.com/2009/03/android-layout-tricks-3-optimize-by.html"&gt;https://android-developers.googleblog.com/2009/03/android-layout-tricks-3-optimize-by.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintTooDeepLayout" defaultSeverity="WARNING" displayName="Layout hierarchy is too deep" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Layout hierarchy is too deep&lt;br&gt;&lt;br&gt;Layouts with too much nesting is bad for performance. Consider using a flatter layout (such as &lt;code&gt;RelativeLayout&lt;/code&gt; or &lt;code&gt;GridLayout&lt;/code&gt;).The default maximum depth is 10 but can be configured with the environment variable &lt;code&gt;ANDROID_LINT_MAX_DEPTH&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: TooDeepLayout&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintAnnotationProcessorOnCompilePath" defaultSeverity="WARNING" displayName="Annotation Processor on Compile Classpath" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Annotation Processor on Compile Classpath&lt;br&gt;&lt;br&gt;This dependency is identified as an annotation processor. Consider adding it to the processor path using &lt;code&gt;annotationProcessor&lt;/code&gt; instead of including it to the compile path.&lt;br&gt;&lt;br&gt;Issue id: AnnotationProcessorOnCompilePath&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintAssertionSideEffect" defaultSeverity="WARNING" displayName="Assertions with Side Effects" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Assertions with Side Effects&lt;br&gt;&lt;br&gt;Assertion conditions can have side effects. This is risky because the behavior depends on whether assertions are on or off. This is usually not intentional, and can lead to bugs where the production version differs from the version tested during development.&lt;br/&gt;
&lt;br/&gt;
Generally, you'll want to perform the operation with the side effect before the assertion, and then assert that the result was what you expected.&lt;br&gt;&lt;br&gt;Issue id: AssertionSideEffect&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintNotificationTrampoline" defaultSeverity="ERROR" displayName="Notification Trampolines" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Notification Trampolines&lt;br&gt;&lt;br&gt;Activities should not be launched indirectly from a notification via an intermediate &lt;code&gt;BroadcastReceiver&lt;/code&gt; or &lt;code&gt;Service&lt;/code&gt;. This can lead to significant lags in some scenarios, and is forbidden if &lt;code&gt;targetSdkVersion&lt;/code&gt; is set to the API level for Android 12 or higher.&lt;br/&gt;
&lt;br/&gt;
To fix this, launch the &lt;code&gt;Activity&lt;/code&gt; directly from the notification.&lt;br&gt;&lt;br&gt;Issue id: NotificationTrampoline&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintLaunchActivityFromNotification" defaultSeverity="WARNING" displayName="Notification Launches Services or BroadcastReceivers" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Notification Launches Services or BroadcastReceivers&lt;br&gt;&lt;br&gt;Notifications should only launch activities -- that's what users expect (and has been the guidance in both the Android SDK and Material Design documentation for a while).&lt;br/&gt;
&lt;br/&gt;
A &lt;code&gt;Service&lt;/code&gt; or a &lt;code&gt;BroadcastReceiver&lt;/code&gt; should not be used as an intermediate, because this can lead to significant performance problems, and as a result, this will not be allowed in Android 12.&lt;br&gt;&lt;br&gt;Issue id: LaunchActivityFromNotification&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/topics/ui/notifiers/notifications?hl=en#Actions"&gt;https://developer.android.com/guide/topics/ui/notifiers/notifications?hl=en#Actions&lt;/a&gt;&lt;br&gt;&lt;a href="https://material.io/design/platform-guidance/android-notifications.html#behavior"&gt;https://material.io/design/platform-guidance/android-notifications.html#behavior&lt;/a&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/topics/ui/notifiers/notifications?hl=en"&gt;https://developer.android.com/guide/topics/ui/notifiers/notifications?hl=en&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUsableSpace" defaultSeverity="WARNING" displayName="Using getUsableSpace()" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using getUsableSpace()&lt;br&gt;&lt;br&gt;When you need to allocate disk space for large files, consider using the new &lt;code&gt;allocateBytes(FileDescriptor, long)&lt;/code&gt; API, which will automatically clear cached files belonging to other apps (as needed) to meet your request.&lt;br/&gt;
&lt;br/&gt;
When deciding if the device has enough disk space to hold your new data, call &lt;code&gt;getAllocatableBytes(UUID)&lt;/code&gt; instead of using &lt;code&gt;getUsableSpace()&lt;/code&gt;, since the former will consider any cached data that the system is willing to clear on your behalf.&lt;br/&gt;
&lt;br/&gt;
Note that these methods require API level 26. If your app is running on older devices, you will probably need to use both APIs, conditionally switching on &lt;code&gt;Build.VERSION.SDK_INT&lt;/code&gt;. Lint only looks in the same compilation unit to see if you are already using both APIs, so if it warns even though you are already using the new API, consider moving the calls to the same file or suppressing the warning.&lt;br&gt;&lt;br&gt;Issue id: UsableSpace&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintDrawAllocation" defaultSeverity="WARNING" displayName="Memory allocations within drawing code" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Memory allocations within drawing code&lt;br&gt;&lt;br&gt;You should avoid allocating objects during a drawing or layout operation. These are called frequently, so a smooth UI can be interrupted by garbage collection pauses caused by the object allocations.&lt;br/&gt;
&lt;br/&gt;
The way this is generally handled is to allocate the needed objects up front and to reuse them for each drawing operation.&lt;br/&gt;
&lt;br/&gt;
Some methods allocate memory on your behalf (such as &lt;code&gt;Bitmap.create&lt;/code&gt;), and these should be handled in the same way.&lt;br&gt;&lt;br&gt;Issue id: DrawAllocation&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintSyntheticAccessor" defaultSeverity="WARNING" displayName="Synthetic Accessor" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Synthetic Accessor&lt;br&gt;&lt;br&gt;A private inner class which is accessed from the outer class will force the compiler to insert a synthetic accessor; this means that you are causing extra overhead. This is not important in small projects, but is important for large apps running up against the 64K method handle limit, and especially for &lt;b&gt;libraries&lt;/b&gt; where you want to make sure your library is as small as possible for the cases where your library is used in an app running up against the 64K limit.&lt;br&gt;&lt;br&gt;Issue id: SyntheticAccessor&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUselessLeaf" defaultSeverity="WARNING" displayName="Useless leaf layout" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Unnecessary leaf layout&lt;br&gt;&lt;br&gt;A layout that has no children or no background can often be removed (since it is invisible) for a flatter and more efficient layout hierarchy.&lt;br&gt;&lt;br&gt;Issue id: UselessLeaf&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUnusedResources" defaultSeverity="WARNING" displayName="Unused resources" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Unused resources&lt;br&gt;&lt;br&gt;Unused resources make applications larger and slow down builds.&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
The unused resource check can ignore tests. If you want to include resources that are only referenced from tests, consider packaging them in a test source set instead.&lt;br/&gt;
&lt;br/&gt;
You can include test sources in the unused resource check by setting the system property lint.unused-resources.include-tests =true, and to exclude them (usually for performance reasons), use lint.unused-resources.exclude-tests =true.&lt;br/&gt;
,&lt;br&gt;&lt;br&gt;Issue id: UnusedResources&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintStaticFieldLeak" defaultSeverity="WARNING" displayName="Static Field Leaks" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Static Field Leaks&lt;br&gt;&lt;br&gt;A static field will leak contexts.&lt;br/&gt;
&lt;br/&gt;
Non-static inner classes have an implicit reference to their outer class. If that outer class is for example a &lt;code&gt;Fragment&lt;/code&gt; or &lt;code&gt;Activity&lt;/code&gt;, then this reference means that the long-running handler/loader/task will hold a reference to the activity which prevents it from getting garbage collected.&lt;br/&gt;
&lt;br/&gt;
Similarly, direct field references to activities and fragments from these longer running instances can cause leaks.&lt;br/&gt;
&lt;br/&gt;
ViewModel classes should never point to Views or non-application Contexts.&lt;br&gt;&lt;br&gt;Issue id: StaticFieldLeak&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUseSparseArrays" defaultSeverity="WARNING" displayName="HashMap can be replaced with SparseArray" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;HashMap can be replaced with SparseArray&lt;br&gt;&lt;br&gt;For maps where the keys are of type integer, it's typically more efficient to use the Android &lt;code&gt;SparseArray&lt;/code&gt; API. This check identifies scenarios where you might want to consider using &lt;code&gt;SparseArray&lt;/code&gt; instead of &lt;code&gt;HashMap&lt;/code&gt; for better performance.&lt;br/&gt;
&lt;br/&gt;
This is &lt;b&gt;particularly&lt;/b&gt; useful when the value types are primitives like ints, where you can use &lt;code&gt;SparseIntArray&lt;/code&gt; and avoid auto-boxing the values from &lt;code&gt;int&lt;/code&gt; to &lt;code&gt;Integer&lt;/code&gt;.&lt;br/&gt;
&lt;br/&gt;
If you need to construct a &lt;code&gt;HashMap&lt;/code&gt; because you need to call an API outside of your control which requires a &lt;code&gt;Map&lt;/code&gt;, you can suppress this warning using for example the &lt;code&gt;@SuppressLint&lt;/code&gt; annotation.&lt;br&gt;&lt;br&gt;Issue id: UseSparseArrays&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintLogConditional" defaultSeverity="WARNING" displayName="Unconditional Logging Calls" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Unconditional Logging Calls&lt;br&gt;&lt;br&gt;The &lt;code&gt;BuildConfig&lt;/code&gt; class provides a constant, &lt;code&gt;DEBUG&lt;/code&gt;, which indicates whether the code is being built in release mode or in debug mode. In release mode, you typically want to strip out all the logging calls. Since the compiler will automatically remove all code which is inside a &lt;code&gt;if (false)&lt;/code&gt; check, surrounding your logging calls with a check for &lt;code&gt;BuildConfig.DEBUG&lt;/code&gt; is a good idea.&lt;br/&gt;
&lt;br/&gt;
If you &lt;b&gt;really&lt;/b&gt; intend for the logging to be present in release mode, you can suppress this warning with a &lt;code&gt;@SuppressLint&lt;/code&gt; annotation for the intentional logging calls.&lt;br&gt;&lt;br&gt;Issue id: LogConditional&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintInefficientWeight" defaultSeverity="WARNING" displayName="Inefficient layout weight" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Inefficient layout weight&lt;br&gt;&lt;br&gt;When only a single widget in a &lt;code&gt;LinearLayout&lt;/code&gt; defines a weight, it is more efficient to assign a width/height of &lt;code&gt;0dp&lt;/code&gt; to it since it will absorb all the remaining space anyway. With a declared width/height of &lt;code&gt;0dp&lt;/code&gt; it does not have to measure its own size first.&lt;br&gt;&lt;br&gt;Issue id: InefficientWeight&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintObsoleteSdkInt" defaultSeverity="WARNING" displayName="Obsolete SDK_INT Version Check" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Obsolete SDK_INT Version Check&lt;br&gt;&lt;br&gt;This check flags version checks that are not necessary, because the &lt;code&gt;minSdkVersion&lt;/code&gt; (or surrounding known API level) is already at least as high as the version checked for.&lt;br/&gt;
&lt;br/&gt;
Similarly, it also looks for resources in &lt;code&gt;-vNN&lt;/code&gt; folders, such as &lt;code&gt;values-v14&lt;/code&gt; where the version qualifier is less than or equal to the &lt;code&gt;minSdkVersion&lt;/code&gt;, where the contents should be merged into the best folder.&lt;br&gt;&lt;br&gt;Issue id: ObsoleteSdkInt&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintDisableBaselineAlignment" defaultSeverity="WARNING" displayName="Missing baselineAligned attribute" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing &lt;code&gt;baselineAligned&lt;/code&gt; attribute&lt;br&gt;&lt;br&gt;When a &lt;code&gt;LinearLayout&lt;/code&gt; is used to distribute the space proportionally between nested layouts, the baseline alignment property should be turned off to make the layout computation faster.&lt;br&gt;&lt;br&gt;Issue id: DisableBaselineAlignment&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintVectorPath" defaultSeverity="WARNING" displayName="Long vector paths" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Long vector paths&lt;br&gt;&lt;br&gt;Using long vector paths is bad for performance. There are several ways to make the &lt;code&gt;pathData&lt;/code&gt; shorter:&lt;br/&gt;
* Using less precision&lt;br/&gt;
* Removing some minor details&lt;br/&gt;
* Using the Android Studio vector conversion tool&lt;br/&gt;
* Rasterizing the image (converting to PNG)&lt;br&gt;&lt;br&gt;Issue id: VectorPath&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintDuplicateDivider" defaultSeverity="WARNING" displayName="Unnecessary Divider Copy" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Unnecessary Divider Copy&lt;br&gt;&lt;br&gt;Older versions of the RecyclerView library did not include a divider decorator, but one was provided as a sample in the support demos. This divider class has been widely copy/pasted into various projects.&lt;br/&gt;
&lt;br/&gt;
In recent versions of the support library, the divider decorator is now included, so you can replace custom copies with the "built-in" version, &lt;code&gt;android.support.v7.widget.DividerItemDecoration&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: DuplicateDivider&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintRedundantNamespace" defaultSeverity="WARNING" displayName="Redundant namespace" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Redundant namespace&lt;br&gt;&lt;br&gt;In Android XML documents, only specify the namespace on the root/document element. Namespace declarations elsewhere in the document are typically accidental leftovers from copy/pasting XML from other files or documentation.&lt;br&gt;&lt;br&gt;Issue id: RedundantNamespace&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintDevModeObsolete" defaultSeverity="WARNING" displayName="Dev Mode Obsolete" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Dev Mode Obsolete&lt;br&gt;&lt;br&gt;In the past, our documentation recommended creating a &lt;code&gt;dev&lt;/code&gt; product flavor with has a minSdkVersion of 21, in order to enable multidexing to speed up builds significantly during development.&lt;br/&gt;
&lt;br/&gt;
That workaround is no longer necessary, and it has some serious downsides, such as breaking API access checking (since the true &lt;code&gt;minSdkVersion&lt;/code&gt; is no longer known).&lt;br/&gt;
&lt;br/&gt;
In recent versions of the IDE and the Gradle plugin, the IDE automatically passes the API level of the connected device used for deployment, and if that device is at least API 21, then multidexing is automatically turned on, meaning that you get the same speed benefits as the &lt;code&gt;dev&lt;/code&gt; product flavor but without the downsides.&lt;br&gt;&lt;br&gt;Issue id: DevModeObsolete&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintOverdraw" defaultSeverity="WARNING" displayName="Overdraw: Painting regions more than once" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Overdraw: Painting regions more than once&lt;br&gt;&lt;br&gt;If you set a background drawable on a root view, then you should use a custom theme where the theme background is null. Otherwise, the theme background will be painted first, only to have your custom background completely cover it; this is called "overdraw".&lt;br/&gt;
&lt;br/&gt;
NOTE: This detector relies on figuring out which layouts are associated with which activities based on scanning the Java code, and it's currently doing that using an inexact pattern matching algorithm. Therefore, it can incorrectly conclude which activity the layout is associated with and then wrongly complain that a background-theme is hidden.&lt;br/&gt;
&lt;br/&gt;
If you want your custom background on multiple pages, then you should consider making a custom theme with your custom background and just using that theme instead of a root element background.&lt;br/&gt;
&lt;br/&gt;
Of course it's possible that your custom drawable is translucent and you want it to be mixed with the background. However, you will get better performance if you pre-mix the background with your drawable and use that resulting image or color as a custom theme background instead.&lt;br&gt;&lt;br&gt;Issue id: Overdraw&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintStringFormatTrivial" defaultSeverity="WARNING" displayName="String.format string only contains trivial conversions" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;&lt;code&gt;String.format&lt;/code&gt; string only contains trivial conversions&lt;br&gt;&lt;br&gt;Every call to &lt;code&gt;String.format&lt;/code&gt; creates a new &lt;code&gt;Formatter&lt;/code&gt; instance, which will decrease the performance of your app. &lt;code&gt;String.format&lt;/code&gt; should only be used when necessary--if the formatted string contains only trivial conversions (e.g. &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;s&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt;) and there are no translation concerns, it will be more efficient to replace them and concatenate with &lt;code&gt;+&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: StringFormatTrivial&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintTooManyViews" defaultSeverity="WARNING" displayName="Layout has too many views" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Layout has too many views&lt;br&gt;&lt;br&gt;Using too many views in a single layout is bad for performance. Consider using compound drawables or other tricks for reducing the number of views in this layout.&lt;br/&gt;
&lt;br/&gt;
The maximum view count defaults to 80 but can be configured with the environment variable &lt;code&gt;ANDROID_LINT_MAX_VIEW_COUNT&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: TooManyViews&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintWakelockTimeout" defaultSeverity="WARNING" displayName="Using wakeLock without timeout" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using wakeLock without timeout&lt;br&gt;&lt;br&gt;Wakelocks have two acquire methods: one with a timeout, and one without. You should generally always use the one with a timeout. A typical timeout is 10 minutes. If the task takes longer than it is critical that it happens (i.e. can't use &lt;code&gt;JobScheduler&lt;/code&gt;) then maybe they should consider a foreground service instead (which is a stronger run guarantee and lets the user know something long/important is happening).&lt;br&gt;&lt;br&gt;Issue id: WakelockTimeout&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintLifecycleAnnotationProcessorWithJava8" defaultSeverity="WARNING" displayName="Lifecycle Annotation Processor with Java 8 Compile Option" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Lifecycle Annotation Processor with Java 8 Compile Option&lt;br&gt;&lt;br&gt;For faster incremental build, switch to the Lifecycle Java 8 API with these steps:&lt;br/&gt;
&lt;br/&gt;
First replace
&lt;pre&gt;
annotationProcessor "androidx.lifecycle:lifecycle-compiler:*version*"
kapt "androidx.lifecycle:lifecycle-compiler:*version*"
&lt;/pre&gt;
with
&lt;pre&gt;
implementation "androidx.lifecycle:lifecycle-common-java8:*version*"
&lt;/pre&gt;
Then remove any &lt;code&gt;OnLifecycleEvent&lt;/code&gt; annotations from &lt;code&gt;Observer&lt;/code&gt; classes and make them implement the &lt;code&gt;DefaultLifecycleObserver&lt;/code&gt; interface.&lt;br&gt;&lt;br&gt;Issue id: LifecycleAnnotationProcessorWithJava8&lt;br&gt;&lt;br&gt;&lt;a href="https://d.android.com/r/studio-ui/lifecycle-release-notes"&gt;https://d.android.com/r/studio-ui/lifecycle-release-notes&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintDuplicateStrings" defaultSeverity="WARNING" displayName="Duplicate Strings" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Duplicate Strings&lt;br&gt;&lt;br&gt;Duplicate strings can make applications larger unnecessarily.&lt;br/&gt;
&lt;br/&gt;
This lint check looks for duplicate strings, including differences for strings where the only difference is in capitalization. Title casing and all uppercase can all be adjusted in the layout or in code.&lt;br&gt;&lt;br&gt;Issue id: DuplicateStrings&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/reference/android/widget/TextView.html#attr_android:inputType"&gt;https://developer.android.com/reference/android/widget/TextView.html#attr_android:inputType&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection></group><group name="校对" path=""><inspection shortName="LanguageDetectionInspection" defaultSeverity="WARNING" displayName="自然语言检测" enabled="false" pluginId="tanvd.grazi" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html lang="zh"&gt;&lt;body&gt;检测自然语言并建议启用相应的语法和拼写检查。&lt;/body&gt;&lt;/html&gt;
</inspection><inspection shortName="GrazieInspection" defaultSeverity="GRAMMAR_ERROR" displayName="语法" enabled="false" pluginId="tanvd.grazi" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html lang="zh"&gt;&lt;body&gt;
报告文本中的语法错误。 您可以在&lt;a href="settings://reference.settingsdialog.project.grazie"&gt;设置 | 编辑器 | 自然语言 | 语法&lt;/a&gt;中配置检查。
&lt;/body&gt;&lt;/html&gt;
</inspection><inspection shortName="SpellCheckingInspection" defaultSeverity="TYPO" displayName="拼写错误" enabled="false" pluginId="com.intellij" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;&lt;body&gt;报告代码、注释和文字中的拼写错误并一键修正。&lt;/body&gt;&lt;/html&gt;
</inspection></group><group name="Dockerfile" path=""><inspection shortName="DockerFileArgumentCount" defaultSeverity="ERROR" displayName="参数数量错误" enabled="false" language="Dockerfile" pluginId="Docker" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 Dockerfile 命令的无效实参数量。&lt;/p&gt;
&lt;p&gt;
  到达带有无效实参数量的指令后，Docker 构建将失败。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DockerFileRunCommandMissingContinuation" defaultSeverity="ERROR" displayName="'RUN' 命令缺少连续字符" enabled="false" language="Dockerfile" pluginId="Docker" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 &lt;code&gt;RUN&lt;/code&gt; 命令中的缺失继续符。&lt;/p&gt;
&lt;p&gt;
  在 &lt;i&gt;shell&lt;/i&gt; 形式的 &lt;code&gt;RUN&lt;/code&gt; 命令中，应使用 '\'（反斜杠）将单条 &lt;code&gt;RUN&lt;/code&gt; 指令延续到下一行。
  否则，Docker 构建会失败。
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  # the command below will fail
  RUN /bin/bash -c 'source $HOME/.bashrc;
      echo $HOME'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  RUN /bin/bash -c 'source $HOME/.bashrc; \
      echo $HOME'
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DockerFileAddOrCopyPaths" defaultSeverity="WARNING" displayName="'ADD'/'COPY' 命令的无效目标" enabled="false" language="Dockerfile" pluginId="Docker" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 &lt;code&gt;ADD&lt;/code&gt; 和 &lt;code&gt;COPY&lt;/code&gt; 命令中无效的目标目录。&lt;/p&gt;
&lt;p&gt;
  根据 &lt;a href="https://docs.docker.com/engine/reference/builder/#add"&gt;Dockerfile 规范&lt;/a&gt;，如果指定了多个源，则目标必须是目录，并且必须以斜杠 '/' 结尾。
  否则，Docker 构建会失败。
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  # 下面的所有命令都将失败
  ADD textA.txt textB.txt relativeDir
  ADD ["binaryA.jar", "binary2.jar", "destination"]
  COPY text3.txt text4.txt /absolute/path
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  ADD textA.txt textB.txt relativeDir/
  ADD ["binaryA.jar", "binary2.jar", "destination/"]
  COPY text3.txt text4.txt /absolute/path/
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DockerJsonFormStringLiterals" defaultSeverity="WARNING" displayName="JSON 数组格式的单引号字符串" enabled="false" language="Dockerfile" pluginId="Docker" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;
  报告 JSON 数组格式的单引号字符串。
&lt;/p&gt;
&lt;p&gt;
  JSON 数组形式，必须在单词周围使用双引号 (")，而不是单引号 (')。 否则，Docker 构建会失败。
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  # 下面的所有命令都将失败
  RUN ['/bin/bash', '-c', 'echo hello']
  ADD ['binaryA.jar', 'binary2.jar', 'destination/']
  COPY ['binaryA.jar', 'binary2.jar', 'destination/']
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  RUN ["/bin/bash", "-c", "echo hello"]
  ADD ["binaryA.jar", "binary2.jar", "destination/"]
  COPY ["binaryA.jar", "binary2.jar", "destination/"]
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DockerFileAssignments" defaultSeverity="ERROR" displayName="'key=value' 对中无效的空格" enabled="false" language="Dockerfile" pluginId="Docker" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 &lt;code&gt;ARG&lt;/code&gt;、&lt;code&gt;ENV&lt;/code&gt; 和 &lt;code&gt;LABEL&lt;/code&gt; 命令中键值对的不正确间距。&lt;/p&gt;
&lt;p&gt;
  尽管 &lt;a href="https://docs.docker.com/engine/reference/builder/#arg"&gt;Dockerfile 规范&lt;/a&gt;中没有明确指定，但不允许使用键值对的某些间距组合。
  到达问题指令后，Docker 构建将失败。
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;ARG&lt;/code&gt; 命令不允许在 '=' 周围有任何空格&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;ENV&lt;/code&gt; 和 &lt;code&gt;LABEL&lt;/code&gt; 在 '=' 后不允许有空格&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;
  # 下面的所有命令都将失败
  ARG answer = 42
  ARG version= "1.0.0"
  LABEL "maintained.by"= someone@gmail.com
  ENV JAVA_HOME= "/docker-java-home"
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  ARG answer=2
  ARG version="1.0.0"
  LABEL "maintained.by"=someone@gmail.com
  ENV JAVA_HOME="/docker-java-home"
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="数值问题" path="Java"><inspection shortName="RemoveLiteralUnderscores" defaultSeverity="INFORMATION" displayName="数字文字中的下划线" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告带下划线的数值文字，并建议通过快速修复将其移除。
如果您需要降低语言级别，这可能会有用。
&lt;p&gt;该快速修复会移除数值文字中的下划线。 例如，&lt;code&gt;1_000_000&lt;/code&gt; 将转换为 &lt;code&gt;1000000&lt;/code&gt;。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  &lt;i&gt;带下划线的数值文字&lt;/i&gt;在 Java 7 中出现。
  此检查有助于为向后兼容早期 Java 版本而降级。
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;2020.2 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="IntegerDivisionInFloatingPointContext" defaultSeverity="WARNING" displayName="浮点上下文中的整数除法" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告结果用作浮点数时的整数除法。
此类除法通常表明有错误，并且由于在整数除法中出现截断，可能会产生意想不到的结果。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  float x = 3.0F + 3/5;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="OverlyComplexArithmeticExpression" defaultSeverity="WARNING" displayName="过于复杂的算术表达式" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告具有过多项的算术表达式。 此类表达式可能难以理解并且可能包含错误。
&lt;p&gt;形参、字段引用和其他主要表达式均计为一项。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;
  &lt;pre&gt;&lt;code&gt;int calc(int a, int b) {
        return a + a + a + b + b + b + b; // 该行包含 7 个项并将被报告。
    }&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;使用下面的字段可指定算术表达式中允许的项数。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryUnaryMinus" defaultSeverity="WARNING" displayName="不必要的一元负号" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告不必要的一元减号。 此类表达式可能难以理解并且可能包含错误。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void unaryMinus(int i) {
    int x = - -i;
  }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此处建议使用以下快速修复：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;p&gt;移除 &lt;code&gt;i&lt;/code&gt; 变量前的 &lt;code&gt;-&lt;/code&gt; 运算符：&lt;/p&gt;
    &lt;pre&gt;&lt;code&gt;void unaryMinus(int i) {
    int x = i;
  }&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
 &lt;p&gt;使用前缀递减运算符替换 &lt;code&gt;-&lt;/code&gt; 运算符：&lt;/p&gt;
    &lt;pre&gt;&lt;code&gt;void unaryMinus(int i) {
    int x = --i;
  }&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;b&gt;另一个示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void unaryMinus(int i) {
    i += - 8;
  }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void unaryMinus(int i) {
    i -= 8;
  }&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NumericOverflow" defaultSeverity="WARNING" displayName="数值溢出" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告计算过程中溢出的表达式。
通常是意外发生这种情况，并且表明存在错误。 例如，使用了错误的类型或应当反方向移位。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  float a = 1.0f/0.0f;
  long b = 30 * 24 * 60 * 60 * 1000;
  long c = 1000L &amp;lt;&amp;lt; 62;
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="BigDecimalMethodWithoutRoundingCalled" defaultSeverity="WARNING" displayName="'BigDecimal' 方法调用没有舍入模式实参" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对没有舍入模式实参的 &lt;code&gt;divide()&lt;/code&gt; 或 &lt;code&gt;setScale()&lt;/code&gt; 的调用。
&lt;p&gt;在结果中不能表示精确值时（例如由于具有非终止十进制扩展），此类调用可能导致 &lt;code&gt;ArithmeticException&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;指定舍入模式可防止 &lt;code&gt;ArithmeticException&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  BigDecimal.valueOf(1).divide(BigDecimal.valueOf(3));
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LongLiteralsEndingWithLowercaseL" defaultSeverity="WARNING" displayName="'long' 文字以 'l' 而不是 'L' 结尾" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告以小写 'l' 结尾的 &lt;code&gt;long&lt;/code&gt; 文字。 这些文字可能令人困惑，因为小写的 'l' 与文字 '1'（一）非常相似。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  long nights = 100l;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  long nights = 100L;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FloatingPointEquality" defaultSeverity="WARNING" displayName="浮点相等比较" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告使用 &lt;code&gt;==&lt;/code&gt; 或 &lt;code&gt;!=&lt;/code&gt; 运算符进行比较的浮点值。
&lt;p&gt;浮点值本质上是不准确的，比较它们是否完全相等很少是所需的语义。&lt;/p&gt;
&lt;p&gt;此检查会忽略与零和无穷大文字的比较。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;
&lt;pre&gt;&lt;code&gt;
  void m(double d1, double d2) {
    if (d1 == d2) {}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ImplicitNumericConversion" defaultSeverity="WARNING" displayName="隐式数字转换" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告数值类型之间的隐式转换。
&lt;p&gt;隐式数字转换本身不是问题，但如果是意外，可能会在跟踪错误时造成困难。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  double m(int i) {
    return i * 10;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  double m(int i) {
    return (double) (i * 10);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;配置检查：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;使用&lt;b&gt;忽略扩大转换&lt;/b&gt;选项可以忽略不会导致数据丢失的隐式转换（例如，&lt;code&gt;int&lt;/code&gt;-&amp;gt;&lt;code&gt;long&lt;/code&gt;）。&lt;/li&gt;
  &lt;li&gt;使用&lt;b&gt;忽略 'char' 与其他类型之间的转换&lt;/b&gt;选项可以忽略 &lt;code&gt;char&lt;/code&gt; 与其他类型之间的转换。 该检查仍将报告浮点数与其他类型之间的转换。&lt;/li&gt;
  &lt;li&gt;使用&lt;b&gt;忽略来自常量和文字的转换&lt;/b&gt;可使检查忽略来自文字和编译时常量的转换。&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NegativeIntConstantInLongContext" defaultSeverity="WARNING" displayName="长整型上下文中的负整型十六进制常量" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 long 上下文中的负 int 十六进制常量。 此类常量会为隐式加宽为 long，意味着它们的高位将为 1，而不是 0（例如，0xFFFF_FFFF 将变成 0xFFFF_FFFF_FFFF_FFFFL）。
这不太可能是有意为之，即使是有意为之，使用显式 long 常量也不会那么容易造成困惑。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  // 警告：这是 int 常量 -1，它被加宽为 long
  // 成为 0xFFFF_FFFF_FFFF_FFFFL.
  long mask = 0xFFFF_FFFF;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2022.3 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="OctalLiteral" defaultSeverity="WARNING" displayName="八进制整数" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告八进制整数文字。 某些编码标准禁止使用八进制文字，因为它们可能容易与十进制文字混淆。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int i = 015;
  int j = 0_777;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此检查有两种不同的快速修复。
  应用&lt;b&gt;将八进制文字转换为十进制文字&lt;/b&gt;快速修复后，代码变为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int i = 13;
  int j = 511;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;应用&lt;b&gt;移除前导零以变为十进制&lt;/b&gt;快速修复后，代码变为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int i = 15;
  int j = 777;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="BigDecimalEquals" defaultSeverity="WARNING" displayName="在 'BigDecimal' 上调用了 'equals()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告比较两个 &lt;code&gt;java.math.BigDecimal&lt;/code&gt; 数字的 &lt;code&gt;equals()&lt;/code&gt; 调用。
这通常会是错误，因为两个 &lt;code&gt;java.math.BigDecimal&lt;/code&gt; 数字只有在值和比例上都相等时才相等。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (new BigDecimal("2.0").equals(
    new BigDecimal("2.00"))) {} // false
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (new BigDecimal("2.0").compareTo(
    new BigDecimal("2.00")) == 0) {} // true
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConfusingFloatingPointLiteral" defaultSeverity="WARNING" displayName="引起混淆的浮点文字" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告任何没有小数点的浮点数、小数点前的数字或小数点后的数字。
&lt;p&gt;此类文字可能令人困惑，并且违反多种编码标准。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;double d = .03;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;double d = 0.03;&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
使用&lt;b&gt;忽略科学记数法中的浮点文字&lt;/b&gt;选项可以忽略科学记数法中的浮点数。&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CachedNumberConstructorCall" defaultSeverity="WARNING" displayName="数字构造函数调用具有基元实参" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告具有基元 &lt;code&gt;long&lt;/code&gt;、&lt;code&gt;integer&lt;/code&gt;、&lt;code&gt;short&lt;/code&gt; 或 &lt;code&gt;byte&lt;/code&gt; 实参的新 &lt;code&gt;Long&lt;/code&gt;、&lt;code&gt;Integer&lt;/code&gt;、&lt;code&gt;Short&lt;/code&gt; 或 &lt;code&gt;Byte&lt;/code&gt; 对象的实例化。
&lt;p&gt;建议使用 Java 5 中引入的 static 方法 &lt;code&gt;valueOf()&lt;/code&gt; 默认情况下，此方法缓存值介于 -128 到 127（包含）之间的对象。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Integer i = new Integer(1);
  Long l = new Long(1L);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;应用快速修复后，代码变为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Integer i = Integer.valueOf(1);
  Long l = Long.valueOf(1L);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;仅当项目或模块的语言级别为 5 或更高时，此检查才会报告。&lt;/p&gt;
&lt;p&gt;
  使用&lt;b&gt;忽略具有字符串实参的新数字表达式&lt;/b&gt;选项可以忽略对包含 &lt;code&gt;String&lt;/code&gt; 实参的数字构造函数的调用。&lt;/p&gt;
&lt;p&gt;
  使用&lt;b&gt;仅在构造函数为 @Deprecated 时报告&lt;/b&gt;选项，仅报告对弃用的构造函数的调用。
  &lt;code&gt;Long&lt;/code&gt;、&lt;code&gt;Integer&lt;/code&gt;、&lt;code&gt;Short&lt;/code&gt; 和 &lt;code&gt;Byte&lt;/code&gt; 构造函数自 JDK 9 起已被弃用。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PointlessArithmeticExpression" defaultSeverity="WARNING" displayName="无意义的算术表达式" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告无意义的算术表达式。 此类表达式包括加 0、减 0、乘以 0 或 1 以及除以 1。
&lt;p&gt;此类表达式可能是自动重构所致，不太可能是开发者的本意。&lt;/p&gt;
&lt;p&gt;该快速修复会简化此类表达式。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;
&lt;pre&gt;&lt;code&gt;
  void f(int a) {
    int x = a - a;
    int y = a + 0;
    int res = x / x;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void f(int a) {
    int x = 0;
    int y = a;
    int res = 1;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  请注意，在极少数情况下，建议的替换可能不完全等同于所有可能输入的原始代码。 例如，该检查会建议将 &lt;code&gt;x / x&lt;/code&gt; 替换为 &lt;code&gt;1&lt;/code&gt;。
  但是，如果 &lt;code&gt;x&lt;/code&gt; 为零，原始代码将抛出 &lt;code&gt;ArithmeticException&lt;/code&gt; 或导致 &lt;code&gt;NaN&lt;/code&gt;。
  另外，如果 &lt;code&gt;x&lt;/code&gt; 为 &lt;code&gt;NaN&lt;/code&gt;，则结果也是 &lt;code&gt;NaN&lt;/code&gt;。 此类行为不太可能出于本意。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ComparisonOfShortAndChar" defaultSeverity="WARNING" displayName="比较 'short' 和 'char' 值" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;short&lt;/code&gt; 与 &lt;code&gt;char&lt;/code&gt; 值之间的相等比较。
&lt;p&gt;此类比较可能会导致难以捉摸的错误，因为虽然两个值都是 2 字节长，&lt;code&gt;short&lt;/code&gt; 值有符号，而 &lt;code&gt;char&lt;/code&gt; 值无符号。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
if (Character.MAX_VALUE == shortValue()) {} // 永远不能为 true
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnaryPlus" defaultSeverity="WARNING" displayName="一元正号" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告使用 &lt;code&gt;+&lt;/code&gt; 一元运算符的情况。 一元加号通常为 null 运算，它的存在可能代表编码错误。 例如，与递增运算符（如 &lt;code&gt;+++&lt;/code&gt; 中）或相等运算符（如 &lt;code&gt;=+&lt;/code&gt; 中）结合使用。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void unaryPlus(int i) {
    int x = + +i;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;建议使用以下快速修复：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;p&gt;移除 &lt;code&gt;i&lt;/code&gt; 变量前的 &lt;code&gt;+&lt;/code&gt; 运算符：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void unaryPlus(int i) {
    int x = i;
  }
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;p&gt;使用前缀递增运算符替换 &lt;code&gt;+&lt;/code&gt; 运算符：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void unaryPlus(int i) {
    int x = ++i;
  }
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
使用下面的复选框可以报告与二进制或另一个一元表达式一起使用的一元加号。
这意味着检查将不会报告将一元加号表达式用于数组初始值设定项表达式或用作方法实参的情况。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="BadOddness" defaultSeverity="WARNING" displayName="可疑的奇数检查" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告以下形式的奇偶校验：&lt;code&gt;x % 2 == 1&lt;/code&gt;。
当与负奇数一起使用时，此类检查将会失败。
请考虑改用 &lt;code&gt;x % 2 != 0&lt;/code&gt; 或 &lt;code&gt;(x &amp; 1) == 1&lt;/code&gt;。
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ComparisonToNaN" defaultSeverity="WARNING" displayName="与 'Double.NaN' 或 'Float.NaN' 比较" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告任何与 &lt;code&gt;Double.NaN&lt;/code&gt; 或 &lt;code&gt;Float.NaN&lt;/code&gt; 的比较。
此类比较毫无意义，因为 NaN 不等于任何内容，包括不等于自身。
改用 &lt;code&gt;Double.isNaN()&lt;/code&gt; 或 &lt;code&gt;Float.isNaN()&lt;/code&gt; 方法。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (x == Double.NaN) {...}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (Double.isNaN(x)) {...}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SuspiciousLiteralUnderscore" defaultSeverity="WARNING" displayName="数字文字中的可疑下划线" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告使用下划线数字分隔符且组的位数不为 3 的小数文字。
此类文字可能包含拼写错误。
&lt;p&gt;此检查不会对包含两个连续下划线的文字发出警告。
还可以忽略 &lt;code&gt;double&lt;/code&gt; 和 &lt;code&gt;float&lt;/code&gt; 文字的分数部分的下划线。
&lt;p&gt;&lt;b&gt;示例&lt;/b&gt;：&lt;code&gt;int oneMillion = 1_000_0000;&lt;/code&gt;&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CharUsedInArithmeticContext" defaultSeverity="WARNING" displayName="在算术上下文中使用 'char' 表达式" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告用于加法或减法表达式的 &lt;code&gt;char&lt;/code&gt; 类型的表达式。
&lt;p&gt;此类代码不一定是问题，但可能会导致错误（例如，如果需要字符串）。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例&lt;/b&gt;：&lt;code&gt;int a = 'a' + 42;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;应用该快速修复后：&lt;code&gt;int a = (int) 'a' + 42;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;对于 &lt;code&gt;String&lt;/code&gt; 上下文：
&lt;pre&gt;&lt;code&gt;int i1 = 1;
int i2 = 2;
System.out.println(i2 + '-' + i1 + &amp;quot; = &amp;quot; + (i2 - i1));&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;code&gt;System.out.println(i2 + &amp;quot;-&amp;quot; + i1 + &amp;quot; = &amp;quot; + (i2 - i1));&lt;/code&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConstantMathCall" defaultSeverity="WARNING" displayName="对 'Math' 的常量调用" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对可被替换为简单的编译时常量的 &lt;code&gt;java.lang.Math&lt;/code&gt; 或 &lt;code&gt;java.lang.StrictMath&lt;/code&gt; 方法的调用。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;double v = Math.sin(0.0);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;double v = 0.0;&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="OctalAndDecimalIntegersMixed" defaultSeverity="WARNING" displayName="同一数组中的八进制和十进制整数" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告单个数组初始值设定项中混合的八进制和十进制整数文字。
当您将数字列表复制到数组初始值设定项中时，可能会发生这种情况。
数组中的某些数字可能用零填充，编译器会将它们解释为八进制。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int[] elapsed = {1, 13, 052};&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;应用移除前导零的快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int[] elapsed = {1, 13, 52};&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果它是一个八进制数（例如，在内联变量之后），那么您可以使用另一个将八进制转换为十进制的快速修复：&lt;/p&gt;
&lt;code&gt;int[] elapsed = {1, 13, 42};&lt;/code&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="InsertLiteralUnderscores" defaultSeverity="INFORMATION" displayName="不可读的数字文字" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告不带下划线的长数值文字并建议添加它们。 下划线使此类文字更易于阅读。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  1000000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  1_000_000
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;仅当项目或模块的语言级别为 7 级或更高级别时，此检查才会报告。&lt;/p&gt;
&lt;p&gt;&lt;small&gt;2020.2 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="DivideByZero" defaultSeverity="WARNING" displayName="除以零" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告除以 0 或对 0 取余。
对于双精度或浮点数，此类表达式将产生 &lt;code&gt;Infinity&lt;/code&gt;、&lt;code&gt;-Infinity&lt;/code&gt; 或 &lt;code&gt;NaN&lt;/code&gt; 结果；对于整数，则抛出 &lt;code&gt;ArithmeticException&lt;/code&gt;。
&lt;p&gt;当表达式的结果为 &lt;code&gt;NaN&lt;/code&gt; 时，该修正会建议将除法表达式替换为 &lt;code&gt;NaN&lt;/code&gt; 常量。
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnpredictableBigDecimalConstructorCall" defaultSeverity="WARNING" displayName="不可预知的 'BigDecimal' 构造函数调用" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对接受 &lt;code&gt;double&lt;/code&gt; 值的 &lt;code&gt;BigDecimal&lt;/code&gt; 构造函数的调用。
这些构造函数生成正好等于提供的 &lt;code&gt;double&lt;/code&gt; 值的 &lt;code&gt;BigDecimal&lt;/code&gt;。
但是，由于 double 是以 IEEE 754 64 位双精度二进制浮点格式进行编码，确切值可能出乎意料。
&lt;p&gt;例如，&lt;code&gt;new BigDecimal(0.1)&lt;/code&gt; 会生成一个 &lt;code&gt;BigDecimal&lt;/code&gt; 对象。 它的值为 &lt;small&gt;&lt;code&gt;0.1000000000000000055511151231257827021181583404541015625&lt;/code&gt;&lt;/small&gt;，这是最接近 0.1 的数字，可以表示为 double。
  要获取存储的值与源代码中编写的值相同的 &lt;code&gt;BigDecimal&lt;/code&gt;，请使用 &lt;code&gt;new BigDecimal("0.1")&lt;/code&gt; 或 &lt;code&gt;BigDecimal.valueOf(0.1)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Constructor {
    void foo() {
      new BigDecimal(0.1);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Constructor {
    void foo() {
      new BigDecimal("0.1");
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NonReproducibleMathCall" defaultSeverity="WARNING" displayName="对 'Math' 的不可重现调用" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告不能保证准确再现结果的对 &lt;code&gt;java.lang.Math&lt;/code&gt; 方法的调用。
&lt;p&gt;在需要结果重现性的环境中，应改用 &lt;code&gt;java.lang.StrictMath&lt;/code&gt;。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="软件包搜索" path=""><inspection shortName="GradlePackageVersionRange" defaultSeverity="WEAK WARNING" displayName="检查依赖项版本中的范围(Gradle)" enabled="false" language="UAST" pluginId="com.jetbrains.packagesearch.intellij-plugin" pluginVersion="223.8836.41" isGlobalTool="false">检测依赖项版本是否为 Gradle 项目中的范围</inspection><inspection shortName="GradlePackageUpdate" defaultSeverity="WEAK WARNING" displayName="检查新的依赖项版本(Gradle)" enabled="false" language="UAST" pluginId="com.jetbrains.packagesearch.intellij-plugin" pluginVersion="223.8836.41" isGlobalTool="false">检测 Gradle 项目中的依赖项有新版本的情况</inspection><inspection shortName="MavenPackageUpdate" defaultSeverity="WEAK WARNING" displayName="检查新的依赖项版本(Maven)" enabled="false" language="XML" pluginId="com.jetbrains.packagesearch.intellij-plugin" pluginVersion="223.8836.41" isGlobalTool="false">检测 Maven 项目中的依赖项有新版本的情况</inspection><inspection shortName="MavenPackageVersionRange" defaultSeverity="WEAK WARNING" displayName="检查依赖项版本中的范围(Maven)" enabled="false" language="XML" pluginId="com.jetbrains.packagesearch.intellij-plugin" pluginVersion="223.8836.41" isGlobalTool="false">检测依赖项版本是否为 Maven 项目中的范围</inspection></group><group name="错误处理" path="Groovy"><inspection shortName="GroovyEmptyFinallyBlock" defaultSeverity="WARNING" displayName="空 'finally' 块" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告空的 &lt;code&gt;finally&lt;/code&gt; 块。
空的 &lt;code&gt;finally&lt;/code&gt; 块通常表明存在编码错误。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
try {
  throw new Exception()
}
finally {
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyEmptyTryBlock" defaultSeverity="WARNING" displayName="空 'try' 块" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告空的 &lt;code&gt;try&lt;/code&gt; 块。
空的 &lt;code&gt;try&lt;/code&gt; 块通常表明存在编码错误。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
try {
}
finally {
  close()
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyEmptyCatchBlock" defaultSeverity="WARNING" displayName="空 'catch' 块" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告空的 &lt;code&gt;catch&lt;/code&gt; 块。 虽然偶尔是有意为之，但空的 &lt;code&gt;catch&lt;/code&gt; 块可能导致调试变得极其困难。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
try {
  throw new Exception()
}
catch (Exception e) {
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
try {
  throw new Exception()
}
catch (Exception ignored) {
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyReturnFromFinallyBlock" defaultSeverity="WARNING" displayName="'return' 位于 'finally' 块内" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;finally&lt;/code&gt; 块中的 &lt;code&gt;return&lt;/code&gt; 语句。
&lt;p&gt;
  虽然偶尔是有意为之，但此类 &lt;code&gt;return&lt;/code&gt; 语句可能会掩盖抛出的异常，并导致调试复杂化。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyThrowFromFinallyBlock" defaultSeverity="WARNING" displayName="'throw' 位于 'finally' 块内" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;finally&lt;/code&gt; 块中的 &lt;code&gt;throw&lt;/code&gt; 语句。
&lt;p&gt;
  虽然偶尔是有意为之，但此类 &lt;code&gt;throw&lt;/code&gt; 语句可能会掩盖抛出的异常，并导致调试变得极其复杂。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyUnusedCatchParameter" defaultSeverity="WARNING" displayName="未使用的 'catch' 形参" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告未在相应的块中使用的 &lt;b&gt;catch&lt;/b&gt; 形参。 此检查不会报告任何命名为 "ignore"或 "ignored" 的 &lt;b&gt;catch&lt;/b&gt; 形参。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  try {
      def arr = new int[3]
      arr[5] = 5
  } catch(Exception &lt;b&gt;ex&lt;/b&gt;) {
      println('Catching the exception')
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此处的形参 &lt;b&gt;ex&lt;/b&gt; 永远不会在 &lt;b&gt;catch&lt;/b&gt; 块中使用。
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  try {
      def arr = new int[3]
      arr[5] = 5
  } catch(Exception &lt;b&gt;ignored&lt;/b&gt;) {
      println('Catching the exception')
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyContinueOrBreakFromFinallyBlock" defaultSeverity="WARNING" displayName="'finally' 块中的 'continue' 或 'break'" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;finally&lt;/code&gt; 块中的 &lt;code&gt;break&lt;/code&gt; 和 &lt;code&gt;continue&lt;/code&gt; 语句。
&lt;p&gt;虽然偶尔是有意为之，但此类语句非常令人困惑，可能会掩盖抛出的异常，并导致调试变得极其复杂。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="MongoJS" path=""><inspection shortName="MongoJSExtDeprecationInspection" defaultSeverity="WARNING" displayName="弃用的元素" enabled="false" language="MongoJSExt" pluginId="com.intellij.database" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 MongoDB 和 JavaScript 代码中已弃用的方法的用法。
&lt;p&gt;快速修复用推荐的替代方法替换了已弃用的方法。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  db.my_collection.insert()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  db.my_collection.insertOne()
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MongoJSDeprecationInspection" defaultSeverity="WARNING" displayName="弃用的元素" enabled="false" language="MongoJS" pluginId="com.intellij.database" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 MongoDB 和 JavaScript 代码中已弃用的方法的用法。
&lt;p&gt;快速修复用推荐的替代方法替换了已弃用的方法。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;db.my_collection.insert()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;db.my_collection.insertOne()&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MongoJSResolveInspection" defaultSeverity="WARNING" displayName="解析问题" enabled="false" language="MongoJS" pluginId="com.intellij.database" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 MongoDB 和 JavaScript 代码中未解析的引用。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;db
use foo
  -- a reference to a non-existing collection
db.non_existing_collection
db['non_existing_collection']
db['non_existing_collection'].find().hasNext()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;non_existing_collection&lt;/code&gt; 集合在数据库中不存在，将被报告。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MongoJSSideEffectsInspection" defaultSeverity="WARNING" displayName="具有副作用的语句" enabled="false" language="MongoJS" pluginId="com.intellij.database" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在数据源处于只读模式时可能导致副作用的语句。
&lt;p&gt;有关启用只读模式的详细信息，请参阅 &lt;a href="https://www.jetbrains.com/help/datagrip/configuring-database-connections.html#enable-read-only-mode-for-a-connection"&gt;IDE 文档中的“为连接启用只读模式”&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;禁用只读模式&lt;/b&gt;快速修复会关闭相应数据源的只读模式。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
db.my_collection.insertOne()
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MongoJSExtSideEffectsInspection" defaultSeverity="WARNING" displayName="具有副作用的语句" enabled="false" language="MongoJSExt" pluginId="com.intellij.database" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在数据源处于只读模式时可能导致副作用的语句。
&lt;p&gt;该快速修复会关闭相应数据源的只读模式。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
db.my_collection.insertOne()
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MongoJSExtResolveInspection" defaultSeverity="WARNING" displayName="解析问题" enabled="false" language="MongoJSExt" pluginId="com.intellij.database" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 MongoDB 和 JavaScript 代码中未解析的引用。
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Spring Data" path="Spring"><inspection shortName="SpringDataMongoDBJsonFieldInspection" defaultSeverity="ERROR" displayName="Spring Data MongoDB JSON 未解析字段" enabled="false" language="Spring-MongoDB-JSON" pluginId="com.intellij.spring.data" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;
  报告在 &lt;code&gt;org.springframework.data.mongodb.repository.Query&lt;/code&gt; 注解内指定的未解析的文档字段。
&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
@Document
class User {
  @Field
  String name;
}

interface UserRepository extends Repository&amp;lt;User, Long&amp;gt; {
  @Query("{ age: { $gt: ?0 } }") // 'age' 被高亮显示为未解决
  List&amp;lt;User&amp;gt; findUsersOlderThan(Integer age);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SpringDataRepositoryMethodParametersInspection" defaultSeverity="WARNING" displayName="Spring Data 仓库方法形参错误" enabled="false" language="UAST" pluginId="com.intellij.spring.data" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告类型不正确的 Spring Data CRUD 仓库方法形参。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Person {
    private int id;
    private String lastname;
    private Address address;
  }

  public class Address {
    private int zipCode;
  }

  public interface CustomerRepository extends CrudRepository&amp;lt;Person, Integer&amp;gt; {
    List&amp;lt;Person&amp;gt; &lt;strong&gt;findByAddress&lt;/strong&gt;(String lastname);  // 应为 'Address' 类型
    List&amp;lt;Person&amp;gt; &lt;strong&gt;findByAddressZipCode&lt;/strong&gt;(String str);   // 应为 'int' 类型
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SpringDataRepositoryMethodReturnTypeInspection" defaultSeverity="WARNING" displayName="Spring Data 仓库方法返回值类型错误" enabled="false" language="UAST" pluginId="com.intellij.spring.data" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告返回类型不正确的 Spring Data CRUD 仓库方法。&lt;/p&gt;
&lt;p&gt;支持以下返回类型：&lt;/p&gt;
&lt;list&gt;
  &lt;li&gt;&lt;code&gt;void&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;基元类型&lt;/li&gt;
  &lt;li&gt;包装器类型&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;T&lt;/code&gt;（当查询方法应最多返回一个结果时）。 如果没有结果，则返回 &lt;code&gt;null&lt;/code&gt;，如果有多个结果，则抛出 &lt;code&gt;IncorrectResultSizeDataAccessException&lt;/code&gt;。
  &lt;/li&gt;
  &lt;li&gt;&lt;code&gt;java.util.List &lt;/code&gt; 或任何常见的 &lt;code&gt; Iterable&lt;/code&gt; 类型&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;java.util.stream.Stream&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;java.util.Optional&lt;/code&gt; 或 &lt;code&gt;scala.Option&lt;/code&gt;（当查询方法应最多返回一个结果时）。 如果没有结果，则返回 &lt;code&gt;Optional.empty()&lt;/code&gt; 或 &lt;code&gt;Optional.absent()&lt;/code&gt;，如果有多个结果，则抛出 &lt;code&gt;IncorrectResultSizeDataAccessException&lt;/code&gt;。
  &lt;/li&gt;
  &lt;li&gt;&lt;code&gt;io.micronaut.data.model.Page&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;io.micronaut.data.model.Slice&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;java.util.concurrent.Future&lt;/code&gt;、&lt;code&gt;java.util.concurrent.CompletableFuture&lt;/code&gt; 或 &lt;code&gt;ListenableFuture&lt;/code&gt;（如果该方法使用 &lt;code&gt;@Async&lt;/code&gt; 进行注解并启用 Spring 异步方法执行）
  &lt;/li&gt;
  &lt;li&gt;&lt;code&gt;GeoResults&amp;lt;T&amp;gt;&lt;/code&gt;、&lt;code&gt;GeoResult&amp;lt;T&amp;gt;&lt;/code&gt; 或 &lt;code&gt;GeoPage&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/list&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SpringDataMethodInconsistencyInspection" defaultSeverity="WARNING" displayName="Spring Data 仓库方法错误" enabled="false" language="UAST" pluginId="com.intellij.spring.data" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;
  报告 &lt;a href="https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories.query-methods.query-creation"&gt;Spring Data Query&lt;/a&gt; 构建器无法为其生成相应查询的 Spring Data CRUD 仓库方法。
&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
interface PersonRepository extends Repository&amp;lt;Person, Long&amp;gt; {
  List&amp;lt;Person&amp;gt; findByEmailAddressAndLastname(EmailAddress emailAddress, String lastname);
  List&amp;lt;Person&amp;gt; findByEmail&lt;strong&gt;Unknown&lt;/strong&gt;AndLastname(EmailAddress emailAddress, String lastname); // 无法解析 'Unknown' 属性
  List&amp;lt;Person&amp;gt; &lt;strong&gt;findByAndLastname&lt;/strong&gt;(EmailAddress emailAddress, String lastname); // 缺少属性名称

  List&amp;lt;Person&amp;gt; findDistinctPeopleByLastnameOrFirstname(String lastname, String firstname);
  List&amp;lt;Person&amp;gt; findPeopleDistinctBy&lt;strong&gt;Unknown&lt;/strong&gt;OrFirstname(String lastname, String firstname); // 无法解析 'Unknown' 属性

  List&amp;lt;Person&amp;gt; findByLastnameOrderByFirstnameAsc(String lastname);
  List&amp;lt;Person&amp;gt; findByLastnameOrderBy&lt;strong&gt;Unknown&lt;/strong&gt;Desc(String lastname);  // 无法解析 'Unknown' 属性
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="UI 窗体" path=""><inspection shortName="OneButtonGroup" defaultSeverity="WARNING" displayName="包含一个按钮的按钮组" enabled="false" language="TEXT" pluginId="com.intellij.uiDesigner" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告仅包含一个 &lt;code&gt;JRadioButton&lt;/code&gt; 的 &lt;code&gt;ButtonGroup&lt;/code&gt; 实例。
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="DuplicateMnemonic" defaultSeverity="WARNING" displayName="助记键重复" enabled="false" language="TEXT" pluginId="com.intellij.uiDesigner" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告具有重复助记符的组件。
&lt;p&gt;该快速修复会为每个组件分配独一无二的助记符。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="BoundFieldAssignment" defaultSeverity="WARNING" displayName="赋值给 UI 绑定字段" enabled="false" language="JAVA" pluginId="com.intellij.uiDesigner" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告绑定到 UI Designer 窗体中的组件的字段赋值。
&lt;p&gt;此类赋值将导致 UI Designer 为此类字段生成的组件设置代码被忽略。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="I18nForm" defaultSeverity="WARNING" displayName="UI 表单中的硬编码字符串文字" enabled="false" language="TEXT" pluginId="com.intellij.uiDesigner" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 UI 窗体中硬编码字符串的任何实例。
&lt;p&gt;硬编码的字符串文字在国际化环境中通常是错误。
  此检查不报告空字符串和仅包含空格的字符串。&lt;/p&gt;

&lt;p&gt;该快速修复会将字符串文字转换为对资源包中属性的引用。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NoLabelFor" defaultSeverity="WARNING" displayName="无组件标签" enabled="false" language="TEXT" pluginId="com.intellij.uiDesigner" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告没有任何静态文本并且没有为此组件使用 &lt;code&gt;setLabelFor&lt;/code&gt; 标记的任何标签的组件。
&lt;p&gt;没有静态文本的组件包括编辑字段与组合框。
无法使用键盘快捷键激活此类组件。 此检查的快速修复允许您自动将相邻标签与有问题的组件相关联。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="FormSpellChecking" defaultSeverity="WARNING" displayName="UI 表单中拼写错误" enabled="false" language="TEXT" pluginId="com.intellij.uiDesigner" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 UI 表单中的拼写错误（例如，&lt;code&gt;JLabel&lt;/code&gt; 文本或 &lt;code&gt;JPanel&lt;/code&gt; 标题）并一键修正。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="InvalidPropertyKeyForm" defaultSeverity="WARNING" displayName="UI 表单中的无效属性键" enabled="false" language="TEXT" pluginId="com.intellij.uiDesigner" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对 .properties 文件的未解析引用。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NoScrollPane" defaultSeverity="WARNING" displayName="可滚动的组件不在 JScrollPane 中" enabled="false" language="TEXT" pluginId="com.intellij.uiDesigner" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告未放置在 &lt;code&gt;JScrollPane&lt;/code&gt; 中的 &lt;code&gt;Scrollable&lt;/code&gt; 组件（&lt;code&gt;JTextField&lt;/code&gt; 除外）。 该快速修复会使用滚动窗格围绕有问题的组件。
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="MissingMnemonic" defaultSeverity="WARNING" displayName="缺少助记键" enabled="false" language="TEXT" pluginId="com.intellij.uiDesigner" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告具有 &lt;code&gt;text&lt;/code&gt; 属性的可聚焦组件或具有分配的 &lt;code&gt;labelFor&lt;/code&gt; 属性但没有助记符的标签。 该快速修复会为此类组件分配独一无二的助记符。
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="NoButtonGroup" defaultSeverity="WARNING" displayName="单选按钮不在组中" enabled="false" language="TEXT" pluginId="com.intellij.uiDesigner" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告未放置在 &lt;code&gt;ButtonGroup&lt;/code&gt; 中的 &lt;code&gt;JRadioButton&lt;/code&gt; 组件。 可以通过快速修复对放置在相邻网格单元格中的单选按钮进行分组。
&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="可移植性" path="Java"><inspection shortName="HardcodedFileSeparators" defaultSeverity="WARNING" displayName="硬编码文件分隔符" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告字符串或字符文字中的正斜杠 (&lt;code&gt;/&lt;/code&gt;) 或反斜杠 (&lt;code&gt;\&lt;/code&gt;)。 这些字符通常用作文件分隔符，如果它们被硬编码，则可移植性可能会受到影响。
&lt;p&gt;
  该检查不会报告转义序列内的反斜杠和紧跟在 '&amp;lt;' 字符之后或紧接在 '&amp;gt;' 字符之前的正斜杠，因为它们通常表示 XML 或 HTML 标记而不是文件名。
  表示 &lt;code&gt;java.util.TimeZone&lt;/code&gt; ID 的字符串、作为有效正则表达式的字符串或与 IANA 注册的 MIME 媒体类型等效的字符串也不会被报告。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  new File("C:\\Users\\Name");
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用该选项可将 &lt;code&gt;example/*&lt;/code&gt; 包含在已识别的媒体类型集中。
  通常，在示例之外（例如在 &lt;code&gt;Content-Type&lt;/code&gt; 标头中）使用 &lt;code&gt;example/*&lt;/code&gt; MIME 媒体类型是错误的。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UseOfSunClasses" defaultSeverity="WARNING" displayName="使用 'sun.*' 类" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告使用 &lt;code&gt;sun.*&lt;/code&gt; 层次结构中的类的情况。
这种类不可在不同的 JVM 之间移植。
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UseOfProcessBuilder" defaultSeverity="WARNING" displayName="使用 'java.lang.ProcessBuilder' 类" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告使用 &lt;code&gt;java.lang.ProcessBuilder&lt;/code&gt; 的情况，由于可执行文件、环境变量、命令行实参及其转义的路径可能会因操作系统而异，可能无法在操作系统之间移植。
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SystemExit" defaultSeverity="WARNING" displayName="调用 'System.exit()' 或相关方法" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对 &lt;code&gt;System.exit()&lt;/code&gt;、&lt;code&gt;Runtime.exit()&lt;/code&gt; 和 &lt;code&gt;Runtime.halt()&lt;/code&gt; 的调用。
&lt;p&gt;
  调用 &lt;code&gt;System.exit()&lt;/code&gt; 或 &lt;code&gt;Runtime.exit()&lt;/code&gt; 会调用关闭挂钩并终止当前运行的 Java 虚拟机。 调用 &lt;code&gt;Runtime.halt()&lt;/code&gt; 会强行终止 JVM，而不会导致启动关闭挂钩。
  这些方法中的每一种都应极其谨慎地使用。 对这些方法的调用使得调用代码对于大多数应用程序服务器来说不可移植。
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用该选项可以忽略主方法中的调用。
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NativeMethods" defaultSeverity="WARNING" displayName="本地方法" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告被声明为 &lt;code&gt;native&lt;/code&gt; 的方法。 原生方法本质上不可移植。
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SystemGetenv" defaultSeverity="WARNING" displayName="调用 'System.getenv()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对 &lt;code&gt;System.getenv()&lt;/code&gt; 的调用。
对 &lt;code&gt;System.getenv()&lt;/code&gt; 的调用本质上不可移植。
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RuntimeExec" defaultSeverity="WARNING" displayName="调用 'Runtime.exec()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对 &lt;code&gt;Runtime.exec()&lt;/code&gt; 或其任何变体的调用。
对 &lt;code&gt;Runtime.exec()&lt;/code&gt; 的调用本质上不可移植。
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UseOfAWTPeerClass" defaultSeverity="WARNING" displayName="使用 AWT 对等类" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告使用 AWT 对等类的情况。 这些类代表原生窗口系统微件，并且不可在不同的窗口系统之间移植。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  import java.awt.peer.ButtonPeer;

  abstract class Sample implements ButtonPeer {
    public void foo() {
        Sample sample;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UseOfJDBCDriverClass" defaultSeverity="WARNING" displayName="使用具体的 JDBC 驱动程序类" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告使用特定 JDBC 驱动程序类的情况。 使用这种类会将您的项目绑定到特定的数据库和驱动程序，从而违背了 JDBC 的目的并导致失去可移植性。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  import java.sql.Driver;

  abstract class Sample implements Driver {
    public void foo() {
        Sample sample;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="HardcodedLineSeparators" defaultSeverity="WARNING" displayName="硬编码行分隔符" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告字符串文字、字符文字或文本块中使用的换行 (&lt;code&gt;\n&lt;/code&gt;) 和回车 (&lt;code&gt;\r&lt;/code&gt;) 字符转义序列。 这些字符通常用作行分隔符，如果它们被硬编码，可移植性可能会受到影响。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String count = "first\nsecond\rthird";
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="sbt" path=""><inspection shortName="SbtReplaceProjectWithProjectIn" defaultSeverity="WARNING" displayName="将 Project() 替换为 project.in()" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 &lt;code&gt;Project&lt;/code&gt; 的用法并建议将其替换为 &lt;code&gt;project.in&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  val proj = Project("proj", path)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  val proj = project.in(path)
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SbtDependencyVersionInspection" defaultSeverity="WEAK WARNING" displayName="库依赖项有较新的稳定版本" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告使用旧的库依赖项版本的情况，并建议将其替换为较新的稳定版本。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  libraryDependencies += "org.scalatest" %% "scalatest" % "3.0.7"
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  libraryDependencies += "org.scalatest" %% "scalatest" % "3.0.8"
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="其他" path="Scala，集合"><inspection shortName="SortFilter" defaultSeverity="WARNING" displayName="在 sort 后使用 filter" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告可以通过交换 &lt;code&gt;sort&lt;/code&gt; 和 &lt;code&gt;filter&lt;/code&gt; 来提高性能的情况。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  var seq: Seq[Int]
  seq.sortWith(lessThan).filter(p)
  seq.sortBy(f).filter(p)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  var seq: Seq[Int]
  seq.filter(p).sortWith(lessThan)
  seq.filter(p).sortBy(f)
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnzipSingleElement" defaultSeverity="WARNING" displayName="解压缩以提取单个元素" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告用于提取单个元素的 &lt;code&gt;unzip&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;该快速修复会将其替换为 &lt;code&gt;map&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
Seq((1, 11), (2, 22)).unzip._1
Seq((1, 11, 111), (2, 22, 222)).unzip3._1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
Seq((1, 11), (2, 22)).map(_._1)
Seq((1, 11, 111), (2, 22, 222)).map(_._1)
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="Import 和依赖项" path="JavaScript and TypeScript"><inspection shortName="JSUrlImportUsage" defaultSeverity="INFORMATION" displayName="使用了 URL 导入" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
检查 JavaScript 语言中使用过的 URL import。
建议下载指定的远程 URL 的模块。
此类关联使 IDE 可以提供正确的代码补全和导航。
&lt;br/&gt;
&lt;br/&gt;
只有 JavaScript 语言中的 ECMAScript 模块支持 import 说明符中的 URL。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PackageJsonMismatchedDependency" defaultSeverity="WARNING" displayName="package.json 中的依赖关系不匹配" enabled="false" language="JSON" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告未安装或与指定的&lt;a href="https://docs.npmjs.com/about-semantic-versioning"&gt;版本范围&lt;/a&gt;不匹配的 package.json 中的依赖项。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NpmUsedModulesInstalled" defaultSeverity="WEAK WARNING" displayName="缺少模块依赖关系" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告未安装或未在 package.json 依赖项中列出的 &lt;code&gt;require()&lt;/code&gt; 调用或 &lt;code&gt;import&lt;/code&gt; 语句中的模块。
&lt;p&gt;建议安装此模块和/或将其包含到 package.json 中。&lt;/p&gt;
&lt;p&gt;对于 &lt;code&gt;require()&lt;/code&gt; 调用，仅在&lt;em&gt;Node.js Core&lt;/em&gt; JavaScript 库范围内的文件中起作用。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ES6UnusedImports" defaultSeverity="WARNING" displayName="未使用的 import" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告冗余的 &lt;code&gt;import&lt;/code&gt; 语句。
如果源文件中没有使用导入的符号，通常就会出现这种情况。
为避免副作用，可以考虑使用 bare import &lt;code&gt;import 'packageName'&lt;/code&gt; 来代替常规 import。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UpdateDependencyToLatestVersion" defaultSeverity="INFORMATION" displayName="将 package.json 依赖项更新为最新版本" enabled="false" language="JSON" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
建议将 package.json 依赖项升级到最新版本，并忽略指定的版本。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ES6CheckImport" defaultSeverity="WEAK WARNING" displayName="未解析的已导入名称" enabled="false" language="ECMAScript 6" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;import&lt;/code&gt; 声明中未解析的名称或绑定。
&lt;p&gt;将忽略 TypeScript 代码。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSXNamespaceValidation" defaultSeverity="INFORMATION" displayName="缺少 JSX 命名空间" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告未导入命名空间的 JSX 构造的用法。
将命名空间置于文件范围中可以确保正确编译代码。
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="未使用的符号" path="JavaScript and TypeScript"><inspection shortName="JSUnusedGlobalSymbols" defaultSeverity="WARNING" displayName="未使用的全局符号" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告未使用的可以全局访问的 public 函数、变量、类或属性。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSUnusedLocalSymbols" defaultSeverity="WARNING" displayName="未使用的局部符号" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告本地可以访问的并且未使用的形参、局部变量、函数、类或 private 成员声明。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSUnusedAssignment" defaultSeverity="WARNING" displayName="未使用的赋值" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告赋值后从未使用其值的变量。&lt;br&gt;
建议移除未使用的变量以缩短代码并避免冗余分配。
&lt;p&gt;报告的情况如下：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;赋值后从未读取的变量。&lt;/li&gt;
  &lt;li&gt;在下次读取变量前，变量的值总是被另一个赋值覆盖。&lt;/li&gt;
  &lt;li&gt;变量的初始值设定项冗余（出于上述原因之一）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="详细或冗余的代码结构" path="Java"><inspection shortName="RedundantLengthCheck" defaultSeverity="WARNING" displayName="冗余的数组长度检查" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告数组迭代后不必要的数组长度检查。 当数组长度为零时。迭代将被跳过，因此没有必要显式地检查长度。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void f(String[] array) {
    if (array.length != 0) { // 不必要的检查
      for (String str : array) {
        System.out.println(str);
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;建议使用快速修复来解开或移除长度检查：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void f(String[] array) {
    for (String str : array) {
      System.out.println(str);
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2022.3 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConditionCoveredByFurtherCondition" defaultSeverity="WARNING" displayName="条件由进一步的条件覆盖" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告由于后续条件完全覆盖而变得冗余的条件。
&lt;p&gt;例如，在 &lt;code&gt;value != -1 &amp;&amp; value &gt; 0&lt;/code&gt; 条件下，第一部分是冗余的：如果它为 false，那么第二部分也为 false。
或者在像 &lt;code&gt;obj != null &amp;&amp; obj instanceof String&lt;/code&gt; 这样的条件下，null 检查是冗余的，因为 &lt;code&gt;instanceof&lt;/code&gt; 运算符意味着非 null。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2018.3 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StringOperationCanBeSimplified" defaultSeverity="WARNING" displayName="冗余的 'String' 操作" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对 &lt;code&gt;toString()&lt;/code&gt; 或 &lt;code&gt;substring()&lt;/code&gt; 等可替换为更简单表达式的 &lt;code&gt;String&lt;/code&gt; 构造函数和方法的冗余调用。
&lt;p&gt;例如，在 &lt;code&gt;"string".substring(0)&lt;/code&gt;、&lt;code&gt;"string".toString()&lt;/code&gt; 或
&lt;code&gt;new StringBuilder().toString().substring(1,3)&lt;/code&gt; 等代码中，可以安全移除对这些方法的调用。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  System.out.println(new String("message"));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  System.out.println("message");
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  请注意，该快速修复会移除冗余的构造函数调用，这可能会影响 &lt;code&gt;String&lt;/code&gt; 引用相等。
  即使被认为是一种不好的做法，如果您仍需要保留，请禁止警告或使用检查设置来忽略冗余的 &lt;code&gt;String&lt;/code&gt; 构造函数调用。
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  请使用下方的&lt;b&gt;不报告 String 构造函数调用&lt;/b&gt;选项来不报告代码（如上例所示）。
  这将避免在使用 &lt;code&gt;new String()&lt;/code&gt; 调用保证不同对象相等性的代码中应用快速修复后改变与 &lt;code&gt;==&lt;/code&gt; 或 &lt;code&gt;!=&lt;/code&gt; 进行字符串比较的结果。
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;2018.1 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="OnlyOneElementUsed" defaultSeverity="WARNING" displayName="仅使用了一个元素" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告其中有且只有一个元素在创建时被查询的列表、数组和字符串。
此类表达式可能会在重构之后出现，并且通常可被替换为访问的元素。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  System.out.println(new int[] {1,2,3,4,5}[2]);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  System.out.println(3);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2022.3 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ExplicitArrayFilling" defaultSeverity="WARNING" displayName="显式数组填充" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以替换为 &lt;code&gt;Arrays.setAll()&lt;/code&gt; 或 &lt;code&gt;Arrays.fill()&lt;/code&gt; 调用的循环。
&lt;p&gt;如果项目或模块的语言级别为 8 或更高，则此检查建议将循环替换为 &lt;code&gt;Arrays.setAll()&lt;/code&gt;。
  您可以在任何语言级别将循环替换为 &lt;code&gt;Arrays.fill()&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  for (int i=0; i&amp;lt;array.length; i++) {
     array[i] = calc(i);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Arrays.setAll(array, this::calc);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2017.1 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ObviousNullCheck" defaultSeverity="WARNING" displayName="使用明显非 null 实参调用 null 检查方法" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告是否在明显为非 null 的值（例如，新创建的对象）上调用 null 检查方法（例如，&lt;code&gt;Objects.requireNonNull&lt;/code&gt; 或 &lt;code&gt;Assert.assertNotNull&lt;/code&gt;）。 这种检查是冗余的，可能表明存在编程错误。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  final String greeting = Objects.requireNonNull("Hi!");
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  final String greeting = "Hi!";
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;2017.2 最新变化&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DuplicateExpressions" defaultSeverity="WEAK WARNING" displayName="同一表达式存在多个匹配项" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
如果表达式的结果可以重用，则报告同一表达式在方法（或构造函数，或类初始值设定项）中的多次等效匹配项。
&lt;p&gt;
  如果表达式没有副作用并且其结果始终相同（就 &lt;code&gt;Object.equals()&lt;/code&gt; 而言），则会报告该表达式。
  此类表达式的示例是 &lt;code&gt;a + b&lt;/code&gt;、&lt;code&gt;Math.max(a, b)&lt;/code&gt;、&lt;code&gt;a.equals(b)&lt;/code&gt;、&lt;code&gt; s.substring(a,b)&lt;/code&gt;。 为确保结果始终相同，已验证表达式中使用的变量在表达式匹配项之间不会更改其值。&lt;/p&gt;
&lt;p&gt;
  此类表达式可能包含不可变的类（如 &lt;code&gt;String&lt;/code&gt;、&lt;code&gt;BigDecimal&lt;/code&gt; 等）和实用程序类（如 &lt;code&gt;Objects&lt;/code&gt;、&lt;code&gt;Math&lt;/code&gt;，&lt;code&gt;random()&lt;/code&gt; 除外）的方法。
  &lt;code&gt;Object.equals() &lt;/code&gt;、&lt;code&gt; Object.hashCode() &lt;/code&gt;、&lt;code&gt; Object.toString() &lt;/code&gt;、
   &lt;code&gt;Comparable.compareTo()&lt;/code&gt; 和 &lt;code&gt;Comparator.compare()&lt;/code&gt; 等常用方法也可以使用，因为没有任何可见的副作用。
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用&lt;b&gt;表达式复杂性阈值&lt;/b&gt;选项可指定最小表达复杂性阈值。 指定更大的数字将移除关于短表达式的报告。
&lt;/p&gt;
&lt;p&gt;
  如果 &lt;code&gt;Path.of&lt;/code&gt; 和 &lt;code&gt;Paths.get&lt;/code&gt; 调用具有相同的实参，则被视为等效调用。 无论其实参有多复杂，这些调用始终会被报告。 使用不同的复杂性阈值可以调整这种行为。
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;2018.3 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryDefault" defaultSeverity="WARNING" displayName="枚举 'switch' 语句的 'default' 不必要" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告由于所有可能的值都被 &lt;code&gt;case&lt;/code&gt; 分支覆盖而导致其 &lt;code&gt;default&lt;/code&gt; 分支绝不会被接受的枚举 &lt;code&gt;switch&lt;/code&gt; 语句或表达式。
&lt;p&gt;此类元素冗余，对于 &lt;code&gt;switch&lt;/code&gt; 表达式更是如此，因为当 &lt;code&gt;case&lt;/code&gt; 分支没有覆盖所有枚举常量时，它们不会进行编译。&lt;/p&gt;
&lt;p&gt;
  需要将语言级别配置为 14，才会报告 &lt;code&gt;switch&lt;/code&gt; 表达式。
&lt;/p&gt;
&lt;p&gt;提供的快速修复可以移除 &lt;code&gt;default&lt;/code&gt; 分支。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  enum E { A, B }
  int foo(E e) {
    return switch (e) {
      case A -&amp;gt; 1;
      case B -&amp;gt; 2;
      default -&amp;gt; 3;
    };
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  enum E { A, B }
  int foo(E e) {
    return switch (e) {
      case A -&amp;gt; 1;
      case B -&amp;gt; 2;
    };
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;使用&lt;b&gt;仅报告 switch 表达式&lt;/b&gt;选项可以仅报告 switch 表达式中的冗余 &lt;code&gt;default&lt;/code&gt; 分支。&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantComparatorComparing" defaultSeverity="WARNING" displayName="可以简化 Comparator 方法" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可简化的 &lt;code&gt;Comparator&lt;/code&gt; 连结符构造。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  c.thenComparing(Comparator.comparing(function));

  Comparator.comparing(Map.Entry::getKey);

  Collections.max(list, Comparator.reverseOrder());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  c.thenComparing(function)

  Map.Entry.comparingByKey()

  Collections.min(list, Comparator.naturalOrder());
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2018.1 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantCollectionOperation" defaultSeverity="WARNING" displayName="冗余的 'Collection' 操作" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告有更简单的替代方案的过于复杂的集合操作。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void f(String[] array, Collection&amp;lt;String&amp;gt; collection) {
    String[] strings = Arrays.asList(array).subList(0, 10).toArray(new String[0]);
    boolean contains = collection.containsAll(Collections.singletonList("x"));
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void f(String[] array, Collection&amp;lt;String&amp;gt; collection) {
    String[] strings = Arrays.copyOf(array, 10);
    boolean contains = collection.contains("x");
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2018.1 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryContinue" defaultSeverity="WARNING" displayName="不必要的 'continue' 语句" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告循环中最后能够到达的 &lt;code&gt;continue&lt;/code&gt; 语句。
这些 &lt;code&gt;continue&lt;/code&gt; 语句是不必要的语句，可以安全移除。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  for (String element: elements) {
    System.out.println();
    continue;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  for (String element: elements) {
    System.out.println();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该检查不分析 JSP 文件。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用&lt;b&gt;在具有 'else' 分支的 'if' 语句的 then 分支中忽略&lt;/b&gt;选项可以忽略位于完整 &lt;code&gt;if&lt;/code&gt;-&lt;code&gt;else&lt;/code&gt; 语句的 &lt;code&gt;then&lt;/code&gt; 分支中的 &lt;code&gt;continue&lt;/code&gt;语句。
&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  for (String element: elements) {
    if(element.isEmpty()) {
      continue;
    } else {
      //...
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SimplifyOptionalCallChains" defaultSeverity="WARNING" displayName="可以简化 Optional 调用链" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以简化的 &lt;b&gt;Optional&lt;/b&gt; 调用链。 下面是一些简化的例子：
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;optional.map(x -&gt; true).orElse(false)&lt;/code&gt; &amp;rarr; &lt;code&gt;optional.isPresent()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;optional.map(x -&gt; Optional.of(x.trim())).orElseGet(Optional::empty)&lt;/code&gt; &amp;rarr; &lt;code&gt;optional.map(String::trim)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;optional.map(x -&gt; (String)x).orElse(null)&lt;/code&gt; &amp;rarr; &lt;code&gt;(String) optional.orElse(null)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Optional.ofNullable(optional.orElse(null))&lt;/code&gt; &amp;rarr; &lt;code&gt;optional&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;val = optional.orElse(null); val != null ? val : defaultExpr &lt;/code&gt; &amp;rarr; &lt;code&gt;optional.orElse(defaultExpr)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;val = optional.orElse(null); if(val != null) expr(val) &lt;/code&gt; &amp;rarr; &lt;code&gt;optional.ifPresent(val -&gt; expr(val))&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2017.2 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantUnmodifiable" defaultSeverity="WARNING" displayName="不可修改的集合包装器的冗余用法" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告从 &lt;code&gt;Collections&lt;/code&gt; 类对不可修改的集合包装器的冗余调用。
&lt;p&gt;如果传递给不可修改的集合包装器的实参已不可变，此类包装会变得冗余。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  List&amp;lt;String&amp;gt; x = Collections.unmodifiableList(Collections.singletonList("abc"));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  List&amp;lt;String&amp;gt; x = Collections.singletonList("abc");
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为了检测返回不可修改集合的方法，该检查使用 &lt;code&gt;org.jetbrains.annotations.Unmodifiable&lt;/code&gt;
和 &lt;code&gt;org.jetbrains.annotations.UnmodifiableView&lt;/code&gt; 注解。
使用它们将检查扩展为您自己的不可修改的集合包装器。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2020.3 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="UnnecessaryLabelOnBreakStatement" defaultSeverity="WARNING" displayName="'break' 语句上的标签不必要" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告包含不必要标签的 &lt;code&gt;break&lt;/code&gt; 语句。 此类标签不会改变控制流，但会导致难以跟随代码。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  label:
  for(int i = 0; i &amp;lt; 10; i++) {
    if (shouldBreak()) break label;
    //doSmth
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  label:
  for(int i = 0; i &amp;lt; 10; i++) {
    if (shouldBreak()) break;
    //doSmth
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SimplifyStreamApiCallChains" defaultSeverity="WARNING" displayName="可以简化 Stream API 调用链" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以简化的流 API 调用链。
简化通常会在集合遍历期间避免一些临时对象创建操作。
&lt;p&gt;
  该检查将替换以下调用链：
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;collection.stream().forEach()&lt;/code&gt; &amp;rarr; &lt;code&gt;collection.forEach()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;collection.stream().collect(toList/toSet/toCollection())&lt;/code&gt; &amp;rarr; &lt;code&gt;new CollectionType&amp;lt;&amp;gt;(collection)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;collection.stream().toArray()&lt;/code&gt; &amp;rarr; &lt;code&gt;collection.toArray()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Arrays.asList().stream()&lt;/code&gt; &amp;rarr; &lt;code&gt;Arrays.stream()&lt;/code&gt; or &lt;code&gt;Stream.of()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;IntStream.range(0, array.length).mapToObj(idx -&gt; array[idx])&lt;/code&gt; &amp;rarr; &lt;code&gt;Arrays.stream(array)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;IntStream.range(0, list.size()).mapToObj(idx -&gt; list.get(idx))&lt;/code&gt; &amp;rarr; &lt;code&gt;list.stream()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Collections.singleton().stream()&lt;/code&gt; &amp;rarr; &lt;code&gt;Stream.of()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Collections.emptyList().stream()&lt;/code&gt; &amp;rarr; &lt;code&gt;Stream.empty()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;stream.filter().findFirst().isPresent()&lt;/code&gt; &amp;rarr; &lt;code&gt;stream.anyMatch()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;stream.collect(counting())&lt;/code&gt; &amp;rarr; &lt;code&gt;stream.count()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;stream.collect(maxBy())&lt;/code&gt; &amp;rarr; &lt;code&gt;stream.max()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;stream.collect(mapping())&lt;/code&gt; &amp;rarr; &lt;code&gt;stream.map().collect()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;stream.collect(reducing())&lt;/code&gt; &amp;rarr; &lt;code&gt;stream.reduce()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;stream.collect(summingInt())&lt;/code&gt; &amp;rarr; &lt;code&gt;stream.mapToInt().sum()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;stream.mapToObj(x -&gt; x)&lt;/code&gt; &amp;rarr; &lt;code&gt;stream.boxed()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;stream.map(x -&gt; {...; return x;})&lt;/code&gt; &amp;rarr; &lt;code&gt;stream.peek(x -&gt; ...)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;!stream.anyMatch()&lt;/code&gt; &amp;rarr; &lt;code&gt;stream.noneMatch()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;!stream.anyMatch(x -&gt; !(...))&lt;/code&gt; &amp;rarr; &lt;code&gt;stream.allMatch()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;stream.map().anyMatch(Boolean::booleanValue)&lt;/code&gt; &amp;rarr; &lt;code&gt;stream.anyMatch()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;IntStream.range(expr1, expr2).mapToObj(x -&gt; array[x])&lt;/code&gt; &amp;rarr; &lt;code&gt;Arrays.stream(array, expr1, expr2)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Collection.nCopies(count, ...)&lt;/code&gt; &amp;rarr; &lt;code&gt;Stream.generate().limit(count)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;stream.sorted(comparator).findFirst()&lt;/code&gt; &amp;rarr; &lt;code&gt;Stream.min(comparator)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;optional.orElseGet(() -&gt; { throw new ...; })&lt;/code&gt; &amp;rarr; &lt;code&gt;optional.orElseThrow()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
  请注意，在某些情况下，替换语义可能略有差异。 例如，&lt;code&gt;Collections.synchronizedList(...).stream().forEach()&lt;/code&gt; 不同步，而 &lt;code&gt;Collections.synchronizedList(...).forEach()&lt;/code&gt; 同步。
  另外，如果得到的元素为 &lt;code&gt;null&lt;/code&gt;，而 &lt;code&gt;Stream.max()&lt;/code&gt; 在本例中抛出 &lt;code&gt;NullPointerException&lt;/code&gt;，则 &lt;code&gt;collect(Collectors.maxBy())&lt;/code&gt; 返回空的 &lt;code&gt;Optional&lt;/code&gt;。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantTypeArguments" defaultSeverity="WARNING" displayName="冗余类型实参" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对显式实参类型可以忽略（因为编译器将明确推断出这些实参类型）的形参化方法的调用。
&lt;p&gt;
  使用冗余类型实参不必要，并且会降低代码的可读性。
&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  List&amp;lt;String&amp;gt; list = Arrays.&amp;lt;String&amp;gt;asList("Hello", "World");
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过快速修复可以移除冗余类型实参：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  List&amp;lt;String&amp;gt; list = Arrays.asList("Hello", "World");
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RedundantFileCreation" defaultSeverity="WARNING" displayName="创建冗余 'File' 实例" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
在只能使用 &lt;code&gt;String&lt;/code&gt; 路径的情况下，报告在下面的一种构造函数中创建的冗余 &lt;code&gt;File&lt;/code&gt;：&lt;code&gt;FileInputStream&lt;/code&gt;、&lt;code&gt;FileOutputStream&lt;/code&gt;、&lt;code&gt;FileReader&lt;/code&gt;、&lt;code&gt;FileWriter&lt;/code&gt;、&lt;code&gt;PrintStream&lt;/code&gt;、&lt;code&gt;PrintWriter&lt;/code&gt;、&lt;code&gt;Formatter&lt;/code&gt;。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
InputStream is = new FileInputStream(new File("in.txt"));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
InputStream is = new FileInputStream("in.txt");
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2020.3 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RedundantCompareToJavaTime" defaultSeverity="WARNING" displayName="带有 'java.time' 'compareTo()' 调用的表达式可以简化" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;!-- Copyright 2000-2022 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license. --&gt;
&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;java.time&lt;/code&gt; 与 &lt;code&gt;compareTo()&lt;/code&gt; 调用（可被替换为 &lt;code&gt;isAfter()&lt;/code&gt;、&lt;code&gt;isBefore()&lt;/code&gt; 或 &lt;code&gt;isEqual()&lt;/code&gt; 调用）的比较。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  LocalDate date1 = LocalDate.now();
  LocalDate date2 = LocalDate.now();
  boolean t = date1.compareTo(date2) &gt; 0;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  LocalDate date1 = LocalDate.now();
  LocalDate date2 = LocalDate.now();
  boolean t = date1.isAfter(date2);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2022.3 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantEscapeInRegexReplacement" defaultSeverity="WARNING" displayName="正则表达式替换字符串中的冗余转义" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告正则表达式方法的替换字符串中的冗余转义。
可以转义正则表达式替换字符串中的任何字符，但如果需要文字 &lt;code&gt;$&lt;/code&gt; 或 &lt;code&gt;\&lt;/code&gt;，则转义是必要的。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  string.replaceAll("a", "\\b");
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  string.replaceAll("a", "b");
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2022.3 最新变化&lt;/small&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryReturn" defaultSeverity="WARNING" displayName="不必要的 'return' 语句" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告返回 &lt;code&gt;void&lt;/code&gt; 的构造函数和方法结尾的 &lt;code&gt;return&lt;/code&gt; 语句。 这些语句冗余，可以安全移除。
&lt;p&gt;此检查不会在 JSP 文件中报告。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;void&lt;/b&gt; message() {
    System.out.println("Hello World");
    &lt;b&gt;return&lt;/b&gt;;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;void&lt;/b&gt; message() {
    System.out.println("Hello World");
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
使用&lt;b&gt;在具有 'else' 分支的 'if' 语句的 then 分支中忽略&lt;/b&gt;选项可以忽略也有 &lt;code&gt;else&lt;/code&gt; 分支的 &lt;code&gt;if&lt;/code&gt; 语句的 then 分支中的 &lt;code&gt;return&lt;/code&gt; 语句。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantStreamOptionalCall" defaultSeverity="WARNING" displayName="'Stream' 或 'Optional' 调用链中存在冗余步骤" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告冗余的 &lt;code&gt;Stream&lt;/code&gt; 或 &lt;code&gt;Optional&lt;/code&gt; 调用（例如 &lt;code&gt;map(x -&amp;gt; x)&lt;/code&gt;、&lt;code&gt;filter(x -&amp;gt; true)&lt;/code&gt;）或冗余的 &lt;code&gt;sorted()&lt;/code&gt; 或 &lt;code&gt;distinct()&lt;/code&gt; 调用。
&lt;!-- tooltip end --&gt;
&lt;p&gt;请注意，代码中 &lt;code&gt;streamOfIntegers.map(Integer::valueOf)&lt;/code&gt; 之类的映射操作效果与 &lt;code&gt;requireNonNull()&lt;/code&gt; 检查相同：如果该流包含 &lt;code&gt;null&lt;/code&gt;，它将抛出 &lt;code&gt;NullPointerException&lt;/code&gt;，因此并非绝对冗余。
  如果不希望报告此类情况，请禁用&lt;b&gt;报告 Stream.map() 中的冗余装箱&lt;/b&gt;选项。&lt;/p&gt;
&lt;p&gt;仅当项目或模块的语言级别为 8 或更高时，此检查才会报告。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NonStrictComparisonCanBeEquality" defaultSeverity="WEAK WARNING" displayName="非严格不等式 '&gt;=' 或 '&lt;=' 可以替换为 '=='" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告根据数据流分析只能对单个操作数值满足的不等条件。
此类条件可被替换为相等条件，以使代码更清晰。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;
  if (x &gt;= 10) {
    ...
    if (x &lt;= 10) { // can be replaced with 'x == 10'
    }
  }
&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2022.2 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantArrayCreation" defaultSeverity="WARNING" displayName="冗余数组创建" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告专门创建以作为 vararg 形参传递的数组。
&lt;p&gt;示例：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Arrays.asList(new String[]{"Hello", "world"})&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;该快速修复会将数组初始值设定项替换为单个实参：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Arrays.asList("Hello", "world")&lt;/code&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ReplaceOnLiteralHasNoEffect" defaultSeverity="WARNING" displayName="替换操作无效" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对 &lt;code&gt;String&lt;/code&gt; 方法 &lt;code&gt;replace()&lt;/code&gt;、&lt;code&gt;replaceAll()&lt;/code&gt; 或 &lt;code&gt;replaceFirst()&lt;/code&gt; 的无效调用。 当限定符和搜索字符串均为编译时常量，且在限定符中找不到搜索字符串时，可以保证此类调用无效。 这是冗余代码，可能表示存在错误。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  // 替换不起任何作用
  "hello".replace("$value$", value);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2022.1 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantClassCall" defaultSeverity="WARNING" displayName="冗余的 'isInstance()' 或 'cast()' 调用" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;java.lang.Class&lt;/code&gt; 方法的冗余调用。
&lt;p&gt;例如，&lt;code&gt;Xyz.class.isInstance(object)&lt;/code&gt; 可以替换为 &lt;code&gt;object instanceof Xyz&lt;/code&gt;。
首选 instanceof 检查：尽管性能与这些方法可能并无本质区别，但它们更好地指示了静态检查。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2018.2 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryLabelOnContinueStatement" defaultSeverity="WARNING" displayName="'continue' 语句上的不必要标签" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告包含不必要标签的 &lt;code&gt;continue&lt;/code&gt; 语句。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  LABEL:
  while (a &amp;gt; b) {
    System.out.println("Hello");
    //下面的代码是循环中的最后一条语句，
    //因此可以移除不必要的标签和 continue
    continue LABEL;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ExcessiveLambdaUsage" defaultSeverity="WARNING" displayName="过度使用 lambda" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告一个普通的 lambda 表达式被用在另一种方法中的情况，这种方法以相同方式运行，但只接受一个具体的值而不是 lambda。
&lt;p&gt;此检查有助于简化代码。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Optional.orElseGet(() -&gt; null)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Optional.orElse(null)
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2017.1 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantCompareCall" defaultSeverity="WARNING" displayName="冗余的 'compare()' 方法调用" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告其中的 &lt;code&gt;compare&lt;/code&gt; 方法多余的比较。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean result = Integer.compare(a, b) == 0;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean result = a == b;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2018.2 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryStringEscape" defaultSeverity="WARNING" displayName="不必要的转义字符" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;String&lt;/code&gt; 和 &lt;code&gt;char&lt;/code&gt; 文字（可选）中不必要的转义字符。
&lt;p&gt;不会报告转义的制表符字符 &lt;code&gt;\t&lt;/code&gt;，因为它原本不可见。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String s = "\'Scare\' quotes";
  String t = """
    All you need is\n\tLove\n""";
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String s = "'Scare' quotes";
  String t = """
    All you need is
    \tLove
  """;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2019.3 最新变化&lt;/small&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryBreak" defaultSeverity="WARNING" displayName="不必要的 'break' 语句" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告任何不必要的 &lt;code&gt;break&lt;/code&gt; 语句。
&lt;p&gt;如果 &lt;code&gt;break&lt;/code&gt; 语句在被移除后没有执行其他语句，则该语句是不必要的语句。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  switch (e) {
    case A -&amp;gt; {
        System.out.println("A");
        break; // 报告 'break' 为不必要的语句
    }
    default -&amp;gt; {
        System.out.println("Default");
        break; // 报告 'break' 为不必要的语句
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CastCanBeReplacedWithVariable" defaultSeverity="INFORMATION" displayName="转换可被替换为变量" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以替换为具有相同值的现有局部或模式变量的类型转换运算。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void foo(Object obj) {
    String s = (String) obj;
    System.out.println(((String) obj).trim());
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void foo(Object obj) {
    String s = (String) obj;
    System.out.println(s.trim());
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2022.3 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DuplicateBranchesInSwitch" defaultSeverity="WEAK WARNING" displayName="'switch' 中存在重复分支" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在不同分支中包含相同代码的 &lt;code&gt;switch&lt;/code&gt; 语句或表达式，并建议合并重复的分支。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;switch&lt;/b&gt; (n) {
    &lt;b&gt;case&lt;/b&gt; 1:
      System.out.println(n);
      &lt;b&gt;break&lt;/b&gt;;
    &lt;b&gt;case&lt;/b&gt; 2:
      System.out.println(n);
      &lt;b&gt;break&lt;/b&gt;;
    &lt;b&gt;default&lt;/b&gt;:
      System.out.println("default");
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;switch&lt;/b&gt; (n) {
    &lt;b&gt;case&lt;/b&gt; 1:
    &lt;b&gt;case&lt;/b&gt; 2:
      System.out.println(n);
      &lt;b&gt;break&lt;/b&gt;;
    &lt;b&gt;default&lt;/b&gt;:
      System.out.println("default");
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2019.1 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StringBufferReplaceableByString" defaultSeverity="WARNING" displayName="'StringBuilder' 可被替换为 'String'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以用单个 &lt;code&gt;String&lt;/code&gt; 串联替换的 &lt;code&gt;StringBuffer&lt;/code&gt;、&lt;code&gt;StringBuilder&lt;/code&gt; 或 &lt;code&gt;StringJoiner&lt;/code&gt; 的用法。
&lt;p&gt;使用 &lt;code&gt;String&lt;/code&gt; 串联会使代码更短更简单。&lt;/p&gt;
&lt;p&gt;
此检查仅在建议的替换不会导致现代 JVM 的性能显著下降时报告。 在许多情况下，&lt;code&gt;String&lt;/code&gt; 串联可能执行效果更好。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  StringBuilder result = new StringBuilder();
  result.append("i = ");
  result.append(i);
  result.append(";");
  return result.toString();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String result = "i = " + i + ";";
  return result;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SimplifyCollector" defaultSeverity="WARNING" displayName="可简化的收集器" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以简化的收集器。
&lt;p&gt;特别是，一些级联的 &lt;code&gt;groupingBy()&lt;/code&gt; 收集器可以使用更简单的 &lt;code&gt;toMap()&lt;/code&gt; 收集器来表示，这也可能会提高性能。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Collectors.groupingByConcurrent(String::length, Collectors.collectingAndThen(Collectors.maxBy(String::compareTo), Optional::get));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Collectors.toConcurrentMap(String::length, Function.identity(), BinaryOperator.maxBy(String::compareTo));
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;仅当项目或模块的语言级别为 8 或更高时，此检查才会报告。&lt;/p&gt;
&lt;p&gt;&lt;small&gt;2017.1 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ManualMinMaxCalculation" defaultSeverity="WARNING" displayName="手动最小值/最大值计算" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以使用 &lt;code&gt;Math.max()&lt;/code&gt; 或 &lt;code&gt;Math.min()&lt;/code&gt; 调用而不是手动计算两个数字的最小值或最大值的情况。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public int min(int a, int b) {
    return b &amp;lt; a ? b : a;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public int min(int a, int b) {
    return Math.min(a, b);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用&lt;b&gt;禁用 float 和 double&lt;/b&gt; 选项，可对 &lt;code&gt;double&lt;/code&gt; 和 &lt;code&gt;float&lt;/code&gt; 类型禁用此检查。
  由于该快速修复在处理 &lt;code&gt;NaN&lt;/code&gt; 时可能会略微更改 &lt;code&gt;float&lt;/code&gt;/
&lt;code&gt;double&lt;/code&gt; 类型的语义，因此这很有用。 然而，如果不考虑 &lt;code&gt;NaN&lt;/code&gt;，此快速修复在大多数情况下其实会修正难以捉摸的错误。
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;2019.2 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CastCanBeRemovedNarrowingVariableType" defaultSeverity="WARNING" displayName="太弱的变量类型导致不必要的转换" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
如果将变量类型范围缩小到转换类型，则报告可以移除的类型转换。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Object x = "  string  ";
  System.out.println(((String)x).trim());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
在这里，将 &lt;code&gt;x&lt;/code&gt; 的类型更改为 &lt;code&gt;String&lt;/code&gt; 使转换变得冗余。 建议的快速修复会更新变量类型并移除该变量上的所有冗余转换：
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String x = "  string  ";
  System.out.println(x.trim());
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2018.2 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RedundantCast" defaultSeverity="WARNING" displayName="冗余类型转换" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告不必要的转换表达式。

&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  static Object toObject(String s) {
    return (Object) s;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用下面的复选框可以忽略澄清转换，例如应为 &lt;code&gt;Object&lt;/code&gt; 的集合调用中的转换：
&lt;pre&gt;&lt;code&gt;
  static void removeFromList(List&amp;lt;String&amp;gt; l, Object o) {
    l.remove((String)o);
  } 
&lt;/code&gt;&lt;/pre&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ExcessiveRangeCheck" defaultSeverity="WARNING" displayName="过度范围检查" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告检查值范围的条件链，这些条件链可以简化为单个检查。
&lt;p&gt;该快速修复会将条件链替换为简化的表达式：&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  x &gt; 2 &amp;&amp; x &amp;lt; 4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  x == 3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  arr.length == 0 || arr.length &gt; 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  arr.length != 1
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2019.1 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="代码样式" path="Scala"><inspection shortName="ScalaStyle" defaultSeverity="WARNING" displayName="Scala 样式检查" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 Scalastyle 发现的问题。&lt;/p&gt;

&lt;p&gt;Scalastyle 可以检查您的 Scala 代码并指出它的潜在问题。&lt;/p&gt;

&lt;p&gt;将配置文件放在 &lt;code&gt;&amp;lt;project-root&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;lt;project-root&amp;gt;/.idea&lt;/code&gt; 或 &lt;code&gt;&amp;lt;project-root&amp;gt;/project&lt;/code&gt; 中。
&lt;p&gt;配置文件的名称可以是 &lt;code&gt;scalastyle-config.xml&lt;/code&gt; 或 &lt;code&gt;scalastyle_config.xml&lt;/code&gt;。
    测试源的配置文件可以被 &lt;code&gt;scalastyle-test-config.xml&lt;/code&gt; 或 &lt;code&gt;scalastyle_test_config.xml&lt;/code&gt; 重写。 &lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;a href="http://www.scalastyle.org/"&gt;Scalastyle&lt;/a&gt; 网站上提供了完整的文档。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="scala2InSource3" defaultSeverity="WARNING" displayName="包含 -Xsource:3 的 Scala 2 语法" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告使用 &lt;code&gt;-Xsource:3&lt;/code&gt; 时可以替换为 Scala 3 的 Scala 2 语法。&lt;/p&gt;

&lt;p&gt;在编译器标志 &lt;code&gt;-Xsource:3&lt;/code&gt; 下，&lt;code&gt;Scala 2.13.6&lt;/code&gt; 已支持以下 Scala 3 结构：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;使用 &lt;code&gt;?&lt;/code&gt; 代替 &lt;code&gt;_&lt;/code&gt; 作为通配符类型中的通配符标记&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;for&lt;/code&gt; 推导式的模式绑定中的 &lt;code&gt;case&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;*&lt;/code&gt; 在 import 中使用 * 代替 &lt;code&gt;_&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;在 import 别名中使用 &lt;code&gt;as&lt;/code&gt; 软关键字代替 &lt;code&gt;=&amp;gt;&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;允许使用 &lt;code&gt;open&lt;/code&gt; 和 &lt;code&gt;infix&lt;/code&gt; 修饰符&lt;/li&gt;
  &lt;li&gt;新的 Scala 3 vararg 接合语法&lt;/li&gt;
  &lt;li&gt;在复合类型中使用 &lt;code&gt;&amp;&lt;/code&gt; 代替 &lt;code&gt;with&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Java 16" path="Java/Java 语言级别迁移帮助"><inspection shortName="ClassCanBeRecord" defaultSeverity="WEAK WARNING" displayName="类可以为记录" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
建议用记录替换类。
&lt;p&gt;当您需要专注于建模不可变数据而不是可扩展行为时，检查会很有用。
  数据驱动方法的自动实现，例如 equals 和访问器，有助于消除样板。&lt;/p&gt;
&lt;p&gt;
  请注意，不是每个类都可以成为记录。 以下是一些限制：
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;类不能包含继承者，并且必须是一个顶级类。&lt;/li&gt;
  &lt;li&gt;类中的所有非 static 字段必须为 final。&lt;/li&gt;
  &lt;li&gt;不允许类包含实例初始值设定项、泛型构造函数或原生方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;要获取完整的限制列表，请参阅 &lt;a href="https://docs.oracle.com/javase/specs/jls/se15/preview/specs/records-jls.html"&gt;Oracle 文档&lt;/a&gt;。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Point {
    private final double x;
    private final double y;

    Point(double x, double y) {
      this.x = x;
      this.y = y;
    }

    double getX() {
      return x;
    }

    double getY() {
      return y;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  record Point(int x, int y) {
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;启用&lt;b&gt;建议重命名 get/is 访问器&lt;/b&gt;选项以允许将 &lt;code&gt;getX()&lt;/code&gt;/&lt;code&gt;isX()&lt;/code&gt; 访问器自动重命名为 &lt;code&gt;x()&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;
  使用&lt;b&gt;当转换使成员更易于访问时&lt;/b&gt;选项可指定转换是否可以违反类封装：
&lt;ul&gt;
  &lt;li&gt;选择&lt;b&gt;不建议转换&lt;/b&gt;选项则从不违反类封装&lt;/li&gt;
  &lt;li&gt;选择&lt;b&gt;在冲突视图中显示受影响的成员&lt;/b&gt;选项则应用转换并通知有关封装违规的问题&lt;/li&gt;
  &lt;li&gt;选择&lt;b&gt;无提示转换&lt;/b&gt;选项则无论是否存在封装违规问题，均可无提示应用转换&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用&lt;b&gt;禁止转换有以下注解的类&lt;/b&gt;列表可在要转换的类中排除其注解匹配指定模式的类。
&lt;/p&gt;
&lt;p&gt;仅当项目或模块的语言级别为 16 或更高时，此检查才会报告。&lt;/p&gt;
&lt;p&gt;&lt;small&gt;2020.3 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PatternVariableCanBeUsed" defaultSeverity="WARNING" displayName="可以使用模式变量" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以替换为模式变量的局部变量声明，模式变量通常更紧凑。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (obj instanceof String) {
    String str = (String) obj;
    System.out.println(str);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以替换为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (obj instanceof String str) {
    System.out.println(str);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;仅当项目或模块的语言级别为 16 或更高时，此检查才会报告。&lt;/p&gt;
&lt;p&gt;&lt;small&gt;2020.1 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Quarkus" path=""><inspection shortName="QsPrivateBeanMembersInspection" defaultSeverity="WARNING" displayName="带有 CDI 注解的 Bean 成员的错误访问修饰符" enabled="false" language="UAST" pluginId="com.intellij.quarkus" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;
  报告注入的字段、观察者方法和具有 private 访问权限的 Bean 构造函数。
&lt;/p&gt;
&lt;p&gt;
  CDI 成员的 private 访问级别增加了设置 Bean 所需的反射操作量。
  改用 package-private 或 protected 访问级别。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="QsYaml" defaultSeverity="WARNING" displayName="无效的 Quarkus YAML 配置" enabled="false" language="yaml" pluginId="com.intellij.quarkus" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 Quarkus 应用程序 YAML 配置文件中已弃用和无法解析的键和值。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="QsProperties" defaultSeverity="WARNING" displayName="无效的 Quarkus application.properties 配置" enabled="false" language="Properties" pluginId="com.intellij.quarkus" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;
  报告 Quarkus &lt;code&gt;.properties&lt;/code&gt; 配置文件中的语法错误、类型错误、已弃用和无法解析的键和值。
&lt;/p&gt;
&lt;p&gt;
  还高亮显示语法和类型错误。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SmallRyeConfigMappingMissingPrefixInspection" defaultSeverity="WARNING" displayName="'@ConfigMapping' 注解中缺少 'prefix' 特性值或者 'prefix' 特性值为空" enabled="false" language="UAST" pluginId="com.intellij.quarkus" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 &lt;code&gt;@io.smallrye.config.ConfigMapping&lt;/code&gt; 注解中的缺失或空 &lt;code&gt;prefix&lt;/code&gt; 特性值。&lt;/p&gt;
&lt;p&gt;IDE 需要正确指定的前缀才能查找配置属性。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="QsUndeclaredPathMimeTypesInspection" defaultSeverity="WEAK WARNING" displayName="'@Path' 的未声明 '@Produces' / '@Consumes' MIME 类型" enabled="false" language="UAST" pluginId="com.intellij.quarkus" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;
  报告没有 &lt;code&gt;@Produces&lt;/code&gt; 或 &lt;code&gt;@Consumes&lt;/code&gt; 注解的端点方法。
&lt;/p&gt;
&lt;p&gt;
  Quarkus 会分析这些注解并将包含在原生可执行文件中的 JAX-RS 提供程序的数量限制为应用程序所需的最少数量。 这减少了原生可执行文件的大小。
&lt;/p&gt;
&lt;p&gt;
  使用 &lt;code&gt;@Produces&lt;/code&gt; 或 &lt;code&gt;@Consumes&lt;/code&gt;（如果 HTTP 方法支持）注解方法或整个类，并指定目标 MIME 类型。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Micronaut Data" path="Micronaut"><inspection shortName="MicronautDataRepositoryMethodReturnType" defaultSeverity="WARNING" displayName="不正确的仓库方法返回值类型" enabled="false" language="UAST" pluginId="com.intellij.micronaut" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告不正确的 Micronaut Data &lt;a href="https://micronaut-projects.github.io/micronaut-data/latest/guide/#querying"&gt; 仓库方法返回类型&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;支持以下返回类型：&lt;/p&gt;
&lt;list&gt;
  &lt;li&gt;void&lt;/li&gt;
  &lt;li&gt;基元类型&lt;/li&gt;
  &lt;li&gt;简单类型&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;java.util.List &lt;/code&gt; 或任何常见的 &lt;code&gt; Iterable&lt;/code&gt; 类型&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;java.util.stream.Stream&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;java.util.Optional&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;io.micronaut.data.model.Page&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;io.micronaut.data.model.Slice&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;java.util.concurrent.Future&lt;/code&gt; 或 &lt;code&gt;java.util.concurrent.CompletableFuture&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;与 Reactive Streams 兼容的类型，例如 &lt;code&gt;Publisher&lt;/code&gt;、&lt;code&gt;Single&lt;/code&gt;、&lt;code&gt;Maybe&lt;/code&gt;、&lt;code&gt;Flux&lt;/code&gt;、&lt;code&gt;Mono&lt;/code&gt; 等
  &lt;/li&gt;
&lt;/list&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MicronautDataMethodInconsistency" defaultSeverity="ERROR" displayName="不正确的仓库方法声明" enabled="false" language="UAST" pluginId="com.intellij.micronaut" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告与&lt;a href="https://micronaut-projects.github.io/micronaut-data/latest/guide/#criteria"&gt;查询模式条件&lt;/a&gt;不匹配的 Micronaut Data 仓库方法。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MicronautDataRepositoryMethodParameters" defaultSeverity="WARNING" displayName="不正确的仓库方法形参" enabled="false" language="UAST" pluginId="com.intellij.micronaut" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告不正确的 Micronaut Data 仓库方法形参类型。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Person {
    private int id;
    private String lastname;
    private Address address;
  }

  public class Address {
    private int zipCode;
  }

  public interface CustomerRepository extends CrudRepository&amp;lt;Person, Integer&amp;gt; {
    List&amp;lt;Person&amp;gt; &lt;strong&gt;findByAddress&lt;/strong&gt;(String lastname);  // 应为 'Address' 类型
    List&amp;lt;Person&amp;gt; &lt;strong&gt;findByAddressZipCode&lt;/strong&gt;(String str);   // 应为 'int' 类型
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="嵌入式" path="Java/性能"><inspection shortName="OverlyLargePrimitiveArrayInitializer" defaultSeverity="WARNING" displayName="原始类型数组的过大初始值设定项" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告包含过多元素的基元数组的数组初始值设定项表达式。 此类初始值设定项可能会导致过大的类文件，因为必须生成代码才能初始化每个数组元素。 在内存或带宽受限的环境中，从资源文件加载大型基元数组可能更高效。
&lt;p&gt;
  此检查适用于 Java ME 和其他资源高度受限的环境。
  不加考虑地应用此检查的结果可能会对代码清晰度和设计产生负面影响。
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用该选项可以指定基元数组初始值设定项中允许的最大元素数。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AbstractClassWithOnlyOneDirectInheritor" defaultSeverity="WARNING" displayName="只有一个直接继承者的抽象类" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告仅具有一个直接继承者的 abstract 类。 虽然这种类可能会在内存受限或带宽受限的环境中提供令人钦佩的设计清晰度，但它们不必要地增加了应用程序的总占用空间。 请考虑将抽象类与其继承者合并。
&lt;p&gt;
  此检查适用于 Java ME 和其他资源高度受限的环境。
  不加考虑地应用此检查的结果可能会对代码清晰度和设计产生负面影响。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  abstract class Base {} // 将被报告

  class Inheritor extends Base {}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RecordStoreResource" defaultSeverity="WARNING" displayName="打开了 'RecordStore'，但未安全关闭" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告未在 &lt;code&gt;try&lt;/code&gt; 块前打开并在相应的 &lt;code&gt;finally&lt;/code&gt; 块中关闭的 Java ME &lt;code&gt;javax.microedition.rms.RecordStore&lt;/code&gt; 资源。
&lt;p&gt;如果在资源关闭之前抛出异常，此类资源可能会被无意泄漏。&lt;/p&gt;
&lt;p&gt;
  此检查适用于 Java ME 和其他资源高度受限的环境。
  不加考虑地应用此检查的结果可能会对代码清晰度和设计产生负面影响。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void foo1() throws RecordStoreException {
      RecordStore rs = RecordStore.openRecordStore("bar", true); // 警告
  }
  void foo2() throws RecordStoreException {
      RecordStore rs = RecordStore.openRecordStore("bar", true); // 无警告
      try {
          /* ... */
      } finally {
          rs.closeRecordStore();
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConnectionResource" defaultSeverity="WARNING" displayName="集合已打开，但未安全关闭" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告未在 &lt;code&gt;try&lt;/code&gt; 块前打开并在相应的 &lt;code&gt;finally&lt;/code&gt; 块中关闭的 Java ME &lt;code&gt;javax.microedition.io.Connection&lt;/code&gt; 资源。 如果在资源关闭之前抛出异常，此类资源可能会被无意泄漏。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void example() throws IOException {
    Connection c = Connector.open("foo");
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="InterfaceWithOnlyOneDirectInheritor" defaultSeverity="WARNING" displayName="只有一个直接继承者的接口" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告仅具有一个直接继承者的接口。
虽然此类接口可能会在内存受限或带宽受限的环境中提供令人钦佩的设计清晰度，但它们不必要地增加了应用程序的总占用空间。 请考虑将接口与其继承者合并。
&lt;p&gt;
  此检查适用于 Java ME 和其他资源高度受限的环境。
  不加考虑地应用此检查的结果可能会对代码清晰度和设计产生负面影响。
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MultiplyOrDivideByPowerOfTwo" defaultSeverity="WARNING" displayName="乘以或除以 2 的幂" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告整数值与可表示为 2 的幂的常量整数的乘积。 此类表达式可以替换为右移或左移运算，以提高性能。
&lt;p&gt;
  请注意，此检查与现代 JVM（例如 HotSpot 或 OpenJ9）无关，因为它们的 JIT 编译器将执行此优化。
  它可能只在一些不执行 JIT 编译的嵌入式系统中有用。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int y = x * 4;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;建议通过快速修复将乘法或除法运算替换为移位运算：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int y = x &amp;lt;&amp;lt; 2;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用该选项可使检查也报告二次幂除法。
  请注意，用移位替换二次幂除法不适用于负数。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MethodCallInLoopCondition" defaultSeverity="WARNING" displayName="循环条件下的方法调用" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告循环语句条件部分中的方法调用。 在资源高度受限的环境中，此类调用可能会对性能产生不利影响。
&lt;p&gt;
  不加考虑地应用此检查的结果可能会对代码清晰度和设计产生负面影响。
  此检查适用于 Java ME 和其他资源高度受限的环境。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String s = "example";
  for (int i = 0; i &amp;lt; s.length(); i++) {
    System.out.println(s.charAt(i));
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String s = "example";
  int length = s.length();
  for (int i = 0; i &amp;lt; length; i++) {
    System.out.println(s.charAt(i));
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用该选项可以忽略对常见 Java 迭代方法（例如 &lt;code&gt;Iterator.hasNext()&lt;/code&gt;）和具有副作用的已知方法（例如 &lt;code&gt;Atomic*.compareAndSet&lt;/code&gt;）的调用。
&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SingleCharacterStartsWith" defaultSeverity="WARNING" displayName="单个字符 'startsWith()' 或 'endsWith()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对 &lt;code&gt;String.startsWith()&lt;/code&gt; 和 &lt;code&gt;String.endsWith()&lt;/code&gt; 的调用，其中单字符字符串文字会作为实参传递。
&lt;p&gt;
  建议通过快速修复，使用更高效实现的 &lt;code&gt;String.charAt()&lt;/code&gt; 替换此类调用。
&lt;/p&gt;
&lt;p&gt;
  然而，由于额外的非零长度检查，此类更改的性能增益很小并且会降低代码的可读性，建议仅在紧密循环内应用该快速修复。
&lt;/p&gt;
&lt;p&gt;
  此检查适用于 Java ME 和其他资源高度受限的环境。
  不加考虑地应用此检查的结果可能会对代码清晰度和设计产生负面影响。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean startsWithX(String s) {
    return s.startsWith("x");
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean startsWithX(String s) {
    return !s.isEmpty() &amp;&amp; s.charAt(0) == 'x';
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ArrayLengthInLoopCondition" defaultSeverity="WARNING" displayName="循环条件下的 Array.length" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对循环语句条件部分中数组的 &lt;code&gt;.length&lt;/code&gt; 属性的访问。 在资源高度受限的环境中，此类调用可能会对性能产生不利影响。
&lt;p&gt;
  此检查适用于 Java ME 和其他资源高度受限的环境。
  不加考虑地应用此检查的结果可能会对代码清晰度和设计产生负面影响。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void foo(Object[] x) {
    for (int i = 0; i &amp;lt; x.length; i++) { /**/ }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CheckForOutOfMemoryOnLargeArrayAllocation" defaultSeverity="WARNING" displayName="没有 OutOfMemoryError 检查的大型数组分配" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告不检查 &lt;code&gt;java.lang.OutOfMemoryError&lt;/code&gt; 的大型数组分配。 在内存受限的环境中，可能应该检查大数据对象的分配是否存在内存耗尽的情况。
&lt;p&gt;
  此检查适用于 Java ME 和其他资源高度受限的环境。
  不加考虑地应用此检查的结果可能会对代码清晰度和设计产生负面影响。
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用该选项可以指定在未检查的数组分配中允许的最大元素数。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PrivateMemberAccessBetweenOuterAndInnerClass" defaultSeverity="WARNING" displayName="合成访问器调用" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告从嵌套类到外部类的非常量 &lt;code&gt;private&lt;/code&gt; 成员的引用。
对于此类引用，javac 将生成 package-private 合成访问器方法，这可能会危及安全性，因为看似为 private 的成员实际上可以从整个软件包中访问。
&lt;p&gt;
  嵌套类及其外部类会被编译为单独的类文件。 Java 虚拟机通常会禁止从一个类访问另一个类的 private 字段和方法。 为了实现从嵌套类访问外部类的 private 成员，javac 创建了一个 package-private 合成访问器方法。
&lt;/p&gt;
&lt;p&gt;
  通过将 &lt;code&gt;private&lt;/code&gt; 成员设为 package-private，实际的可访问性变成了显式。
  这也会节省少量内存，可能会在资源受限的环境中提高性能。
&lt;/p&gt;
&lt;p&gt;
  仅当项目或模块的语言级别为 10 或更低时，此检查才会报告。
  在 Java 11 和更高版本中，由于基于嵌套的访问控制 (&lt;a href="https://openjdk.org/jeps/181"&gt;JEP 181&lt;/a&gt;)，不再生成访问器方法。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Outer {
    private void x() {}

    class Inner {
      void y() {
        x();
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Outer {
    void x() {}

    class Inner {
      void y() {
        x();
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="工作表" path="Scala"><inspection shortName="AmmoniteUnresolvedLibrary" defaultSeverity="WARNING" displayName="Ammonite 未解析 import" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告并帮助修正 &lt;b&gt;Ammonite&lt;/b&gt; 脚本中未解析的 import。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="WorksheetPackageDeclaration" defaultSeverity="ERROR" displayName="工作表软件包声明" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告工作表中使用的软件包声明。&lt;/p&gt;
&lt;p&gt;在 &lt;b&gt;REPL&lt;/b&gt; 模式下，软件包声明是无效语句。 在 &lt;b&gt;Plain&lt;/b&gt; 模式下，编译时会自动添加所需的软件包声明。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Android Lint: Accessibility" path=""><inspection shortName="AndroidLintKeyboardInaccessibleWidget" defaultSeverity="WARNING" displayName="Keyboard inaccessible widget" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Keyboard inaccessible widget&lt;br&gt;&lt;br&gt;A widget that is declared to be clickable but not declared to be focusable is not accessible via the keyboard. Please add the &lt;code&gt;focusable&lt;/code&gt; attribute as well.&lt;br&gt;&lt;br&gt;Issue id: KeyboardInaccessibleWidget&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintGetContentDescriptionOverride" defaultSeverity="ERROR" displayName="Overriding getContentDescription() on a View" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Overriding &lt;code&gt;getContentDescription()&lt;/code&gt; on a View&lt;br&gt;&lt;br&gt;Overriding &lt;code&gt;getContentDescription()&lt;/code&gt; may prevent some accessibility services from properly navigating content exposed by your view. Instead, call &lt;code&gt;setContentDescription()&lt;/code&gt; when the content description needs to be changed.&lt;br&gt;&lt;br&gt;Issue id: GetContentDescriptionOverride&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintContentDescription" defaultSeverity="WARNING" displayName="Image without contentDescription" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Image without &lt;code&gt;contentDescription&lt;/code&gt;&lt;br&gt;&lt;br&gt;Non-textual widgets like ImageViews and ImageButtons should use the &lt;code&gt;contentDescription&lt;/code&gt; attribute to specify a textual description of the widget such that screen readers and other accessibility tools can adequately describe the user interface.&lt;br/&gt;
&lt;br/&gt;
Note that elements in application screens that are purely decorative and do not provide any content or enable a user action should not have accessibility content descriptions. In this case, just suppress the lint warning with a tools:ignore="ContentDescription" attribute.&lt;br/&gt;
&lt;br/&gt;
Note that for text fields, you should not set both the &lt;code&gt;hint&lt;/code&gt; and the &lt;code&gt;contentDescription&lt;/code&gt; attributes since the hint will never be shown. Just set the &lt;code&gt;hint&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: ContentDescription&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/topics/ui/accessibility/apps#special-cases"&gt;https://developer.android.com/guide/topics/ui/accessibility/apps#special-cases&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintLabelFor" defaultSeverity="WARNING" displayName="Missing accessibility label" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing accessibility label&lt;br&gt;&lt;br&gt;Editable text fields should provide an &lt;code&gt;android:hint&lt;/code&gt; or, provided your &lt;code&gt;minSdkVersion&lt;/code&gt; is at least 17, they may be referenced by a view with a &lt;code&gt;android:labelFor&lt;/code&gt; attribute.&lt;br/&gt;
&lt;br/&gt;
When using &lt;code&gt;android:labelFor&lt;/code&gt;, be sure to provide an &lt;code&gt;android:text&lt;/code&gt; or an &lt;code&gt;android:contentDescription&lt;/code&gt;.&lt;br/&gt;
&lt;br/&gt;
If your view is labeled but by a label in a different layout which includes this one, just suppress this warning from lint.&lt;br&gt;&lt;br&gt;Issue id: LabelFor&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintClickableViewAccessibility" defaultSeverity="WARNING" displayName="Accessibility in Custom Views" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Accessibility in Custom Views&lt;br&gt;&lt;br&gt;If a &lt;code&gt;View&lt;/code&gt; that overrides &lt;code&gt;onTouchEvent&lt;/code&gt; or uses an &lt;code&gt;OnTouchListener&lt;/code&gt; does not also implement &lt;code&gt;performClick&lt;/code&gt; and call it when clicks are detected, the &lt;code&gt;View&lt;/code&gt; may not handle accessibility actions properly. Logic handling the click actions should ideally be placed in &lt;code&gt;View#performClick&lt;/code&gt; as some accessibility services invoke &lt;code&gt;performClick&lt;/code&gt; when a click action should occur.&lt;br&gt;&lt;br&gt;Issue id: ClickableViewAccessibility&lt;/body&gt;&lt;/html&gt;</inspection></group><group name="通用" path="Reactive Streams"><inspection shortName="ReactiveStreamsThrowInOperator" defaultSeverity="WEAK WARNING" displayName="Throw 语句位于 Reactive 运算符中" enabled="false" language="UAST" pluginId="com.intellij.reactivestreams" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 Reactor/RxJava 运算符代码中的 &lt;code&gt;throw&lt;/code&gt; 表达式。&lt;/p&gt;
&lt;p&gt;从 Reactor/RxJava 运算符抛出异常表明可能存在问题，因为您可以返回“类似于 Reactive”的错误：从 &lt;code&gt;flatMap()&lt;/code&gt; 的 &lt;code&gt;Mono.error()&lt;/code&gt; 或 &lt;code&gt;Flowable.error()&lt;/code&gt;，或者从 Reactor 的 &lt;code&gt;handle()&lt;/code&gt; 运算符调用 &lt;code&gt;sink.error()&lt;/code&gt;。
&lt;/p&gt;
&lt;p&gt;
此外，Reactor 工厂方法允许在没有任何错误的情况下返回已检查的异常，而在没有 &lt;code&gt;Exceptions&lt;/code&gt; 类的情况下抛出此类异常会导致编译错误。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
Flux.just(1, 2, 3).flatMap(i -&gt; {
            throw new RuntimeException();
        })
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
Flux.just(1, 2, 3).flatMap(i -&gt; {
            return Flux.error(new RuntimeException());
        })
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2019.3 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReactiveStreamsPublisherImplementation" defaultSeverity="WARNING" displayName="类实现发布者" enabled="false" language="UAST" pluginId="com.intellij.reactivestreams" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告直接实现 &lt;code&gt;Publisher&lt;/code&gt; 接口的类。&lt;/p&gt;
&lt;p&gt;考虑使用来自 RxJava、Reactor 或 Mutiny 的 static 生成器，例如&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;Flux.just()&lt;/code&gt;、&lt;code&gt;Flux.create()&lt;/code&gt;、&lt;code&gt;Flux.generate()&lt;/code&gt;、&lt;code&gt;Flux.from()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Mono.create()&lt;/code&gt;、&lt;code&gt;Mono.from()&lt;/code&gt;、&lt;code&gt;Mono.just()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Flowable.just()&lt;/code&gt;、&lt;code&gt;Flowable.from()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Maybe.just()&lt;/code&gt;、&lt;code&gt;Maybe.from()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Multi.createFrom()&lt;/code&gt;, &lt;code&gt;Multi.createBy()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Uni.createFrom()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReactiveStreamsNullableInLambdaInTransform" defaultSeverity="WARNING" displayName="在转换方法中从 lambda 返回 null 或可为 null 的内容" enabled="false" language="UAST" pluginId="com.intellij.reactivestreams" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告可能在 Reactive Streams 链中返回 &lt;code&gt;null&lt;/code&gt; 的转换操作。&lt;/p&gt;

&lt;p&gt;
  Reactive Streams 不支持可 null 值，因为这些值会导致此类代码失败。
  该快速修复会建议将 &lt;code&gt;map()&lt;/code&gt; 替换为 &lt;code&gt;mapNotNull&lt;/code&gt;，从而忽略异常。
&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;repository.findWithTailableCursorBy()
    .map(e -&gt; (Person)null)
    .doOnNext(System.out::println)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;repository.findWithTailableCursorBy()
    .mapNotNull(e -&gt; (Person)null)
    .doOnNext(System.out::println)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;small&gt;2019.3 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReactiveStreamsUnusedPublisher" defaultSeverity="WARNING" displayName="未使用的发布者" enabled="false" language="UAST" pluginId="com.intellij.reactivestreams" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告未使用的 &lt;code&gt;Publisher&lt;/code&gt; 实例。&lt;/p&gt;
&lt;p&gt;
  要使用生成新的 &lt;code&gt;Publisher&lt;/code&gt; 实例的运算符（返回 Mono/Flux/Flowable 的 Mono/Flux/Flowable 对象的方法），您必须通过 &lt;code&gt;subscribe()&lt;/code&gt; 订阅创建的 &lt;code&gt;Publisher&lt;/code&gt;。
&lt;/p&gt;
&lt;p&gt;
  使用工厂（例如，&lt;code&gt;Mono.just()&lt;/code&gt;）而不订阅返回的 &lt;code&gt;Publisher&lt;/code&gt;，会创建一个从未使用的对象，并被视为不必要的内存分配。
&lt;/p&gt;
&lt;p&gt;
  例如，&lt;code&gt;Mono.just(1, 2, 3).map(i -&gt; i + 3)&lt;/code&gt; 不会被执行，除非您订阅了此 &lt;code&gt;Publisher&lt;/code&gt;，或者除非您通过应用运算符生成新的 &lt;code&gt;Publisher&lt;/code&gt; 并订阅它。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;未使用的 &lt;code&gt;Flux&lt;/code&gt; 实例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
Flux.just(1, 2, 3);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用者使用的 &lt;code&gt;Flux&lt;/code&gt; 实例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
Flux.just(1, 2, 3).subscribe(System.out::println);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不会报告对使用 Error Prone 或 AssertJ 的 &lt;code&gt;@CanIgnoreReturnValue&lt;/code&gt; 注解进行注解的方法的调用。
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2019.3 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReactiveStreamsSubscriberImplementation" defaultSeverity="WARNING" displayName="类实现订阅者" enabled="false" language="UAST" pluginId="com.intellij.reactivestreams" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告直接实现 &lt;code&gt;Subscriber&lt;/code&gt; 接口的类。&lt;/p&gt;
&lt;p&gt;考虑使用来自 RxJava、Reactor 或 Mutiny 的 static 生成器，例如&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;Flux.just()&lt;/code&gt;、&lt;code&gt;Flux.create()&lt;/code&gt;、&lt;code&gt;Flux.generate()&lt;/code&gt;、&lt;code&gt;Flux.from()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Mono.create()&lt;/code&gt;、&lt;code&gt;Mono.from()&lt;/code&gt;、&lt;code&gt;Mono.just()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Flowable.just()&lt;/code&gt;、&lt;code&gt;Flowable.from()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Maybe.just()&lt;/code&gt;、&lt;code&gt;Maybe.from()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Multi.createFrom()&lt;/code&gt;, &lt;code&gt;Multi.createBy()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Uni.createFrom()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReactiveStreamsTooLongSameOperatorsChain" defaultSeverity="WARNING" displayName="相同方法链过长" enabled="false" language="UAST" pluginId="com.intellij.reactivestreams" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告长的 Reactive Streams 转换链。&lt;/p&gt;
&lt;p&gt;每个运算符方法调用，例如 &lt;code&gt;map()&lt;/code&gt; 或 &lt;code&gt;filter()&lt;/code&gt;，都会为这些运算符创建一些对象。
  在每个订阅上对每个流元素调用长运算符链可能会导致性能开销。
  为避免这种情况，请尽可能将长运算符链合并为一个运算符调用。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
Flux.just(1, 2, 3)
        .map(it -&gt; it + 1)
        .map(it -&gt; it + 2)
        .map(it -&gt; it + 3)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
Flux.just(1, 2, 3)
        .map(it -&gt; it + 1 + 2 + 3)
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2019.3 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="JavaBeans 问题" path="Java"><inspection shortName="PropertyValueSetToItself" defaultSeverity="WARNING" displayName="属性值设置为自身" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告以相同的对象 getter 作为值的 setter 方法的调用。
该代码通常不执行任何工作，并且可能不是有意为之。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bean.setPayerId(bean.getPayerId());&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FieldHasSetterButNoGetter" defaultSeverity="WARNING" displayName="字段具有 setter 但没有 getter" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告含有 setter 方法但没有 getter 方法的字段。
&lt;p&gt;
  在某些 bean 容器中，当在 Java bean 规范中使用时，这些字段可能难以使用。
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SuspiciousGetterSetter" defaultSeverity="WARNING" displayName="可疑的 getter/setter" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告所访问字段的名称不是其预期名称的 getter 或 setter 方法。
例如，当 &lt;code&gt;getY()&lt;/code&gt; 返回 &lt;code&gt;x&lt;/code&gt; 字段时。 这通常可能表明复制粘贴错误。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Point {
    private int x;
    private int y;

    public void setX(int x) { // 警告：setter 'setX()' 分配字段 'y'
      this.y = x;
    }

    public int getY() { // 警告：getter 'getY()' 返回字段 'x'
      return x;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用下面的复选框可报告类中字段的名称与 getter 或 setter 的名称相匹配的情况。
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ClassWithoutNoArgConstructor" defaultSeverity="WARNING" displayName="没有无实参构造函数的类" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告没有构造函数（不带实参，即没有形参）的类。
无实参构造函数在某些上下文中是必需的。 例如，如果需要使用反射来创建类。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Bean {
    private String name;

    public Bean(String name) {
      this.name = name;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用下面的复选框可忽略没有显式构造函数的类。
  编译器为这种类提供了默认的无实参构造函数。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ClassWithoutConstructor" defaultSeverity="WARNING" displayName="不带构造函数的类" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告没有构造函数的类。
&lt;p&gt;某些编码标准禁止这种类。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Android Lint: Internationalization" path=""><inspection shortName="AndroidLintRtlEnabled" defaultSeverity="WARNING" displayName="Using RTL attributes without enabling RTL support" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using RTL attributes without enabling RTL support&lt;br&gt;&lt;br&gt;To enable right-to-left support, when running on API 17 and higher, you must set the &lt;code&gt;android:supportsRtl&lt;/code&gt; attribute in the manifest &lt;code&gt;&amp;lt;application&gt;&lt;/code&gt; element.&lt;br/&gt;
&lt;br/&gt;
If you have started adding RTL attributes, but have not yet finished the migration, you can set the attribute to false to satisfy this lint check.&lt;br&gt;&lt;br&gt;Issue id: RtlEnabled&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintEnforceUTF8" defaultSeverity="ERROR" displayName="Encoding used in resource files is not UTF-8" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Encoding used in resource files is not UTF-8&lt;br&gt;&lt;br&gt;XML supports encoding in a wide variety of character sets. However, not all tools handle the XML encoding attribute correctly, and nearly all Android apps use UTF-8, so by using UTF-8 you can protect yourself against subtle bugs when using non-ASCII characters.&lt;br/&gt;
&lt;br/&gt;
In particular, the Android Gradle build system will merge resource XML files assuming the resource files are using UTF-8 encoding.&lt;br&gt;&lt;br&gt;Issue id: EnforceUTF8&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintRtlSymmetry" defaultSeverity="WARNING" displayName="Padding and margin symmetry" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Padding and margin symmetry&lt;br&gt;&lt;br&gt;If you specify padding or margin on the left side of a layout, you should probably also specify padding on the right side (and vice versa) for right-to-left layout symmetry.&lt;br&gt;&lt;br&gt;Issue id: RtlSymmetry&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintByteOrderMark" defaultSeverity="ERROR" displayName="Byte order mark inside files" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Byte order mark inside files&lt;br&gt;&lt;br&gt;Lint will flag any byte-order-mark (BOM) characters it finds in the middle of a file. Since we expect files to be encoded with UTF-8 (see the EnforceUTF8 issue), the BOM characters are not necessary, and they are not handled correctly by all tools. For example, if you have a BOM as part of a resource name in one particular translation, that name will not be considered identical to the base resource's name and the translation will not be used.&lt;br&gt;&lt;br&gt;Issue id: ByteOrderMark&lt;br&gt;&lt;br&gt;&lt;a href="https://en.wikipedia.org/wiki/Byte_order_mark"&gt;https://en.wikipedia.org/wiki/Byte_order_mark&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintWeekBasedYear" defaultSeverity="WARNING" displayName="Week Based Year" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Week Based Year&lt;br&gt;&lt;br&gt;The &lt;code&gt;DateTimeFormatter&lt;/code&gt; pattern &lt;code&gt;YYYY&lt;/code&gt; returns the &lt;i&gt;week&lt;/i&gt; based year, not the era-based year. This means that 12/29/2019 will format to 2019, but 12/30/2019 will format to 2020!&lt;br/&gt;
&lt;br/&gt;
If you expected this to format as 2019, you should use the pattern &lt;code&gt;yyyy&lt;/code&gt; instead.&lt;br&gt;&lt;br&gt;Issue id: WeekBasedYear&lt;br&gt;&lt;br&gt;&lt;a href="https://stackoverflow.com/questions/46847245/using-datetimeformatter-on-january-first-cause-an-invalid-year-value"&gt;https://stackoverflow.com/questions/46847245/using-datetimeformatter-on-january-first-cause-an-invalid-year-value&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintHardcodedText" defaultSeverity="WARNING" displayName="Hardcoded text" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Hardcoded text&lt;br&gt;&lt;br&gt;Hardcoding text attributes directly in layout files is bad for several reasons:&lt;br/&gt;
&lt;br/&gt;
* When creating configuration variations (for example for landscape or portrait) you have to repeat the actual text (and keep it up to date when making changes)&lt;br/&gt;
&lt;br/&gt;
* The application cannot be translated to other languages by just adding new translations for existing string resources.&lt;br/&gt;
&lt;br/&gt;
There are quickfixes to automatically extract this hardcoded string into a resource lookup.&lt;br&gt;&lt;br&gt;Issue id: HardcodedText&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintConstantLocale" defaultSeverity="WARNING" displayName="Constant Locale" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Constant Locale&lt;br&gt;&lt;br&gt;Assigning &lt;code&gt;Locale.getDefault()&lt;/code&gt; to a constant is suspicious, because the locale can change while the app is running.&lt;br&gt;&lt;br&gt;Issue id: ConstantLocale&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintRelativeOverlap" defaultSeverity="WARNING" displayName="Overlapping items in RelativeLayout" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Overlapping items in RelativeLayout&lt;br&gt;&lt;br&gt;If relative layout has text or button items aligned to left and right sides they can overlap each other due to localized text expansion unless they have mutual constraints like &lt;code&gt;toEndOf&lt;/code&gt;/&lt;code&gt;toStartOf&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: RelativeOverlap&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintSetTextI18n" defaultSeverity="WARNING" displayName="TextView Internationalization" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;TextView Internationalization&lt;br&gt;&lt;br&gt;When calling &lt;code&gt;TextView#setText&lt;/code&gt;&lt;br/&gt;
* Never call &lt;code&gt;Number#toString()&lt;/code&gt; to format numbers; it will not handle fraction separators and locale-specific digits properly. Consider using &lt;code&gt;String#format&lt;/code&gt; with proper format specifications (&lt;code&gt;%d&lt;/code&gt; or &lt;code&gt;%f&lt;/code&gt;) instead.&lt;br/&gt;
* Do not pass a string literal (e.g. "Hello") to display text. Hardcoded text can not be properly translated to other languages. Consider using Android resource strings instead.&lt;br/&gt;
* Do not build messages by concatenating text chunks. Such messages can not be properly translated.&lt;br&gt;&lt;br&gt;Issue id: SetTextI18n&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/topics/resources/localization.html"&gt;https://developer.android.com/guide/topics/resources/localization.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintRtlHardcoded" defaultSeverity="WARNING" displayName="Using left/right instead of start/end attributes" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using left/right instead of start/end attributes&lt;br&gt;&lt;br&gt;Using &lt;code&gt;Gravity#LEFT&lt;/code&gt; and &lt;code&gt;Gravity#RIGHT&lt;/code&gt; can lead to problems when a layout is rendered in locales where text flows from right to left. Use &lt;code&gt;Gravity#START&lt;/code&gt; and &lt;code&gt;Gravity#END&lt;/code&gt; instead. Similarly, in XML &lt;code&gt;gravity&lt;/code&gt; and &lt;code&gt;layout_gravity&lt;/code&gt; attributes, use &lt;code&gt;start&lt;/code&gt; rather than &lt;code&gt;left&lt;/code&gt;.&lt;br/&gt;
&lt;br/&gt;
For XML attributes such as paddingLeft and &lt;code&gt;layout_marginLeft&lt;/code&gt;, use &lt;code&gt;paddingStart&lt;/code&gt; and &lt;code&gt;layout_marginStart&lt;/code&gt;. &lt;b&gt;NOTE&lt;/b&gt;: If your &lt;code&gt;minSdkVersion&lt;/code&gt; is less than 17, you should add &lt;b&gt;both&lt;/b&gt; the older left/right attributes &lt;b&gt;as well as&lt;/b&gt; the new start/end attributes. On older platforms, where RTL is not supported and the start/end attributes are unknown and therefore ignored, you need the older left/right attributes. There is a separate lint check which catches that type of error.&lt;br/&gt;
&lt;br/&gt;
(Note: For &lt;code&gt;Gravity#LEFT&lt;/code&gt; and &lt;code&gt;Gravity#START&lt;/code&gt;, you can use these constants even when targeting older platforms, because the &lt;code&gt;start&lt;/code&gt; bitmask is a superset of the &lt;code&gt;left&lt;/code&gt; bitmask. Therefore, you can use &lt;code&gt;gravity="start"&lt;/code&gt; rather than &lt;code&gt;gravity="left|start"&lt;/code&gt;.)&lt;br&gt;&lt;br&gt;Issue id: RtlHardcoded&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintRtlCompat" defaultSeverity="ERROR" displayName="Right-to-left text compatibility issues" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Right-to-left text compatibility issues&lt;br&gt;&lt;br&gt;API 17 adds a &lt;code&gt;textAlignment&lt;/code&gt; attribute to specify text alignment. However, if you are supporting older versions than API 17, you must &lt;b&gt;also&lt;/b&gt; specify a gravity or layout_gravity attribute, since older platforms will ignore the &lt;code&gt;textAlignment&lt;/code&gt; attribute.&lt;br&gt;&lt;br&gt;Issue id: RtlCompat&lt;/body&gt;&lt;/html&gt;</inspection></group><group name="代码样式问题" path="CSS"><inspection shortName="CssMissingSemicolon" defaultSeverity="WARNING" displayName="缺少分号" enabled="false" language="CSS" pluginId="com.intellij.css" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告声明末尾处缺少的分号。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CssRedundantUnit" defaultSeverity="WARNING" displayName="冗余度量单位" enabled="false" language="CSS" pluginId="com.intellij.css" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
在规范不要求提供单位的情况下，报告值为零的度量单位。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;width: 0px&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="XML" path=""><inspection shortName="CheckDtdRefs" defaultSeverity="ERROR" displayName="未解析的 DTD 引用" enabled="false" language="XML" pluginId="com.intellij" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告特定于 DTD 的引用（例如，对 XML 实体或 DTD 元素声明的引用）中的不一致。
适用于 DTD 和 XML 文件。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CheckXmlFileWithXercesValidator" defaultSeverity="ERROR" displayName="外部验证失败" enabled="false" language="XML" pluginId="com.intellij" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 Xerces 验证程序检测到的 XML 文件和指定 DTD 或架构的差异。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="XmlDeprecatedElement" defaultSeverity="WARNING" displayName="弃用的符号" enabled="false" language="XML" pluginId="com.intellij" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告弃用的 XML 元素或特性。
&lt;p&gt;可以通过 XML 注释或带有 'deprecated' 文本的文档标记来标记符号。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DeprecatedClassUsageInspection" defaultSeverity="WARNING" displayName="XML 中的弃用 API 用法" enabled="false" language="XML" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 XML 文件中已弃用的类和方法的用法。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="XmlUnboundNsPrefix" defaultSeverity="WARNING" displayName="未绑定的命名空间前缀" enabled="false" language="XML" pluginId="com.intellij" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 XML 中未绑定的命名空间前缀。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="XmlDefaultAttributeValue" defaultSeverity="WARNING" displayName="包含默认值的冗余特性" enabled="false" language="XML" pluginId="com.intellij" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对 XML 特性默认值的冗余赋值。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="XmlInvalidId" defaultSeverity="ERROR" displayName="未解析的 'id' 引用" enabled="false" language="XML" pluginId="com.intellij" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 XML 中未解析的 &lt;code&gt;id&lt;/code&gt; 引用。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CheckTagEmptyBody" defaultSeverity="WARNING" displayName="空元素内容" enabled="false" language="XML" pluginId="com.intellij" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告没有内容的 XML 元素。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &amp;lt;user&gt;
    &amp;lt;name&gt;&amp;lt;/name&gt;
  &amp;lt;/user&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &amp;lt;user&gt;
    &amp;lt;name/&gt;
  &amp;lt;/user&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="XmlUnusedNamespaceDeclaration" defaultSeverity="WARNING" displayName="未使用的架构声明" enabled="false" language="XML" pluginId="com.intellij" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 XML 中未使用的命名空间声明或位置提示。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="XmlHighlighting" defaultSeverity="ERROR" displayName="XML 高亮显示" enabled="false" language="XML" pluginId="com.intellij" pluginVersion="223.8836.41" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
报告批量代码检查结果中的 XML 验证问题。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="XmlDuplicatedId" defaultSeverity="ERROR" displayName="重复 'id' 特性" enabled="false" language="XML" pluginId="com.intellij" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 XML 中重复的 &lt;code&gt;id&lt;/code&gt; 特性。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="XmlWrongRootElement" defaultSeverity="ERROR" displayName="错误的根元素" enabled="false" language="XML" pluginId="com.intellij" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告与 &lt;code&gt;&amp;lt;doctype&amp;gt;&lt;/code&gt; 标记中指定的名称不同的根标记名称。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="XmlPathReference" defaultSeverity="ERROR" displayName="未解析的文件引用" enabled="false" language="XML" pluginId="com.intellij" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 XML 中未解析的文件引用。
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="控制流问题" path="Groovy"><inspection shortName="GroovyIfStatementWithIdenticalBranches" defaultSeverity="WARNING" displayName="具有相同分支的 if 语句" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告具有相同的 "then" 和 &lt;code&gt;else&lt;/code&gt; 分支的 &lt;code&gt;if&lt;/code&gt; 语句。
此类语句几乎肯定表明程序员出现错误。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
if (condition) {
  print "foo"
} else {
  print "foo"
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
print "foo"
&lt;/code&gt;
&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyLoopStatementThatDoesntLoop" defaultSeverity="WARNING" displayName="不循环的循环语句" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告语句体保证最多执行一次的 &lt;code&gt;for&lt;/code&gt; 或 &lt;code&gt;while&lt;/code&gt; 语句。 虽然可以有意编写此类语句，但它们通常表明存在错误。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
  for (int i in 0..&amp;lt;10) {
    return
  }
&lt;/code&gt;
&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyFallthrough" defaultSeverity="WARNING" displayName="'switch' 语句中的直落" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 switch 语句中的 &lt;i&gt;fallthrough&lt;/i&gt;。  虽然偶尔有用，但直落通常是无意为之，并且可能导致意外的错误。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
switch(n) {
  case 1:
    print 1
  case 2: // "case 1" 直落到 "case 2"。 从 "case 2" 开始的语句将在执行 "case 1" 后立即执行。
    print 2
    break
  default:
    print "Default"
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="GroovyIfStatementWithTooManyBranches" defaultSeverity="WARNING" displayName="具有过多分支的 if 语句" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告分支太多的 &lt;code&gt;if&lt;/code&gt; 语句。
此类语句可能令人困惑，并且通常表明设计抽象度不足。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
if (a) {
  print "foo"
} else if (b) {
  print "bar"
} else if (c) {
  print "baz"
} else if (d) {
  print "Too many branches"
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
 使用&lt;b&gt;最大分支数&lt;/b&gt;字段可指定预期的最大分支数量。
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovySwitchStatementWithNoDefault" defaultSeverity="WARNING" displayName="没有 default case 的 switch 语句" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告不包含 &lt;code&gt;default&lt;/code&gt; 标签的 &lt;code&gt;switch&lt;/code&gt; 语句。
&lt;p&gt;
  某些编码实践可能会坚持将此标签添加到所有 &lt;code&gt;switch&lt;/code&gt; 语句。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyBreak" defaultSeverity="WARNING" displayName="'break' 语句" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;switch&lt;/code&gt; 语句外的 &lt;code&gt;break&lt;/code&gt; 语句。
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyTrivialIf" defaultSeverity="WARNING" displayName="冗余的 'if' 语句" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以简化为单个赋值或 &lt;code&gt;return&lt;/code&gt; 语句的
&lt;code&gt;if&lt;/code&gt; 语句。

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (foo())
    return true;
  else
    return false;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  return foo();
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyConditionalCanBeConditionalCall" defaultSeverity="INFORMATION" displayName="三元表达式可被替换为安全调用" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以使用安全调用替换的三元表达式。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  def charArray(String s) {
      s == null ? null : s.toCharArray()
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  def charArray(String s) {
      s?.toCharArray()
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyContinue" defaultSeverity="WARNING" displayName="'continue' 语句" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;continue&lt;/code&gt; 语句。
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyTrivialConditional" defaultSeverity="WARNING" displayName="冗余条件表达式" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;x ? true : false&lt;/code&gt; 或类似形式并且可以大大简化的三元条件运算符。

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  foo() ? true : false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
foo()
&lt;/code&gt;&lt;/pre&gt;

&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyConditionalCanBeElvis" defaultSeverity="INFORMATION" displayName="三元表达式可被替换为 elvis 表达式" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以使用 elvis 表达式替换的三元表达式。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  def notNull(o, defaultValue) {
      o != null ? o : defaultValue
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  def notNull(o, defaultValue) {
      o ?: defaultValue
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyUnnecessaryReturn" defaultSeverity="WARNING" displayName="不必要的 'return' 语句" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告返回 &lt;code&gt;void&lt;/code&gt; 的构造函数和方法结尾的 &lt;code&gt;return&lt;/code&gt; 语句。 此类调用不必要，并且可以安全移除。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;void&lt;/b&gt; foo (String s){
      print(s)
      &lt;b&gt;return&lt;/b&gt;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;void&lt;/b&gt; foo (String s){
      print(s)
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;有关更多信息，请参阅 Java 中的相同检查。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyUnnecessaryContinue" defaultSeverity="WARNING" displayName="不必要的 'continue' 语句" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告循环中最后能够到达的 &lt;code&gt;continue&lt;/code&gt; 语句。
这些 &lt;code&gt;continue&lt;/code&gt; 语句是不必要的语句，可以安全移除。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  for(int i in array) {
      println(i)
      &lt;b&gt;continue&lt;/b&gt;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  for(int i in array) {
      println(i)
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;有关更多信息，请参阅 Java 中的相同检查。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyReturnFromClosureCanBeImplicit" defaultSeverity="WARNING" displayName="'return' 语句可以是隐式语句" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告闭包末尾可以设置为隐式的返回声明。
&lt;p&gt;
  Groovy 闭包隐式返回其中最后一条语句的值。
&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  def foo = {
    return 1
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  def foo = {
    1
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GrFinalVariableAccess" defaultSeverity="WARNING" displayName="final 变量访问" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告未初始化的 final 字段，以及 final 变量、形参和字段的无效赋值。
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyConstantIfStatement" defaultSeverity="WARNING" displayName="常量 if 语句" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告将布尔常量作为条件的 &lt;code&gt;if&lt;/code&gt; 语句。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (true) {
      // ...
  }
  if (false) {
      // ...
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyConditionalWithIdenticalBranches" defaultSeverity="WARNING" displayName="分支相同的三元表达式" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告包含相同 "then" 和 "else" 分支的三元表达式。 此类表达式几乎肯定表明程序员出现错误。
&lt;p&gt;该快速修复会将替换表达式替换为其 "then" 分支。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  condition ? a.foo() : a.foo()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  a.foo()
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyConstantConditional" defaultSeverity="WARNING" displayName="常量条件表达式" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告将布尔常量作为条件的条件表达式。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  true ? result1 : result2
  false ? result1 : result2
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="有效性问题" path="Gradle"><inspection shortName="DeprecatedConfigurations" defaultSeverity="WARNING" displayName="已弃用的配置" enabled="false" language="Groovy" pluginId="org.jetbrains.plugins.gradle" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;                                            
&lt;p&gt;检测已弃用的配置方法的用法。&lt;/p&gt;

  配置方法可能因为以下两个可能的原因之一而被弃用：
  &lt;ul&gt;
  &lt;li&gt;Gradle API 已经发展，因此应该避免选择旧方法；&lt;/li&gt;
  &lt;li&gt;某款插件提供了已弃用配置方法的更好版本。&lt;/li&gt;
  &lt;/ul&gt;
  最有可能的是，将会有替代已弃用方法的替代方法。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
plugins {
  id 'java'
}

dependencies {
  archive 'org.gradle.api:gradle:1.0' // reports 'archive'
}
&lt;/code&gt;&lt;/pre&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="IncorrectPluginDslStructure" defaultSeverity="ERROR" displayName="插件 DSL 结构" enabled="false" language="Groovy" pluginId="org.jetbrains.plugins.gradle" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;                                            
&lt;p&gt;检测 'plugins {}' 块前不允许的语句。 &lt;/p&gt;
由于 Gradle 插件 DSL 的限制，在 '&lt;code&gt;plugins {}&lt;/code&gt;' 块前只有一组受限的 Groovy 语句可用。 唯一的选项是 '&lt;code&gt;buildscript {}&lt;/code&gt;'、'&lt;code&gt;pluginManagement {}&lt;/code&gt;' 和其他 '&lt;code&gt;plugins {}&lt;/code&gt;'。 &lt;br&gt;
  &lt;a href="https://docs.gradle.org/current/userguide/plugins.html#plugins_dsl_limitations"&gt;请参阅 Gradle 文档&lt;/a&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
import foo.bar.Baz
plugins {} // reports 'plugins'
plugins {
  foo() // reporst 'foo'
  id 'java'
}
&lt;/code&gt;&lt;/pre&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="代码" path="Plugin DevKit"><inspection shortName="ActionIsNotPreviewFriendly" defaultSeverity="WARNING" displayName="字段会阻塞意图预览" enabled="false" language="UAST" pluginId="DevKit" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;LocalQuickFix&lt;/code&gt; 和 &lt;code&gt;IntentionAction&lt;/code&gt; 实现中阻止意图预览操作正常运行的字段。 此外，在类型已知是安全的字段上报告了过多的 &lt;code&gt;@SafeFieldForPreview&lt;/code&gt; 注解。
&lt;p&gt;
  意图预览是 IntelliJ 平台的一项功能，可以显示在应用快速修复或意图操作后对当前文件所做的更改。 为了在快速修复中实现这一功能，需要使用指向当前文件的非物理副本的自定义 &lt;code&gt;ProblemDescriptor&lt;/code&gt; 调用 &lt;code&gt;LocalQuickFix.generatePreview()&lt;/code&gt;。 在意图操作中，使用当前文件的非物理副本和虚部编辑器调用 &lt;code&gt;IntentionAction.generatePreview()&lt;/code&gt;
  通常，这些方法只委托给 &lt;code&gt;LocalQuickFix.applyFix()&lt;/code&gt; 或 &lt;code&gt;IntentionAction.invoke()&lt;/code&gt;。
  但是，某些快速修复可能会直接或间接引用物理元素并将其用于写入。 由于快速修复试图更新的是物理 PSI 而不是非物理 PSI，预览不起作用。
  为避免这种情况，&lt;code&gt;generatePreview()&lt;/code&gt; 的默认实现仅在快速修复或意图操作类的所有实例字段均具有安全类型（基元、字符串等）的情况下进行委托。
&lt;/p&gt;
&lt;p&gt;
  您可以通过多种方式修正此问题：
&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;
    如果该字段其实未存储任何 PSI 引用，或者该 PSI 仅用于读取，
您可以使用 &lt;code&gt;@SafeFieldForPreview&lt;/code&gt; 注解该字段。 如果字段类型永远无法存储任何可写入的 PSI 引用，则也可以使用 &lt;code&gt;@SafeTypeForPreview&lt;/code&gt;。
  &lt;/li&gt;
  &lt;li&gt;
    您可以重写 &lt;code&gt;getFileModifierForPreview()&lt;/code&gt; 方法，然后创建一个快速修复副本，将其重新绑定至作为形参提供的非物理文件副本。 使用 &lt;code&gt;PsiTreeUtil.findSameElementInCopy()&lt;/code&gt; 可以在提供的非物理副本中找到相应的 PSI 元素。
  &lt;/li&gt;
  &lt;li&gt;
    不要在字段中存储 PSI 引用，而应尽量从快速修复中的 &lt;code&gt;ProblemDescriptor.getPsiElement()&lt;/code&gt; 或意图操作中提供的文件/编辑器中提取所有必要的信息。
    您还可以继承抽象 &lt;code&gt;LocalQuickFixAndIntentionActionOnPsiElement&lt;/code&gt; 类并实现其 &lt;code&gt;invoke()&lt;/code&gt; 和 &lt;code&gt;isAvailable()&lt;/code&gt; 方法，这些方法具有
&lt;code&gt;startElement&lt;/code&gt; 和 &lt;code&gt;endElement&lt;/code&gt; 形参。 这些形参会自动映射到非物理文件副本。
  &lt;/li&gt;
  &lt;li&gt;
    您可以重写 &lt;code&gt;generatePreview()&lt;/code&gt; 方法并提供完全自定义的预览行为。
    例如，可以显示自定义 HTML 文档而不是实际预览，只要您在修改当前文件之外还进行了相应操作。
  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;
  此检查不会报告 &lt;code&gt;getFileModifierForPreview()&lt;/code&gt; 或 &lt;code&gt;generatePreview()&lt;/code&gt; 的自定义实现是否存在。 但是，这并不意味着实现正确且预览有效。
  请进行测试。 另请注意，预览结果是在后台线程中计算的，因此您无法在预览期间启动写入操作或执行任何需要写入操作的运算。 最后，如果 &lt;code&gt;startInWriteAction()&lt;/code&gt; 返回 &lt;code&gt;false&lt;/code&gt;，则不会自动生成预览。 在这种情况下，需要有自定义的 &lt;code&gt;generatePreview()&lt;/code&gt; 实现。
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2022.1 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ComponentRegistrationProblems" defaultSeverity="ERROR" displayName="组件类型不匹配" enabled="false" language="UAST" pluginId="DevKit" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告未正确注册的插件组件（操作和组件）。
&lt;p&gt;
  报告的问题如下：
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;操作/组件实现类为 abstract。&lt;/li&gt;
  &lt;li&gt;类在 plugin.xml 中被注册为操作，但不扩展 &lt;code&gt;AnAction&lt;/code&gt; 类。&lt;/li&gt;
  &lt;li&gt;操作类没有 public 无实参构造函数。
  &lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="QuickFixGetFamilyNameViolation" defaultSeverity="WARNING" displayName="QuickFix 的 getFamilyName() 实现不得依赖于特定上下文" enabled="false" language="UAST" pluginId="DevKit" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告使用上下文信息的 &lt;code&gt;QuickFix#getFamilyName()&lt;/code&gt;。
&lt;p&gt;
  此方法不得使用任何非静态信息。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UsePrimitiveTypes" defaultSeverity="WARNING" displayName="将 'PsiType#equals(Object)' 与基元类型结合使用" enabled="false" language="UAST" pluginId="DevKit" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告使用 &lt;code&gt;==&lt;/code&gt; 比较 &lt;code&gt;PsiPrimitiveType&lt;/code&gt; 实例。
&lt;p&gt;
  基元类型应使用 &lt;code&gt;equals&lt;/code&gt; 进行比较，因为 Java 8 类型注解也对其适用。
&lt;/p&gt;
&lt;p&gt;
  替换为 &lt;code&gt;equals()&lt;/code&gt; 调用。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MissingActionUpdateThread" defaultSeverity="WARNING" displayName="缺少 ActionUpdateThread" enabled="false" language="JVM" pluginId="DevKit" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告隐式声明已弃用且开销很大的 &lt;code&gt;ActionUpdateThread.OLD_EDT&lt;/code&gt; 模式的操作、操作组和其他 &lt;code&gt;ActionUpdateThreadAware&lt;code&gt;。

&lt;p&gt;
  当一个操作或一个操作组定义自己的 &lt;code&gt;update&lt;/code&gt; 方法时，IntelliJ 平台会尝试模仿在 UI 线程中调用 &lt;code&gt;update&lt;/code&gt; 和 &lt;code&gt;getChildren&lt;/code&gt; 方法的旧同步方式，并向其提供 &lt;code&gt;AnActionEvent.dataContext&lt;/code&gt; 中的所有数据。
  为此，它会预先在后台线程上缓存所有可能的数据（即使不需要）。
&lt;/p&gt;
&lt;p&gt;
  通过重写 &lt;code&gt;getActionUpdateThread&lt;/code&gt; 方法，提供两种新模式之一：&lt;code&gt;ActionUpdateThread.EDT&lt;/code&gt; 或 &lt;code&gt;ActionUpdateThread.BGT&lt;/code&gt;。
&lt;/p&gt;
&lt;p&gt;
  有关更多信息，请参阅 &lt;code&gt;ActionUpdateThread&lt;/code&gt; 文档。
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UndesirableClassUsage" defaultSeverity="WARNING" displayName="不需要的类用法" enabled="false" language="UAST" pluginId="DevKit" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告不需要的类（主要是 Swing 组件）的用法。
&lt;p&gt;
  快速修复将使用建议的 IntelliJ 平台替代版本进行替换。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="UnsafeReturnStatementVisitor" defaultSeverity="WARNING" displayName="不安全的 return 语句访问者" enabled="false" language="UAST" pluginId="DevKit" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;JavaRecursiveElementVisitor.visitReturnStatement()&lt;/code&gt; 的不安全用法。
&lt;p&gt;
  即使 &lt;code&gt;PsiReturnStatement&lt;/code&gt; 属于另一个 &lt;code&gt;PsiClass&lt;/code&gt; 或 &lt;code&gt;PsiLambdaExpression&lt;/code&gt;，也进行处理，这在大多数情况下是一个错误，访问者最可能应该实现 &lt;code&gt;visitClass()&lt;/code&gt; 和 &lt;code&gt;visitLambdaExpression()&lt;/code&gt; 方法。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="NonDefaultConstructor" defaultSeverity="ERROR" displayName="服务和扩展类的非默认构造函数" enabled="false" language="UAST" pluginId="DevKit" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告具有非默认（空）构造函数的扩展/服务类。
&lt;p&gt;
  只有在相应的方法中需要时，才应获取其他依赖项。
  允许使用在相应级别具有扩展/服务的 &lt;code&gt;Project&lt;/code&gt; 的构造函数。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ComponentNotRegistered" defaultSeverity="WARNING" displayName="组件/操作未注册" enabled="false" language="JVM" pluginId="DevKit" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告未在 &lt;code&gt;plugin.xml&lt;/code&gt; 描述符中注册的插件组件和操作。
&lt;p&gt;
  这在使用“创建类”意图时可简化新组件的开发，并且可以帮助跟踪潜在的过时组件。
&lt;/p&gt;
&lt;p&gt;
  提供的用于注册组件的快速修复将在 &lt;code&gt;plugin.xml&lt;/code&gt; 描述符中添加必要的注册。
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;配置检查：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;使用&lt;b&gt;检查操作&lt;/b&gt;选项可以关闭操作的检查，因为它们可能是有意创建的，并且可能是动态注册的。
  &lt;/li&gt;
  &lt;li&gt;使用&lt;b&gt;忽略非 public 类&lt;/b&gt;选项可以忽略 abstract 和非 public 类。&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LeakableMapKey" defaultSeverity="WARNING" displayName="映射键可能会泄漏" enabled="false" language="UAST" pluginId="DevKit" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在插件代码中将 &lt;code&gt;Language&lt;/code&gt; 或 &lt;code&gt;FileType&lt;/code&gt; 用作映射键。
&lt;p&gt;
  此类用法可能导致无法正确卸载插件。
&lt;/p&gt;
&lt;p&gt;
  请考虑使用 &lt;code&gt;String&lt;/code&gt; 作为键。
&lt;/p&gt;
&lt;p&gt;
  有关更多信息，请参阅 SDK 文档中的&lt;a href="https://plugins.jetbrains.com/docs/intellij/dynamic-plugins.html"&gt;动态插件&lt;/a&gt;。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SerializableCtor" defaultSeverity="WARNING" displayName="可序列化类中的非默认构造函数" enabled="false" language="UAST" pluginId="DevKit" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可序列化类中的非默认构造函数。
&lt;p&gt;
  平台的 &lt;code&gt;IonObjectSerializer&lt;/code&gt; 要求显式指定 &lt;code&gt;@PropertyMapping&lt;/code&gt;。
&lt;/p&gt;
&lt;p&gt;
  快速修复将为构造函数生成必要的 &lt;code&gt;@PropertyMapping&lt;/code&gt; 注解。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UseDPIAwareBorders" defaultSeverity="WARNING" displayName="使用 DPI 感知边界" enabled="false" language="UAST" pluginId="DevKit" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以简化的 &lt;code&gt;javax.swing.border.EmptyBorder&lt;/code&gt; 和 &lt;code&gt;JBUI.Borders.emptyXyz()&lt;/code&gt; 的用法。
&lt;p&gt;
  &lt;code&gt;EmptyBorder&lt;/code&gt; 实例非 DPI 感知，并且可能导致 UI 布局问题。
&lt;/p&gt;
&lt;p&gt;
  快速修复会使用 &lt;code&gt;JBUI.Borders.empty()&lt;/code&gt; 执行替换或简化表达式。
&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;
// 不良：
Border border1 = new EmptyBorder(1, 2, 3, 4);
Border border2 = new EmptyBorder(1, 2, 1, 2);
Border border3 = new EmptyBorder(1, 0, 0, 0);

// 优良：
Border border1 = JBUI.Borders.empty(1, 2, 3, 4);
Border border2 = JBUI.Borders.empty(1, 2);
Border border3 = JBUI.Borders.emptyTop(1);
&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="InspectionUsingGrayColors" defaultSeverity="WARNING" displayName="使用新的 Color(a,a,a)" enabled="false" language="UAST" pluginId="DevKit" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告用于创建灰色的 &lt;code&gt;java.awt.Color&lt;/code&gt; 的用法。
&lt;p&gt;
  快速修复&lt;b&gt;转换为 'Gray'&lt;/b&gt; 将改用 &lt;code&gt;com.intellij.ui.Gray&lt;/code&gt; 常量。
&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;
// 不良：
Color gray = new Color(37, 37, 37);

// 优良：
Color gray = Gray._37;
&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="UseDPIAwareInsets" defaultSeverity="WARNING" displayName="使用 DPI 感知嵌入" enabled="false" language="UAST" pluginId="DevKit" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以简化的 &lt;code&gt;java.awt.Insets&lt;/code&gt; 和 &lt;code&gt;JBUI.insetsXyz()&lt;/code&gt; 的用法。
&lt;p&gt;
  &lt;code&gt;Insets&lt;/code&gt; 实例非 DPI 感知，并且可能导致 UI 布局问题。
&lt;/p&gt;
&lt;p&gt;
  快速修复会使用 &lt;code&gt;JBUI.insets()&lt;/code&gt; 执行替换或简化表达式。
&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;
// 不良：
Insets insets1 = new Insets(1, 2, 3, 4);
Insets insets2 = new Insets(1, 2, 1, 2);
Insets insets3 = new Insets(1, 0, 0, 0);

// 优良：
Insets insets1 = JBUI.insets(1, 2, 3, 4);
Insets insets2 = JBUI.insets(1, 2);
Insets insets3 = JBUI.insetsTop(1);
&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="UsePluginIdEquals" defaultSeverity="WARNING" displayName="使用 'PluginId#equals(Object)'" enabled="false" language="UAST" pluginId="DevKit" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告使用 &lt;code&gt;==&lt;/code&gt; 比较 &lt;code&gt;PluginId&lt;/code&gt; 实例。
&lt;p&gt;
  替换为 &lt;code&gt;equals()&lt;/code&gt; 调用。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FileEqualsUsage" defaultSeverity="WARNING" displayName="File.equals() 用法" enabled="false" language="UAST" pluginId="DevKit" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;java.io.File.equals()/hashCode()/compareTo()&lt;/code&gt; 方法的用法。
&lt;p&gt;
  它们在 macOS 上不支持不区分大小写。
&lt;/p&gt;
&lt;p&gt;
  请改用 &lt;code&gt;com.intellij.openapi.util.io.FileUtil.filesEquals()/fileHashCode()/compareFiles()&lt;/code&gt; 方法。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="UseCouple" defaultSeverity="WARNING" displayName="使用 Couple 而不是 Pair" enabled="false" language="UAST" pluginId="DevKit" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以替换为 &lt;code&gt;Couple&amp;lt;T&amp;gt;&lt;/code&gt; 的 &lt;code&gt;Pair&amp;lt;T, T&amp;gt;&lt;/code&gt; 的用法。
&lt;p&gt;
  快速修复将执行替换。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnspecifiedActionsPlace" defaultSeverity="WARNING" displayName="未指定的操作位置" enabled="false" language="UAST" pluginId="DevKit" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告为 &lt;code&gt;ActionManager.createActionToolbar()&lt;/code&gt; 和 &lt;code&gt;ActionManager.createActionPopupMenu()&lt;/code&gt; 传递未指定的 &lt;code&gt;place&lt;/code&gt; 形参的情况。
&lt;p&gt;
  必须指定正确的 &lt;code&gt;place&lt;/code&gt; 才能通过 &lt;code&gt;AnActionEvent.getPlace()&lt;/code&gt; 区分 &lt;code&gt;update()/actionPerformed()&lt;/code&gt; 中操作的用法。
&lt;/p&gt;
&lt;p&gt;
示例：
&lt;pre&gt;
// 不良：
actionManager.createActionToolbar("", group, false);
actionManager.createActionToolbar("unknown", group, false);
actionManager.createActionPopupMenu(ActionPlaces.UNKNOWN, group);

// 优良：
actionManager.createActionToolbar("MyPlace", group, false);
actionManager.createActionPopupMenu(ActionPlaces.EDITOR_TOOLBAR, group);
&lt;/pre&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="UnsafeVfsRecursion" defaultSeverity="WARNING" displayName="不安全的 VFS 递归" enabled="false" language="UAST" pluginId="DevKit" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告递归方法中 &lt;code&gt;VirtualFile.getChildren()&lt;/code&gt; 的用法。
&lt;p&gt;
  对循环符号链接迭代时，这可能导致无限循环。
  请改用 &lt;code&gt;VfsUtilCore.visitChildrenRecursively()&lt;/code&gt;。
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
void processDirectory(VirtualFile dir) {
  for (VirtualFile file : dir.getChildren()) { // 不良
    if (!file.isDirectory()) {
      processFile(file);
    } else {
      processDirectory(file); // 递归调用
    }
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;
void processDirectory(VirtualFile dir) {
  VfsUtilCore.visitChildrenRecursively(dir, new VirtualFileVisitor&amp;lt;Void&gt;() { // 优良
    @Override
    public boolean visitFile(@NotNull VirtualFile file) {
      if (!file.isDirectory()) {
        processFile(file);
      }
      return true;
    }
  });
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="StatefulEp" defaultSeverity="WARNING" displayName="有状态扩展" enabled="false" language="JVM" pluginId="DevKit" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告处于潜在泄漏状态的扩展和快速修复。
&lt;p&gt;
  保留对 &lt;code&gt;PsiElement&lt;/code&gt;、&lt;code&gt;PsiReference&lt;/code&gt; 或 &lt;code&gt;Project&lt;/code&gt; 实例的引用可能导致内存泄漏。
&lt;/p&gt;
&lt;p&gt;
  理想情况下，它们应该是无状态的。
  对于快速修复，可将 &lt;code&gt;LocalQuickFixOnPsiElement&lt;/code&gt; 视为一个方便的基类。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PresentationAnnotation" defaultSeverity="ERROR" displayName="@Presentation 中的图标路径无效" enabled="false" language="UAST" pluginId="DevKit" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;com.intellij.ide.presentation.Presentation&lt;/code&gt; 注解中 &lt;code&gt;icon&lt;/code&gt; 特性的无效和弃用值。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MissingRecentApi" defaultSeverity="ERROR" displayName="在旧 IDE 中无法使用 IntelliJ API" enabled="false" language="UAST" pluginId="DevKit" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在比 &lt;code&gt;&amp;lt;idea-version&gt;&lt;/code&gt; &lt;code&gt;@since-build&lt;/code&gt; (&lt;code&gt;plugin.xml&lt;/code&gt;) 中指定的版本&lt;em&gt;更新&lt;/em&gt;的版本中引入的 IntelliJ Platform API 的用法。
&lt;p&gt;
  使用此类 API 可能导致插件与旧的 IDE 版本不兼容。
&lt;/p&gt;
&lt;p&gt;
  为了避免在旧 IDE 版本中运行插件时可能出现的问题，请相应地提高 &lt;code&gt;since-build&lt;/code&gt;，或移除此 API 的用法。
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;配置检查：&lt;/p&gt;
如果 &lt;code&gt;&amp;lt;idea-version&gt;&lt;/code&gt; &lt;code&gt;@since/until-build&lt;/code&gt; 特性在 &lt;code&gt;plugin.xml&lt;/code&gt; 中未指定，请显式设置 &lt;b&gt;Since&lt;/b&gt;/&lt;b&gt;Until&lt;/b&gt;。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PsiElementConcatenation" defaultSeverity="WARNING" displayName="使用 PsiElement 字符串表示生成新表达式是不正确的" enabled="false" language="JAVA" pluginId="DevKit" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告字符串中 &lt;code&gt;PsiElement&lt;/code&gt; 和 &lt;code&gt;PsiType&lt;/code&gt; 的直接用法。
&lt;p&gt;
  为 &lt;code&gt;PsiJavaParserFacade.createExpressionFromText()&lt;/code&gt;（或类似方法）构建字符串时，应改用 &lt;code&gt;PsiElement.getText()&lt;/code&gt;。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="IncorrectParentDisposable" defaultSeverity="WARNING" displayName="不正确的 parentDisposable 参数" enabled="false" language="UAST" pluginId="DevKit" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在插件代码中将 &lt;code&gt;Application&lt;/code&gt; 或 &lt;code&gt;Project&lt;/code&gt; 用作父级 &lt;code&gt;Disposable&lt;/code&gt;。
&lt;p&gt;
  此类用法可能导致无法正确卸载插件。
  请参阅 SDK 文档中的&lt;a
  href="https://plugins.jetbrains.com/docs/intellij/disposers.html?from=IncorrectParentDisposable#choosing-a-disposable-parent"&gt;选择可处置的父级&lt;/a&gt;。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="UseJBColor" defaultSeverity="WARNING" displayName="使用 Darcula 感知 JBColor" enabled="false" language="UAST" pluginId="DevKit" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;java.awt.Color&lt;/code&gt; 的用法。
&lt;p&gt;
  这可能无法检测到“深色”主题（例如，捆绑的“Darcula”），因而可能导致 UI 效果不佳。
&lt;/p&gt;
&lt;p&gt;
  快速修复会将用法替换为 &lt;code&gt;JBColor&lt;/code&gt;，后者可以定义“深色”颜色变体。
&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;
// 不良：
Color darkGreen = new Color(12, 58, 27);
Color blue = Color.BLUE;

// 优良：
Color darkGreen = new JBColor(12, 58, 27);
Color blue = JBColor.BLUE;
Color green = new JBColor(new Color(12, 58, 27), new Color(27, 112, 39));
&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="UElementAsPsi" defaultSeverity="WARNING" displayName="UElement 作为 PsiElement 的用法" enabled="false" language="UAST" pluginId="DevKit" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告将 UAST &lt;code&gt;UElement&lt;/code&gt; 作为 &lt;code&gt;PsiElement&lt;/code&gt; 的用法。
&lt;p&gt;
  以这种方式获取的 &lt;code&gt;PsiElement&lt;/code&gt; 不明确。
&lt;/p&gt;
&lt;p&gt;
  要获取“物理”&lt;code&gt;PsiElement&lt;/code&gt;，请使用 &lt;code&gt;UElementKt.getSourcePsiElement()&lt;/code&gt;，
  对于“模拟”Java 元素（&lt;code&gt;PsiClass&lt;/code&gt;、&lt;code&gt;PsiMethod&lt;/code&gt; 等）的行为的 &lt;code&gt;PsiElement&lt;/code&gt;，
  请使用 &lt;code&gt;UElementKt.getAsJavaPsiElement()&lt;/code&gt;。
&lt;/p&gt;
&lt;p&gt;
  请参阅 SDK 文档中的 &lt;a href="https://plugins.jetbrains.com/docs/intellij/uast.html"&gt;UAST - 统一抽象语法树&lt;/a&gt;。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnresolvedPluginConfigReference" defaultSeverity="ERROR" displayName="未解析的插件配置引用" enabled="false" language="UAST" pluginId="DevKit" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对插件配置元素的未解析引用。

&lt;h4&gt;扩展&lt;/h4&gt;
&lt;p&gt;
  使用未知 &lt;code&gt;id&lt;/code&gt; 引用扩展程序可能在运行时导致错误。
&lt;/p&gt;
&lt;p&gt;
  支持以下扩展点：
&lt;ul&gt;
  &lt;li&gt;资源包 &lt;code&gt;advanced.setting.*&lt;/code&gt; 键中的 &lt;code&gt;com.intellij.advancedSetting&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Experiments.isFeatureEnabled()/setFeatureEnabled()&lt;/code&gt; 中的 &lt;code&gt;com.intellij.experimentalFeature&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Notification&lt;/code&gt; 构造函数和 &lt;code&gt;NotificationGroupManager.getNotificationGroup()&lt;/code&gt; 中的 &lt;code&gt;com.intellij.notificationGroup&lt;/code&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Registry&lt;/code&gt; 方法 &lt;code&gt;key&lt;/code&gt; 形参中的 &lt;code&gt;com.intellij.registryKey&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;资源包 &lt;code&gt;toolwindow.stripe.*&lt;/code&gt; 键中的 &lt;code&gt;com.intellij.toolWindow&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;扩展点&lt;/h4&gt;
&lt;p&gt;
  在 &lt;code&gt;plugin.xml&lt;/code&gt; 中引用对应的 &lt;code&gt;&amp;lt;extensionPoint&gt;&lt;/code&gt; 声明的扩展点名称。
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;com.intellij.openapi.extensions.ExtensionPointName&lt;/code&gt; 构造函数和 &lt;code&gt;create()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;com.intellij.openapi.extensions.ProjectExtensionPointName&lt;/code&gt; 构造函数&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;com.intellij.openapi.util.KeyedExtensionCollector&lt;/code&gt; 和继承者构造函数&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UseVirtualFileEquals" defaultSeverity="WARNING" displayName="使用 'VirtualFile#equals(Object)'" enabled="false" language="UAST" pluginId="DevKit" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告使用 &lt;code&gt;==&lt;/code&gt; 比较 &lt;code&gt;VirtualFile&lt;/code&gt; 实例。
&lt;p&gt;
  替换为 &lt;code&gt;equals()&lt;/code&gt; 调用。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MissingAccessibleContext" defaultSeverity="WARNING" displayName="缺少可访问上下文" enabled="false" language="UAST" pluginId="DevKit" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告不提供无障碍功能上下文的 Swing 组件。
&lt;p&gt;
  此信息由屏幕阅读器使用。 如果不提供，则视障用户将无法访问该组件。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  ListCellRenderer&amp;lt;String&amp;gt; renderer = (list, val, index, sel, cell) -&gt; {
    JPanel panel = new JPanel();
    return panel;
  };
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  要修正此问题，您应该在返回的 &lt;code&gt;JPanel&lt;/code&gt; 上调用 &lt;code&gt;setAccessibleName()&lt;/code&gt; 或重写其 &lt;code&gt;getAccessibleContext()&lt;/code&gt; 方法。
&lt;/p&gt;
&lt;p&gt;
  返回的文本应反映组件的用途。 例如，在 &lt;code&gt;ListCellRenderer&lt;/code&gt; 的情况下，这将是菜单项的文本。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Android Lint: Usability" path=""><inspection shortName="AndroidLintSquareAndRoundTilePreviews" defaultSeverity="WARNING" displayName="TileProvider does not have round and square previews" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;TileProvider does not have round and square previews&lt;br&gt;&lt;br&gt;Tile projects should specify preview resources for different screen shapes. The preview resource is specified in the manifest under tile service. And you have to make sure they have resources for different screen shapes.&lt;br&gt;&lt;br&gt;Issue id: SquareAndRoundTilePreviews&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintGifUsage" defaultSeverity="WARNING" displayName="Using .gif format for bitmaps is discouraged" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using &lt;code&gt;.gif&lt;/code&gt; format for bitmaps is discouraged&lt;br&gt;&lt;br&gt;The &lt;code&gt;.gif&lt;/code&gt; file format is discouraged. Consider using &lt;code&gt;.png&lt;/code&gt; (preferred) or &lt;code&gt;.jpg&lt;/code&gt; (acceptable) instead.&lt;br&gt;&lt;br&gt;Issue id: GifUsage&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/topics/resources/drawable-resource.html#Bitmap"&gt;https://developer.android.com/guide/topics/resources/drawable-resource.html#Bitmap&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintBackButton" defaultSeverity="WARNING" displayName="Back button" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Back button&lt;br&gt;&lt;br&gt;According to the Android Design Guide,&lt;br/&gt;
&lt;br/&gt;
"Other platforms use an explicit back button with label to allow the user to navigate up the application's hierarchy. Instead, Android uses the main action bar's app icon for hierarchical navigation and the navigation bar's back button for temporal navigation."&lt;br/&gt;
&lt;br/&gt;
This check is not very sophisticated (it just looks for buttons with the label "Back"), so it is disabled by default to not trigger on common scenarios like pairs of Back/Next buttons to paginate through screens.&lt;br&gt;&lt;br&gt;Issue id: BackButton&lt;br&gt;&lt;br&gt;&lt;a href="https://material.io/design/"&gt;https://material.io/design/&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintNegativeMargin" defaultSeverity="WARNING" displayName="Negative Margins" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Negative Margins&lt;br&gt;&lt;br&gt;Margin values should be positive. Negative values are generally a sign that you are making assumptions about views surrounding the current one, or may be tempted to turn off child clipping to allow a view to escape its parent. Turning off child clipping to do this not only leads to poor graphical performance, it also results in wrong touch event handling since touch events are based strictly on a chain of parent-rect hit tests. Finally, making assumptions about the size of strings can lead to localization problems.&lt;br&gt;&lt;br&gt;Issue id: NegativeMargin&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintButtonCase" defaultSeverity="WARNING" displayName="Cancel/OK dialog button capitalization" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Cancel/OK dialog button capitalization&lt;br&gt;&lt;br&gt;The standard capitalization for OK/Cancel dialogs is "OK" and "Cancel". To ensure that your dialogs use the standard strings, you can use the resource strings @android:string/ok and @android:string/cancel.&lt;br&gt;&lt;br&gt;Issue id: ButtonCase&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintIconExtension" defaultSeverity="WARNING" displayName="Icon format does not match the file extension" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Icon format does not match the file extension&lt;br&gt;&lt;br&gt;Ensures that icons have the correct file extension (e.g. a &lt;code&gt;.png&lt;/code&gt; file is really in the PNG format and not for example a GIF file named &lt;code&gt;.png&lt;/code&gt;).&lt;br&gt;&lt;br&gt;Issue id: IconExtension&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintAlwaysShowAction" defaultSeverity="WARNING" displayName="Usage of showAsAction=always" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Usage of &lt;code&gt;showAsAction=always&lt;/code&gt;&lt;br&gt;&lt;br&gt;Using &lt;code&gt;showAsAction="always"&lt;/code&gt; in menu XML, or &lt;code&gt;MenuItem.SHOW_AS_ACTION_ALWAYS&lt;/code&gt; in Java code is usually a deviation from the user interface style guide.Use &lt;code&gt;ifRoom&lt;/code&gt; or the corresponding &lt;code&gt;MenuItem.SHOW_AS_ACTION_IF_ROOM&lt;/code&gt; instead.&lt;br/&gt;
&lt;br/&gt;
If &lt;code&gt;always&lt;/code&gt; is used sparingly there are usually no problems and behavior is roughly equivalent to &lt;code&gt;ifRoom&lt;/code&gt; but with preference over other &lt;code&gt;ifRoom&lt;/code&gt; items. Using it more than twice in the same menu is a bad idea.&lt;br/&gt;
&lt;br/&gt;
This check looks for menu XML files that contain more than two &lt;code&gt;always&lt;/code&gt; actions, or some &lt;code&gt;always&lt;/code&gt; actions and no &lt;code&gt;ifRoom&lt;/code&gt; actions. In Java code, it looks for projects that contain references to &lt;code&gt;MenuItem.SHOW_AS_ACTION_ALWAYS&lt;/code&gt; and no references to &lt;code&gt;MenuItem.SHOW_AS_ACTION_IF_ROOM&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: AlwaysShowAction&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintIconColors" defaultSeverity="WARNING" displayName="Icon colors do not follow the recommended visual style" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Icon colors do not follow the recommended visual style&lt;br&gt;&lt;br&gt;Notification icons and Action Bar icons should only white and shades of gray. See the Android Design Guide for more details. Note that the way Lint decides whether an icon is an action bar icon or a notification icon is based on the filename prefix: &lt;code&gt;ic_menu_&lt;/code&gt; for action bar icons, &lt;code&gt;ic_stat_&lt;/code&gt; for notification icons etc. These correspond to the naming conventions documented in &lt;a href="https://material.io/design/iconography/"&gt;https://material.io/design/iconography/&lt;/a&gt;&lt;br&gt;&lt;br&gt;Issue id: IconColors&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintIconDensities" defaultSeverity="WARNING" displayName="Icon densities validation" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Icon densities validation&lt;br&gt;&lt;br&gt;Icons will look best if a custom version is provided for each of the major screen density classes (low, medium, high, extra high). This lint check identifies icons which do not have complete coverage across the densities.&lt;br/&gt;
&lt;br/&gt;
Low density is not really used much anymore, so this check ignores the ldpi density. To force lint to include it, set the environment variable &lt;code&gt;ANDROID_LINT_INCLUDE_LDPI=true&lt;/code&gt;. For more information on current density usage, see &lt;a href="https://developer.android.com/about/dashboards"&gt;https://developer.android.com/about/dashboards&lt;/a&gt;&lt;br&gt;&lt;br&gt;Issue id: IconDensities&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/practices/screens_support.html"&gt;https://developer.android.com/guide/practices/screens_support.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintIconMixedNinePatch" defaultSeverity="WARNING" displayName="Clashing PNG and 9-PNG files" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Clashing PNG and 9-PNG files&lt;br&gt;&lt;br&gt;If you accidentally name two separate resources &lt;code&gt;file.png&lt;/code&gt; and &lt;code&gt;file.9.png&lt;/code&gt;, the image file and the nine patch file will both map to the same drawable resource, &lt;code&gt;@drawable/file&lt;/code&gt;, which is probably not what was intended.&lt;br&gt;&lt;br&gt;Issue id: IconMixedNinePatch&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintIconDipSize" defaultSeverity="WARNING" displayName="Icon density-independent size validation" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Icon density-independent size validation&lt;br&gt;&lt;br&gt;Checks the all icons which are provided in multiple densities, all compute to roughly the same density-independent pixel (&lt;code&gt;dip&lt;/code&gt;) size. This catches errors where images are either placed in the wrong folder, or icons are changed to new sizes but some folders are forgotten.&lt;br&gt;&lt;br&gt;Issue id: IconDipSize&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintTypographyQuotes" defaultSeverity="WARNING" displayName="Straight quotes can be replaced with curvy quotes" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Straight quotes can be replaced with curvy quotes&lt;br&gt;&lt;br&gt;Straight single quotes and double quotes, when used as a pair, can be replaced by "curvy quotes" (or directional quotes). This can make the text more readable. Note that you should never use grave accents and apostrophes to quote, `like this'. (Also note that you should not use curvy quotes for code fragments.)&lt;br&gt;&lt;br&gt;Issue id: TypographyQuotes&lt;br&gt;&lt;br&gt;&lt;a href="https://en.wikipedia.org/wiki/Quotation_mark"&gt;https://en.wikipedia.org/wiki/Quotation_mark&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintConvertToWebp" defaultSeverity="WARNING" displayName="Convert to WebP" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Convert to WebP&lt;br&gt;&lt;br&gt;The WebP format is typically more compact than PNG and JPEG. As of Android 4.2.1 it supports transparency and lossless conversion as well. Note that there is a quickfix in the IDE which lets you perform conversion.&lt;br/&gt;
&lt;br/&gt;
Previously, launcher icons were required to be in the PNG format but that restriction is no longer there, so lint now flags these.&lt;br&gt;&lt;br&gt;Issue id: ConvertToWebp&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintIconLocation" defaultSeverity="WARNING" displayName="Image defined in density-independent drawable folder" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Image defined in density-independent drawable folder&lt;br&gt;&lt;br&gt;The res/drawable folder is intended for density-independent graphics such as shapes defined in XML. For bitmaps, move it to &lt;code&gt;drawable-mdpi&lt;/code&gt; and consider providing higher and lower resolution versions in &lt;code&gt;drawable-ldpi&lt;/code&gt;, &lt;code&gt;drawable-hdpi&lt;/code&gt; and &lt;code&gt;drawable-xhdpi&lt;/code&gt;. If the icon &lt;b&gt;really&lt;/b&gt; is density independent (for example a solid color) you can place it in &lt;code&gt;drawable-nodpi&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: IconLocation&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/practices/screens_support.html"&gt;https://developer.android.com/guide/practices/screens_support.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintIconNoDpi" defaultSeverity="WARNING" displayName="Icon appears in both -nodpi and dpi folders" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Icon appears in both &lt;code&gt;-nodpi&lt;/code&gt; and dpi folders&lt;br&gt;&lt;br&gt;Bitmaps that appear in &lt;code&gt;drawable-nodpi&lt;/code&gt; folders will not be scaled by the Android framework. If a drawable resource of the same name appears &lt;b&gt;both&lt;/b&gt; in a &lt;code&gt;-nodpi&lt;/code&gt; folder as well as a dpi folder such as &lt;code&gt;drawable-hdpi&lt;/code&gt;, then the behavior is ambiguous and probably not intentional. Delete one or the other, or use different names for the icons.&lt;br&gt;&lt;br&gt;Issue id: IconNoDpi&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintTypographyOther" defaultSeverity="WARNING" displayName="Other typographical problems" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Other typographical problems&lt;br&gt;&lt;br&gt;This check looks for miscellaneous typographical problems and offers replacement                     sequences that will make the text easier to read and your application more                     polished.&lt;br&gt;&lt;br&gt;Issue id: TypographyOther&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintIconDuplicatesConfig" defaultSeverity="WARNING" displayName="Identical bitmaps across various configurations" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Identical bitmaps across various configurations&lt;br&gt;&lt;br&gt;If an icon is provided under different configuration parameters such as &lt;code&gt;drawable-hdpi&lt;/code&gt; or &lt;code&gt;-v11&lt;/code&gt;, they should typically be different. This detector catches cases where the same icon is provided in different configuration folder which is usually not intentional.&lt;br&gt;&lt;br&gt;Issue id: IconDuplicatesConfig&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintAppLinkUrlError" defaultSeverity="ERROR" displayName="URL not supported by app for Firebase App Indexing" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;URL not supported by app for Firebase App Indexing&lt;br&gt;&lt;br&gt;Ensure the URL is supported by your app, to get installs and traffic to your app from Google Search.&lt;br&gt;&lt;br&gt;Issue id: AppLinkUrlError&lt;br&gt;&lt;br&gt;&lt;a href="https://g.co/AppIndexing/AndroidStudio"&gt;https://g.co/AppIndexing/AndroidStudio&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintIconExpectedSize" defaultSeverity="WARNING" displayName="Icon has incorrect size" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Icon has incorrect size&lt;br&gt;&lt;br&gt;There are predefined sizes (for each density) for launcher icons. You should follow these conventions to make sure your icons fit in with the overall look of the platform.&lt;br&gt;&lt;br&gt;Issue id: IconExpectedSize&lt;br&gt;&lt;br&gt;&lt;a href="https://material.io/design/iconography/"&gt;https://material.io/design/iconography/&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintAutofill" defaultSeverity="WARNING" displayName="Use Autofill" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Use Autofill&lt;br&gt;&lt;br&gt;Specify an &lt;code&gt;autofillHints&lt;/code&gt; attribute when targeting SDK version 26 or higher or explicitly specify that the view is not important for autofill. Your app can help an autofill service classify the data correctly by providing the meaning of each view that could be autofillable, such as views representing usernames, passwords, credit card fields, email addresses, etc.&lt;br/&gt;
&lt;br/&gt;
The hints can have any value, but it is recommended to use predefined values like 'username' for a username or 'creditCardNumber' for a credit card number. For a list of all predefined autofill hint constants, see the &lt;code&gt;AUTOFILL_HINT_&lt;/code&gt; constants in the &lt;code&gt;View&lt;/code&gt; reference at &lt;a href="https://developer.android.com/reference/android/view/View.html"&gt;https://developer.android.com/reference/android/view/View.html&lt;/a&gt;.&lt;br/&gt;
&lt;br/&gt;
You can mark a view unimportant for autofill by specifying an &lt;code&gt;importantForAutofill&lt;/code&gt; attribute on that view or a parent view. See &lt;a href="https://developer.android.com/reference/android/view/View.html#setImportantForAutofill(int)"&gt;https://developer.android.com/reference/android/view/View.html#setImportantForAutofill(int)&lt;/a&gt;.&lt;br&gt;&lt;br&gt;Issue id: Autofill&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/topics/text/autofill.html"&gt;https://developer.android.com/guide/topics/text/autofill.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintIconDuplicates" defaultSeverity="WARNING" displayName="Duplicated icons under different names" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Duplicated icons under different names&lt;br&gt;&lt;br&gt;If an icon is repeated under different names, you can consolidate and just use one of the icons and delete the others to make your application smaller. However, duplicated icons usually are not intentional and can sometimes point to icons that were accidentally overwritten or accidentally not updated.&lt;br&gt;&lt;br&gt;Issue id: IconDuplicates&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintTypographyDashes" defaultSeverity="WARNING" displayName="Hyphen can be replaced with dash" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Hyphen can be replaced with dash&lt;br&gt;&lt;br&gt;The "n dash" (u2013, &amp;amp;#8211;) and the "m dash" (u2014, &amp;amp;#8212;) characters are used for ranges (n dash) and breaks (m dash). Using these instead of plain hyphens can make text easier to read and your application will look more polished.&lt;br&gt;&lt;br&gt;Issue id: TypographyDashes&lt;br&gt;&lt;br&gt;&lt;a href="https://en.wikipedia.org/wiki/Dash"&gt;https://en.wikipedia.org/wiki/Dash&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintTypographyEllipsis" defaultSeverity="WARNING" displayName="Ellipsis string can be replaced with ellipsis character" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Ellipsis string can be replaced with ellipsis character&lt;br&gt;&lt;br&gt;You can replace the string "..." with a dedicated ellipsis character, ellipsis character (u2026, &amp;amp;#8230;). This can help make the text more readable.&lt;br&gt;&lt;br&gt;Issue id: TypographyEllipsis&lt;br&gt;&lt;br&gt;&lt;a href="https://en.wikipedia.org/wiki/Ellipsis"&gt;https://en.wikipedia.org/wiki/Ellipsis&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMonochromeLauncherIcon" defaultSeverity="WARNING" displayName="Monochrome icon is not defined" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Monochrome icon is not defined&lt;br&gt;&lt;br&gt;If &lt;code&gt;android:roundIcon&lt;/code&gt; and &lt;code&gt;android:icon&lt;/code&gt; are both in your manifest, you must either remove the reference to &lt;code&gt;android:roundIcon&lt;/code&gt; if it is not needed; or, supply the monochrome icon in the drawable defined by the &lt;code&gt;android:roundIcon&lt;/code&gt; and &lt;code&gt;android:icon&lt;/code&gt; attribute.&lt;br/&gt;
&lt;br/&gt;
For example, if &lt;code&gt;android:roundIcon&lt;/code&gt; and &lt;code&gt;android:icon&lt;/code&gt; are both in the manifest, a launcher might choose to use &lt;code&gt;android:roundIcon&lt;/code&gt; over &lt;code&gt;android:icon&lt;/code&gt; to display the adaptive app icon. Therefore, your themed application iconwill not show if your monochrome attribute is not also specified in &lt;code&gt;android:roundIcon&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: MonochromeLauncherIcon&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintSmallSp" defaultSeverity="WARNING" displayName="Text size is too small" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Text size is too small&lt;br&gt;&lt;br&gt;Avoid using sizes smaller than 11sp.&lt;br&gt;&lt;br&gt;Issue id: SmallSp&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintTextFields" defaultSeverity="WARNING" displayName="Missing inputType" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing &lt;code&gt;inputType&lt;/code&gt;&lt;br&gt;&lt;br&gt;Providing an &lt;code&gt;inputType&lt;/code&gt; attribute on a text field improves usability because depending on the data to be input, optimized keyboards can be shown to the user (such as just digits and parentheses for a phone number). &lt;br/&gt;
&lt;br/&gt;
The lint detector also looks at the &lt;code&gt;id&lt;/code&gt; of the view, and if the id offers a hint of the purpose of the field (for example, the &lt;code&gt;id&lt;/code&gt; contains the phrase &lt;code&gt;phone&lt;/code&gt; or &lt;code&gt;email&lt;/code&gt;), then lint will also ensure that the &lt;code&gt;inputType&lt;/code&gt; contains the corresponding type attributes.&lt;br/&gt;
&lt;br/&gt;
If you really want to keep the text field generic, you can suppress this warning by setting &lt;code&gt;inputType="text"&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: TextFields&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintTypographyFractions" defaultSeverity="WARNING" displayName="Fraction string can be replaced with fraction character" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Fraction string can be replaced with fraction character&lt;br&gt;&lt;br&gt;You can replace certain strings, such as 1/2, and 1/4, with dedicated characters for these, such as ½ (&amp;amp;#189;) and ¼ (&amp;amp;#188;). This can help make the text more readable.&lt;br&gt;&lt;br&gt;Issue id: TypographyFractions&lt;br&gt;&lt;br&gt;&lt;a href="https://en.wikipedia.org/wiki/Number_Forms"&gt;https://en.wikipedia.org/wiki/Number_Forms&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintButtonOrder" defaultSeverity="WARNING" displayName="Button order" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Button order&lt;br&gt;&lt;br&gt;According to the Android Design Guide,&lt;br/&gt;
&lt;br/&gt;
"Action buttons are typically Cancel and/or OK, with OK indicating the preferred or most likely action. However, if the options consist of specific actions such as Close or Wait rather than a confirmation or cancellation of the action described in the content, then all the buttons should be active verbs. As a rule, the dismissive action of a dialog is always on the left whereas the affirmative actions are on the right."&lt;br/&gt;
&lt;br/&gt;
This check looks for button bars and buttons which look like cancel buttons, and makes sure that these are on the left.&lt;br&gt;&lt;br&gt;Issue id: ButtonOrder&lt;br&gt;&lt;br&gt;&lt;a href="https://material.io/components/dialogs/"&gt;https://material.io/components/dialogs/&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintIconXmlAndPng" defaultSeverity="WARNING" displayName="Icon is specified both as .xml file and as a bitmap" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Icon is specified both as &lt;code&gt;.xml&lt;/code&gt; file and as a bitmap&lt;br&gt;&lt;br&gt;If a drawable resource appears as an &lt;code&gt;.xml&lt;/code&gt; file in the &lt;code&gt;drawable/&lt;/code&gt; folder, it's usually not intentional for it to also appear as a bitmap using the same name; generally you expect the drawable XML file to define states and each state has a corresponding drawable bitmap.&lt;br&gt;&lt;br&gt;Issue id: IconXmlAndPng&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMissingApplicationIcon" defaultSeverity="WARNING" displayName="Missing application icon" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing application icon&lt;br&gt;&lt;br&gt;You should set an icon for the application as whole because there is no default. This attribute must be set as a reference to a drawable resource containing the image (for example &lt;code&gt;@drawable/icon&lt;/code&gt;).&lt;br&gt;&lt;br&gt;Issue id: MissingApplicationIcon&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/studio/publish/preparing#publishing-configure"&gt;https://developer.android.com/studio/publish/preparing#publishing-configure&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintButtonStyle" defaultSeverity="WARNING" displayName="Button should be borderless" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Button should be borderless&lt;br&gt;&lt;br&gt;Button bars typically use a borderless style for the buttons. Set the &lt;code&gt;style="?android:attr/buttonBarButtonStyle"&lt;/code&gt; attribute on each of the buttons, and set &lt;code&gt;style="?android:attr/buttonBarStyle"&lt;/code&gt; on the parent layout&lt;br&gt;&lt;br&gt;Issue id: ButtonStyle&lt;br&gt;&lt;br&gt;&lt;a href="https://material.io/components/dialogs/"&gt;https://material.io/components/dialogs/&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintWebpUnsupported" defaultSeverity="ERROR" displayName="WebP Unsupported" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;WebP Unsupported&lt;br&gt;&lt;br&gt;The WebP format requires Android 4.0 (API 15). Certain features, such as lossless encoding and transparency, requires Android 4.2.1 (API 18; API 17 is 4.2.0.)&lt;br&gt;&lt;br&gt;Issue id: WebpUnsupported&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMipmapIcons" defaultSeverity="WARNING" displayName="Use Mipmap Launcher Icons" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Use Mipmap Launcher Icons&lt;br&gt;&lt;br&gt;Launcher icons should be provided in the &lt;code&gt;mipmap&lt;/code&gt; resource directory. This is the same as the &lt;code&gt;drawable&lt;/code&gt; resource directory, except resources in the &lt;code&gt;mipmap&lt;/code&gt; directory will not get stripped out when creating density-specific APKs.&lt;br/&gt;
&lt;br/&gt;
In certain cases, the Launcher app may use a higher resolution asset (than would normally be computed for the device) to display large app shortcuts. If drawables for densities other than the device's resolution have been stripped out, then the app shortcut could appear blurry.&lt;br/&gt;
&lt;br/&gt;
To fix this, move your launcher icons from `drawable-`dpi to `mipmap-`dpi and change references from @drawable/ and R.drawable to @mipmap/ and R.mipmap.&lt;br/&gt;
&lt;br/&gt;
In Android Studio this lint warning has a quickfix to perform this automatically.&lt;br&gt;&lt;br&gt;Issue id: MipmapIcons&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintAllCaps" defaultSeverity="WARNING" displayName="Combining textAllCaps and markup" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Combining textAllCaps and markup&lt;br&gt;&lt;br&gt;The textAllCaps text transform will end up calling &lt;code&gt;toString&lt;/code&gt; on the &lt;code&gt;CharSequence&lt;/code&gt;, which has the net effect of removing any markup such as &lt;code&gt;&amp;lt;b&gt;&lt;/code&gt;. This check looks for usages of strings containing markup that also specify &lt;code&gt;textAllCaps=true&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: AllCaps&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintIconLauncherShape" defaultSeverity="WARNING" displayName="The launcher icon shape should use a distinct silhouette" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;The launcher icon shape should use a distinct silhouette&lt;br&gt;&lt;br&gt;According to the Android Design Guide (&lt;a href="https://material.io/design/iconography/"&gt;https://material.io/design/iconography/&lt;/a&gt;) your launcher icons should "use a distinct silhouette", a "three-dimensional, front view, with a slight perspective as if viewed from above, so that users perceive some depth."&lt;br/&gt;
&lt;br/&gt;
The unique silhouette implies that your launcher icon should not be a filled square.&lt;br&gt;&lt;br&gt;Issue id: IconLauncherShape&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintIconMissingDensityFolder" defaultSeverity="WARNING" displayName="Missing density folder" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing density folder&lt;br&gt;&lt;br&gt;Icons will look best if a custom version is provided for each of the major screen density classes (low, medium, high, extra-high, extra-extra-high). This lint check identifies folders which are missing, such as &lt;code&gt;drawable-hdpi&lt;/code&gt;.&lt;br/&gt;
&lt;br/&gt;
Low density is not really used much anymore, so this check ignores the ldpi density. To force lint to include it, set the environment variable &lt;code&gt;ANDROID_LINT_INCLUDE_LDPI=true&lt;/code&gt;. For more information on current density usage, see &lt;a href="https://developer.android.com/about/dashboards"&gt;https://developer.android.com/about/dashboards&lt;/a&gt;&lt;br&gt;&lt;br&gt;Issue id: IconMissingDensityFolder&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/practices/screens_support.html"&gt;https://developer.android.com/guide/practices/screens_support.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintViewConstructor" defaultSeverity="WARNING" displayName="Missing View constructors for XML inflation" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing View constructors for XML inflation&lt;br&gt;&lt;br&gt;Some layout tools (such as the Android layout editor) need to find a constructor with one of the following signatures:&lt;br/&gt;
* &lt;code&gt;View(Context context)&lt;/code&gt;&lt;br/&gt;
* &lt;code&gt;View(Context context, AttributeSet attrs)&lt;/code&gt;&lt;br/&gt;
* &lt;code&gt;View(Context context, AttributeSet attrs, int defStyle)&lt;/code&gt;&lt;br/&gt;
&lt;br/&gt;
If your custom view needs to perform initialization which does not apply when used in a layout editor, you can surround the given code with a check to see if &lt;code&gt;View#isInEditMode()&lt;/code&gt; is false, since that method will return &lt;code&gt;false&lt;/code&gt; at runtime but true within a user interface editor.&lt;br&gt;&lt;br&gt;Issue id: ViewConstructor&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMenuTitle" defaultSeverity="ERROR" displayName="Missing menu title" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing menu title&lt;br&gt;&lt;br&gt;From the action bar documentation:&lt;br/&gt;
"It's important that you always define android:title for each menu item &amp;#8212; even if you don't declare that the title appear with the action item &amp;#8212; for three reasons:&lt;br/&gt;
&lt;br/&gt;
* If there's not enough room in the action bar for the action item, the menu item appears in the overflow menu and only the title appears.&lt;br/&gt;
* Screen readers for sight-impaired users read the menu item's title.&lt;br/&gt;
* If the action item appears with only the icon, a user can long-press the item to reveal a tool-tip that displays the action item's title.&lt;br/&gt;
&lt;br/&gt;
The android:icon is always optional, but recommended.&lt;br&gt;&lt;br&gt;Issue id: MenuTitle&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/training/appbar"&gt;https://developer.android.com/training/appbar&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintSelectableText" defaultSeverity="WARNING" displayName="Dynamic text should probably be selectable" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Dynamic text should probably be selectable&lt;br&gt;&lt;br&gt;If a &lt;code&gt;&amp;lt;TextView&gt;&lt;/code&gt; is used to display data, the user might want to copy that data and paste it elsewhere. To allow this, the &lt;code&gt;&amp;lt;TextView&gt;&lt;/code&gt; should specify &lt;code&gt;android:textIsSelectable="true"&lt;/code&gt;.&lt;br/&gt;
&lt;br/&gt;
This lint check looks for TextViews which are likely to be displaying data: views whose text is set dynamically.&lt;br&gt;&lt;br&gt;Issue id: SelectableText&lt;/body&gt;&lt;/html&gt;</inspection></group><group name="安全性" path="Java"><inspection shortName="CloneableClassInSecureContext" defaultSeverity="WARNING" displayName="安全上下文中的可克隆类" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可能被克隆的类。
&lt;p&gt;
  如果一个类支持 &lt;code&gt;Cloneable&lt;/code&gt; 接口，并且它的 &lt;code&gt;clone()&lt;/code&gt; 方法没有定义为立即抛出错误，则该类可以被克隆。 在用于安全使用的代码中，可克隆类可能是危险的。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;code&gt;class SecureBean implements Cloneable {}&lt;/code&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;&lt;code&gt;class SecureBean {}&lt;/code&gt;
&lt;p&gt;
当类扩展现有的可克隆类或实现可克隆接口时，应用该快速修复后，代码可能如下所示： 
&lt;pre&gt;&lt;code&gt;class SecureBean extends ParentBean {
    @Override
    protected SecureBean clone() throws CloneNotSupportedException {
        throw new CloneNotSupportedException();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JDBCExecuteWithNonConstantString" defaultSeverity="WARNING" displayName="'Statement.execute()' 调用具有非常量字符串" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对 &lt;code&gt;java.sql.Statement.execute()&lt;/code&gt; 或其任何变体的调用，这些变体会将动态构造的字符串作为要执行的查询。
&lt;p&gt;构造的 SQL 语句是安全漏洞的常见来源。
  默认情况下，此检查会忽略编译时常量。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  ResultSet execute(Statement statement, String name) throws SQLException {
    return statement.executeQuery("select * from " + name); // 报告警告
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
使用检查选项可以将任何 &lt;code&gt;static&lt;/code&gt; &lt;code&gt;final&lt;/code&gt; 字段视为常量。
请小心，因为启用该选项时，像下面这样的字符串将被忽略：
&lt;pre&gt;&lt;code&gt;
  private static final String SQL = "SELECT * FROM user WHERE name='" + getUserInput() + "'";
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CustomSecurityManager" defaultSeverity="WARNING" displayName="自定义 'SecurityManager'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;java.lang.SecurityManager&lt;/code&gt; 的用户定义子类。
&lt;p&gt;
  虽然不一定代表安全漏洞，但应彻底和专业地检查这种类是否存在可能的安全问题。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class CustomSecurityManager extends SecurityManager {
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SystemProperties" defaultSeverity="WARNING" displayName="系统属性的访问" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告使用以下其中一种方法访问系统属性的代码：
&lt;ul&gt;
  &lt;li&gt;
    &lt;code&gt;System.getProperties()&lt;/code&gt;、&lt;code&gt;System.setProperty()&lt;/code&gt;、&lt;code&gt;System.setProperties()&lt;/code&gt;、&lt;code&gt;System.clearProperties()&lt;/code&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;code&gt;Integer.getInteger()&lt;/code&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;code&gt;Boolean.getBoolean()&lt;/code&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
虽然访问系统属性本身并不是安全风险，但它经常出现在恶意代码中。
在任何安全审核中都应该仔细检查访问系统属性的代码。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SerializableDeserializableClassInSecureContext" defaultSeverity="WARNING" displayName="安全上下文中的可序列化类" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以被序列化或反序列化的类。
&lt;p&gt;
  如果一个类支持 &lt;code&gt;Serializable&lt;/code&gt; 接口，并且它的 &lt;code&gt;readObject()&lt;/code&gt; 和 &lt;code&gt;writeObject()&lt;/code&gt; 方法未被定义为总是抛出异常，那么就可以被序列化。 在供安全使用的代码中，可序列化的类可能比较危险。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class DeserializableClass implements Serializable { // 该类不包含抛出异常的 'writeObject()' 方法
    private int sensitive = 736326;

    private void readObject(ObjectInputStream in) {
        throw new Error();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class DeserializableClass implements Serializable {
    private int sensitive = 736326;

    private void readObject(ObjectInputStream in) {
        throw new Error();
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
        throw new java.io.NotSerializableException("DeserializableClass");
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用以下选项配置检查：
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    列出此检查不应报告其继承者的类。
    这适用于从超类继承 &lt;code&gt;Serializable&lt;/code&gt; 但不用于序列化的类。
    请注意，与其忽略这些类，添加始终抛出异常的 &lt;code&gt;readObject()&lt;/code&gt; 和 &lt;code&gt;writeObject()&lt;/code&gt; 方法可能更安全。
  &lt;/li&gt;
  &lt;li&gt;
    是否忽略可序列化的匿名类。
  &lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RuntimeExecWithNonConstantString" defaultSeverity="WARNING" displayName="'Runtime.exec()' 调用具有非常量字符串" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对 &lt;code&gt;java.lang.Runtime.exec()&lt;/code&gt; 的调用，该调用会将动态构造的字符串作为要执行的命令。
&lt;p&gt;
  构造的执行字符串是安全漏洞的常见来源。
  默认情况下，此检查会忽略编译时常量。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String i = getUserInput();
  Runtime runtime = Runtime.getRuntime();
  runtime.exec("foo" + i); // 报告警告
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
使用检查设置可以将任何 &lt;code&gt;static&lt;/code&gt; &lt;code&gt;final&lt;/code&gt; 字段视为常量。
请小心，因为启用该选项时，像下面这样的字符串将被忽略：
&lt;pre&gt;&lt;code&gt;
  static final String COMMAND = "ping " + getDomainFromUserInput() + "'";
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CustomClassloader" defaultSeverity="WARNING" displayName="声明了自定义的 'ClassLoader'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;java.lang.ClassLoader&lt;/code&gt; 的用户定义子类。
&lt;p&gt;
  虽然不一定代表安全漏洞，但应彻底检查这种类是否存在可能的安全问题。
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PublicStaticCollectionField" defaultSeverity="WARNING" displayName="'public static' 集合字段" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可修改的 &lt;code&gt;public&lt;/code&gt; &lt;code&gt;static&lt;/code&gt; 集合字段。
&lt;p&gt;尽管这些字段经常用于存储常量值集合，但它们仍然代表着安全隐患，因为即使字段被声明为 &lt;code&gt;final&lt;/code&gt;，它们的内容仍可能被修改。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public static final List&amp;lt;String&amp;gt; EVENTS = new ArrayList&amp;lt;&amp;gt;();
  &lt;/code&gt;
&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用&lt;b&gt;选项&lt;/b&gt;部分中的表可指定返回不可修改集合的方法。
  将不会报告使用这些方法初始化的 &lt;code&gt;public&lt;/code&gt; &lt;code&gt;static&lt;/code&gt; 集合字段。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PublicStaticArrayField" defaultSeverity="WARNING" displayName="'public static' 数组字段" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;public&lt;/code&gt; &lt;code&gt;static&lt;/code&gt; 数组字段。
&lt;p&gt;
  此类字段通常用于存储常量值数组。 尽管如此，它们仍然存在安全隐患，因为它们的内容可能会被修改，即使该字段被声明为 &lt;code&gt;final&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public static String[] allowedPasswords = {"foo", "bar"};
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LoadLibraryWithNonConstantString" defaultSeverity="WARNING" displayName="'System.loadLibrary()' 调用具有非常量字符串" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对&lt;code&gt;java.lang.System.loadLibrary()&lt;/code&gt;、&lt;code&gt;java.lang.System.load()&lt;/code&gt;、&lt;code&gt;java.lang.Runtime.loadLibrary()&lt;/code&gt; 和 &lt;code&gt;java.lang.Runtime.load()&lt;/code&gt; 的调用，它们会将动态构造的字符串作为库的名称。
&lt;p&gt;
  构造的库名称字符串是安全漏洞的常见来源。
  默认情况下，此检查会忽略编译时常量。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void test(int i) {
    System.loadLibrary("foo" + i);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
使用检查设置可以将任何 &lt;code&gt;static final&lt;/code&gt; 字段视为常量。
请小心，因为启用该选项时，像下面这样的字符串将被忽略：
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  private static final String LIBRARY = getUserInput();
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SystemSetSecurityManager" defaultSeverity="WARNING" displayName="调用 'System.setSecurityManager()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对 &lt;code&gt;System.setSecurityManager()&lt;/code&gt; 的调用。
&lt;p&gt;虽然通常是良性的，但任何对 &lt;code&gt;System.setSecurityManager()&lt;/code&gt; 的调用都应在每个安全审核中仔细检查。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnsecureRandomNumberGeneration" defaultSeverity="WARNING" displayName="不安全的随机数生成" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告任何使用 &lt;code&gt;java.lang.Random&lt;/code&gt; 或 &lt;code&gt;java.lang.Math.random()&lt;/code&gt; 的情况。
&lt;p&gt;
  在安全环境中，&lt;code&gt;java.secure.SecureRandom&lt;/code&gt; 是更好的选择，因为它提供加密安全的随机数生成。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  long token = new Random().nextLong();
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DesignForExtension" defaultSeverity="WARNING" displayName="为扩展设计" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告非 &lt;code&gt;static&lt;/code&gt;、&lt;code&gt;private&lt;/code&gt;、&lt;code&gt;final&lt;/code&gt; 或 &lt;code&gt;abstract&lt;/code&gt;，且其语句体不为空的方法。
&lt;p&gt;
  使用避免此类方法的样式进行编码可以保护类的约定不会被它们的子类破坏。 这种样式的好处是子类不会因为忘记调用 super 方法而破坏超类的状态。 代价是子类的灵活性受到限制，特别是它们不能阻止超类中代码的执行。 使用该快速修复可以添加缺失的修饰符。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    public boolean equals(Object o) { return true; }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    public final boolean equals(Object o) { return true; }
  }
&lt;/code&gt;&lt;/pre&gt;
此检查适用于将在安全环境中使用的代码，可能不适合限制较少的环境。
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ClassLoaderInstantiation" defaultSeverity="WARNING" displayName="'ClassLoader' 实例化" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;java.lang.ClassLoader&lt;/code&gt; 类的实例化。
&lt;p&gt;虽然通常是良性的，但在任何安全审核中都应该仔细检查 &lt;code&gt;ClassLoader&lt;/code&gt; 的任何实例化。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    Class&amp;lt;?&amp;gt; loadExtraClass(String name) throws Exception {
      try(URLClassLoader loader =
          new URLClassLoader(new URL[]{new URL("extraClasses/")})) {
        return loader.loadClass(name);
      }
    }
  &lt;/code&gt;
&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NonFinalClone" defaultSeverity="WARNING" displayName="非 final 'clone()' 位于安全上下文中" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告没有 &lt;code&gt;final&lt;/code&gt; 修饰符的 &lt;code&gt;clone()&lt;/code&gt; 方法。
&lt;p&gt;
  &lt;code&gt;clone()&lt;/code&gt; 可以用于在不使用构造函数的情况下实例化对象，因此允许重写 &lt;code&gt;clone()&lt;/code&gt; 方法可能导致对象损坏，甚至导致安全漏洞。 将 &lt;code&gt;clone()&lt;/code&gt; 方法或封闭类本身设为 &lt;code&gt;final&lt;/code&gt; 可以防止这种情况。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Main implements Cloneable {
      @Override
      protected Object clone() throws CloneNotSupportedException {
        return super.clone();
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JDBCPrepareStatementWithNonConstantString" defaultSeverity="WARNING" displayName="'Connection.prepare*()' 调用具有非常量字符串" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对 &lt;code&gt;java.sql.Connection.prepareStatement()&lt;/code&gt;、&lt;code&gt;java.sql.Connection.prepareCall()&lt;/code&gt; 或其任何变体的调用，这些变体会将动态构造的字符串作为要准备的语句。
&lt;p&gt;
  构造的 SQL 语句是安全漏洞的常见来源。 默认情况下，此检查会忽略编译时常量。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String bar() { return "bar"; }

  Connection connection = DriverManager.getConnection("", "", "");
  connection.("SELECT * FROM user WHERE name='" + bar() + "'");
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
使用检查设置可以将任何 &lt;code&gt;static&lt;/code&gt; &lt;code&gt;final&lt;/code&gt; 字段视为常量。 请小心，因为启用该选项时，像下面这样的字符串将被忽略：
&lt;pre&gt;&lt;code&gt;
  static final String SQL = "SELECT * FROM user WHERE name='" + getUserInput() + "'";
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="OpenAPI 规范" path=""><inspection shortName="SwJsonMaybeSpecificationInspection" defaultSeverity="WARNING" displayName="可能的 OpenAPI/Swagger 规范候选项" enabled="false" language="JSON" pluginId="com.intellij.swagger" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
检测可解释为 OpenAPI/Swagger 规范一部分的 JSON 文件。
&lt;p&gt;
  此类文件不包含显式规范特性，但它们引用自附近的主规范文件。
&lt;/p&gt;
&lt;!-- tooltip end --&gt;

&lt;p&gt;
  下面的示例包含位于同一目录中的两个文件。 第一个是一个普通的主规范文件。
  第二个引用自第一个，因此建议将其视为一个规范。
&lt;/p&gt;

&lt;p&gt;&lt;b&gt;主规范文件 `openapi.yaml`：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
openapi: 3.1.0
components:
  schemas:
    CustomSchema:
      description: Custom schema object
      properties:
        foo:
          $ref: 'common.components.json#/components/schemas/CommonSchema'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;b&gt;规范文件候选项 `common.components.json`：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
{
  "components": { # 'Mark file as OpenAPI specification' highlighting
    "schemas": {
      "CommonSchema": {
        "description": "Common schema object reused in several specifications"
      }
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SwYamlMaybeSpecificationInspection" defaultSeverity="WARNING" displayName="可能的 OpenAPI/Swagger 规范候选项" enabled="false" language="yaml" pluginId="com.intellij.swagger" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
检测可解释为 OpenAPI/Swagger 规范一部分的 YAML 文件。
&lt;p&gt;
  此类文件不包含显式规范特性，但它们引用自附近的主规范文件。
&lt;/p&gt;
&lt;!-- tooltip end --&gt;

&lt;p&gt;
  下面的示例包含位于同一目录中的两个文件。 第一个是一个普通的主规范文件。
  第二个引用自第一个，因此建议将其视为一个规范。
&lt;/p&gt;

&lt;p&gt;&lt;b&gt;主规范文件 `openapi.yaml`：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
openapi: 3.1.0
components:
  schemas:
    CustomSchema:
      description: Custom schema object
      properties:
        foo:
          $ref: 'common.components.yaml#/components/schemas/CommonSchema'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;b&gt;规范文件候选项 `common.components.yaml`：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
components: # 'Mark file as OpenAPI specification' highlighting
  schemas:
    CommonSchema:
      description: Common schema object reused in several specifications
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="CDI (上下文和依赖项注入)" path=""><inspection shortName="CdiDomBeans" defaultSeverity="WARNING" displayName="beans.xml 中不正确的 Bean 定义" enabled="false" language="XML" pluginId="com.intellij.cdi" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 &lt;code&gt;beans.xml&lt;/code&gt; 配置文件中不正确的 Bean 定义。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="CdiInjectionPointsInspection" defaultSeverity="WARNING" displayName="有不明确的依赖项的注入点" enabled="false" language="UAST" pluginId="com.intellij.cdi" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告具有不明确依赖项的 Bean 类中的注入点。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  interface Engine {}

  @Singleton
  class GasEngine implements Engine {}

  @Singleton
  class ElectricEngine implements Engine {}

  @Singleton
  class Car {
    @Inject Engine &lt;b&gt;engine&lt;/b&gt;; // 依赖项不明确：有多个 Bean 匹配注入点
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CdiUnknownProducersForDisposerMethodInspection" defaultSeverity="WARNING" displayName="无生产者的 Disposer 方法形参" enabled="false" language="UAST" pluginId="com.intellij.cdi" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告没有相应生产者方法的 disposer 方法。&lt;/p&gt;
&lt;p&gt;每个 disposer 方法必须恰好有一个与相应生产者方法或生产者字段返回类型相同类型的已处置形参。 在为生产者方法或生产者字段搜索 disposer 方法时，容器会考虑已处置形参的类型和限定符。 如果已处理的形参解析为同一 Bean 类声明的生产者方法或生产者字段，则容器在销毁该生产者方法或生产者字段返回的任何实例时必须调用此方法。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CdiDisposerMethodInspection" defaultSeverity="ERROR" displayName="不正确的 disposer 方法" enabled="false" language="UAST" pluginId="com.intellij.cdi" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告不正确的 disposer 方法。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;不能为 abstract。&lt;/li&gt;
  &lt;li&gt;必须只有一个使用 &lt;code&gt;@Disposes&lt;/code&gt; 注解的已处置形参。&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="CdiSpecializesInspection" defaultSeverity="ERROR" displayName="不正确的 @Specializes 用法" enabled="false" language="UAST" pluginId="com.intellij.cdi" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 &lt;code&gt;@Specializes&lt;/code&gt; 注解的不正确用法。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;专用化 Bean 必须扩展另一个 Bean&lt;/li&gt;
  &lt;li&gt;专用化方法必须重写其直接超类的 &lt;code&gt;@Produces&lt;/code&gt; 方法&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;@Named&lt;/code&gt; 注解不能用于专用化类和专用类&lt;/li&gt;
  &lt;li&gt;两个或多个类不能专用化同一个超类&lt;/li&gt;
  &lt;li&gt;专用化方法不能为 static&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="CdiInterceptorInspection" defaultSeverity="ERROR" displayName="无绑定类型的 @Interceptor 类" enabled="false" language="UAST" pluginId="com.intellij.cdi" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告没有绑定类型的 &lt;code&gt;@Interceptor&lt;/code&gt; 类。 侦听器必须指定至少一个侦听器绑定。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="CdiUnproxyableBeanTypesInspection" defaultSeverity="ERROR" displayName="无法代理 Bean 类型不正确的用法" enabled="false" language="UAST" pluginId="com.intellij.cdi" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告无法代理的 Bean 类型的不正确用法。&lt;/p&gt;
&lt;p&gt;容器不能代理某些合法的 Bean 类型：没有不带形参的非 private 构造函数的类、声明为 final 的类或具有 final 方法、基元类型和数组类型的类。&lt;/p&gt;

&lt;p&gt;此检查会报告此类 Bean 类型的以下违规行为：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;声明钝化范围的托管 Bean 必须为 &lt;code&gt;java.io.Serializable&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;不可序列化类型的 Bean 不能注入钝化范围的 Bean&lt;/li&gt;
  &lt;li&gt;容器必须能够代理注入的正常范围 Bean&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CdiStereotypeInspection" defaultSeverity="ERROR" displayName="不正确的 @Stereotype 注解类" enabled="false" language="UAST" pluginId="com.intellij.cdi" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告不正确的 &lt;code&gt;@Stereotype&lt;/code&gt; 注解类：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;不允许对构造型使用非空 &lt;code&gt;@Named&lt;/code&gt; 注解&lt;/li&gt;
  &lt;li&gt;不允许对构造型使用限定符注解&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="CdiNormalScopeInspection" defaultSeverity="WARNING" displayName="具有非默认范围的 Bean 声明 public 字段" enabled="false" language="UAST" pluginId="com.intellij.cdi" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告具有不在默认 &lt;code&gt;@Dependent&lt;/code&gt; 范围内的 public 实例字段的托管 Bean。
  根据 CDI 规范，上下文范围（&lt;code&gt;@RequestScoped&lt;/code&gt;、&lt;code&gt;@ApplicationScoped&lt;/code&gt;、&lt;code&gt;@SessionScoped&lt;/code&gt; 和 &lt;code&gt;ConversationScoped&lt;/code&gt;）不允许用于具有 public 实例字段的托管  Bean。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @ApplicationScoped // 警告：具有非默认范围的 Bean 不得具有 public 字段
  class Car {
    public String engine;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="CdiAlternativeInspection" defaultSeverity="ERROR" displayName="被否决的 @Alternative Bean" enabled="false" language="UAST" pluginId="com.intellij.cdi" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;
  报告被否决的 &lt;code&gt;@Alternative&lt;/code&gt; Bean。
  当一个 Bean 使用 &lt;code&gt;@Vetoed&lt;/code&gt; 注解或在被否决的软件包中声明时，会被视为否决。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="CdiTypedAnnotationInspection" defaultSeverity="ERROR" displayName="不正确的 @Typed 注解用法" enabled="false" language="UAST" pluginId="com.intellij.cdi" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告违反以下规则的 &lt;code&gt;@Typed&lt;/code&gt; 注解用法：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;只有生产者方法可以具有 &lt;code&gt;@Typed&lt;/code&gt; 注解&lt;/li&gt;
  &lt;li&gt;Bean 类型必须对应 &lt;code&gt;@Typed&lt;/code&gt; 注解中提到的类型&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="CdiStereotypeRestrictionsInspection" defaultSeverity="ERROR" displayName="Bean 在构造型中存在范围冲突" enabled="false" language="UAST" pluginId="com.intellij.cdi" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告在不同范围内具有多个构造型的类，或者未指定范围的类&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CdiInjectInspection" defaultSeverity="ERROR" displayName="不正确的依赖项注入位置" enabled="false" language="UAST" pluginId="com.intellij.cdi" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告不正确的注入点：使用 &lt;code&gt;@Inject&lt;/code&gt; 注解并违反 CDI 规范的字段、方法和形参。&lt;/p&gt;

&lt;p&gt;字段要求：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;不能为 static 或 final&lt;/li&gt;
  &lt;li&gt;不能使用 &lt;code&gt;@Produces&lt;/code&gt; 注解&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对包含注入的方法的要求：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;不能为 static 或 abstract&lt;/li&gt;
  &lt;li&gt;不能具有使用 &lt;code&gt;@Disposes&lt;/code&gt; 和 &lt;code&gt;@Observes&lt;/code&gt; 注解的形参&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="CdiScopeInspection" defaultSeverity="WARNING" displayName="不正确的 Bean 范围" enabled="false" language="UAST" pluginId="com.intellij.cdi" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告不正确的 Bean 范围：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;单例 Bean 必须是 &lt;code&gt;@ApplicationScoped&lt;/code&gt; 或 &lt;code&gt;@Dependent&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;会话无状态 Bean 必须是 &lt;code&gt;@Dependent&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="CdiObservesInspection" defaultSeverity="ERROR" displayName="不正确的 observer 方法" enabled="false" language="UAST" pluginId="com.intellij.cdi" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告不正确的观察者方法定义。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;只得包含一个 &lt;code&gt;@Observes&lt;/code&gt; 形参&lt;/li&gt;
  &lt;li&gt;不能具有使用 &lt;code&gt;@Disposes&lt;/code&gt; 注解的形参&lt;/li&gt;
  &lt;li&gt;不能使用 &lt;code&gt;@Inject&lt;/code&gt; 和 &lt;code&gt;@Produces&lt;/code&gt; 注解&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="CdiManagedBeanInconsistencyInspection" defaultSeverity="ERROR" displayName="不正确的托管 Bean 定义" enabled="false" language="UAST" pluginId="com.intellij.cdi" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告不正确的 Bean 定义规则。&lt;/p&gt;
&lt;p&gt;顶级 Java 类可以为简单的 Bean，如果：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;它不是形参化类型。&lt;/li&gt;
  &lt;li&gt;它不是一个非 static 内部类。&lt;/li&gt;
  &lt;li&gt;它是一个具体类，或者使用 &lt;code&gt;@Decorator&lt;/code&gt; 进行注解。&lt;/li&gt;
  &lt;li&gt;拥有适当的构造函数：该类具有没有形参的构造函数，或声明使用 &lt;code&gt; @Initializer &lt;/code&gt; 注解的构造函数。
  &lt;/li&gt;
  &lt;li&gt;它不实现以下任何接口：
    &lt;code&gt;javax.servlet.Servlet&lt;/code&gt;、
    &lt;code&gt;javax.servlet.Filter&lt;/code&gt;、
    &lt;code&gt;javax.servlet.ServletContextListener&lt;/code&gt;、
    &lt;code&gt;javax.servlet.http.HttpSessionListener&lt;/code&gt;、
    &lt;code&gt;javax.servlet.ServletRequestListener&lt;/code&gt;、
    &lt;code&gt;javax.ejb.EnterpriseBean&lt;/code&gt;。
  &lt;/li&gt;
  &lt;li&gt;它不扩展 &lt;code&gt;javax.faces.component.UIComponent&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="CdiDecoratorInspection" defaultSeverity="ERROR" displayName="不正确的 @Decorator 类" enabled="false" language="UAST" pluginId="com.intellij.cdi" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告不正确的 &lt;code&gt;@Decorator&lt;/code&gt; Bean 定义。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;不能为 final。&lt;/li&gt;
  &lt;li&gt;必须恰好有一个使用 &lt;code&gt;@Delegate&lt;/code&gt; 注解的代理特性（字段或形参）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="数据流" path="Groovy"><inspection shortName="GroovyVariableNotAssigned" defaultSeverity="WARNING" displayName="未分配变量" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告可能未初始化的变量。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyUnusedIncOrDec" defaultSeverity="WARNING" displayName="未使用的递增或递减" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告未使用的增量和减量表达式。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyUnusedAssignment" defaultSeverity="WARNING" displayName="未使用的赋值" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告赋值后因值从未使用而导致变量冗余的情况。&lt;/p&gt;
&lt;p&gt;如果变量未使用，建议将其移除，以缩短代码并避免冗余分配。&lt;/p&gt;
&lt;p&gt;报告的情况如下：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;该变量赋值后从未读取&lt;/li&gt;
  &lt;li&gt;在读取下一个变量之前，该值始终被另一个赋值重写&lt;/li&gt;
  &lt;li&gt;变量初始值设定项冗余（由于以上两种原因之一）&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt; 有关更多信息，请参阅 Java 中的相同检查。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyMissingReturnStatement" defaultSeverity="WARNING" displayName="缺少 return 语句" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告具有非 &lt;b&gt;void&lt;/b&gt; 返回类型的方法结尾缺少 &lt;code&gt;return&lt;/code&gt; 语句。
方法的执行流应该可以执行到方法结尾。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
String foo(int a) {
  if (a &gt; 0) {
    return "more than zero"
  }
} // foo(-1) 将返回 'null'

int bar(int a) {
  if (a &gt; 0) {
    return a
  }
} // bar(-1) 将失败并引发运行时异常
&lt;/code&gt;
&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyVariableCanBeFinal" defaultSeverity="WARNING" displayName="变量可以为 final" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告可能添加了 final 修饰符的形参或局部变量。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  def list = [1,2,3]
  return list
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：
&lt;pre&gt;&lt;code&gt;
  final def list = [1,2,3]
  return list
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;有关更多信息，请参阅 Java 中的相同检查。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="抽象问题" path="Java"><inspection shortName="FeatureEnvy" defaultSeverity="WARNING" displayName="特性依恋" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告&lt;em&gt;特性依恋&lt;/em&gt;代码异味。 当方法调用另一个类的方法三次或更多次时，将抛出警告。 对库类、父类、包含类的调用不计入此检查。 特性依恋通常表明该功能位于错误的类中。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class JobManager {
    // 警告：此方法调用 Job 类的
    // 三个方法
    // 最好将此调用链
    // 移至 Job 类本身。
    void performJob(Job job) {
      job.beforeStart();
      job.process();
      job.afterProcessing();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="InstanceofThis" defaultSeverity="WARNING" displayName="'this' 的 'instanceof' 检查" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在其中检查 &lt;code&gt;this&lt;/code&gt; 表达式的 &lt;code&gt;instanceof&lt;/code&gt; 或 &lt;code&gt;getClass() == SomeClass.class&lt;/code&gt; 的用法。
&lt;p&gt;此类表达式表明面向对象的设计失败，应该替换为多态构造。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
class Super {
  void process() {
    if (this instanceof Sub) { // 警告
      doSomething();
    } else {
      doSomethingElse();
    }
  }
}
  
class Sub extends Super {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;要修正该问题，可以使用重写方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
class Super {
  void process() {
    doSomethingElse();
  }
}
  
class Sub extends Super {
  @Override
  void process() {
    doSomething();
  }
}  
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="InterfaceMethodClashesWithObject" defaultSeverity="WARNING" displayName="接口方法与 'Object' 中的方法冲突" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告与 &lt;code&gt;java.lang.Object&lt;/code&gt; 类中的 &lt;b&gt;protected&lt;/b&gt; 方法 &lt;code&gt;clone()&lt;/code&gt; 和 &lt;code&gt;finalize()&lt;/code&gt; 冲突的接口方法。
&lt;p&gt;在接口中，可以使用与 &lt;code&gt;java.lang.Object&lt;/code&gt; 方法不兼容的返回类型来声明这些方法。
  实现此类接口的类不可编译。
  当接口正常工作时，虽然仍可根据它创建 lambda，但不建议这样做。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  // // 警告：此接口不能由任何类实现，
  // 只能由 lambda 或方法引用实现
  interface MyInterface {
    double clone();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnresolvedClassReferenceRepair" defaultSeverity="INFORMATION" displayName="未解析的类引用" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告未解析的类引用。
&lt;p&gt;该快速修复会建议尝试解析引用。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="BooleanParameter" defaultSeverity="WARNING" displayName="'public' 方法具有 'boolean' 形参" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告接受 &lt;code&gt;boolean&lt;/code&gt; 形参的 public 方法。
&lt;p&gt;如果某个 public 方法（API 的一部分）不是 setter，则向该方法添加 &lt;code&gt;boolean&lt;/code&gt; 形参几乎始终是一种不好的做法。
使用此类方法读取代码时，如果不查看源代码或文档，会很难理解 &lt;code&gt;boolean&lt;/code&gt; 的含义。&lt;/p&gt;
&lt;p&gt;此问题也被称为&lt;a href="https://ariya.io/2011/08/hall-of-api-shame-boolean-trap"&gt;布尔陷阱&lt;/a&gt;。
  &lt;code&gt;boolean&lt;/code&gt; 形参通常可以替换为 &lt;code&gt;enum&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  // 警告：在查看对此方法的
  // 调用时，很难理解
  // 布尔形参的含义
  public boolean setPermission(File f,
                               int access,
                               boolean enable,
                               boolean ownerOnly) {
    // ...
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
使用&lt;b&gt;仅报告具有多个布尔形参的方法&lt;/b&gt;选项可以仅在一个方法包含多个布尔形参时发出警告。
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="OverlyStrongTypeCast" defaultSeverity="WARNING" displayName="过强的类型转换" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告过强的类型转换。 例如，将对象转换为 &lt;code&gt;ArrayList&lt;/code&gt;，将其转换为 &lt;code&gt;List&lt;/code&gt; 也可以。
&lt;p&gt;
  &lt;b&gt;注意&lt;/b&gt;：与&lt;i&gt;冗余类型转换&lt;/i&gt;检查非常相似，如果您有意使用过强的转换来生成 &lt;code&gt;ClassCastException&lt;/code&gt;，则对此检查应用修正可能会改变程序的语义。
&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  interface Super {
    void doSmth();
  }
  interface Sub extends Super { }

  void use(Object obj) {
    // 警告：可以使用 ((Super)obj).doSmth()
    ((Sub)obj).doSmth();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  在代码中有匹配的 &lt;code&gt;instanceof&lt;/code&gt; 检查时，使用下面的复选框可忽略转换。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MethodOnlyUsedFromInnerClass" defaultSeverity="WARNING" displayName="仅在内部类中使用 private 方法" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告仅从包含该方法的类的内部类调用的 &lt;code&gt;private&lt;/code&gt; 方法。 此类方法可以安全地移到该内部类中。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
public class Outer {
  public static void main(String[] args) {
    new Inner().run(args[0]);
  }

  static class Inner {
    void run(String arg) {
      // 方法 isEmpty() 仅从内部类使用
      // 考虑将其移到内部类
      if (!isEmpty(arg)) {
        System.out.println("Argument is supplied");
      }
    }
  }

  private static boolean isEmpty(String s) {
    return s != null &amp;&amp; s.trim().isEmpty();
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
使用下面的第一个复选框可忽略从匿名类或本地类调用的 &lt;code&gt;private&lt;/code&gt; 方法。
&lt;p&gt;
使用第三个复选框可仅报告 &lt;code&gt;static&lt;/code&gt; 方法。
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ClassReferencesSubclass" defaultSeverity="WARNING" displayName="类引用其子类之一" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告包含对其中一个子类进行了引用的类。
此类引用可能令人困惑，并违反面向对象设计的多条规则。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Entity {
    // 警告：该类引用了其子类
    void compare(SimpleEntity entity) {
      ...
    }
  }
  class SimpleEntity extends Entity {
    ...
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="InstanceofChain" defaultSeverity="WARNING" displayName="'instanceof' 检查链" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告所有语句条件均为 &lt;code&gt;instanceof&lt;/code&gt; 表达式或类等式表达式（例如与 &lt;code&gt;String.class&lt;/code&gt; 比较）的 &lt;code&gt;if&lt;/code&gt;-&lt;code&gt;else&lt;/code&gt; 语句的任何链。
此类结构通常表明面向对象的设计失败，面向对象的设计要求此类基于类型的调度应通过多态方法调用而不是类型测试的显式链来完成。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  double getArea(Shape shape) {
    // 警告：抽象失败。
    // 最好在 shape 接口中
    // 声明 getArea() 抽象方法，
    // 并在每个继承者中实现。
    if (shape instanceof Point) {
      return 0;
    }
    if (shape instanceof Circle) {
      return Math.PI *
        Math.pow(((Circle) shape).radius(), 2);
    }
    if (shape instanceof Rectangle) {
      return ((Rectangle) shape).width() *
        ((Rectangle) shape).height();
    }
    throw new IllegalArgumentException();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用下面的复选框可忽略库类中的 &lt;code&gt;instanceof&lt;/code&gt; 表达式。
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UseOfConcreteClass" defaultSeverity="WARNING" displayName="具体类的使用" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告使用具体类而非接口的情况。
此类声明可能代表抽象失败，并可能使测试更加困难。
&lt;p&gt;
此检查不会报告其类来自系统或第三方库的声明。
&lt;code&gt;equals()&lt;/code&gt; 方法实现中不会报告转换、instanceof 和局部变量。
此外，&lt;code&gt;clone()&lt;/code&gt; 方法实现中不会报告转换。
&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  interface Entity {}
  class EntityImpl implements Entity {}

  void processObject(Object obj) {
    // 警告：具体类的 instanceof
    if (obj instanceof EntityImpl) {
      // 警告：转换为具体类，
      // 而不是接口
      processEntity((EntityImpl)obj);
    }
  }
  // 警告：具体类的形参
  void processEntity(EntityImpl obj) {
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用&lt;b&gt;忽略抽象类类型&lt;/b&gt;选项可以忽略对抽象类的转换。&lt;/p&gt;
&lt;p&gt;使用后续选项可控制报告问题的上下文。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MagicNumber" defaultSeverity="WARNING" displayName="幻数" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告“幻数”：未通过常量声明来命名的数值文字。
&lt;p&gt;使用幻数会导致代码不清晰，并且如果幻数在一个位置更改但在另一个位置保持不变，则会导致错误。 此检查不会报告数字 0、1、2、3、4、5、6、7、8、9、10、100、1000、0L、1L、2L、0.0、1.0、0.0F 和 1.0F。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void checkFileSize(long bytes) {
    if (bytes &gt; 1_048_576) {
      throw new IllegalArgumentException("too big");
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;快速修复引入了一个新常量：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  static final int MAX_SUPPORTED_FILE_SIZE = 1_048_576;

  void checkFileSize(long bytes) {
    if (bytes &gt; MAX_SUPPORTED_FILE_SIZE) {
      throw new IllegalArgumentException("too big");
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;配置检查：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;使用&lt;b&gt;忽略 'hashCode()' 方法中的常量&lt;/b&gt;选项可在 &lt;code&gt;hashCode()&lt;/code&gt; 方法中禁用此检查。&lt;/li&gt;
  &lt;li&gt;使用&lt;b&gt;在注解中忽略&lt;/b&gt;选项可以忽略注解中的幻数。&lt;/li&gt;
  &lt;li&gt;在构造 &lt;code&gt;Collection&lt;/code&gt;、&lt;code&gt;Map&lt;/code&gt;、&lt;code&gt;StringBuilder&lt;/code&gt; 或 &lt;code&gt;StringBuffer&lt;/code&gt; 对象时，使用&lt;b&gt;忽略 StringBuilders 和 Collections 的初始容量&lt;/b&gt;选项可以忽略用作初始容量的幻数。&lt;/li&gt;
&lt;/ul&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PublicMethodNotExposedInInterface" defaultSeverity="WARNING" displayName="'public' 方法在接口中未公开" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告未在接口中公开的类中的 &lt;code&gt;public&lt;/code&gt; 方法。
&lt;p&gt;通过接口公开所有 &lt;code&gt;public&lt;/code&gt; 方法对于维护松散耦合非常重要，某些基于组件的编程风格可能需要这样做。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
interface Person {
  String getName();
}

class PersonImpl implements Person {
  private String name;

  // 正常：方法在接口中公开
  @Override
  public String getName() {
    return name;
  }

  // 警告：方法为 public
  // 但未在接口中公开
  public void setName() {
    this.name = name;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用&lt;b&gt;有注解时忽略&lt;/b&gt;列表可指定特殊注解。 此检查将忽略使用其中一种注解进行注解的方法。
&lt;p&gt;
  使用&lt;b&gt;如果包含类未实现非库接口，则忽略&lt;/b&gt;选项可以忽略未实现项目中任何接口的类中的方法。
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TypeMayBeWeakened" defaultSeverity="WARNING" displayName="类型可能被削弱" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以更改为更抽象（更弱）类型的变量和方法返回类型。
这使代码更抽象，因此可重用性更高。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  // 形参类型可以削弱为 java.util.List
  void processList(ArrayList&amp;lt;String&amp;gt; list) {
    if (list.isEmpty()) return;
    System.out.println("Processing");
    for (String s : list) {
      System.out.println("String: " + s);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  启用下面的&lt;b&gt;使用右侧类型&lt;/b&gt;复选框可防止在右侧并非类型转换或新表达式时削弱赋值的左侧。 在变量中存储方法调用结果时，保留方法调用结果的类型不会不必要地削弱它，反而会很有用。
&lt;/p&gt;
&lt;p&gt;
  启用下面的&lt;b&gt;使用形参化类型&lt;/b&gt;复选框可在求值的对象用作形参类型为 &lt;code&gt;java.lang.Object&lt;/code&gt; 的集合方法的实参时，将集合的形参化类型用作最弱的类型。
  在将对象传递给以下集合方法时，使用此选项可以防止削弱为 &lt;code&gt;Object&lt;/code&gt;：
  &lt;code&gt;get()&lt;/code&gt;、&lt;code&gt;remove()&lt;/code&gt;、&lt;code&gt;contains()&lt;/code&gt;、&lt;code&gt;indexOf()&lt;/code&gt;、&lt;code&gt;lastIndexOf()&lt;/code&gt;、&lt;code&gt;containsKey()&lt;/code&gt; 和 &lt;code&gt;containsValue()&lt;/code&gt;。
&lt;/p&gt;
&lt;p&gt;
  启用下面的&lt;b&gt;不削弱为 Object&lt;/b&gt; 复选框可以指定是否应将类型削弱为 &lt;code&gt;java.lang.Object&lt;/code&gt;。
  削弱为 &lt;code&gt;java.lang.Object&lt;/code&gt; 很少有用。
&lt;/p&gt;
&lt;p&gt;
  启用下面的&lt;b&gt;仅削弱为接口&lt;/b&gt;复选框，可仅在该类型可以削弱为接口类型时才报告问题。
&lt;/p&gt;
&lt;p&gt;
  启用下面的&lt;b&gt;不削弱返回类型&lt;/b&gt;复选框，可防止在返回类型可能被削弱时报告问题。
  只分析变量。
&lt;/p&gt;
&lt;p&gt;
  启用下面的&lt;b&gt;不建议削弱声明为 'var' 的变量&lt;/b&gt;复选框，可防止报告使用 'var' 关键字声明的局部变量 (Java 10+)
&lt;/p&gt;
&lt;p&gt;
&lt;b&gt;停止类&lt;/b&gt;意在防止类削弱至低于停止类的程度，即便可能出现这种情况，也能予以防止。
在某些情况下，这可能会提高可读性。
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="DeclareCollectionAsInterface" defaultSeverity="WARNING" displayName="按类 (而不是接口) 声明的集合" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告使用集合类作为类型而不是使用相应接口进行的 &lt;code&gt;Collection&lt;/code&gt; 变量的声明。 如果削弱变量类型会导致编译错误，则不发出警告。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  // 警告：使用了具体集合类 ArrayList。
  int getTotalLength(ArrayList&amp;lt;String&amp;gt; list) {
    return list.stream().mapToInt(String::length).sum();
  }

  // 无警告，因为 trimToSize() 方法
  // 在 List 接口中不可用
  void addData(ArrayList&amp;lt;String&amp;gt; data) {
    data.add("Hello");
    data.add("World");
    data.trimToSize();
  }
&lt;/code&gt;&lt;/pre&gt;
建议通过快速修复使用相应集合接口（例如 &lt;code&gt;Collection&lt;/code&gt;、&lt;code&gt;Set&lt;/code&gt; 或 &lt;code&gt;List&lt;/code&gt;）。
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="OptionalUsedAsFieldOrParameterType" defaultSeverity="WARNING" displayName="用作字段或形参类型的 'Optional'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;java.util.Optional&amp;lt;T&amp;gt;&lt;/code&gt;、&lt;code&gt;java.util.OptionalDouble&lt;/code&gt;、&lt;code&gt;java.util.OptionalInt&lt;/code&gt;、&lt;code&gt;java.util.OptionalLong&lt;/code&gt; 或 &lt;code&gt;com.google.common.base.Optional&lt;/code&gt; 用为字段或形参的类型的任何情况。
&lt;p&gt;&lt;code&gt;Optional&lt;/code&gt; 设计为在需要一个明确的方式来表示 "没有结果"的情况下，为库方法的返回类型提供有限的机制。&lt;/p&gt;
&lt;p&gt;如果类需要 &lt;code&gt;Serializable&lt;/code&gt;，则使用 &lt;code&gt;java.util.Optional&lt;/code&gt; 类型的字段也有问题，因为 &lt;code&gt;java.util.Optional&lt;/code&gt; 不可序列化。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class MyClass {
    Optional&amp;lt;String&amp;gt; name; // Optional 字段

    // Optional 形参
    void setName(Optional&amp;lt;String&amp;gt; name) {
      this.name = name;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StaticMethodOnlyUsedInOneClass" defaultSeverity="WARNING" displayName="static 成员仅在其他一个类中使用" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
报告仅从包含类以外的类使用的 &lt;code&gt;static&lt;/code&gt; 方法和字段。 此类成员可以移动到所使用的类。
此检查将忽略从成员的类内部的匿名类访问的工厂方法和成员。
调用同一个类中名称相同但形参较少的方法的方便重载也会被忽略。
&lt;!-- tooltip end --&gt;
&lt;p&gt;
仅在从测试类使用 static 成员时，可以使用第一个复选框来禁止此检查。
&lt;p&gt;
使用下面的第二个复选框可以忽略匿名类、本地类或非 static 内部类中的成员用法。
&lt;p&gt;
使用下面的第三个复选框，可以不对没有问题的情况下也无法移动的成员发出警告，例如，由于目标类中已存在签名相同的方法，或者由于移动此方法时将无法访问方法内部使用的字段或方法。
&lt;p&gt;
使用第四个复选框可以忽略位于实用程序类中的成员。
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="可能引起混淆的代码结构" path="JavaScript and TypeScript"><inspection shortName="NegatedIfStatementJS" defaultSeverity="WARNING" displayName="否定的 'if' 语句" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告具有 &lt;b&gt;else&lt;/b&gt; 分支和否定条件的 &lt;b&gt;if&lt;/b&gt; 语句。
翻转 &lt;b&gt;if&lt;/b&gt; 和 &lt;b&gt;else&lt;/b&gt; 分支的顺序通常会改进此类语句的清晰度。
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="NestedFunctionJS" defaultSeverity="WARNING" displayName="嵌套函数" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告嵌套在另一个函数中的函数。
尽管 JavaScript 允许嵌套函数，但此类结构可能令人困惑。
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用下面的复选框以忽略匿名嵌套函数。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConfusingPlusesOrMinusesJS" defaultSeverity="WARNING" displayName="'+' 或 '-' 的序列会引起混淆" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 JavaScript 代码中 &lt;code&gt;+&lt;/code&gt; 或 &lt;code&gt;-&lt;/code&gt; 字符的可疑组合 (例如 &lt;code&gt;a+++b&lt;/code&gt;) 。  此类序列令人困惑，并且它们的语义可能会因为空格的变化而变化。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="OverlyComplexArithmeticExpressionJS" defaultSeverity="WARNING" displayName="过于复杂的算术表达式" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;!-- Copied from community/plugins/InspectionGadgets/src/inspectionDescriptions/OverlyComplexArithmeticExpression.html --&gt;
&lt;html&gt;
&lt;body&gt;
报告包含太多项的算术表达式。 此类表达方式可能令人困惑，并且容易出错。
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用下面的字段可指定算术表达式中允许的最大项数。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PointlessArithmeticExpressionJS" defaultSeverity="WARNING" displayName="无意义的算术表达式" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告包括加零或减零、乘零或一、除一和零移位的算术表达式。 此类表达式可能是由于没有完全完成自动化重构而造成。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MagicNumberJS" defaultSeverity="WARNING" displayName="幻数" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;!-- Copied from community/plugins/InspectionGadgets/src/inspectionDescriptions/MagicNumber.html --&gt;
&lt;html&gt;
&lt;body&gt;
报告使用数值文字但未通过常量声明来命名的“幻数”。
幻数可能导致生成意图不明确的代码，如果一个代码位置中的幻数被更改，但在另一个代码位置未被更改，则可能导致错误。 数字 0、1、2、3、4、5、6、7、8、9、10、100、1000、
0.0 和 1.0 将被忽略。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="IncrementDecrementResultUsedJS" defaultSeverity="WARNING" displayName="使用增量或减量的结果" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告赋值结果在包含其的表达式中
使用的递增 (&lt;code&gt;++&lt;/code&gt;) 或递减 (&lt;code&gt;--&lt;/code&gt;) 表达式。 此类赋值可能会由于运算顺序而导致困惑，因为赋值的评估可能会以意想不到的方式影响外部表达式。 示例：&lt;code&gt;var a = b++&lt;/code&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="OverlyComplexBooleanExpressionJS" defaultSeverity="WARNING" displayName="过度复杂的布尔表达式" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;!-- Copied from community/plugins/InspectionGadgets/src/inspectionDescriptions/OverlyComplexBooleanExpression.html --&gt;
&lt;html&gt;
&lt;body&gt;
报告包含太多项的布尔表达式。 此类表达方式可能令人困惑，并且容易出错。
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用下面的字段可指定算术表达式中允许的最大项数。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="EmptyStatementBodyJS" defaultSeverity="WARNING" displayName="带空体的语句" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告语句体为空的 &lt;code&gt;if&lt;/code&gt; 、&lt;code&gt;while&lt;/code&gt; 、&lt;code&gt;for&lt;/code&gt; 或 &lt;code&gt;with&lt;/code&gt; 语句。 此类语句通常是由拼写错误所致，可能会引起混淆。
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用下面的复选框指定是否应报告以空块语句为主体的语句。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="BlockStatementJS" defaultSeverity="WARNING" displayName="不必要的块语句" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告不用作 &lt;code&gt;if&lt;/code&gt; 、&lt;code&gt;for&lt;/code&gt; 、&lt;code&gt;while&lt;/code&gt; 、&lt;code&gt;do&lt;/code&gt; 、
&lt;code&gt;with&lt;/code&gt; 或 &lt;code&gt;try&lt;/code&gt; 语句体，也不用作函数声明体的块语句。 从 ECMAScript 6 开始，JavaScript 块为 &lt;code&gt;let&lt;/code&gt; 和 &lt;code&gt;const&lt;/code&gt; 变量引入了新的范围，
但独立的块语句在与 &lt;code&gt;var&lt;/code&gt; 变量一起使用时仍然会引起混淆，并导致难以捉摸的错误。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NestedConditionalExpressionJS" defaultSeverity="WARNING" displayName="嵌套条件表达式" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告另一个三元条件中的三元条件表达式。
此类嵌套条件可能极其令人困惑，最好替换为更显式的条件逻辑。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NegatedConditionalExpressionJS" defaultSeverity="WARNING" displayName="否定条件表达式" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;!-- Copied from community/plugins/InspectionGadgets/src/inspectionDescriptions/NegatedConditional.html --&gt;
&lt;html&gt;
&lt;body&gt;
报告条件被否定的条件表达式。
建议翻转条件表达式中分支的顺序以增加语句的清晰度。
示例：&lt;code&gt;!condition ? 2 : 1&lt;/code&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConfusingFloatingPointLiteralJS" defaultSeverity="WARNING" displayName="浮点文字会引起混淆" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;!-- Copied from community/plugins/InspectionGadgets/src/inspectionDescriptions/ConfusingFloatingPointLiteral.html --&gt;
&lt;html&gt;
&lt;body&gt;
报告任何没有小数点的浮点数或小数点前的任何数字
或小数点后的任何数字。 此类文字可能令人困惑，并且违反多种编码标准。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DynamicallyGeneratedCodeJS" defaultSeverity="WARNING" displayName="执行动态生成的代码" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;eval()&lt;/code&gt;、&lt;code&gt;setTimeout()&lt;/code&gt; 或 &lt;code&gt;setInterval()&lt;/code&gt; 函数的调用或 &lt;code&gt;Function&lt;/code&gt; 对象的分配。  这些函数用于执行通常动态生成的
任意 JavaScript 文本字符串。  这可能非常令人困惑，并且可能存在安全风险。
&lt;br/&gt;&lt;br/&gt;
忽略静态地向这些方法提供回调函数而不生成代码的情况。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CallerJS" defaultSeverity="WARNING" displayName="使用 'caller' 属性" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 JavaScript 函数中 &lt;code&gt;caller&lt;/code&gt; 属性的用法。
使用此属性访问调用方法的堆栈帧可能格外令人困惑，并导致难以捉摸的错误。
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="最佳做法" path="Gradle"><inspection shortName="ConfigurationAvoidance" defaultSeverity="WARNING" displayName="配置避免" enabled="false" language="Groovy" pluginId="org.jetbrains.plugins.gradle" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;                                            
&lt;p&gt;(Gradle 4.9+) 检测预先与任务交互的 API 的用法。&lt;/p&gt;
  与任务预先交互意味着很多困难：
  &lt;ul&gt;
  &lt;li&gt;用户应该手动设置任务之间的所有依赖关系；&lt;/li&gt;
  &lt;li&gt; 在&lt;a href="https://docs.gradle.org/current/userguide/build_lifecycle.html#sec:build_phases"&gt;配置阶段&lt;/a&gt;，所有通过预先 API 访问的任务都会被配置，即使它们没有在之后执行。 这会导致性能下降。&lt;/li&gt;
  &lt;/ul&gt;
  最终， 预先 API 将被弃用，取而代之的是延迟 API。&lt;br&gt;
  &lt;a href="https://docs.gradle.org/current/userguide/task_configuration_avoidance.html"&gt;有关迁移指南，请参阅 Gradle 文档。&lt;/a&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
task foo { // 报告 'task'，建议将其替换为 'task.register'
  // ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="其他" path="Groovy"><inspection shortName="GrMethodMayBeStatic" defaultSeverity="WARNING" displayName="方法可以为 'static'" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以安全设置为 &lt;code&gt;static&lt;/code&gt; 的方法。
&lt;p&gt;
  如果方法未 &lt;code&gt;synchronized&lt;/code&gt;，未引用它的类的任何实例方法和实例字段，并且未在子类中被重写，则可能是 &lt;code&gt;static&lt;/code&gt; 方法。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="TypeCustomizer" defaultSeverity="WARNING" displayName="类型自定义工具检查" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告可作为自定义类型检查器且未添加到编译器资源的文件。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Android Lint: Lint Implementation Issues" path=""><inspection shortName="AndroidLintUastImplementation" defaultSeverity="WARNING" displayName="Avoid using UAST implementation" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Avoid using UAST implementation&lt;br&gt;&lt;br&gt;Use UAST interface whenever possible, and do not rely on UAST implementation, which is subject to change. If language-specific information is needed, the next option is to use PSI directly (though these APIs are less stable and can depend on compiler internals, especially in the case of Kotlin).&lt;br&gt;&lt;br&gt;Issue id: UastImplementation&lt;/body&gt;&lt;/html&gt;</inspection></group><group name="代码样式问题" path="Java/Java 语言级别迁移帮助"><inspection shortName="TrailingWhitespacesInTextBlock" defaultSeverity="WARNING" displayName="文本块中的尾随空格" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告带有尾随空格字符的文本块。
尾随空格被视为是附带的，将被 Java 编译器去除。
&lt;!-- tooltip end --&gt;
&lt;p&gt;仅当项目或模块的语言级别为 15 或更高时，此检查才会报告。&lt;/p&gt;
&lt;p&gt;&lt;small&gt;2021.1 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="赋值问题" path="Java"><inspection shortName="AssignmentUsedAsCondition" defaultSeverity="WARNING" displayName="用作条件的赋值" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告用作 &lt;code&gt;if&lt;/code&gt;、&lt;code&gt;while&lt;/code&gt;、&lt;code&gt;for&lt;/code&gt; 或
&lt;code&gt;do&lt;/code&gt; 语句或条件表达式的赋值。
&lt;p&gt;虽然有时是有意为之，但这种用法令人困惑，并且可能表明存在拼写错误（例如，应使用 &lt;code&gt;=&lt;/code&gt; 而不是 &lt;code&gt;==&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;该快速修复会将 &lt;code&gt;=&lt;/code&gt; 替换为 &lt;code&gt;==&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void update(String str, boolean empty) {
    // 警告：'empty' 被重新赋值，
    // 不与 str.isEmpty() 进行比较
    if (empty = str.isEmpty()) {
      ...
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void update(String str, boolean empty) {
    if (empty == str.isEmpty()) {
      ...
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AssignmentToNull" defaultSeverity="WARNING" displayName="'null' 赋值" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在声明外被赋值给 &lt;code&gt;null&lt;/code&gt; 的变量。
&lt;p&gt;Java 中 &lt;code&gt;null&lt;/code&gt; 的主要用途是表示未初始化的引用变量。 在极少数情况下，将变量显式赋值给 &lt;code&gt;null&lt;/code&gt; 有助于垃圾回收。 但是，使用 &lt;code&gt;null&lt;/code&gt; 来表示缺失、未指定、无效值或找不到的元素被认为是一种不好的做法，可能会使您的代码更容易出现 &lt;code&gt;NullPointerExceptions&lt;/code&gt;。
  请改为考虑定义具有预期语义的 sentinel 对象或使用像 &lt;code&gt;Optional&lt;/code&gt; 这样的库类型来表示没有值。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Integer convert(String s) {
    Integer value;
    try {
      value = Integer.parseInt(s);
    } catch (NumberFormatException e) {
      // 警告：null 用于表示“无效值”
      value = null;
    }
    return value;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
使用&lt;b&gt;忽略对字段的赋值&lt;/b&gt;选项可忽略对字段的赋值。
&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AssignmentToMethodParameter" defaultSeverity="WARNING" displayName="赋值给方法形参" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对方法形参的赋值或修改。
&lt;p&gt;虽然有时是有意为之，但此结构可能令人困惑，因此在一些 Java 项目中被禁止使用。&lt;/p&gt;
&lt;p&gt;该快速修复会添加新变量的声明。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void printTrimmed(String s) {
    s = s.trim();
    System.out.println(s);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void printTrimmed(String s) {
    String trimmed = s.trim();
    System.out.println(trimmed);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用&lt;b&gt;如果赋值是原始形参的转换，则忽略&lt;/b&gt;选项可忽略根据先前值修改形参值的赋值。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NestedAssignment" defaultSeverity="WARNING" displayName="嵌套赋值" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告嵌套在其他表达式中的赋值表达式。
&lt;p&gt;此类表达式可能令人困惑，并违反一般设计原则，即任何结构应当只发挥一种作用。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String userName;
  // 警告：使用了对 'userName' 赋值的结果
  String message = "Hello " + (userName = "Alice") + "!"
  System.out.println(message);
  System.out.println("Goodbye " + userName);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AssignmentToForLoopParameter" defaultSeverity="WARNING" displayName="赋值给 'for' 循环形参" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对循环体内 &lt;code&gt;for&lt;/code&gt; 循环形参的赋值或修改。
&lt;p&gt;虽然偶尔是有意为之，但此结构可能令人困惑，通常是由拼写错误或使用错误变量引起。&lt;/p&gt;
&lt;p&gt;该快速修复会添加新变量的声明。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  for (String s : list) {
    // 警告：s 在循环内被更改
    s = s.trim();
    System.out.println("String: " + s);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  for (String s : list) {
    String trimmed = s.trim();
    System.out.println("String: " + trimmed);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不报告没有 update 语句的基本 &lt;code&gt;for&lt;/code&gt; 循环中的赋值。
  在此类情况下，赋值很可能是预期的，不能轻易移动到 &lt;code&gt;for&lt;/code&gt; 循环的更新部分。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  for (int i = 0; i &amp;lt; list.size(); ) {
    if (element.equals(list.get(i))) {
      list.remove(i);
    } else {
      // 因为没有 update 语句
      // 所以不报告 for 循环形参的修改
      i++;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;使用&lt;b&gt;检查增强型 'for' 循环形参&lt;/b&gt;选项可指定是否还应报告增强的 &lt;code&gt;for&lt;/code&gt; 循环形参的修改。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AssignmentToSuperclassField" defaultSeverity="WARNING" displayName="构造函数将值赋给在超类中定义的字段" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对超类中从子类构造函数中声明的字段的赋值或修改。
&lt;p&gt;最好在其自己的构造函数中初始化超类的字段，并在子类中委托给该构造函数。 如果它在构造后没有改变，这还将允许声明一个字段 &lt;code&gt;final&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Super {
    int x;
  }
  class Sub extends Super {
    Sub(int _x) {
      // Warning: x is declared in a superclass
      x = _x;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;要避免此问题，请声明超类构造函数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Super {
    final int x;

    Super(int _x) {
      x = _x;
    }
  }
  class Sub extends Super {
    Sub(int _x) {
      super(_x);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AssignmentToStaticFieldFromInstanceMethod" defaultSeverity="WARNING" displayName="从实例上下文赋值给 static 字段" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对实例方法中 &lt;code&gt;static&lt;/code&gt; 字段的赋值或修改。
&lt;p&gt;虽然合法，但此类赋值很难安全完成，并且通常是无意中将字段标记为 &lt;code&gt;static&lt;/code&gt; 的结果。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Counter {
    private static int count = 0;

    void increment() {
      // 警告：从实例方法
      // 更新 static 字段
      count++;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReplaceAssignmentWithOperatorAssignment" defaultSeverity="INFORMATION" displayName="赋值可被替换为运算符赋值" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以替换为运算符赋值的赋值运算。
&lt;p&gt;使用运算符赋值的代码更短，可能更清晰。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  x = x + 3;
  x = x / 3;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  x += 3;
  x /= 3;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
使用&lt;b&gt;忽略条件运算符&lt;/b&gt;选项可忽略 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 和 &lt;code&gt;||&lt;/code&gt;。 将条件运算符替换为运算符赋值将使惰性求值变为及早求值，从而可能改变表达式的语义。
&lt;/p&gt;
&lt;p&gt;
使用&lt;b&gt;忽略模糊运算符&lt;/b&gt;选项可忽略不太为人所知的 &lt;code&gt;^&lt;/code&gt; 和 &lt;code&gt;%&lt;/code&gt;。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AssignmentToCatchBlockParameter" defaultSeverity="WARNING" displayName="赋值给 'catch' 块形参" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对 &lt;code&gt;catch&lt;/code&gt; 块形参的赋值。
&lt;p&gt;更改 &lt;code&gt;catch&lt;/code&gt; 块形参很容易令人困惑，不建议使用。&lt;/p&gt;
&lt;p&gt;该快速修复会添加新变量的声明。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void processFile(String fileName) throws Exception {
    try {
      doProcessFile(fileName);
    } catch(Exception ex) {
      if (ex instanceof UncheckedIOException) {
        // Warning: catch block parameter reassigned
        ex = ((UncheckedIOException) ex).getCause();
      }
      throw ex;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void processFile(String fileName) throws Exception {
    try {
      doProcessFile(fileName);
    } catch(Exception ex) {
      Exception unwrapped = ex;
      if (unwrapped instanceof UncheckedIOException) {
        unwrapped = ((UncheckedIOException)
          unwrapped).getCause();
      }
      throw unwrapped;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="IncrementDecrementUsedAsExpression" defaultSeverity="WARNING" displayName="使用 '++' 或 '--' 的结果" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告嵌套在其他表达式中的增量或减量表达式。
此类表达式可能令人困惑，并违反一般设计原则，即任何结构应当只发挥一种作用。
&lt;p&gt;该快速修复会将递增或递减运算提取到单独的表达式语句中。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int i = 10;
  while (i-- &gt; 0) {
    System.out.println(i);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int i = 10;
  while (i &gt; 0) {
    i--;
    System.out.println(i);
  }
  i--;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AssignmentToLambdaParameter" defaultSeverity="WARNING" displayName="赋值给 lambda 形参" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对 lambda 形参的赋值或修改。
虽然偶尔是有意为之，但此结构可能令人困惑，通常是由拼写错误或使用错误变量所致。
&lt;p&gt;该快速修复会添加新变量的声明。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  list.forEach(s -&gt; {
    s = s.trim();
    System.out.println("String: " + s);
  });
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  list.forEach(s -&gt; {
    String trimmed = s.trim();
    System.out.println("String: " + trimmed);
  });
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;使用&lt;b&gt;如果赋值是原始形参的转换，则忽略&lt;/b&gt;选项可以忽略根据先前值修改形参值的赋值。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Mutiny" path="Reactive Streams"><inspection shortName="MutinyCallingSubscribeInNonBlockingScope" defaultSeverity="WARNING" displayName="在 &quot;reactive&quot; 方法中调用 'subscribe'" enabled="false" language="UAST" pluginId="com.intellij.reactivestreams" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 "reactive" 方法中的 &lt;code&gt;subscribe()&lt;/code&gt; 调用。&lt;/p&gt;
&lt;p&gt;返回 Publisher（包括 &lt;code&gt;Uni&lt;/code&gt; 和 &lt;code&gt;Multi&lt;/code&gt;）的方法不应直接调用 &lt;code&gt;subscribe()&lt;/code&gt; 方法，因为它可能破坏反应式调用链。&lt;/p&gt;
&lt;p&gt;不要使用 &lt;code&gt;subscribe()&lt;/code&gt;，而应考虑使用组合运算符，例如 &lt;code&gt;flatMap()&lt;/code&gt;、&lt;code&gt;merge()&lt;/code&gt; 等。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Multi&amp;lt;String&amp;gt; stringMulti(){
    Multi&amp;lt;String&amp;gt; multi = Multi.createFrom().item("abc");
    multi.subscribe(); // &amp;lt;- 在非阻塞上下文中阻塞 'subscribe' 调用
    return multi;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="继承问题" path="Java"><inspection shortName="AbstractMethodWithMissingImplementations" defaultSeverity="WARNING" displayName="缺少实现的 abstract 方法" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告每个具体子类中没有实现的 &lt;code&gt;abstract&lt;/code&gt; 方法。
&lt;p&gt;
  这会导致子类发生编译时错误；该检查会报告 abstract 方法点处的问题，从而可以更快地检测出问题。
&lt;/p&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AbstractMethodOverridesConcreteMethod" defaultSeverity="WARNING" displayName="abstract 方法重写具体方法" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告重写具体 super 方法的 &lt;code&gt;abstract&lt;/code&gt; 方法。
&lt;p&gt;此检查不会报告从 &lt;code&gt;java.lang.Object&lt;/code&gt; 重写的方法。&lt;/p&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ExtendsConcreteCollection" defaultSeverity="WARNING" displayName="类显式扩展 'Collection' 类" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告扩展 &lt;code&gt;java.util.Collection&lt;/code&gt; 或 &lt;code&gt;java.util.Map&lt;/code&gt; 类的具体子类的类。
&lt;p&gt;
  一种常见但欠佳的做法是对具体集合类型进行子类化。 它比委托集合调用要脆弱得多。
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ImplicitSubclassInspection" defaultSeverity="ERROR" displayName="final 声明不能在运行时被重写" enabled="false" language="UAST" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在运行时代码阻止某个框架（例如 Spring 或 Hibernate）对类进行子类化的情况。
&lt;!-- tooltip end --&gt;
&lt;p&gt;必要但不可能进行子类化的典型示例：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;使用特定于框架的注解（例如 Spring &lt;code&gt;@Configuration&lt;/code&gt;）标记的 &lt;code&gt;final&lt;/code&gt; 类&lt;/li&gt;
  &lt;li&gt;使用特定于框架的注解（例如 Spring &lt;code&gt;@Transactional&lt;/code&gt;）标记的 &lt;code&gt;final&lt;/code&gt;、&lt;code&gt;static&lt;/code&gt; 或 &lt;code&gt;private&lt;/code&gt; 方法&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;final&lt;/code&gt; 类中使用特定于框架的注解标记的方法&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;报告的情况清单取决于使用的框架。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ProblematicVarargsMethodOverride" defaultSeverity="WARNING" displayName="非 vararg 方法重写 vararg 方法" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告重写可变 arity（亦称 vararg）方法但将可变 arity 形参替换为数组形参的方法。
尽管这段代码有效，但它可能令人困惑，因而应当避免。
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ExtendsUtilityClass" defaultSeverity="WARNING" displayName="类扩展实用程序类" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告扩展实用类的类。
&lt;p&gt;
实用类是非空类，其中所有字段和方法都为 static。
  扩展实用类还允许无意中对实用类进行对象实例化，因为不能为了允许扩展而将构造函数设置为 private。
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  配置检查：
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    使用&lt;b&gt;如果重写类为实用程序类，则忽略&lt;/b&gt;选项可以忽略任何重写实用程序类但本身也是实用程序类的类。
  &lt;/li&gt;
&lt;/ul&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StaticInheritance" defaultSeverity="WARNING" displayName="静态继承" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告仅为提供对常量的访问而实现的接口。
这种继承常常令人困惑，可能隐藏重要的依赖关系信息。
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ExtendsAnnotation" defaultSeverity="WARNING" displayName="类扩展注解接口" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告声明为注解接口的实现或扩展的类。
&lt;p&gt;尽管扩展注解接口是合法之举，但通常是偶然为之，并且结果不能作为注解使用。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MissingOverrideAnnotation" defaultSeverity="INFORMATION" displayName="缺少 '@Override' 注解" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
  报告重写超类方法但未使用 &lt;code&gt;@java.lang.Override&lt;/code&gt; 注解的方法。
  &lt;p&gt;
  由于表明了意图，使用 &lt;code&gt;@java.lang.Override&lt;/code&gt; 注解方法提高了代码可读性。
  此外，在被重写的方法的签名与超类方法不匹配时，编译器会报错。
  &lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
  &lt;pre&gt;&lt;code&gt;
    class X {
      public String toString() {
        return "hello world";
      }
    }
  &lt;/code&gt;&lt;/pre&gt;
  &lt;p&gt;在应用快速修复后：&lt;/p&gt;
  &lt;pre&gt;&lt;code&gt;
    class X {
      @Override
      public String toString() {
        return "hello world";
      }
    }
  &lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;配置检查：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    使用&lt;b&gt;忽略 'equals()'、'hashCode()' 和 'toString()'&lt;/b&gt; 选项可以忽略这些 &lt;code&gt;java.lang.Object&lt;/code&gt; 方法：&lt;code&gt;equals()&lt;/code&gt;、&lt;code&gt;hashCode()&lt;/code&gt; 和
&lt;code&gt;toString()&lt;/code&gt;。 由于 &lt;code&gt;@Override&lt;/code&gt; 注解而使得这些方法消失且代码不再编译的风险相对较小。
  &lt;/li&gt;
  &lt;li&gt;
    使用&lt;b&gt;忽略匿名类中的方法&lt;/b&gt;选项可以忽略匿名类中的方法。
  &lt;/li&gt;
  &lt;li&gt;
    禁用&lt;b&gt;当方法的重写方法并非全部具有 '@Override' 注解时，高亮显示该方法&lt;/b&gt;选项，可以仅就缺少 &lt;code&gt;@Override&lt;/code&gt; 注解的方法发出警告，而不就其一个或多个后代缺少 &lt;code&gt;@Override&lt;/code&gt; 注解的被重写方法发出警告。
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;仅当项目或模块的语言级别为 5 或更高时，此检查才会报告。&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="AbstractClassWithoutAbstractMethods" defaultSeverity="WARNING" displayName="没有 'abstract' 方法的抽象类" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告没有任何 &lt;code&gt;abstract&lt;/code&gt; 方法的 &lt;code&gt;abstract&lt;/code&gt; 类。
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RefusedBequest" defaultSeverity="WARNING" displayName="方法不调用 super 方法" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告重写特定方法而不调用 &lt;code&gt;super&lt;/code&gt; 的方法。
&lt;p&gt;这也称作&lt;i&gt;被拒绝的遗赠&lt;/i&gt;。 此类方法可能表明抽象失败，导致出现难以跟踪的错误。&lt;/p&gt;
  &lt;p&gt;该检查不报告默认方法和从 &lt;code&gt;java.lang.Object&lt;/code&gt; 重写的方法，但对 &lt;code&gt;clone()&lt;/code&gt; 除外。
  &lt;code&gt;clone()&lt;/code&gt; 方法预计会调用其 &lt;code&gt;super&lt;/code&gt;，从而自动返回正确类型的对象。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;pre&gt;&lt;code&gt;
  class A {
    @Override
    public Object clone() { // 已报告，因为它不调用 'super.clone()'
      return new A();
    }
  }
  &lt;/code&gt;&lt;/pre&gt; &lt;/li&gt;
  &lt;li&gt;&lt;pre&gt;&lt;code&gt;
  interface I {
    default void foo() {}
  }

  class A implements I {
    // 禁用“忽略 'default' super 方法”和“忽略注解”选项时对方法发出警告
    @Override
    public void foo(){}
  }
    &lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;配置检查：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    使用&lt;b&gt;仅在通过以下方式注解 super 方法时报告&lt;/b&gt;选项，可忽略使用所提供列表中的注解标记的 &lt;code&gt;super&lt;/code&gt; 方法。 您可以手动将注解添加到此列表中。
  &lt;/li&gt;
  &lt;li&gt;
    使用&lt;b&gt;忽略空 super 方法&lt;/b&gt;选项，可忽略仅抛出异常或空的 &lt;code&gt;super&lt;/code&gt; 方法。
  &lt;/li&gt;
  &lt;li&gt;
    使用&lt;b&gt;忽略 'default' super 方法&lt;/b&gt;选项，可忽略包含 &lt;code&gt;default&lt;/code&gt; 关键字的 &lt;code&gt;super&lt;/code&gt; 方法。
  &lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AbstractClassExtendsConcreteClass" defaultSeverity="WARNING" displayName="抽象类扩展具体类" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告扩展具体类的 &lt;code&gt;abstract&lt;/code&gt; 类。
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ParameterTypePreventsOverriding" defaultSeverity="WARNING" displayName="形参类型阻止重写" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告与相应 super 方法的形参类型同名但属于不同软件包的子类方法的形参类型。
在这些情况下，子类方法不能重写 super 方法。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
&lt;b&gt;public class&lt;/b&gt; A {
 &lt;b&gt;public void&lt;/b&gt; method(Object o) {}
}

&lt;b&gt;public class&lt;/b&gt; B &lt;b&gt;extends&lt;/b&gt; A {
 &lt;b&gt;public void&lt;/b&gt; method(Object o) {} // 对形参类型发出警告
 &lt;b&gt;class&lt;/b&gt; Object {}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
&lt;b&gt;public class&lt;/b&gt; A {
 &lt;b&gt;public void&lt;/b&gt; method(Object o) {}
}

&lt;b&gt;public class&lt;/b&gt; B &lt;b&gt;extends&lt;/b&gt; A {
 &lt;b&gt;public void&lt;/b&gt; method(java.lang.Object o) {} // 新形参类型
 &lt;b&gt;class&lt;/b&gt; Object {}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AbstractClassNeverImplemented" defaultSeverity="WARNING" displayName="没有具体子类的抽象类" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告没有任何具体子类的 &lt;code&gt;abstract&lt;/code&gt; 类。
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AbstractMethodOverridesAbstractMethod" defaultSeverity="WARNING" displayName="abstract 方法重写 abstract 方法" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告重写 &lt;code&gt;abstract&lt;/code&gt; 方法的 &lt;code&gt;abstract&lt;/code&gt; 方法。
&lt;p&gt;此类方法毫无意义，因为任何具体的子类都必须实现抽象方法。&lt;/p&gt;
&lt;p&gt;
  此检查不会报告返回类型、异常声明、注解或修饰符与被重写方法不同的方法。
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  配置检查：
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    使用&lt;b&gt;忽略 Javadoc 与其 super 方法不同的方法&lt;/b&gt;选项，以忽略 Javadoc 注释与其 super 方法不同的任何抽象方法。
  &lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FrequentlyUsedInheritorInspection" defaultSeverity="INFORMATION" displayName="类可以扩展常用的基类" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以替换为更具体的常用类或接口的实现或扩展的类或接口。
&lt;p&gt;为进行此检查，超类需位于项目源文件中，并且项目需要使用 IntelliJ IDEA 构建系统。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class MyInheritor implements A {} // B 针对 A 引用提供建议

  interface A {}

  abstract class B implements A {}

  abstract class C1 extends B {}
  abstract class C2 extends B {}
  abstract class C3 extends B {}
  abstract class C4 extends B {}
  abstract class C5 extends B {}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;默认情况下，此检查不会在编辑器中高亮显示问题，而是只提供快速修复。&lt;/p&gt;
&lt;p&gt;&lt;small&gt;2017.2 最新变化&lt;/small&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="InterfaceNeverImplemented" defaultSeverity="WARNING" displayName="没有具体子类的接口" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告没有具体子类的接口。
&lt;!-- tooltip end --&gt;
&lt;p&gt;配置检查：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    使用下面的列表可以添加注解。 该检查将忽略使用其中一种注解声明的接口。
  &lt;/li&gt;
  &lt;li&gt;
    使用下面的复选框可以忽略仅声明常量字段的接口。
    即使没有实现，仍然可以使用此类接口。
  &lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NonProtectedConstructorInAbstractClass" defaultSeverity="WARNING" displayName="抽象类中的 public 构造函数" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;abstract&lt;/code&gt; 类的 &lt;code&gt;public&lt;/code&gt; 构造函数。
&lt;p&gt;
  &lt;code&gt;abstract&lt;/code&gt; 类的构造函数只能从其子类的构造函数进行调用，将其声明为 &lt;code&gt;public&lt;/code&gt; 可能令人困惑。
&lt;/p&gt;
&lt;p&gt;该快速修复会将此类构造函数设为 protected。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;public abstract class&lt;/b&gt; Foo {
    &lt;b&gt;public&lt;/b&gt; Foo () { // 警告：有 'public' 修饰符
        /* ... */
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;public abstract class&lt;/b&gt; Foo {
    &lt;b&gt;protected&lt;/b&gt; Foo () {
        /* ... */
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;配置检查：&lt;/p&gt;
&lt;p&gt;使用下面的&lt;b&gt;忽略非 public 类&lt;/b&gt;选项可以忽略非 public 类中的 &lt;code&gt;public&lt;/code&gt; 构造函数。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TypeParameterExtendsFinalClass" defaultSeverity="WARNING" displayName="类型形参扩展 'final' 类" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告为扩展 &lt;code&gt;final&lt;/code&gt; 类而声明的类型形参。
&lt;p&gt;由于无法扩展 &lt;code&gt;final&lt;/code&gt; 类，建议将类型形参替换为指定的 &lt;code&gt;final&lt;/code&gt; 类的类型。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;void&lt;/b&gt; foo() {
    List&amp;lt;? &lt;b&gt;extends&lt;/b&gt; Integer&amp;gt; list; // 警告：Integer 类为 final 类
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;void&lt;/b&gt; foo() {
    List&amp;lt;Integer&amp;gt; list;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantMethodOverride" defaultSeverity="WARNING" displayName="方法与其 super 方法相同" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告与其 super 方法相同的方法。 此类方法与其 super 方法的签名相同，并且要么方法体相同，要么其主体仅包含对 super 方法的调用。
这些方法冗余，可以移除。
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用下面的复选框，对重写库方法的方法进行检查。
  检查库方法可能会减慢检查速度。
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="性能" path="Java"><inspection shortName="IOStreamConstructor" defaultSeverity="WARNING" displayName="可以使用 'Files' 方法构建 'InputStream' 和 'OutputStream'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可被分别替换为 &lt;code&gt;Files.newInputStream()&lt;/code&gt; 或 &lt;code&gt;Files.newOutputStream()&lt;/code&gt; 调用的 &lt;code&gt;new FileInputStream()&lt;/code&gt; 或 &lt;code&gt;new FileOutputStream()&lt;/code&gt; 表达式。
&lt;br&gt;
使用 &lt;code&gt;Files&lt;/code&gt; 方法创建的流通常比使用流构造函数创建的流更有效。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  InputStream is = new BufferedInputStream(new FileInputStream(file));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  InputStream is = new BufferedInputStream(Files.newInputStream(file.toPath()));
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;如果语言级别为 10 或更高，则此检查不会显示警告，但快速修复仍然可用。&lt;/p&gt;
&lt;p&gt;仅当项目或模块的语言级别为 7 或更高时，此检查才会报告。&lt;/p&gt;
&lt;p&gt;&lt;small&gt;2022.1 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SlowListContainsAll" defaultSeverity="WARNING" displayName="对 'list.containsAll(collection)' 的调用可能具有较差性能" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;java.util.List&lt;/code&gt; 上对 &lt;code&gt;containsAll()&lt;/code&gt; 的调用。
&lt;p&gt;
  此方法调用的时间复杂度为 O(n&amp;middot;m)，其中 n 是调用该方法的列表中的元素数，m 是作为形参传递至该方法的集合中的元素数。
  当列表很大时，这可能是一项开销巨大的操作。
&lt;/p&gt;
&lt;p&gt;
  该快速修复会将列表包装在 &lt;code&gt;new java.util.HashSet&amp;lt;&amp;gt;()&lt;/code&gt; 中，因为从 &lt;code&gt;java.util.List&lt;/code&gt; 创建 
  &lt;code&gt;java.util.HashSet&lt;/code&gt; 并在 &lt;code&gt;java.util.HashSet&lt;/code&gt; 上执行 &lt;code&gt;containsAll()&lt;/code&gt; 的所需时间为 O(n+m)。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  public boolean check(List&amp;lt;String&amp;gt; list, Collection&amp;lt;String&amp;gt; collection) {
    // O(n&amp;middot;m) 复杂度
    return list.containsAll(collection);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  public boolean check(List&amp;lt;String&amp;gt; list, Collection&amp;lt;String&amp;gt; collection) {
    // O(n+m) 复杂度
    return new HashSet&amp;lt;&amp;gt;(list).containsAll(collection);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2022.1 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="CollectionContainsUrl" defaultSeverity="WARNING" displayName="'Map' 或 'Set' 可能包含 'URL' 对象" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告包含 &lt;code&gt;java.net.URL&lt;/code&gt; 对象的 &lt;code&gt;java.util.Set&lt;/code&gt; 和 &lt;code&gt;java.util.Map&lt;/code&gt; 变量。
此类集合将在插入的对象上调用 &lt;code&gt;equals()&lt;/code&gt; 和 &lt;code&gt;hashCode()&lt;/code&gt; 方法，这可能会导致 &lt;code&gt;URL&lt;/code&gt; 对象的性能问题。
&lt;p&gt;
  &lt;code&gt;URL&lt;/code&gt; 的 &lt;code&gt;equals()&lt;/code&gt; 和 &lt;code&gt;hashCode()&lt;/code&gt; 方法可以执行 DNS 查找来解析主机名。
  这可能会导致重大延迟，具体取决于网络和 DNS 服务器的可用性和速度。
  使用 &lt;code&gt;java.net.URI&lt;/code&gt; 代替 &lt;code&gt;java.net.URL&lt;/code&gt; 将避免 DNS 查找。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Set&amp;lt;URL&amp;gt; set = new HashSet&amp;lt;URL&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="IfStatementMissingBreakInLoop" defaultSeverity="WARNING" displayName="在 'if' 条件下提前退出循环" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告包含 &lt;code&gt;if&lt;/code&gt; 语句并且以 &lt;code&gt;break&lt;/code&gt; 结尾但又不改变语义的循环。
这可以防止冗余的循环迭代。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean found = false;
  for (int i = 0; i &amp;lt; arr.length; i++) {
    if (Objects.equals(value, arr[i])) {
      found = true;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean found = false;
  for (int i = 0; i &amp;lt; arr.length; i++) {
    if (Objects.equals(value, arr[i])) {
      found = true;
      break;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2019.2 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DynamicRegexReplaceableByCompiledPattern" defaultSeverity="WARNING" displayName="动态正则表达式可被替换为已编译的 'Pattern'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告使用常量实参对 &lt;code&gt;java.lang.String&lt;/code&gt; 的正则表达式方法（例如 &lt;code&gt;matches()&lt;/code&gt; 或 &lt;code&gt;split()&lt;/code&gt;）的调用。
&lt;p&gt;
  此类调用可以有利地替换为 &lt;code&gt;private static final Pattern&lt;/code&gt; 字段，从而不必在每次使用正则表达式时都对其进行编译。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  text.replaceAll("abc", replacement);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  private static final Pattern ABC = Pattern.compile("abc", Pattern.LITERAL);
  ABC.matcher(text).replaceAll(Matcher.quoteReplacement(replacement));
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StringConcatenationInLoops" defaultSeverity="WARNING" displayName="字符串串联在循环中" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告循环中的 String 串联。
&lt;p&gt;
  由于每个 String 串联都会复制整个字符串，因此通常最好将其替换为对 &lt;code&gt;StringBuilder.append()&lt;/code&gt; 或 &lt;code&gt;StringBuffer.append()&lt;/code&gt; 的显式调用。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String str = "";
  for(int i=0; i&amp;lt;10; i++) {
    str += i;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String str = "";
  StringBuilder strBuilder = new StringBuilder(str);
  for(int i = 0; i&amp;lt;10; i++) {
    strBuilder.append(i);
  }
  str = strBuilder.toString();
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  有时，通过该快速修复可将 &lt;code&gt;String&lt;/code&gt; 变量转换为 &lt;code&gt;StringBuilder&lt;/code&gt; 或引入新的 &lt;code&gt;StringBuilder&lt;/code&gt;。 原始代码专门处理 &lt;code&gt;null&lt;/code&gt; 值时应小心，因为替换可能会改变语义。 如果可能为 &lt;code&gt;null&lt;/code&gt;，建议进行 null 安全修正，生成必要的 null 检查。 此外，也不能保证自动替换总是性能更好。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CallToSimpleGetterInClass" defaultSeverity="WARNING" displayName="从类内调用简单 getter" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告从属性的类内部对简单属性 getter 的调用。
&lt;p&gt;
  简单的属性 getter 会被定义为只返回字段的值，而不进行其他计算。 可以使用该快速修复安全地内联此类简单的 getter 调用。
  为了保持代码清晰，某些编码标准还建议不使用简单的 getter。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Salient {
    private String name;

    public String getName() {
      return name;
    }

    @Override
    public String toString() {
      return getName();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Salient {
    private String name;

    public String getName() {
      return name;
    }

    @Override
    public String toString() {
      return name;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;使用以下选项配置检查：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;是否仅报告 &lt;code&gt;this&lt;/code&gt; 上的 getter 调用，而不报告作为形参传入的相同类型的对象。&lt;/li&gt;
  &lt;li&gt;是否忽略非 &lt;code&gt;private&lt;/code&gt; getter。&lt;/li&gt;
&lt;/ul&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StringEqualsEmptyString" defaultSeverity="WARNING" displayName="'String.equals()' 可被替换为 'String.isEmpty()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;equals()&lt;/code&gt; 被调用以将 &lt;code&gt;String&lt;/code&gt; 与空字符串进行比较的情况。
在这种情况下，使用 &lt;code&gt;.isEmpty()&lt;/code&gt; 更好，因为它可以准确显示您正在检查的内容。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void checkString(String s){
    if ("".equals(s)) throw new IllegalArgumentException();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void checkString(String s){
    if (s != null &amp;&amp; s.isEmpty()) throw new IllegalArgumentException();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  &lt;code&gt;"".equals(str)&lt;/code&gt; 在 &lt;code&gt;str&lt;/code&gt; 为空时返回 false。 为了安全起见，当 &lt;code&gt;equals()&lt;/code&gt; 实参可以为空时，此检查的快速修复会插入一个显式 null 检查。 使用该选项可使检查忽略此类情况。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AutoUnboxing" defaultSeverity="WARNING" displayName="自动拆箱" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告受拆箱转换（自动将对象解开为基元值）影响的表达式。
尽量不使用对象，而是使用基元。 它可能会显著影响性能。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int x = new Integer(42);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该快速修复会将转换设为显式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int x = new Integer(42).intValue();&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  &lt;i&gt;自动拆箱&lt;/i&gt;在 Java 5 中出现。
  此检查有助于为向后兼容早期 Java 版本而降级。
&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ManualArrayToCollectionCopy" defaultSeverity="WARNING" displayName="手动数组到集合复制" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告使用循环将数组内容复制到集合中的代码。
&lt;p&gt;
  一种更短并且有可能更快（取决于集合实现）的方法是使用 &lt;code&gt;Collection.addAll(Arrays.asList())&lt;/code&gt; 或 &lt;code&gt;Collections.addAll()&lt;/code&gt;。
&lt;/p&gt;
&lt;p&gt;
&lt;p&gt;仅报告内部没有附加语句的循环。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void addAll(List&amp;lt;String&amp;gt; list, String[] arr) {
    for (int i = 0; i &amp;lt; arr.length; i++) {
      String s = arr[i];
      list.add(s);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void addAll(List&amp;lt;String&amp;gt; list, String[] arr) {
    Collections.addAll(list, arr);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LengthOneStringsInConcatenation" defaultSeverity="INFORMATION" displayName="单字符字符串串联" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告与一个字符组成的字符串文字的串联。
&lt;p&gt;这些文字可以替换为等效的字符文字，从而提升一定的性能。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String hello = hell + "o";
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String hello = hell + 'o';
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryTemporaryOnConversionToString" defaultSeverity="WARNING" displayName="转换为 'String' 时有不必要的临时对象" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告从基元类型转换为 &lt;code&gt;String&lt;/code&gt; 时创建的不必要的临时对象。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String foo = new Integer(3).toString();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String foo = Integer.toString(3);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ObjectInstantiationInEqualsHashCode" defaultSeverity="WARNING" displayName="'equals()' 或 'hashCode()' 内部的对象实例化" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;equals()&lt;/code&gt;、&lt;code&gt;hashCode()&lt;/code&gt;、&lt;code&gt;compareTo()&lt;/code&gt; 和 &lt;code&gt;Comparator.compare()&lt;/code&gt; 方法内（临时）新对象的构造。
&lt;p&gt;
  除了构造函数调用之外，还可以通过在 &lt;code&gt;foreach&lt;/code&gt; 语句中自动装箱或迭代器创建来创建新对象。
  这可能会导致性能问题，例如，将对象添加到 &lt;code&gt;Set&lt;/code&gt; 或 &lt;code&gt;Map&lt;/code&gt; 时，这些方法将在这些地方被经常调用。
&lt;/p&gt;
&lt;p&gt;
  当在 &lt;code&gt;throw&lt;/code&gt; 或 &lt;code&gt;assert&lt;/code&gt; 语句中创建对象时，该检查将不会报告。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Person {
    private String name;
    private int age;

    public boolean equals(Object o) {
      return Arrays.equals(new Object[] {name, age}, new Object[] {((Foo)o).name, ((Foo)o).age});
    }

    public int hashCode() {
      return (name + age).hashCode();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  在此示例中，在 &lt;code&gt;equals()&lt;/code&gt; 内部创建了两个额外的数组，&lt;code&gt;age&lt;/code&gt; 字段的用法需要装箱，而 &lt;code&gt;name + age&lt;/code&gt; 隐式地创建了一个新字符串。
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TrivialStringConcatenation" defaultSeverity="WARNING" displayName="与空字符串串联" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告其中一个实参为空字符串的字符串串联。
此类连接是不必要且低效的，特别是当用作将非 &lt;code&gt;String&lt;/code&gt; 对象或基元格式化为 &lt;code&gt;String&lt;/code&gt; 的习惯用法时。
&lt;p&gt;
  建议通过快速修复来简化串联。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void foo(int x, int y) {
    String s = "" + x + " ; " + y;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void foo(int x, int y) {
    String s = x + " ; " + y;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AutoBoxing" defaultSeverity="WARNING" displayName="自动装箱" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告受自动装箱转换（将基元值自动包装为对象）影响的表达式。
尽量不使用对象，而是使用基元。 它可能会显著影响性能。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Integer x = 42;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该快速修复会将转换设为显式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Integer x = Integer.valueOf(42);&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  &lt;i&gt;自动装箱&lt;/i&gt;在 Java 5 中出现。
  此检查有助于为向后兼容早期 Java 版本而降级。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CollectionAddAllCanBeReplacedWithConstructor" defaultSeverity="WARNING" displayName="冗余的 'Collection.addAll()' 调用" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
在使用无参构造函数实例化集合后，立即报告 &lt;code&gt;Collection.addAll()&lt;/code&gt; 和 &lt;code&gt;Map.putAll()&lt;/code&gt; 调用。
&lt;p&gt;此类结构可以替换为对形参化构造函数的单次调用，从而简化代码。 此外，对于某些集合，替换可能会更高效。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Set&amp;lt;String&amp;gt; set = new HashSet&amp;lt;&amp;gt;();
  set.addAll(Arrays.asList("alpha", "beta", "gamma"));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Set&amp;lt;String&amp;gt; set = new HashSet&amp;lt;&amp;gt;(Arrays.asList("alpha", "beta", "gamma"));
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  默认支持 JDK 集合类。
  此外，还可以使用&lt;b&gt;要检查的类&lt;/b&gt;面板指定其他类。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ManualArrayCopy" defaultSeverity="WARNING" displayName="手动数组复制" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可被替换为 &lt;code&gt;System.arraycopy()&lt;/code&gt; 调用的数组内容的手动复制。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  for (int i = 0; i &amp;lt; array.length; i++) {
    newArray[i] = array[i];
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  System.arraycopy(array, 0, newArray, 0, array.length);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StringConcatenationInsideStringBufferAppend" defaultSeverity="WARNING" displayName="字符串串联作为 'StringBuilder.append()' 调用的实参" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告用作 &lt;code&gt;StringBuffer.append()&lt;/code&gt;、&lt;code&gt;StringBuilder.append()&lt;/code&gt; 或 &lt;code&gt;Appendable.append()&lt;/code&gt; 的实参的 &lt;code&gt;String&lt;/code&gt; 串联。
&lt;p&gt;
  此类调用可以有利地转变为现有 &lt;code&gt;StringBuffer/Builder/Appendable&lt;/code&gt; 中的链式追加调用，从而节省额外的 &lt;code&gt;StringBuffer/Builder&lt;/code&gt; 分配成本。
  此检查将忽略编译时求值的 &lt;code&gt;String&lt;/code&gt; 串联，在这种情况下，转换只会降低性能。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void bar(StringBuilder builder, String name) {
    builder.append("Hello," + name);    //警告
    builder.append("Hello," + "world"); //无警告
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="BoxingBoxedValue" defaultSeverity="WARNING" displayName="装箱已装箱的值" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告已装箱值的装箱。
&lt;p&gt;
  这是冗余的操作，因为任何装箱的值都会先自动拆箱，然后再次对该值装箱。 如果在内部循环中进行，此类代码可能会导致性能问题。
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Integer value = 1;
  method(Integer.valueOf(value));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Integer value = 1;
  method(value);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CallToSimpleSetterInClass" defaultSeverity="WARNING" displayName="从类内调用简单 setter" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告从属性的类内部对简单属性 setter 的调用。
&lt;p&gt;
  简单的属性 setter 被定义为只将其形参的值分配给一个字段，而不进行其他计算。 可以安全地内联此类简单的 setter 调用。
  为了保持代码清晰，某些编码标准还建议不使用简单的 setter。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
  private int index;
    public Foo(int idx) {
       setIndex(idx);
    }
    public void setIndex(int idx) {
       index = idx;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    private int index;
    public Foo(int idx) {
      index = idx;
    }
    public void setIndex(int idx) {
      index = idx;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;使用以下选项配置检查：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;是否仅报告 &lt;code&gt;this&lt;/code&gt; 上的 setter 调用，而不报告作为形参传入的相同类型的对象。&lt;/li&gt;
  &lt;li&gt;是否忽略非 &lt;code&gt;private&lt;/code&gt; setter。&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FieldMayBeStatic" defaultSeverity="WARNING" displayName="字段可以为 'static'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以安全地设为 &lt;code&gt;static&lt;/code&gt; 的实例变量。 如果字段被声明为 &lt;code&gt;final&lt;/code&gt; 并用常量初始化，则该字段可以为 static 字段。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public final String str = "sample";
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SlowAbstractSetRemoveAll" defaultSeverity="WARNING" displayName="调用 'set.removeAll(list)' 可能较为缓慢" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对包含 &lt;code&gt;java.util.List&lt;/code&gt; 实参的 &lt;code&gt;java.util.Set.removeAll()&lt;/code&gt; 的调用。
&lt;p&gt;
  当实参大小大于或等于集合大小，并且集合是 &lt;code&gt;java.util.AbstractSet&lt;/code&gt; 的子类时，此类调用可能会很慢。
  在本例中，对集合中的每个元素调用了 &lt;code&gt;List.contains()&lt;/code&gt;，将执行线性搜索。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public void check(String... ss) {
    // 可能的 O(n^2) 复杂度
    mySet.removeAll(List.of(ss));
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public void check(String... ss) {
    // O(n) 复杂度
    List.of(ss).forEach(mySet::remove);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2020.3 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="StringBufferToStringInConcatenation" defaultSeverity="WARNING" displayName="连接中的 'StringBuilder.toString()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告字符串串联中的 &lt;code&gt;StringBuffer.toString()&lt;/code&gt; 或 &lt;code&gt;StringBuilder.toString()&lt;/code&gt; 调用。
此类调用在串联时不必要且可以移除，从而节省方法调用和对象分配，这样可以提高性能。
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ObjectAllocationInLoop" defaultSeverity="WARNING" displayName="循环中的对象分配" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告循环内的对象或数组分配。 虽然不一定是问题，但循环内的对象分配是查找内存泄漏和性能问题的好地方。
&lt;p&gt;
  检查会报告以下结构：
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;通过 &lt;code&gt;new&lt;/code&gt; 运算符进行的显式分配&lt;/li&gt;
  &lt;li&gt;已知会返回新对象的方法&lt;/li&gt;
  &lt;li&gt;实例绑定方法引用&lt;/li&gt;
  &lt;li&gt;捕获变量或 &lt;code&gt;this&lt;/code&gt; 引用的 lambda&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  // 显式分配
  for (Status status : Status.values()) {
    declarationsMap.put(status, new ArrayList&amp;lt;&amp;gt;());
  }

  // Lambda 捕获变量
  String message = "Engine running.";
  for (Engine engine : engines) {
      if (!isRunning(engine)) {
          logger.warn(() -&gt; {
              return String.format(message);
          });
      }
  }

  // 实例绑定方法引用
  for(Node node : nodes) {
    descriptor = node.getDescription();
    descriptor.ifPresent(dynamicTestExecutor::execute);
  }
&lt;/code&gt;
&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="EqualsHashCodeCalledOnUrl" defaultSeverity="WARNING" displayName="在 'URL' 对象上调用了 'equals()' 或 'hashCode()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在 &lt;code&gt;java.net.URL&lt;/code&gt; 对象上的 &lt;code&gt;hashCode()&lt;/code&gt; 和 &lt;code&gt;equals()&lt;/code&gt; 调用。
&lt;p&gt;
  &lt;code&gt;URL&lt;/code&gt; 的 &lt;code&gt;equals()&lt;/code&gt; 和 &lt;code&gt;hashCode()&lt;/code&gt; 方法可以执行 DNS 查找来解析主机名。
  这可能会导致重大延迟，具体取决于网络和 DNS 服务器的可用性和速度。
  使用 &lt;code&gt;java.net.URI&lt;/code&gt; 代替 &lt;code&gt;java.net.URL&lt;/code&gt; 将避免 DNS 查找。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int equalsHashCode(URL url1, URL url2) {
    return url1.hashCode() == url2.hashCode();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ListRemoveInLoop" defaultSeverity="WARNING" displayName="在循环中调用了 'List.remove()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在循环中调用的可以替换为 &lt;code&gt;List.subList().clear()&lt;/code&gt; 的 &lt;code&gt;List.remove(index)&lt;/code&gt;。
&lt;p&gt;在删除多个元素的情况下，此替换对于大多数  &lt;code&gt;List&lt;/code&gt; 实现更有效。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void removeRange(List&amp;lt;String&amp;gt; list, int from, int to) {
    for (int i = from; i &amp;lt; to; i++) {
        list.remove(from);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void removeRange(List&amp;lt;String&amp;gt; list, int from, int to) {
    if (to &amp;gt; from) {
      list.subList(from, to).clear();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  该快速修复会自动添加范围检查，以防止在最小值大于最大值时可能出现的 &lt;code&gt;IndexOutOfBoundsException&lt;/code&gt;。 如果代码中不可能出现这种情况，则可将其移除。
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2018.2 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LengthOneStringInIndexOf" defaultSeverity="WARNING" displayName="'String.indexOf()' 调用中的单字符字符串实参" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在 &lt;code&gt;String.indexOf()&lt;/code&gt; 和 &lt;code&gt;String.lastIndexOf()&lt;/code&gt; 调用中用作实参的单字符字符串。
&lt;p&gt;建议通过快速修复将此类字符串文字替换为等效的字符文字，从而获得一些性能增强。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  return s.indexOf("x");
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  return s.indexOf('x');
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UseBulkOperation" defaultSeverity="WARNING" displayName="可以使用批量操作代替迭代" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告循环内部可以替换为批量方法的单一运算。
&lt;p&gt;
  批量方法不仅更短，而且有时性能也更好。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  void test(Collection&amp;lt;Integer&amp;gt; numbers) {
    List&amp;lt;Integer&amp;gt; result = new ArrayList&amp;lt;&gt;();
    for (Integer i : numbers) {
      result.add(i);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;应用修正后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void test(Collection&amp;lt;Integer&amp;gt; numbers) {
    List&amp;lt;Integer&amp;gt; result = new ArrayList&amp;lt;&gt;();
    result.addAll(numbers);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  即便批量方法需要集合，&lt;b&gt;使用 Arrays.asList() 包装数组&lt;/b&gt;选项也使您能够报告数组。
  在本例中，该快速修复会自动将数组包装在 &lt;code&gt;Arrays.asList()&lt;/code&gt; 调用中。
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;2017.1 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MapReplaceableByEnumMap" defaultSeverity="WARNING" displayName="'Map' 可被替换为 'EnumMap'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告键类型为枚举类的 &lt;code&gt;java.util.Map&lt;/code&gt; 对象的实例化。 此类 &lt;code&gt;java.util.Map&lt;/code&gt; 对象可以替换为 &lt;code&gt;java.util.EnumMap&lt;/code&gt; 对象。
&lt;p&gt;
  &lt;code&gt;java.util.EnumMap&lt;/code&gt; 实现可以更加高效，因为底层数据结构是简单的数组。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Map&amp;lt;MyEnum, String&amp;gt; myEnums = new HashMap&amp;lt;&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Map&amp;lt;MyEnum, String&amp;gt; myEnums = new EnumMap&amp;lt;&amp;gt;(MyEnum.class);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CollectionsMustHaveInitialCapacity" defaultSeverity="WARNING" displayName="没有初始容量的集合" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在不指定初始容量的情况下实例化新 &lt;code&gt;Collection&lt;/code&gt; 对象的尝试。
&lt;p&gt;
  如果未指定初始容量，则使用默认容量，这很少是最佳选择。 如果在超出初始容量时需要重新分配空间和复制内存，则未能为集合指定初始容量可能会导致性能问题。
  此检查会检查在检查的设置中列出的类的分配。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  new HashMap&amp;lt;String, String&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;使用以下选项配置检查：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;列出应检查的集合类。&lt;/li&gt;
  &lt;li&gt;是否忽略字段初始值设定项。&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryTemporaryOnConversionFromString" defaultSeverity="WARNING" displayName="从 'String' 转换时有不必要的临时对象" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告从 &lt;code&gt;String&lt;/code&gt; 转换为基元类型时创建的不必要的临时对象。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  new Integer("3").intValue()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Integer.valueOf("3")
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RandomDoubleForRandomInteger" defaultSeverity="WARNING" displayName="使用 'Random.nextDouble()' 获取随机整数" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对 &lt;code&gt;java.util.Random.nextDouble()&lt;/code&gt; 的调用，这些调用用于通过将调用乘以一个系数并转换为整数来创建正整数。
&lt;p&gt;
  对于在一定范围内生成随机正整数，&lt;code&gt;java.util.Random.nextInt(int)&lt;/code&gt; 更加简单和高效。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int getRandomInt() {
    return (int) ((new Random()).nextDouble() * SIZE);
  }
  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int getRandomInt() {
    return (new Random()).nextInt(SIZE);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ToArrayCallWithZeroLengthArrayArgument" defaultSeverity="WARNING" displayName="'Collection.toArray()' 调用样式" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告非首选样式的 &lt;code&gt;Collection.toArray()&lt;/code&gt; 调用，并建议应用首选样式。
&lt;p&gt;将集合转换为数组有两种样式：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;预先确定大小的数组，例如 &lt;code&gt;c.toArray(new String[c.size()])&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;空数组，例如 &lt;code&gt;c.toArray(new String[0])&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在旧的 Java 版本中，建议使用预先确定大小的数组，因为创建适当大小的数组所需的反射调用非常慢。&lt;/p&gt;
&lt;p&gt;不过，自 OpenJDK 6 的最新更新以来，此调用已被添加，使得空数组版本的性能与预先确定大小的版本相同，有时甚至更高一筹。 此外，传递预先确定大小的数组对于并发集合或同步集合很危险，因为 &lt;code&gt;size&lt;/code&gt; 和 &lt;code&gt;toArray&lt;/code&gt; 调用之间可能会发生数据竞争。 如果在运算过程中并发收缩该集合，可能导致数组末尾出现额外的 &lt;code&gt;null&lt;/code&gt;。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;使用检查选项可以选择首选样式。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ArraysAsListWithZeroOrOneArgument" defaultSeverity="WARNING" displayName="'Arrays.asList()' 调用的实参过少" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对最多包含一个实参的 &lt;code&gt;Arrays.asList()&lt;/code&gt; 的调用。
&lt;p&gt;
  在 JDK 9 及更高版本中，此类调用可以替换为 &lt;code&gt;Collections.singletonList()&lt;/code&gt;、&lt;code&gt;Collections.emptyList()&lt;/code&gt; 或 &lt;code&gt;List.of()&lt;/code&gt;，从而节省内存。&lt;/p&gt;
&lt;p&gt;特别是，无实参的 &lt;code&gt;Collections.emptyList()&lt;/code&gt; 和 &lt;code&gt;List.of()&lt;/code&gt; 总是返回共享实例，而无实参的 &lt;code&gt;Arrays.asList()&lt;/code&gt; 每次调用时都会创建一个新对象。&lt;/p&gt;
&lt;p&gt;注意：&lt;code&gt;Collections.singletonList()&lt;/code&gt; 和 &lt;code&gt;List.of()&lt;/code&gt; 返回的列表不可变，而列表返回的 &lt;code&gt;Arrays.asList()&lt;/code&gt; 允许调用 &lt;code&gt;set()&lt;/code&gt; 方法。
这在极少数情况下可能会破坏代码。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  List&amp;lt;String&amp;gt; empty = Arrays.asList();
  List&amp;lt;String&amp;gt; one = Arrays.asList("one");
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  List&amp;lt;String&amp;gt; empty = Collections.emptyList();
  List&amp;lt;String&amp;gt; one = Collections.singletonList("one");
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="BooleanConstructor" defaultSeverity="WARNING" displayName="布尔构造函数调用" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;Boolean&lt;/code&gt; 对象的创建情况。
&lt;p&gt;
  基本不必要创建新的 &lt;code&gt;Boolean&lt;/code&gt; 对象，如果经常这样做，可能会导致性能问题。 此外，&lt;code&gt;Boolean&lt;/code&gt; 构造函数自 Java 9 起已弃用，在未来的 Java 版本中可能会被移除或变得无法访问。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Boolean b1 = new Boolean(true);
  Boolean b2 = new Boolean(str);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Boolean b1 = Boolean.TRUE;
  Boolean b2 = Boolean.valueOf(str);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StringBufferMustHaveInitialCapacity" defaultSeverity="WARNING" displayName="没有初始容量的 'StringBuilder'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对新 &lt;code&gt;StringBuffer&lt;/code&gt; 或 &lt;code&gt;StringBuilder&lt;/code&gt; 对象进行实例化而不指定其初始容量的尝试。
&lt;p&gt;
  如果未指定初始容量，则使用默认容量，这很少是最佳选择。
  如果在超出初始容量时需要重新分配空间并复制内存，则未指定 &lt;code&gt;StringBuffer&lt;/code&gt; 的初始容量可能会导致性能问题。
&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  // 未指定容量
  var sb = new StringBuilder();
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StringReplaceableByStringBuffer" defaultSeverity="WARNING" displayName="非常量 'String' 可被替换为 'StringBuilder'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告被声明为 &lt;code&gt;java.lang.String&lt;/code&gt; 且重复追加的变量。 此类变量可以更有效地被声明为 &lt;code&gt;java.lang.StringBuffer&lt;/code&gt; 或 &lt;code&gt;java.lang.StringBuilder&lt;/code&gt;。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String s = "";
  for (int i = 0; i &amp;lt; names.length; i++) {
    String name = names[i] + (i == names.length - 1 ? "" : " ");
    s = s + name;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此类循环可以替换为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  StringBuilder s = new StringBuilder();
  for (int i = 0; i &amp;lt; names.length; i++) {
    String name = names[i] + (i == names.length - 1 ? "" : " ");
    s.append(name);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者甚至可以替换为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String s = String.join(" ", names);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用该选项可使此检查仅在变量被附加到循环中时报告。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReplaceInefficientStreamCount" defaultSeverity="WARNING" displayName="以 count() 结尾的低效 Stream API 调用链" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以优化并且以 &lt;code&gt;count()&lt;/code&gt; 运算结束的 Stream API 调用链。
&lt;p&gt;
  以下调用链替换为此检查：
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;Collection.stream().count()&lt;/code&gt; &amp;rarr; &lt;code&gt;Collection.size()&lt;/code&gt;. 在 Java 8 中，&lt;code&gt;Collection.stream().count()&lt;/code&gt; 实际上是通过迭代集合元素来进行计数，而 &lt;code&gt;Collection.size()&lt;/code&gt; 对于大多数集合来说速度要快得多。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Stream.flatMap(Collection::stream).count()&lt;/code&gt; &amp;rarr; &lt;code&gt;Stream.mapToLong(Collection::size).sum()&lt;/code&gt;. 同样，不需要遍历所有嵌套集合。 相反，它们的大小可以相加。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Stream.filter(o -&gt; ...).count() &gt; 0&lt;/code&gt; &amp;rarr; &lt;code&gt;Stream.anyMatch(o -&gt; ...)&lt;/code&gt;. 与初始调用不同，一旦找到匹配元素后 &lt;code&gt;anyMatch()&lt;/code&gt; 就可以立即停止计算。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Stream.filter(o -&gt; ...).count() == 0&lt;/code&gt; &amp;rarr; &lt;code&gt;Stream.noneMatch(o -&gt; ...)&lt;/code&gt;. 与以上相似。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
  请注意，如果替换涉及 &lt;code&gt;anyMatch()&lt;/code&gt; 等短路操作，那么中间流操作产生副作用时，可能会出现明显的行为变化。 在 Stream API 调用中通常应避免副作用。
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ClassInitializerMayBeStatic" defaultSeverity="WARNING" displayName="类初始值设定项可能为 'static'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以使之为 &lt;code&gt;static&lt;/code&gt; 的实例初始值设定项。
&lt;p&gt;
  如果实例初始值设定项不引用其类的任何非 static 成员，则可以为 static。
  static 初始值设定项在类解析后执行，而实例初始值设定项对此类的每个实例化执行。&lt;/p&gt;
&lt;p&gt;此检查不报告匿名类中的实例空初始值设定项和初始值设定项。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class A {
     public static String CONSTANT;
     {
        CONSTANT = "Hello";
     }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class A {
     public static String CONSTANT;
     static {
        CONSTANT = "Hello"; // 现在每个类仅实例化一次
     }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ExplicitArgumentCanBeLambda" defaultSeverity="INFORMATION" displayName="显式实参可以是 lambda" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告接受非普通表达式的方法调用，这些方法调用可以替换为接受 lambda 的等效方法调用。
&lt;p&gt;
将表达式转换为 lambda 可确保不会评估方法中未使用的表达式。 例如，&lt;code&gt;optional.orElse(createDefaultValue())&lt;/code&gt; 可以转换为 &lt;code&gt;optional.orElseGet(this::createDefaultValue)&lt;/code&gt;。
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2018.1 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="BulkFileAttributesRead" defaultSeverity="WARNING" displayName="可使用批量 'Files.readAttributes()' 调用" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告连续多个 &lt;code&gt;java.io.File&lt;/code&gt; 特性检查，例如：
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;isDirectory()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;isFile()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;lastModified()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;length()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
此类调用可被替换为批量 &lt;code&gt;Files.readAttributes()&lt;/code&gt; 调用。
这通常比多个单独的特性检查性能更好。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean isNewFile(File file, long lastModified) throws IOException {
    return file.isFile() &amp;&amp; file.lastModified() &gt; lastModified;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean isNewFile(File file, long lastModified) throws IOException {
    BasicFileAttributes fileAttributes = Files.readAttributes(file.toPath(), BasicFileAttributes.class);
    return fileAttributes.isRegularFile() &amp;&amp; fileAttributes.lastModifiedTime().toMillis() &gt; lastModified;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;如果 &lt;code&gt;IOException&lt;/code&gt; 在当前上下文中未被处理，则此检查不会显示警告，但快速修复仍然可用。&lt;/p&gt;
&lt;p&gt;请注意，替换通常不完全相同，应谨慎使用。 特别是，如果文件根本不存在，行为可能会有所不同。&lt;/p&gt;
&lt;p&gt;仅当项目或模块的语言级别为 7 或更高时，此检查才会报告。&lt;/p&gt;
&lt;p&gt;&lt;small&gt;2022.1 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TailRecursion" defaultSeverity="INFORMATION" displayName="尾递归" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告尾递归，即方法在返回前调用自身作为其最后一项操作。
&lt;p&gt;
  尾递归总是可以替换为循环，循环的速度快得多。
  有些 JVM 执行尾调用优化，而其他一些 JVM 则不执行。 因此，尾递归解决方案在不同的虚拟机上可能有截然不同的性能特征。
&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int factorial(int val, int runningVal) {
    if (val == 1) {
      return runningVal;
    } else {
      return factorial(val - 1, runningVal * val);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int factorial(int val, int runningVal) {
    while (true) {
      if (val == 1) {
        return runningVal;
      } else {
        runningVal = runningVal * val;
        val = val - 1;
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="WrapperTypeMayBePrimitive" defaultSeverity="WARNING" displayName="包装器类型可能是基元" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告主要用作基元类型的包装器类型的局部变量。
&lt;p&gt;在某些情况下，装箱可能会导致严重的性能损失，尤其是在循环中。&lt;/p&gt;
&lt;p&gt;采用启发估计装箱操作次数。 例如，循环内的转换数量视为更多。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  public void example() {
    Integer value = 12;
    needBox(value);
    for (int i = 0; i &amp;lt; 10; i++) {
      // 循环的用法正变得越来越频繁
      needPrimitive(value);
    }
  }

  void needPrimitive(int value) {}
  void needBox(Integer value) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  public void example() {
    int value = 12;
    needBox(value);
    for (int i = 0; i &amp;lt; 10; i++) {
      // 循环的用法正变得越来越频繁
      needPrimitive(value);
    }
  }

  void needPrimitive(int value) {}
  void needBox(Integer value) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  &lt;small&gt;2018.2 最新变化&lt;/small&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="InstantiatingObjectToGetClassObject" defaultSeverity="WARNING" displayName="实例化对象以获取 'Class' 对象" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告实例化类以获取其类对象的代码。
&lt;p&gt;直接按名称访问类对象时的性能更好。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Class&amp;lt;?&amp;gt; c = new Sample().getClass();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Class&amp;lt;?&amp;gt; c = Sample.class;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SetReplaceableByEnumSet" defaultSeverity="WARNING" displayName="'Set' 可被替换为 'EnumSet'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告内容类型为枚举类的 &lt;code&gt;java.util.Set&lt;/code&gt; 对象的实例化。 此类 &lt;code&gt;Set&lt;/code&gt; 对象可以替换为 &lt;code&gt;java.util.EnumSet&lt;/code&gt; 对象。
&lt;p&gt;
  与其他集合相比，&lt;code&gt;EnumSet&lt;/code&gt; 实现的效率更高，因为底层数据结构是位向量。 使用该快速修复可以将初始值设定项替换为 &lt;code&gt;EnumSet.noneOf()&lt;/code&gt; 调用。 当变量类型是 &lt;code&gt;Set&lt;/code&gt; 的子类时，此快速修复不可用。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  enum MyEnum { FOO, BAR; }

  Set&amp;lt;MyEnum&amp;gt; enums = new HashSet&amp;lt;MyEnum&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  enum MyEnum { FOO, BAR; }

  Set&amp;lt;MyEnum&amp;gt; enums = EnumSet.noneOf(MyEnum.class);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MethodMayBeStatic" defaultSeverity="WARNING" displayName="方法可以为 'static'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以安全设置为 &lt;code&gt;static&lt;/code&gt; 的方法。
尽可能将方法设置为 static 可减少内存消耗并提高代码质量。
&lt;p&gt;如果满足以下条件，则方法可以为 &lt;code&gt;static&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    不是 &lt;code&gt;synchronized&lt;/code&gt;、&lt;code&gt;native&lt;/code&gt; 或 &lt;code&gt;abstract&lt;/code&gt;，
  &lt;/li&gt;
  &lt;li&gt;
    不引用包含类中的任何非 static 方法和非 static 字段，
  &lt;/li&gt;
  &lt;li&gt;
    不是重写，也不会在子类中被重写。
  &lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;使用以下选项配置检查：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;是否只报告 &lt;code&gt;private&lt;/code&gt; 和 &lt;code&gt;final&lt;/code&gt; 方法，从而提高此检查的性能。&lt;/li&gt;
  &lt;li&gt;是否忽略空方法。&lt;/li&gt;
  &lt;li&gt;使用 Java 8 或更高版本时是否忽略接口中的默认方法。&lt;/li&gt;
  &lt;li&gt;
    是否让该快速修复在调用被设为 &lt;code&gt;static&lt;/code&gt; 的方法时使用类引用替换实例限定符，即调用 &lt;code&gt;myClass.m()&lt;/code&gt; 将被替换为 &lt;code&gt;MyClass.m()&lt;/code&gt;。
  &lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantStringFormatCall" defaultSeverity="WARNING" displayName="冗余调用 'String.format()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对 &lt;code&gt;format()&lt;/code&gt; 和 &lt;code&gt;printf()&lt;/code&gt; 等可以安全移除或简化的方法的调用。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  System.out.println(String.format("Total count: %d", 42));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  System.out.printf("Total count: %d%n", 42);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ObjectEqualsCanBeEquality" defaultSeverity="INFORMATION" displayName="'equals()' 调用可被替换为 '=='" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对可以替换为 &lt;code&gt;==&lt;/code&gt; 或 &lt;code&gt;!=&lt;/code&gt; 表达式而又不改变语义的 &lt;code&gt;equals()&lt;/code&gt; 的调用。
&lt;p&gt;当这些调用用于比较没有自身的 &lt;code&gt;equals()&lt;/code&gt; 实现但使用默认 &lt;code&gt;Object.equals()&lt;/code&gt; 的&lt;code&gt;final&lt;/code&gt; 类时，可以替换这些调用。
此替换可能会提升性能。&lt;/p&gt;
&lt;p&gt;对 &lt;code&gt;enum&lt;/code&gt; 值上的 &lt;code&gt;equals()&lt;/code&gt; 调用进行单独检查：对 Enum 值调用 'equals()'。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;!--&lt;p&gt;&lt;small&gt;New in 2017.3&lt;/small&gt;--&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="KeySetIterationMayUseEntrySet" defaultSeverity="WARNING" displayName="可以优化对 'keySet()' 的迭代" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对 &lt;code&gt;java.util.Map&lt;/code&gt; 实例的 &lt;code&gt;keySet()&lt;/code&gt; 的迭代，其中迭代的键用于从映射中检索值。
&lt;p&gt;
  替换为 &lt;code&gt;entrySet()&lt;/code&gt; 或 &lt;code&gt;values()&lt;/code&gt; 的迭代时，此类迭代可能会更有效（如果实际上没有使用键）。
&lt;/p&gt;
&lt;p&gt;
  同理，如果在 lambda 中检索值，则 &lt;code&gt;keySet().forEach(key -&amp;gt; ...)&lt;/code&gt; 可以替换为 &lt;code&gt;forEach((key, value) -&amp;gt; ...)&lt;/code&gt;。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  for (Object key : map.keySet()) {
   Object val = map.get(key);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  for (Object val : map.values()) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="版本控制" path=""><inspection shortName="IgnoreFileDuplicateEntry" defaultSeverity="WARNING" displayName="忽略文件重复项" enabled="false" language="IgnoreLang" pluginId="com.intellij" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告忽略文件（例如 .gitignore、.hgignore）中的重复条目（模式）。
这些文件中的重复条目冗余，可以移除。

&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;
    # Output directories
    /out/
    /target/
    &lt;b&gt;&lt;span style="color: #BE9117; "&gt;/out/&lt;/span&gt;&lt;/b&gt;
&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="常规" path="JavaScript and TypeScript"><inspection shortName="JSPrimitiveTypeWrapperUsage" defaultSeverity="WARNING" displayName="使用了基元类型对象包装器" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告基元类型包装器使用不当或基元类型属性被修改的情况，因为在后一种情况下，所赋之值将丢失。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="WebpackConfigHighlighting" defaultSeverity="WARNING" displayName="Webpack 配置符合 JSON 架构" enabled="false" language="JavaScript" pluginId="intellij.webpack" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
根据 &lt;a href="https://github.com/webpack/webpack/blob/master/schemas/WebpackOptions.json"&gt;webpack 选项架构&lt;/a&gt;验证 webpack 配置文件中的选项（名称应以 `webpack` 开头，例如 `webpack.config.js`）。
&lt;br/&gt;&lt;br/&gt;
禁用此检查以关闭配置对象内部的验证和代码补全。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSUnnecessarySemicolon" defaultSeverity="WARNING" displayName="不必要的分号" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告不必要的分号。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ES6DestructuringVariablesMerge" defaultSeverity="WEAK WARNING" displayName="正在析构具有相同键的属性" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告多个包含相同键的解构属性。 建议合并这些属性。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSMethodCanBeStatic" defaultSeverity="INFORMATION" displayName="方法可以为 'static'" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以安全地设为 &lt;code&gt;static&lt;/code&gt; 的类方法。
如果某个方法未引用其类的任何非 static 方法和非 static 字段，并且未在子类中被重写，
则该方法可以为 &lt;code&gt;static&lt;/code&gt; 方法。
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用下面的第一个复选框只检查 &lt;code&gt;private&lt;/code&gt; 方法。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSUndeclaredVariable" defaultSeverity="WEAK WARNING" displayName="隐式声明的全局 JavaScript 变量" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告全局变量的隐式声明。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  var aaa = 1; // 优良
  bbb = 2; // 不良，如果未在某处用 'var' 声明 bbb
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSMismatchedCollectionQueryUpdate" defaultSeverity="WARNING" displayName="不匹配的集合查询和更新" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告查询了其内容但未更新或更新了其内容但未查询
的字段或变量的集合。 这种不匹配的查询和更新毫无意义，
并且可能表明有死码或排版错误。
&lt;p&gt;
根据查询方法是否返回某些内容或向其传递回调，来自动检测查询方法。
使用下表指定哪些方法是更新方法。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSFileReferences" defaultSeverity="WARNING" displayName="未解析的文件引用" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 JavaScript 文件中未解析的文件引用，包括 CommonJS 和 AMD 模块引用。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSUnresolvedLibraryURL" defaultSeverity="WARNING" displayName="HTTP 链接缺少本地存储的库" enabled="false" language="HTML" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告未与任何本地存储文件关联的外部 JavaScript 库的 URL。 建议下载此库。
此类关联使 IDE 可以提供正确的代码补全和导航。 
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSNonStrictModeUsed" defaultSeverity="WARNING" displayName="使用了非严格模式" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告不处于 &lt;code&gt; strict&lt;/code&gt; 模式的 JavaScript 文件。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSXUnresolvedComponent" defaultSeverity="WEAK WARNING" displayName="未解析的 JSX 组件" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对 JSX 组件的未解析引用。
如果引用的组件在此项目或其依赖项中定义，则建议添加缺少的 import 语句，或创建采用此名称的新组件。
&lt;p&gt;新组件的模板可以在“编辑器 | 文件和代码模板”中修改。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSCommentMatchesSignature" defaultSeverity="WARNING" displayName="不匹配的 JSDoc 和函数签名" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 JSDoc 注释中形参的名称和数量与函数的实际形参之间不匹配的情况。
建议更新 JSDoc 注释中的形参。
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
/**
 * @param height Height in pixels
 */
function sq(height, width) {} // 宽度未记录
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
/**
 * @param height Height in pixels
 * @param width
 */
function sq(height, width) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSLastCommaInObjectLiteral" defaultSeverity="WARNING" displayName="对象文字中的最后一个逗号多余" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对象文字中尾随逗号的用法。

&lt;p&gt;只有将 JavaScript 语言版本设置为 ECMAScript 5.1 时才报告该警告。&lt;/p&gt;

&lt;p&gt;此规范允许在对象文字中使用尾随逗号，但在使用尾随逗号时，某些浏览器可能会抛出错误。&lt;/p&gt;

&lt;p&gt;您可以在&lt;b&gt;代码样式&lt;/b&gt; | &lt;b&gt;JavaScript&lt;/b&gt; 或 &lt;b&gt;TypeScript&lt;/b&gt; | &lt;b&gt;标点符号&lt;/b&gt;中配置尾随逗号的格式设置选项。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ES6RedundantNestingInTemplateLiteral" defaultSeverity="WEAK WARNING" displayName="模板文字中的冗余嵌套" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告字符串或模板文字的嵌套实例。 建议将嵌套的实例内联到包含其的模板字符串中。
&lt;!-- tooltip end --&gt;
&lt;p&gt;示例： &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
let a = `Hello, ${`Brave ${"New"}`} ${"World"}!`
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;应用快速修复后，代码如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
let a = `Hello, Brave New World!`
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ES6ShorthandObjectProperty" defaultSeverity="INFORMATION" displayName="属性可被替换为速记形式" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以转换为 ES6 速记样式的对象属性，并提供快速修复来执行此操作。
&lt;!-- tooltip end --&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
var obj = {foo:foo}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;应用快速修复后，代码如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
var obj = {foo}
&lt;/code&gt;&lt;/pre&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSReferencingMutableVariableFromClosure" defaultSeverity="WARNING" displayName="从闭包中引用可变变量" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告函数中对外部可变变量的访问。 
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  for (var i = 1; i &amp;lt;= 3; i++) {
    setTimeout(function() {
        console.log(i); // 不良
    }, 0);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSJoinVariableDeclarationAndAssignment" defaultSeverity="INFORMATION" displayName="变量声明可与变量的第一个赋值合并" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在没有初始值设定项的情况下声明并且在代码或单个嵌套范围中使用多得多的变量。 建议将此变量移到更靠近其用法的位置，并将其与初始值设定项表达式联接起来。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSValidateJSDoc" defaultSeverity="WARNING" displayName="JSDoc 中的语法错误和未解析的引用" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告文档注释中的语法差异。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSClosureCompilerSyntax" defaultSeverity="WARNING" displayName="JSDoc 标记不正确的用法" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;em&gt;Google Closure Compiler&lt;/em&gt; 注解隐含的警告，包括 &lt;code&gt;@abstract&lt;/code&gt;、&lt;code&gt;@interface&lt;/code&gt; 和 &lt;code&gt;@implement&lt;/code&gt; 标记的正确使用情况。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSLastCommaInArrayLiteral" defaultSeverity="WARNING" displayName="数组文字中的最后一个逗号多余" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告数组文字中尾随逗号的用法。

&lt;p&gt;只有将 JavaScript 语言版本设置为 ECMAScript 5.1 时才报告该警告。&lt;/p&gt;

&lt;p&gt;尽管此规范允许在数组中使用尾随逗号，但在使用尾随逗号时，某些浏览器可能会抛出错误。&lt;/p&gt;

&lt;p&gt;您可以在&lt;b&gt;代码样式&lt;/b&gt; | &lt;b&gt;JavaScript&lt;/b&gt; 或 &lt;b&gt;TypeScript&lt;/b&gt; | &lt;b&gt;标点符号&lt;/b&gt;中配置尾随逗号的格式设置选项。 &lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ES6PreferShortImport" defaultSeverity="WARNING" displayName="可以缩短导入" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可缩短其 &lt;code&gt;from&lt;/code&gt; 部分的 ES6 import。 建议导入父目录。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSAnnotator" defaultSeverity="ERROR" displayName="未遵循 ECMAScript 规范" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告基本语法问题以及与语言规范不一致的情况，例如关键字的无效用法、不兼容的数字格式的用法或 getter/setter 的多个形参。
&lt;br&gt;
通常必须报告此类错误，并且不应禁用这些错误。
但在某些情况下，例如由于 JavaScript 的动态性质而导致问题、使用尚未支持的语言功能或 IDE 检查器中有错误时，禁止报告这些很基本的错误可能会很方便。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSJQueryEfficiency" defaultSeverity="WARNING" displayName="可以优化 JQuery 选择器" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以缓存的重复 jQuery 选择器，或报告特性或伪选择器的用法（可选）。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ES6ClassMemberInitializationOrder" defaultSeverity="WARNING" displayName="在 static 初始值设定项中使用可能未分配的属性" enabled="false" language="ECMAScript 6" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告引用另一个未提升的类成员，而被引用的这个类成员可能尚未初始化的类成员初始值设定项。
&lt;br/&gt;&lt;br/&gt;
由于针对字段进行类成员初始化，所以一个字段不能引用后面声明的另一个字段。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSCheckFunctionSignatures" defaultSeverity="WEAK WARNING" displayName="签名不匹配" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告其中的实参与所引用函数的签名不匹配的 JavaScript 调用表达式，包括实参的类型及其数量。
也报告在形参和返回类型方面与被重载函数不匹配的重载函数。

&lt;p&gt;将忽略 TypeScript 代码。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSValidateTypes" defaultSeverity="WEAK WARNING" displayName="类型不匹配" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告类型不正确的以下对象： 
&lt;ul&gt;
  &lt;li&gt;函数调用中的形参&lt;/li&gt;
  &lt;li&gt;返回值&lt;/li&gt;
  &lt;li&gt;赋值表达式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;将忽略 TypeScript 代码。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSUnfilteredForInLoop" defaultSeverity="WARNING" displayName="未过滤 for..in 循环" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告未筛选的 &lt;code&gt;for-in&lt;/code&gt; 循环。
&lt;br/&gt;&lt;br/&gt;
使用此结构不仅会处理对象自身的属性，还会处理对象原型的属性。
在某些特定情况下可能出人意料，例如，在复制或修改所有属性的实用程序方法中
或者 &lt;code&gt;Object&lt;/code&gt; 的原型可能被错误修改时。
例如，以下代码将打印 &lt;b&gt;42&lt;/b&gt; 和 &lt;b&gt;myMethod&lt;/b&gt;：
&lt;br/&gt;&lt;br/&gt;
&lt;pre&gt;&lt;code&gt;
Object.prototype.myMethod = function myMethod() {};
let a = { foo: 42 };
for (let i in a) {
  console.log(a[i]);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;建议将整个循环替换为 &lt;code&gt;Object.keys()&lt;/code&gt; 方法，或添加 &lt;code&gt;hasOwnProperty()&lt;/code&gt; 检查。 应用快速修复后，代码如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
for (let i in a) {
  if (a.hasOwnProperty(i)) {
    console.log(a[i]);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSXSyntaxUsed" defaultSeverity="ERROR" displayName="已使用 JSX 语法" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 JavaScript 代码中 JSX 标记的用法。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSDuplicatedDeclaration" defaultSeverity="WARNING" displayName="重复声明" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告一个范围中的多个声明。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSUnresolvedFunction" defaultSeverity="WEAK WARNING" displayName="未解析的 JavaScript 函数" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告调用中未解析的函数。
&lt;p&gt;将忽略 TypeScript 代码。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSUnresolvedExtXType" defaultSeverity="WARNING" displayName="未解析的 Ext JS xtype" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告没有相应类的 Ext JS &lt;code&gt;xtype&lt;/code&gt; 引用。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSDeprecatedSymbols" defaultSeverity="WEAK WARNING" displayName="已使用弃用的符号" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告弃用的函数变量的用法。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSAccessibilityCheck" defaultSeverity="WARNING" displayName="已引用无法访问的 @private 和 @protected 成员" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对使用 &lt;code&gt;@private&lt;/code&gt; 或 &lt;code&gt;@protected&lt;/code&gt; 标记进行标记，但不符合这些标记所隐含的可见性规则的 JavaScript 成员的引用。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSUnresolvedVariable" defaultSeverity="WEAK WARNING" displayName="未解析的 JavaScript 变量" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告未解析的引用变量或字段。
&lt;p&gt;将忽略 TypeScript 代码。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="注解" path="Groovy"><inspection shortName="GrPOJO" defaultSeverity="WARNING" displayName="无 @CompileStatic 的 @POJO" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报表注解 &lt;code&gt;@groovy.transform.stc.POJO&lt;/code&gt; 在没有&lt;code&gt;@groovy.transform.CompileStatic&lt;/code&gt; 的情况下的应用。&lt;p&gt;
&lt;p&gt;注解 &lt;code&gt;@POJO&lt;/code&gt; 将 Groovy 类的编译过程更改为字节码。 如果没有显式启用的静态编译（通过 &lt;code&gt;@CompileStatic&lt;/code&gt; 注解完成），它就不起作用。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @POJO // 报告 @POJO
  class A {}
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SingletonConstructor" defaultSeverity="ERROR" displayName="@Singleton 构造函数" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;除非被声明为非 strict，否则报告使用 &lt;code&gt;@Singleton&lt;/code&gt; 注解的类的构造函数。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Singleton
  class Foo{
      Foo(){
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有两种可能的快速修复方法：移除该构造函数，或者将 &lt;code&gt;@Singleton&lt;/code&gt; 声明为非 strict。&lt;/p&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Singleton
  class Foo{
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Singleton(&lt;b&gt;strict = false&lt;/b&gt;)
  class Foo{
      Foo(){
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GrAnnotationReferencingUnknownIdentifiers" defaultSeverity="WARNING" displayName="@TupleConstructor 和 @MapConstructor" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;@TupleConstructor&lt;/code&gt; 和 &lt;code&gt;@MapConstructor&lt;/code&gt;
&lt;code&gt;includes&lt;/code&gt; 和 &lt;code&gt;excludes&lt;/code&gt; 注解特性值中的未解析标识符。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  // 未解析的 'c'
  @TupleConstructor(includes = ['a', 'b', 'c'])
  class X {
      def a
      def b
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GrNamedVariantLabels" defaultSeverity="WARNING" displayName="@NamedVariant/@NamedParam/@NamedDelegate 未解析标签" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告通过 &lt;code&gt;@NamedVariant&lt;/code&gt;/&lt;code&gt;@NamedParam&lt;/code&gt;/&lt;code&gt;@NamedDelegate&lt;/code&gt; 注解的方法调用中未解析的实参标签。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @groovy.transform.NamedVariant
  def foo(a, b) {}

  // 未解析的标签 'c'
  foo(a: 1, b: 2, c: 3)
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="DelegatesTo" defaultSeverity="WARNING" displayName="@DelegatesTo" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告未使用的 &lt;code&gt;@DelegatesTo.Target&lt;/code&gt; 注解和未解析的 &lt;code&gt;@DelegatedTo.target&lt;/code&gt; 注解特性值。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  // 未使用的目标 't1' 和未解析的目标 't2'
  def m(
      @DelegatesTo.Target('t1') target,
      @DelegatesTo(target = 't2') Closure c
  ) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="Micronaut" path=""><inspection shortName="MnCacheAnnotationParameters" defaultSeverity="ERROR" displayName="未解析的缓存注解形参引用" enabled="false" language="UAST" pluginId="com.intellij.micronaut" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 &lt;code&gt;parameters&lt;/code&gt; 特性的值包含未定义方法形参名称的 Micronaut Cache 注解。&lt;/p&gt;
&lt;p&gt;支持以下注解：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;io.micronaut.cache.annotation.Cacheable&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;io.micronaut.cache.annotation.CachePut&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;io.micronaut.cache.annotation.CacheInvalidate&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @CachePut(parameters = "myParameter") // 错误：无法解析符号 'myParameter'
  public String cachedMethod(String name_is_not_equal_to_myParameter) {
    return "...";
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MnPropertiesConfig" defaultSeverity="WARNING" displayName="Micronaut 应用程序属性" enabled="false" language="Properties" pluginId="com.intellij.micronaut" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 Micronaut 应用程序 &lt;code&gt;.properties&lt;/code&gt; 配置文件中已弃用的配置键和无效值。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MnUnresolvedPathVariable" defaultSeverity="WARNING" displayName="未解析的 @PathVariable 引用" enabled="false" language="UAST" pluginId="com.intellij.micronaut" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告在方法签名中声明但在 URL 路径中缺失或者在 URL 路径中声明但在方法签名中缺失的 &lt;code&gt;@PathVariable&lt;/code&gt; 形参。
  该快速修复会添加缺失的形参。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Get("/path/{myVariable}/")
  public String handler(@PathVariable String name_is_not_equal_to_myVariable) {
    return "...";
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;应用快速修复后，结果如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Get("/path/{myVariable}/")
  public String handler(@PathVariable String myVariable) {
    return "...";
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MnInjectionPoints" defaultSeverity="WARNING" displayName="未解析的缓存注解形参引用" enabled="false" language="UAST" pluginId="com.intellij.micronaut" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告具有缺少的或不明确的依赖项的 Bean 类中的注入点。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  interface Engine {}

  @Singleton
  class GasEngine implements Engine {}

  @Singleton
  class ElectricEngine implements Engine {}

  @Singleton
  class Car {

    @Inject
    Engine &lt;b&gt;engine&lt;/b&gt;; // 依赖项不明确：有多个 Bean 匹配注入点
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MnYamlConfig" defaultSeverity="WARNING" displayName="Micronaut application.yaml" enabled="false" language="yaml" pluginId="com.intellij.micronaut" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 Micronaut 应用程序 &lt;code&gt;.yaml&lt;/code&gt; 配置文件中已弃用的配置键和无效值。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="依赖性问题" path="Java"><inspection shortName="ClassWithTooManyDependents" defaultSeverity="WARNING" displayName="依赖项过多的类" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
报告被过多其他类直接依赖的类。
&lt;p&gt;对这种类的任何修改都可能需要更改许多其他类，这可能开销巨大。&lt;/p&gt;
&lt;p&gt;仅报告顶级类。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;使用下面的字段可指定类的最大允许依赖项数。&lt;/p&gt;
&lt;p&gt;仅适用于&lt;b&gt;代码 | 检查代码&lt;/b&gt;或&lt;b&gt;代码 | 分析代码 | 通过名称运行检查&lt;/b&gt;，并且不会在编辑器中报告。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CyclicPackageDependency" defaultSeverity="WARNING" displayName="循环软件包依赖关系" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
报告相互依赖或循环依赖于其他软件包的软件包。
&lt;p&gt;此类循环依赖项会使代码变得脆弱且难以维护。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;仅适用于&lt;b&gt;代码 | 检查代码&lt;/b&gt;或&lt;b&gt;代码 | 分析代码 | 通过名称运行检查&lt;/b&gt;，并且不会在编辑器中报告。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ClassWithTooManyTransitiveDependencies" defaultSeverity="WARNING" displayName="可传递依赖项过多的类" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
报告直接或间接依赖于过多其他类的类。
&lt;p&gt;对这种类的任何依赖项的修改都可能需要更改该类，从而使其容易出现不稳定。&lt;/p&gt;
&lt;p&gt;仅报告顶级类。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;使用&lt;b&gt;最大传递依赖项数&lt;/b&gt;字段可指定类允许的最大直接或间接依赖项数。&lt;/p&gt;
&lt;p&gt;仅适用于&lt;b&gt;代码 | 检查代码&lt;/b&gt;或&lt;b&gt;代码 | 分析代码 | 通过名称运行检查&lt;/b&gt;，并且不会在编辑器中报告。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CyclicClassDependency" defaultSeverity="WARNING" displayName="循环类依赖" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
报告相互依赖或循环依赖于其他类的类。
&lt;p&gt;此类循环依赖项会使代码变得脆弱且难以维护。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;仅适用于&lt;b&gt;代码 | 检查代码&lt;/b&gt;或&lt;b&gt;代码 | 分析代码 | 通过名称运行检查&lt;/b&gt;，并且不会在编辑器中报告。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ClassWithTooManyDependencies" defaultSeverity="WARNING" displayName="依赖过多的类" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
报告直接依赖于项目中过多其他类的类。
&lt;p&gt;对这种类的任何依赖项的修改都可能需要更改该类，从而使其容易出现不稳定。&lt;/p&gt;
&lt;p&gt;仅报告顶级类。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;使用&lt;b&gt;最大依赖项数&lt;/b&gt;字段可指定类允许的最大依赖项数。&lt;/p&gt;
&lt;p&gt;仅适用于&lt;b&gt;代码 | 检查代码&lt;/b&gt;或&lt;b&gt;代码 | 分析代码 | 通过名称运行检查&lt;/b&gt;，并且不会在编辑器中报告。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ClassWithTooManyTransitiveDependents" defaultSeverity="WARNING" displayName="传递依赖项过多的类" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
报告被过多其他类直接或间接依赖的类。
&lt;p&gt;对这种类的任何修改都可能需要更改许多其他类，这可能开销巨大。&lt;/p&gt;
&lt;p&gt;仅报告顶级类。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;使用&lt;b&gt;最大传递依赖项数&lt;/b&gt;字段可指定类允许的最大直接或间接依赖项数。&lt;/p&gt;
&lt;p&gt;仅适用于&lt;b&gt;代码 | 检查代码&lt;/b&gt;或&lt;b&gt;代码 | 分析代码 | 通过名称运行检查&lt;/b&gt;，并且不会在编辑器中报告。&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="简化: forall 和 exists" path="Scala，集合"><inspection shortName="ExistsForallReplace" defaultSeverity="WARNING" displayName="forall 和 exists 中的双重求反" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 &lt;code&gt;exists&lt;/code&gt; 或 &lt;code&gt;forall&lt;/code&gt; 调用中的双重否定。&lt;/p&gt;

&lt;p&gt;该快速修复会移除双重否定。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  def condition(x: Int): Boolean = ???
  !Seq(1, 2).exists(x =&gt; !condition(x))
  !Seq(1, 2).forall(x =&gt; !condition(x))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  def condition(x: Int): Boolean = ???
  Seq(1, 2).forall(x =&gt; condition(x))
  Seq(1, 2).exists(x =&gt; condition(x))
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Play2" path="Scala"><inspection shortName="Play2RoutingUrlClashInspection" defaultSeverity="WARNING" displayName="Play2 路由 URL 冲突检查" enabled="false" language="Play2HtmlRouting" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告由于 URL 匹配而相互冲突的 URL 模式的路由。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="Play2UnresolvedResource" defaultSeverity="WARNING" displayName="Play2 未解析的资源检查" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告未解析的 Play2 资源。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="Play2BadFileNameInspection" defaultSeverity="WARNING" displayName="Play2 文件名检查" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 Play2 中的错误文件名。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="Play2RoutingActionInspection" defaultSeverity="WARNING" displayName="Play2 路由操作检查" enabled="false" language="Play2HtmlRouting" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 URL 路由的各种错误。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Spring Boot" path="Spring"><inspection shortName="SpringBootApplicationSetup" defaultSeverity="ERROR" displayName="无效的 Spring Boot 应用程序设置" enabled="false" language="UAST" pluginId="com.intellij.spring.boot" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告默认软件包中的&lt;code&gt;@SpringBootApplication&lt;/code&gt; 和冗余的&lt;code&gt;@EnableAutoConfiguration&lt;/code&gt; 或 &lt;code&gt;@ComponentScan&lt;/code&gt; 注解。&lt;/p&gt;
&lt;p&gt;该快速修复会移除冗余注解。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
@SpringBootApplication
@ComponentScan // 报告 '冗余声明: @SpringBootApplication 已暗示 @ComponentScan'
public class DemoApplication {
    public static void main(String[] args) {
        SpringApplication.run(DemoApplication.class, args);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @SpringBootApplication
  public class DemoApplication {
    public static void main(String[] args) {
        SpringApplication.run(DemoApplication.class, args);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2018.2 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SpringBootAdditionalConfig" defaultSeverity="ERROR" displayName="无效的 additional-spring-configuration-metadata.json" enabled="false" language="JSON" pluginId="com.intellij.spring.boot" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;
  报告 &lt;code&gt;additional-spring-configuration-metadata.json&lt;/code&gt; 配置文件中缺失和弃用的属性、未解析的引用和无效值。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  {
    "properties": [
      {
        "name": "old.key",
        "type": "com.Unknown", // 报告 '无法解析 'Unknown' 类'
        "description": "Description for old.key", // 报告 '文本应以 '.' 结尾'
        "deprecation": {
          "replacement": "new.key", // 报告 '无法解析配置键引用 'new.key''
          "reason": "Reason", // 报告 '文本应以 '.' 结尾'
          "level": "warning"
         }
      },
      {
        "name": "duplicate", // 报告 'duplicate' 的重复条目'
        "type": "java.lang.String"
      },
      {
        "name": "duplicate", // 报告 'duplicate' 的重复条目'
        "type": "java.lang.String"
      },
      {
        // 报告 '缺少必要的 'name''
        "type": "java.lang.String"
      }
    ]
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConfigurationProperties" defaultSeverity="ERROR" displayName="无效的 @ConfigurationProperties" enabled="false" language="UAST" pluginId="com.intellij.spring.boot" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 &lt;code&gt;@ConfigurationProperties&lt;/code&gt; 注解中定义的无效前缀：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;缺少前缀&lt;/li&gt;
  &lt;li&gt;空前缀&lt;/li&gt;
  &lt;li&gt;重复前缀&lt;/li&gt;
  &lt;li&gt;短横线隔开式命名以外的表示法中的前缀&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
  检查在使用 &lt;code&gt;@ConfigurationProperties&lt;/code&gt; 注解且未通过 &lt;code&gt;@EnableConfigurationProperties&lt;/code&gt; 注册、标记为 Spring 组件或通过 &lt;code&gt;@ConfigurationPropertiesScan&lt;/code&gt; 扫描的类中触发。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  当项目或模块的 Spring Boot 版本设置为 2.2.0 或更高版本时，此检查仅在使用 &lt;code&gt;@ConfigurationProperties&lt;/code&gt; 注解且未通过 &lt;code&gt;@ConfigurationPropertiesScan&lt;/code&gt; 扫描的类中触发。
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;2018.3 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SpringBootApplicationYaml" defaultSeverity="WARNING" displayName="无效的 YAML 配置" enabled="false" language="yaml" pluginId="com.intellij.spring.boot" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;
  报告 Spring Boot 应用程序 &lt;code&gt;.yaml&lt;/code&gt; 配置文件中未解析和弃用的配置键和无效值，它们可能导致运行时错误。
&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
server:
  port: invalid # 报告 '无法将 'invalid' 转换为 java.lang.Integer'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果已弃用的配置键有替换键，您可以应用 '使用替换键' 快速修复。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
logging:
  path: ${path} # 报告 '已弃用的配置属性 'logging.path''
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
logging:
  file:
    path: ${path}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;
  如果 &lt;code&gt;spring-configuration-metadata.json&lt;/code&gt; 中未定义配置键，您可以应用创建 &lt;code&gt;META-INF/spring-additional-configuration-metadata.json&lt;/code&gt; 文件并定义必要键的 '定义配置键' 快速修复。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
new:
  key: value # 报告 '无法解析配置属性 'new.key''
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;应用快速修复后，以下内容将添加到 &lt;code&gt;META-INF/spring-additional-configuration-metadata.json&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
{
  "properties": [
    {
      "name": "new.key",
      "type": "java.lang.String",
      "description": "Description for new.key."
  }
] }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用&lt;b&gt;替换令牌&lt;/b&gt;选项定义用于配置文件中值占位符的令牌。
  这些令牌以 &lt;code&gt;beginToken*endToken&lt;/code&gt; 的形式指定。
  如果没有 &lt;code&gt;*&lt;/code&gt;，则假定开始和结束的令牌相同。
&lt;/p&gt;
&lt;p&gt;
  例如，开始和结束令牌的默认值都是 &lt;code&gt;@&lt;/code&gt;，这使您可以定义占位符，例如 &lt;code&gt;some.property=@another.property@&lt;/code&gt;。
&lt;/p&gt;
&lt;p&gt;替换令牌 (&lt;code&gt;@property.key@&lt;/code&gt;) 内的值不会高亮显示。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SpringBootReactorHooksOnDebug" defaultSeverity="WARNING" displayName="可疑的 Hooks.onOperatorDebug() 用法" enabled="false" language="UAST" pluginId="com.intellij.spring.boot" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告调用 &lt;code&gt;ReactorDebugAgent.init()&lt;/code&gt; 时 &lt;code&gt;Hooks.onOperatorDebug()&lt;/code&gt; 的用法。&lt;/p&gt;
&lt;p&gt;
  如果 &lt;code&gt;ReactorDebugAgent&lt;/code&gt; 在类路径中，并且 &lt;code&gt;spring.reactor.debug-agent.enabled&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt;（默认值），启动时自动调用 &lt;code&gt;ReactorDebugAgent.init()&lt;/code&gt;。
  同时使用 &lt;code&gt;Hooks.onOperatorDebug()&lt;/code&gt; 和 &lt;code&gt;ReactorDebugAgent.init()&lt;/code&gt; 会导致 Reactor 生成双倍的调试堆栈帧。
  此外，&lt;code&gt;Hooks.onOperatorDebug()&lt;/code&gt; 会导致性能开销。
&lt;/p&gt;

&lt;p&gt;该快速修复会移除对 &lt;code&gt;Hooks.onOperatorDebug()&lt;/code&gt; 的调用。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public void hook() {
    Hooks.onOperatorDebug(); // 报告 '初始化 ReactorDebugAgent 时调用 Hooks.onOperatorDebug()'
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public void hook() {
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;此检查仅在项目或模块的 Spring Boot 版本为 2.2.0 或更高时触发。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SpringBootApplicationProperties" defaultSeverity="WARNING" displayName="无效的属性配置" enabled="false" language="Properties" pluginId="com.intellij.spring.boot" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;
  报告 Spring Boot 应用程序 &lt;code&gt;.properties&lt;/code&gt; 配置文件中未解析和弃用的配置键和无效值，这可能导致运行时错误。
&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
server.port=invalid # 报告 '无法将 'invalid' 转换为 java.lang.Integer'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果已弃用的配置键有替换键，您可以应用 '使用替换键' 快速修复。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
logging.path=${path} # 报告 '已弃用的配置属性 'logging.path''
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
logging.file.path=${path}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;
  如果 &lt;code&gt;spring-configuration-metadata.json&lt;/code&gt; 中未定义配置键，您可以应用创建 &lt;code&gt;META-INF/spring-additional-configuration-metadata.json&lt;/code&gt; 文件并定义必要键的 '定义配置键' 快速修复。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
new.key=value #报告 '无法解析配置属性 'new.key''
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;应用快速修复后，以下内容将添加到 &lt;code&gt;META-INF/spring-additional-configuration-metadata.json&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
{
  "properties": [
    {
      "name": "new.key",
      "type": "java.lang.String",
      "description": "Description for new.key."
  }
] }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该检查还会高亮显示列表和映射配置键中的索引表示法错误。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
spring.datasource.schema[]=${schema} #报告 '缺少索引值'
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;p&gt;
  使用&lt;b&gt;替换令牌&lt;/b&gt;选项定义用于配置文件中值占位符的令牌。
  这些令牌以 &lt;code&gt;beginToken*endToken&lt;/code&gt; 的形式指定。
  如果没有 &lt;code&gt;*&lt;/code&gt;，则假定开始和结束的令牌相同。
&lt;/p&gt;
&lt;p&gt;
  例如，开始和结束令牌的默认值都是 &lt;code&gt;@&lt;/code&gt;，这使您可以定义占位符，例如 &lt;code&gt;some.property=@another.property@&lt;/code&gt;。
&lt;/p&gt;
&lt;p&gt;替换令牌 (&lt;code&gt;@property.key@&lt;/code&gt;) 内的值不会高亮显示。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Maven" path="Kotlin/Migration"><inspection shortName="MavenCoroutinesDeprecation" defaultSeverity="ERROR" displayName="与 Maven 中的 Kotlin 1.3+ 一起使用的 kotlinx.coroutines 依赖项不兼容" enabled="false" language="XML" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告为了与 Kotlin 1.3 及更高版本兼容而应更新的 Maven 中的 &lt;b&gt;kotlinx.coroutines&lt;/b&gt; 库依赖项。
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="命名约定" path="JavaScript and TypeScript"><inspection shortName="ParameterNamingConventionJS" defaultSeverity="WARNING" displayName="函数形参命名约定" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告名称太短、太长或不符合
指定正则表达式模式的函数形参。
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用下面提供的字段来指定局部变量名称的最小长度、
最大长度以及预期的正则表达式。 使用标准 &lt;code&gt;java.util.regex&lt;/code&gt; 格式的正则表达式。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSClassNamingConvention" defaultSeverity="WARNING" displayName="类命名约定" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告用 JSDoc &lt;code&gt;@constructor&lt;/code&gt; 或 &lt;code&gt;@class&lt;/code&gt; 标记进行注解，
并且其名称太短、太长或不符合指定正则表达式模式的类或函数。
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用下面提供的字段来指定类名称的最小长度、
最大长度以及预期的正则表达式。 对正则表达式使用标准的 &lt;code&gt;java.util.regex&lt;/code&gt; 格式。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FunctionNamingConventionJS" defaultSeverity="WARNING" displayName="函数命名约定" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告名称太短、太长或不符合
指定正则表达式模式的函数。
&lt;!-- tooltip end --&gt;
&lt;p&gt;
 使用下面提供的字段来指定函数名称的最小长度、
最大长度以及正则表达式。 对正则表达式使用标准的 &lt;code&gt;java.util.regex&lt;/code&gt; 格式。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LocalVariableNamingConventionJS" defaultSeverity="WARNING" displayName="局部变量命名约定" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告名称太短、太长或不符合
指定正则表达式模式的局部变量。
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用下面提供的字段来指定局部变量名称的最小长度、
最大长度以及预期的正则表达式。 使用标准 &lt;code&gt;java.util.regex&lt;/code&gt; 格式的正则表达式。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSNonASCIINames" defaultSeverity="WARNING" displayName="包含非 ASCII 符号的标识符" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告名称中的非 ASCII 符号。&lt;br/&gt;&lt;br/&gt;
如果选择“仅允许 ASCII 名称”选项，则报告所有包含非 ASCII 符号的名称。&lt;br/&gt;
否则，报告所有同时包含 ASCII 和非 ASCII 符号的名称。
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Spring Cloud Stream" path="Spring"><inspection shortName="SpringCloudStreamInconsistencyInspection" defaultSeverity="WARNING" displayName="流处理程序方法错误" enabled="false" language="UAST" pluginId="com.intellij.spring.cloud" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告流处理程序方法中的不一致错误。&lt;/p&gt;
&lt;p&gt;
  使用 &lt;code&gt;@StreamListener&lt;/code&gt; 或 &lt;code&gt;@StreamEmitter&lt;/code&gt; 注解的输入和输出流处理程序方法具有各种约束。
  违反约束会导致运行时出错。
&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;code&gt;@StreamListener&lt;/code&gt; &lt;code&gt;value&lt;/code&gt; 特性中定义的通道永远不能与使用 &lt;code&gt;@Input&lt;/code&gt; 或 &lt;code&gt;@Output&lt;/code&gt; 注解的方法形参组合
  &lt;/li&gt;
  &lt;li&gt;必须为使用 &lt;code&gt;@StreamListener&lt;/code&gt; 注解的方法指定输入通道&lt;/li&gt;
  &lt;li&gt;必须为可以返回值的方法指定输出通道&lt;/li&gt;
  &lt;li&gt;不能为不返回值的方法指定输出通道&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;@StreamListener&lt;/code&gt; &lt;code&gt;condition&lt;/code&gt; 不能为返回值的方法设置特性&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SpringCloudStreamMessageChannelInspection" defaultSeverity="WARNING" displayName="未解析的消息通道" enabled="false" language="UAST" pluginId="com.intellij.spring.cloud" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 &lt;code&gt;@StreamListener&lt;/code&gt;、&lt;code&gt;@SendTo&lt;/code&gt;、&lt;code&gt;@Output&lt;/code&gt; 和 &lt;code&gt;@Input&lt;/code&gt; 注解中未解析的通道特性。&lt;/p&gt;
&lt;p&gt;使用无效的绑定名称会在运行时导致 '找不到 Bean' 错误。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @EnableBinding(Sink.class)
  public class LogSource {
    @StreamListener(Sink.class)
	  public void log1() {
    }

    @StreamListener("invalid")  // 报告 '找不到通道'
	  public void log2() {
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="转换" path="Java/数值问题"><inspection shortName="UnnecessaryExplicitNumericCast" defaultSeverity="WARNING" displayName="不必要的显式数字转换" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告将由编译器隐式插入的基元数字类型转换。
此外，报告编译器将移除的任何基元数值转换。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int x = (short)5; // 该转换将被 javac 工具移除&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;code&gt;int x = 5;&lt;/code&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DoubleLiteralMayBeFloatLiteral" defaultSeverity="WARNING" displayName="转换为 'float' 可以是 'float' 文字" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告被立即转换为 &lt;code&gt;float&lt;/code&gt; 的 &lt;code&gt;double&lt;/code&gt; 文字表达式。
&lt;p&gt;此类文字表达式可以替换为等效的 &lt;code&gt;float&lt;/code&gt; 文字。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;float f = (float)1.1;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;float f = 1.1f;&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="IntLiteralMayBeLongLiteral" defaultSeverity="WARNING" displayName="转换为 'long' 可以是 'long' 文字" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告立即转换为 &lt;code&gt;long&lt;/code&gt; 的 &lt;code&gt;int&lt;/code&gt; 文字表达式。
&lt;p&gt;此类文字表达式可以替换为等效的 &lt;code&gt;long&lt;/code&gt; 文字。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Long l = (long)42;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Long l = 42L;&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="IntegerMultiplicationImplicitCastToLong" defaultSeverity="WARNING" displayName="整数乘法或移位隐式转换为 'long'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告隐式转换为 long 的整数乘法和左移。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void f(int i) {
    long val = 65536 * i;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;应用快速修复后，代码变为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void x(int i) {
    long val = 65536&lt;b&gt;L&lt;/b&gt; * i;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void f(int i) {
    long value = i &amp;lt;&amp;lt; 24;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;应用快速修复后，代码变为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void f(int i) {
    long value = (long) i &amp;lt;&amp;lt; 24;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  此类乘法通常表明有错误，因为可能会意外发生溢出截断。
  将 &lt;code&gt;int&lt;/code&gt; 文字转换为 &lt;code&gt;long&lt;/code&gt; 文字 (&lt;code&gt;65536&lt;b&gt;L&lt;/b&gt;&lt;/code&gt;) 可以修正该问题。
&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CastThatLosesPrecision" defaultSeverity="WARNING" displayName="损失精度的数字转换" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可能导致精度损失的基元数值类型之间的转换运算。
&lt;p&gt;此类转换不一定是问题，但如果意外造成精度损失，则可能会导致难以跟踪错误。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int a = 420;
  byte b = (byte) a;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;使用&lt;b&gt;忽略从 int 到 char 的转换&lt;/b&gt;选项可以忽略从 &lt;code&gt;int&lt;/code&gt; 到 &lt;code&gt;char&lt;/code&gt; 的转换。
  在实现 I/O 操作时经常使用这种类型的转换，因为 &lt;code&gt;java.io.Reader&lt;/code&gt; 类的 &lt;code&gt;read()&lt;/code&gt; 方法会返回一个 &lt;code&gt;int&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;使用&lt;b&gt;忽略从 int 128-255 到字节的转换&lt;/b&gt;选项可以忽略从 &lt;code&gt;int&lt;/code&gt; 到 &lt;code&gt;byte&lt;/code&gt; 的常量值 (128-255) 的转换。
  此类值将溢出到仍能容纳在一个字节内的负数。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="克隆问题" path="Java"><inspection shortName="UseOfClone" defaultSeverity="WARNING" displayName="使用 'clone()' 或 'Cloneable'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;clone()&lt;/code&gt; 方法的实现和对它的调用以及 &lt;code&gt;java.lang.Cloneable&lt;/code&gt; 的使用。
&lt;p&gt;某些编码标准禁止使用 &lt;code&gt;clone()&lt;/code&gt;，建议改为使用复制构造函数或 &lt;code&gt;static&lt;/code&gt; 工厂方法。&lt;/p&gt;
&lt;p&gt;该检查会忽略在数组上对 &lt;code&gt;clone()&lt;/code&gt; 的调用，因为这是一种正确而又紧凑的数组复制方式。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CloneDeclaresCloneNotSupported" defaultSeverity="WARNING" displayName="'clone()' 未声明 'CloneNotSupportedException'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告不声明 &lt;code&gt;throws CloneNotSupportedException&lt;/code&gt; 的 &lt;code&gt;clone()&lt;/code&gt; 方法。
&lt;p&gt;如果没有声明 &lt;code&gt;throws CloneNotSupportedException&lt;/code&gt;，该方法的子类将不能以标准方式禁止克隆。 此检查不会报告声明为 &lt;code&gt;final&lt;/code&gt; 的 &lt;code&gt;clone()&lt;/code&gt; 方法和 &lt;code&gt;final&lt;/code&gt; 类内的 &lt;code&gt;clone()&lt;/code&gt; 方法。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;配置检查：&lt;/p&gt;
&lt;p&gt;使用&lt;b&gt;仅对 'protected' 克隆方法发出警告&lt;/b&gt;选项可以指示此检查仅对 &lt;code&gt;protected clone()&lt;/code&gt; 方法发出警告。
&lt;i&gt;Effective Java&lt;/i&gt; 一书（第二版和第三版）建议在 &lt;code&gt;public&lt;/code&gt; 方法上省略 &lt;code&gt;CloneNotSupportedException&lt;/code&gt; 声明，因为不抛出已检查的异常的方法更容易使用。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;public class&lt;/b&gt; Example &lt;b&gt;implements&lt;/b&gt; Cloneable {
    // 方法未声明 ’throws CloneNotSupportedException‘
    &lt;b&gt;protected&lt;/b&gt; Object clone() {
        &lt;b&gt;try&lt;/b&gt; {
            &lt;b&gt;return&lt;/b&gt; &lt;b&gt;super&lt;/b&gt;.clone();
        } &lt;b&gt;catch&lt;/b&gt; (CloneNotSupportedException e) {
            &lt;b&gt;return&lt;/b&gt; null;
        }
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CloneInNonCloneableClass" defaultSeverity="WARNING" displayName="不可克隆类中的 'clone()' 方法" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告重写 &lt;code&gt;clone()&lt;/code&gt; 方法但不实现 &lt;code&gt;Cloneable&lt;/code&gt; 接口的类。
这通常表示编程错误。
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用&lt;b&gt;仅对 'public' 克隆方法发出警告&lt;/b&gt;选项可以忽略不是 &lt;code&gt;public&lt;/code&gt; 的方法。&lt;/p&gt;
&lt;p&gt;对于设计为继承的类，您可以选择不实现 &lt;code&gt;Cloneable&lt;/code&gt; 接口，而是重写 &lt;code&gt;clone()&lt;/code&gt; 并将其声明为 &lt;code&gt;protected&lt;/code&gt;，并决定是否在子类中实现 &lt;code&gt;Cloneable&lt;/code&gt; 接口。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CloneCallsConstructors" defaultSeverity="WARNING" displayName="'clone()' 用构造函数实例化对象" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对 &lt;code&gt;clone()&lt;/code&gt; 方法中的对象构造函数的调用。
&lt;p&gt;与其直接创建这些对象来支持后续的子类，不如调用 &lt;code&gt;clone()&lt;/code&gt; 来实例化 &lt;code&gt;clone()&lt;/code&gt; 方法中的对象。
此检查不会报告被声明为 &lt;code&gt;final&lt;/code&gt; 的 &lt;code&gt;clone()&lt;/code&gt; 方法或者&lt;code&gt;final&lt;/code&gt; 类上的 &lt;code&gt;clone()&lt;/code&gt; 方法。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NonPublicClone" defaultSeverity="WARNING" displayName="'clone()' 方法不是 'public'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;protected&lt;/code&gt; 而不是 &lt;code&gt;public&lt;/code&gt; 的 &lt;code&gt;clone()&lt;/code&gt; 方法。
&lt;p&gt;从 &lt;code&gt;java.lang.Object&lt;/code&gt; 重写 &lt;code&gt;clone()&lt;/code&gt; 方法时，应将该方法设为 &lt;code&gt;public&lt;/code&gt;，以便从软件包外部的非子类进行访问。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CloneableImplementsClone" defaultSeverity="WARNING" displayName="没有 'clone()' 方法的可克隆类" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告实现 &lt;code&gt;Cloneable&lt;/code&gt; 接口但不重写 &lt;code&gt;clone()&lt;/code&gt; 方法的类。
&lt;p&gt;这种类使用 &lt;code&gt;clone()&lt;/code&gt; 的默认实现，它不是 &lt;code&gt;public&lt;/code&gt;，而是 &lt;code&gt;protected&lt;/code&gt;，并且不复制该类的可变状态。&lt;/p&gt;
&lt;p&gt;可以通过快速修复生成基本的 &lt;code&gt;clone()&lt;/code&gt; 方法，它可以作为 &lt;code&gt;Cloneable&lt;/code&gt; 类所期望的正常运行的 &lt;code&gt;clone()&lt;/code&gt; 方法的基础。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;public class&lt;/b&gt; Data &lt;b&gt;implements&lt;/b&gt; Cloneable {
    &lt;b&gt;private&lt;/b&gt; String[] names;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;public class&lt;/b&gt; Data &lt;b&gt;implements&lt;/b&gt; Cloneable {
    &lt;b&gt;private&lt;/b&gt; String[] names;

    @Override
    &lt;b&gt;public&lt;/b&gt; Data clone() {
      &lt;b&gt;try&lt;/b&gt; {
        Data clone = (Data) &lt;b&gt;super&lt;/b&gt;.clone();
        // TODO：在此处复制可变状态，因此克隆无法更改原始克隆的内部项 
         &lt;b&gt;return&lt;/b&gt; clone;
      } &lt;b&gt;catch&lt;/b&gt; (CloneNotSupportedException e) {
        &lt;b&gt;throw new&lt;/b&gt; AssertionError();
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!--
Note for translators: the text of the TODO comment in the example code above comes from
community/plugins/InspectionGadgets/InspectionGadgetsAnalysis/resources/messages/InspectionGadgetsBundle.properties
property key: cloneable.class.without.clone.todo.message
--&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;使用&lt;b&gt;忽略由于继承而可克隆的类&lt;/b&gt;选项可以忽略因继承自 &lt;code&gt;Cloneable&lt;/code&gt; 类而 &lt;code&gt;Cloneable&lt;/code&gt; 的类。&lt;/p&gt;
&lt;p&gt;使用&lt;b&gt;忽略需要 Cloneable 才能调用超类的 clone() 方法的情况&lt;/b&gt;选项可以忽略因从超类调用 &lt;code&gt;clone()&lt;/code&gt; 方法而需要实现 &lt;code&gt;Cloneable&lt;/code&gt; 的类。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CloneReturnsClassType" defaultSeverity="WARNING" displayName="'clone()' 应当具有等于其所包含类的返回值类型" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告返回类型与其所在的类不同的 &lt;code&gt;clone()&lt;/code&gt; 方法。
&lt;p&gt;&lt;code&gt;clone()&lt;/code&gt; 方法的返回类型通常为 &lt;code&gt;java.lang.Object&lt;/code&gt;，这导致其难以被客户端使用。
&lt;i&gt;Effective Java&lt;/i&gt;（第二版和第三版）建议将 &lt;code&gt;clone()&lt;/code&gt; 方法的返回类型设为与其返回对象的类的类型相同。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;class&lt;/b&gt; Foo &lt;b&gt;implements&lt;/b&gt; Cloneable {
    &lt;b&gt;public&lt;/b&gt; Object clone() {
      &lt;b&gt;try&lt;/b&gt; {
        &lt;b&gt;return&lt;/b&gt; super.clone();
      } &lt;b&gt;catch&lt;/b&gt; (CloneNotSupportedException e) {
        &lt;b&gt;throw new&lt;/b&gt; AssertionError();
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;class&lt;/b&gt; Foo &lt;b&gt;implements&lt;/b&gt; Cloneable {
    &lt;b&gt;public&lt;/b&gt; Foo clone() {
      &lt;b&gt;try&lt;/b&gt; {
        &lt;b&gt;return&lt;/b&gt; (Foo)super.clone();
      } &lt;b&gt;catch&lt;/b&gt; (CloneNotSupportedException e) {
        &lt;b&gt;throw new&lt;/b&gt; AssertionError();
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="可能的错误" path="Kotlin"><inspection shortName="SetterBackingFieldAssignment" defaultSeverity="WARNING" displayName="不包含赋值的现有支持字段" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告不更新支持字段的属性 setter。
&lt;p&gt;该快速修复会向支持字段中添加赋值。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Test {
      var foo: Int = 1
          set(value) {
          }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Test {
      var foo: Int = 1
          set(value) {
              field = value
          }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnusedLambdaExpressionBody" defaultSeverity="WARNING" displayName="包含 lambda 表达式主体的函数未使用的返回值" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告调用的函数从表达式主体返回 lambda 时返回值并未使用的调用。
&lt;p&gt;
如果函数头和主体块之间存在 &lt;code&gt;=&lt;/code&gt;，则不会评估函数中的代码，这可能导致不正确的行为。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;从函数声明中移除 = 令牌&lt;/b&gt;可用于自动修正代码。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun printHello() = { println("Hello") }

  fun main() {
      printHello() // 此函数不打印任何内容
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun printHello() { println("Hello") }

  fun main() {
      printHello()
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="KotlinEqualsBetweenInconvertibleTypes" defaultSeverity="WARNING" displayName="'equals()' 位于不可转换类型的对象之间" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对接收器和实参的基元、枚举或字符串类型不兼容的 &lt;code&gt;equals()&lt;/code&gt; 的调用。

&lt;p&gt;虽然此类调用理论上可能有用，但很可能是错误。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  5.equals("");
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="WrapUnaryOperator" defaultSeverity="WEAK WARNING" displayName="模糊一元运算符与数字常量一同使用" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告后跟 &lt;code&gt;-1.inc()&lt;/code&gt; 等点限定符的一元运算符。
&lt;p&gt;&lt;code&gt;-1.inc()&lt;/code&gt; 之类的代码可能会产生误导，因为 &lt;code&gt;-&lt;/code&gt; 的优先级低于 &lt;code&gt;.inc()&lt;/code&gt;。
    因此，&lt;code&gt;-1.inc()&lt;/code&gt; 计算结果为 &lt;code&gt;-2&lt;/code&gt;，而非预期的 &lt;code&gt;0&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;使用 () 包装一元运算符和值&lt;/b&gt;快速修复可用于自动修正代码。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="KotlinThrowableNotThrown" defaultSeverity="WARNING" displayName="Throwable 未抛出" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
当创建的 &lt;code&gt;Throwable&lt;/code&gt; 从未实际抛出时，报告 &lt;code&gt;Throwable&lt;/code&gt; 或其子类的实例化。
&lt;p&gt;报告的代码指出了测试中难以捕获的错误。&lt;/p&gt;
&lt;p&gt;
    此外，当结果 &lt;code&gt;Throwable&lt;/code&gt; 实例未抛出时，此检查会报告返回 &lt;code&gt;Throwable&lt;/code&gt; 或其子类实例的方法调用。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun check(condition: Boolean) {
      if (!condition) /* throw is missing here */ IllegalArgumentException("condition is not met");
  }

  fun createError() = RuntimeException()

  fun foo() {
      /* throw is missing here */ createError()
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CanSealedSubClassBeObject" defaultSeverity="WEAK WARNING" displayName="密封的子类没有状态和重写的 equals" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告没有状态和被重写的 &lt;code&gt;equals()&lt;/code&gt; 方法的 &lt;code&gt;sealed&lt;/code&gt; 类的直接继承者。
&lt;p&gt;强烈建议重写 &lt;code&gt;equals()&lt;/code&gt; 以提供比较稳定性，或将 &lt;code&gt;class&lt;/code&gt; 转换为 &lt;code&gt;object&lt;/code&gt; 以达到相同的效果。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  sealed class Receiver {
      class Everyone : Receiver()
      class User(val id: Int) : Receiver()
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;快速修复会将 &lt;code&gt;class&lt;/code&gt; 转换为 &lt;code&gt;object&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  sealed class Receiver {
      object Everyone : Receiver()
      class User(val id: Int) : Receiver()
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="KDocUnresolvedReference" defaultSeverity="WARNING" displayName="KDoc 中存在未解析的引用" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 KDoc 注释中未解析的引用。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  /**
   * [unresolvedLink]
   */
  fun foo() {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;要修正此问题，请使链接有效。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DelegationToVarProperty" defaultSeverity="WARNING" displayName="正在委托给 'var' 属性" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告至 &lt;code&gt;var&lt;/code&gt; 属性的接口委托
&lt;p&gt;仅使用属性的初始值进行委托，任何后续的赋值都不会影响它。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Example(var text: CharSequence): CharSequence by text
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;快速修复可将属性替换为不可变的属性：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Example(val text: CharSequence): CharSequence by text
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果您出于某种原因依赖可变性，则可使用另一种方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Example(text: CharSequence): CharSequence by text {
      var text = text
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="UnsafeCastFromDynamic" defaultSeverity="WEAK WARNING" displayName="从动态类型的隐式(不安全)转换" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告指定检查范围内可隐式转换为其他类型的动态类型表达式。
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SelfAssignment" defaultSeverity="WARNING" displayName="冗余赋值" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告变量对自身的赋值。
&lt;p&gt;该快速修复会移除冗余赋值。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test() {
      var bar = 1
      bar = bar
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test() {
      var bar = 1
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="EqualsOrHashCode" defaultSeverity="WARNING" displayName="'equals()' 和 'hashCode()' 未配对" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告重写 &lt;code&gt;equals()&lt;/code&gt; 但不重写 &lt;code&gt;hashCode()&lt;/code&gt;（或者相反操作）的类。
同时还报告重写 &lt;code&gt;equals()&lt;/code&gt; 或 &lt;code&gt;hashCode()&lt;/code&gt; 的对象声明。
&lt;p&gt;这可能会导致在将类添加到 &lt;code&gt;Collection&lt;/code&gt; 时产生不良行为&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class C1 {
      override fun equals(other: Any?) = true
  }

  class C2 {
      override fun hashCode() = 0
  }

  object O1 {
      override fun equals(other: Any?) = true
  }

  object O2 {
      override fun hashCode() = 0
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该快速修复会为类重写 &lt;code&gt;equals()&lt;/code&gt; 或 &lt;code&gt;hashCode()&lt;/code&gt; 方法并为对象删除这些方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
   class C1 {
       override fun equals(other: Any?) = true
       override fun hashCode(): Int {
           return javaClass.hashCode()
       }
   }

   class C2 {
       override fun hashCode() = 0
       override fun equals(other: Any?): Boolean {
           if (this === other) return true
           if (javaClass != other?.javaClass) return false
           return true
       }
   }

   object O1 {
   }

   object O2 {
   }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ConvertObjectToDataObject" defaultSeverity="WEAK WARNING" displayName="将 'object' 转换为 'data object'" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告可转换为 &lt;code&gt;data object&lt;/code&gt; 的 &lt;code&gt;object&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果 &lt;code&gt;object&lt;/code&gt; 使用 &lt;code&gt;java.io.Serializable&lt;/code&gt; 进行注解，则 &lt;code&gt;data object&lt;/code&gt; 会自动生成 &lt;code&gt;toString&lt;/code&gt;、&lt;code&gt;equals&lt;/code&gt;、&lt;code&gt;hashCode&lt;/code&gt; 和 &lt;code&gt;readResolve&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;主要在两种情况下，您应该考虑将 &lt;code&gt;object&lt;/code&gt; 转换为 &lt;code&gt;data object&lt;/code&gt;。 第一种情况是当自定义 &lt;code&gt;toString&lt;/code&gt; 返回类的名称时。 第二种情况是当 &lt;code&gt;object&lt;/code&gt; 实现 &lt;code&gt;java.io.Serializable&lt;/code&gt; 时&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    object Foo {
        override fun toString(): String = "Foo"
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    数据对象 Foo
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;仅当项目或模块的 Kotlin 语言级别为 1.8 或更高时，此检查才会报告&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RecursivePropertyAccessor" defaultSeverity="WARNING" displayName="递归属性访问器" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;
    报告能够以 &lt;code&gt;StackOverflowError&lt;/code&gt; 结束的递归属性访问器调用。
    此类调用经常与支持字段访问混淆。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  var counter: Int = 0
      set(value) {
          &lt;b&gt;counter&lt;/b&gt; = if (value &lt; 0) 0 else value
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  var counter: Int = 0
      set(value) {
          &lt;b&gt;field&lt;/b&gt; = if (value &lt; 0) 0 else value
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConflictingExtensionProperty" defaultSeverity="WARNING" displayName="扩展属性与合成属性冲突" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告与那些从 Java &lt;code&gt;get&lt;/code&gt; 或 &lt;code&gt;set&lt;/code&gt; 方法自动生成的合成属性相冲突的扩展属性。
&lt;p&gt;应移除或重命名此类属性，以避免将来在编译器中进行更改时破坏代码。&lt;/p&gt;
&lt;p&gt;该快速修复会删除扩展属性。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  val File.name: String
      get() = getName()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该快速修复会添加 &lt;code&gt;@Deprecated&lt;/code&gt; 注解：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Deprecated("Is replaced with automatic synthetic extension", ReplaceWith("name"), level = DeprecationLevel.HIDDEN)
  val File.name: String
      get() = getName()
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="DataClassPrivateConstructor" defaultSeverity="WARNING" displayName="private 数据类构造函数通过 'copy' 方法公开" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告数据类中的 &lt;code&gt;private&lt;/code&gt; 主构造函数。
&lt;p&gt;
    &lt;code&gt;data&lt;/code&gt; 类拥有 &lt;code&gt;copy()&lt;/code&gt; 工厂方法，可以像构造函数一样使用。
    为了提供足够的安全性，构造函数不应被标记为 &lt;code&gt;private&lt;/code&gt;。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  data class User private constructor(val name: String)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;快速修复可将构造函数可见性修饰符更改为 &lt;code&gt;public&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  data class User(val name: String)
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="IncompleteDestructuring" defaultSeverity="WARNING" displayName="析构声明不完整" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告不完整的析构声明。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  data class Person(val name: String, val age: Int)
  val person = Person("", 0)
  val (name) = person
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该快速修复会使用新变量完成析构声明：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  data class Person(val name: String, val age: Int)
  val person = Person("", 0)
  val (name, age) = person
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="UnusedUnaryOperator" defaultSeverity="WARNING" displayName="未使用的一元运算符" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告表达式上的未使用的数字类型一元运算符。
&lt;p&gt;使用一元运算符时如果不带大括号，它们将会中断之前的表达式。
因此，跨越多行的数学表达式可能会产生误导。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun main() {
      val result = 1 + 2 * 3
                  + 3              // &amp;lt;== 请注意，'+ 3' 不属于 'result' 变量，它并未使用
      println("Result = $result")  // 结果为 '7'，而非预期的 '10'
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConvertNaNEquality" defaultSeverity="WARNING" displayName="将带 'NaN' 的相等检查转换为 'isNaN' 调用" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告使用 &lt;code&gt;Float.NaN&lt;/code&gt; 或 &lt;code&gt;Double.NaN&lt;/code&gt; 的相等检查（应替换为 &lt;code&gt;isNaN()&lt;/code&gt; 检查）。
&lt;p&gt;
    根据 IEEE 754，对照 NaN 进行的相等检查始终返回 &lt;code&gt;false&lt;/code&gt;，即便对 &lt;code&gt;NaN == NaN&lt;/code&gt; 也如此。
    因此，这种检查很可能是错误的。
&lt;/p&gt;
&lt;p&gt;快速修复可将比较替换为使用不同比较技术的 &lt;code&gt;isNaN()&lt;/code&gt; 检查，并能够正确处理 &lt;code&gt;NaN&lt;/code&gt; 值。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun check(value: Double): Boolean {
      return Double.NaN == value
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;应用修正后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun check(value: Double): Boolean {
      return value.isNaN()
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SuspiciousVarProperty" defaultSeverity="WARNING" displayName="可疑的 'var' 属性: 它的 setter 不会影响其 getter 结果" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告具有默认 setter 和 getter 且未引用支持字段的 &lt;code&gt;var&lt;/code&gt; 属性。
&lt;p&gt;
此类属性不影响调用其 setter；因此，将此类属性更改为 &lt;code&gt;val&lt;/code&gt; 并删除初始值设定项将会更加清晰易懂。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;更改为 val 并删除初始值设定项&lt;/b&gt;快速修复可用于自动修正代码。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  // 此属性始终返回 '1'，属性为 'var' 并不重要
  var foo: Int = 0
      get() = 1
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UselessCallOnCollection" defaultSeverity="WARNING" displayName="对集合类型的无用调用" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告标准库中已筛选的集合上的 &lt;code&gt;filter…&lt;/code&gt; 调用。
&lt;p&gt;只有在类型不同于结果类型的接收器上调用时，标准库中 &lt;code&gt;filterNotNull()&lt;/code&gt; 或 &lt;code&gt;filterIsInstance&lt;/code&gt; 之类的几个函数才有意义。 在其他情况下，可以忽略此类调用，因为结果将相同。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;移除冗余调用&lt;/b&gt;快速修复可用于自动修正代码。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(list: List&amp;lt;String&amp;gt;) {
      val x = list.filterNotNull() // 快速修复会简化为 'list'
      val y = list.filterIsInstance&amp;lt;String&amp;gt;() // 快速修复会简化为 'list'
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="UnusedDataClassCopyResult" defaultSeverity="WARNING" displayName="数据类复制的未使用结果" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告未使用其结果的数据类 &lt;code&gt;copy&lt;/code&gt; 函数调用。
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="UselessCallOnNotNull" defaultSeverity="WARNING" displayName="对非 null 类型的无用调用" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告非 null 接收器上仅对可 null 接收器有意义的调用。
&lt;p&gt;只有在可 null 类型的接收器上调用时，标准库中 &lt;code&gt;orEmpty()&lt;/code&gt; 或 &lt;code&gt;isNullOrEmpty&lt;/code&gt; 之类的几个函数才有意义。 在其他情况下，可以忽略它们，因为结果将相同。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;移除冗余调用&lt;/b&gt;和&lt;b&gt;将调用更改为 …&lt;/b&gt; 快速修复可用于自动修正代码。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(s: String) {
      val x = s.orEmpty() // 快速修复会简化为 's'
      val y = s.isNullOrEmpty() // 快速修复会简化为 's.isEmpty()'
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="KotlinConstantConditions" defaultSeverity="WARNING" displayName="恒定条件" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告静态已知始终为 true、false、null 或零的非普通条件和值。
虽然有时会有意为之，但通常这是程序中存在逻辑错误的迹象。 此外，报告永远无法到达 &lt;code&gt;when&lt;/code&gt; 分支和某些静态已知始终失败的表达式。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
fun process(x: Int?) {
  val isNull = x == null
  if (!isNull) {
    if (&lt;span style="background: yellow"&gt;x != null&lt;/span&gt;) {} // 条件始终为 true
    require(&lt;span style="background: yellow"&gt;x!! &amp;lt; 0 &amp;&amp; x &amp;gt; 10&lt;/span&gt;) // 条件始终为 false
  } else {
    println(x&lt;span style="background: yellow"&gt;!!&lt;/span&gt;) // !! operator will always fail
  }
}
fun process(v: Any) {
  when(v) {
    is CharSequence -&amp;gt; println(v &lt;span style="background: yellow"&gt;as&lt;/span&gt; Int) // 转换将始终失败
    &lt;span style="background: yellow"&gt;is String&lt;/span&gt; -&amp;gt; println(v) // 分支无法到达
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2021.3 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SuspiciousCallableReferenceInLambda" defaultSeverity="WEAK WARNING" displayName="可疑的可调用引用用作 lambda 结果" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告具有一个可调用引用的 lambda 表达式。
&lt;p&gt;将 lambda 替换为可调用引用而不将大括号更改为圆括号是常见错误。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  listOf(1,2,3).map { it::toString }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  listOf(1,2,3).map(Int::toString)
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ArrayInDataClass" defaultSeverity="WEAK WARNING" displayName="数据类中的数组属性" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;data&lt;/code&gt; 类中类型为 &lt;code&gt;Array&lt;/code&gt; 但没有被重写的 &lt;code&gt;equals()&lt;/code&gt; 或 &lt;code&gt;hashCode()&lt;/code&gt; 的属性。
&lt;p&gt;
    数组形参通过引用相等进行了比较，这可能是一种意外行为。
    在此类情况下，强烈建议重写 &lt;code&gt;equals()&lt;/code&gt; 和 &lt;code&gt;hashCode()&lt;/code&gt;。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  data class Text(val lines: Array&amp;lt;String&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该快速修复会生成缺失的 &lt;code&gt;equals()&lt;/code&gt; 和 &lt;code&gt;hashCode()&lt;/code&gt; 实现：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  data class Text(val lines: Array&amp;lt;String&amp;gt;) {
      override fun equals(other: Any?): Boolean {
          if (this === other) return true
          if (javaClass != other?.javaClass) return false

          other as Text

          if (!lines.contentEquals(other.lines)) return false

          return true
      }

      override fun hashCode(): Int {
          return lines.contentHashCode()
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SuspiciousEqualsCombination" defaultSeverity="WEAK WARNING" displayName="可疑的 == 与 === 组合" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在单个表达式内的同一变量上使用的 &lt;code&gt;==&lt;/code&gt; 和 &lt;code&gt;===&lt;/code&gt; 比较。
&lt;p&gt;由于相似性，&lt;code&gt;==&lt;/code&gt; 和 &lt;code&gt;===&lt;/code&gt; 可能会在无通知的情况下混用，需要仔细检查使用的是 &lt;code&gt;==&lt;/code&gt; 而非 &lt;code&gt;===&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (type === FIELD || type == METHOD || type == ANNOTATION_METHOD || // 请注意，"==" 使用错误
      type === LAMBDA_EXPRESSION) return
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SelfReferenceConstructorParameter" defaultSeverity="WARNING" displayName="构造函数永远无法补全" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告具有非 null 自引用形参的构造函数。
&lt;p&gt;此类构造函数从不实例化类。&lt;/p&gt;
&lt;p&gt;该快速修复会将形参类型转换为可 null。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class SelfRef(val ref: SelfRef)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class SelfRef(val ref: SelfRef?)
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ForEachParameterNotUsed" defaultSeverity="WEAK WARNING" displayName="迭代元素不在 forEach 中使用" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告不使用可迭代值的 &lt;code&gt;forEach&lt;/code&gt; 循环。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  listOf(1, 2, 3).forEach { }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该快速修复会在 &lt;code&gt;forEach&lt;/code&gt; 部分引入匿名形参：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  listOf(1, 2, 3).forEach { _ -&gt; }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ControlFlowWithEmptyBody" defaultSeverity="WARNING" displayName="带空体的控制流" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告语句体为空的 &lt;code&gt;if&lt;/code&gt;、&lt;code&gt;while&lt;/code&gt;、&lt;code&gt;do&lt;/code&gt; 或 &lt;code&gt;for&lt;/code&gt; 语句。
&lt;p&gt;虽然偶尔是有意为之，但此结构令人困惑，并且通常是由拼写错误所致。&lt;/p&gt;
&lt;p&gt;该快速修复会移除语句。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (a &amp;gt; b) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="EmptyRange" defaultSeverity="WARNING" displayName="start 大于 endInclusive 的范围为空" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告由于 &lt;code&gt;start&lt;/code&gt; 值大于 &lt;code&gt;endInclusive&lt;/code&gt; 值而为空的范围。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  val range = 2..1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该快速修复会将 &lt;code&gt;..&lt;/code&gt; 运算符更改为 &lt;code&gt;downTo&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  val range = 2 downTo 1
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="DeferredResultUnused" defaultSeverity="WARNING" displayName="'@Deferred' 结果未被使用" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
如果未使用返回值，则报告具有 &lt;code&gt;Deferred&lt;/code&gt; 结果类型的函数调用。
&lt;p&gt;如果未使用 &lt;code&gt;Deferred&lt;/code&gt; 返回值，则调用站点不会等待补全此函数。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun calcEverythingAsync() = CompletableDeferred(42)

  fun usage() {
      calcEverythingAsync()
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该快速修复会提供具有 &lt;code&gt;Deferred&lt;/code&gt; 初始值设定项的变量：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun calcEverythingAsync() = CompletableDeferred(42)

  fun usage() {
      val answer = calcEverythingAsync()
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="KotlinCatchMayIgnoreException" defaultSeverity="WARNING" displayName="'catch' 块可能会忽略异常" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告空的或可能忽略异常的 &lt;code&gt;catch&lt;/code&gt; 块。
&lt;p&gt;虽然偶尔是有意为之，但空的 &lt;code&gt;catch&lt;/code&gt; 块可能导致调试复杂化。
    此外，忽略 &lt;code&gt;catch&lt;/code&gt; 形参可能是错误的。&lt;/p&gt;

&lt;p&gt;
    该检查不会报告任何命名为 &lt;code&gt;ignore&lt;/code&gt;、&lt;code&gt;ignored&lt;/code&gt; 或 &lt;code&gt;_&lt;/code&gt; 的 &lt;code&gt;catch&lt;/code&gt; 形参。
&lt;/p&gt;
&lt;p&gt;
    您可以使用快速修复将异常名称更改为 &lt;code&gt;_&lt;/code&gt;。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  try {
    throwingMethod()
  } catch (ex: IOException) {

  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  try {
    throwingMethod()
  } catch (_: IOException) {

  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
使用&lt;b&gt;当 'catch' 块包含注释时不发出警告&lt;/b&gt;选项可以忽略包含注释的 &lt;code&gt;catch&lt;/code&gt; 块。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LeakingThis" defaultSeverity="WARNING" displayName="在构造函数中泄漏 'this'" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
在对象构造期间使用 &lt;code&gt;this&lt;/code&gt; 报告不安全的操作，包括：

&lt;ul&gt;
  &lt;li&gt;在类初始化期间访问非 final 属性：从构造函数或属性初始化&lt;/li&gt;
  &lt;li&gt;在类初始化期间调用非 final 函数&lt;/li&gt;
  &lt;li&gt;在非 final 类的构造函数中使用 &lt;code&gt;this&lt;/code&gt; 作为函数实参&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
    如果其他类继承自给定的类，则在执行不安全操作时，可能无法完全初始化它们。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;abstract class&lt;/b&gt; Base {
      &lt;b&gt;val&lt;/b&gt; code = calculate()
      &lt;b&gt;abstract fun&lt;/b&gt; calculate(): Int
  }

  &lt;b&gt;class&lt;/b&gt; Derived(&lt;b&gt;private val&lt;/b&gt; x: Int) : Base() {
      &lt;b&gt;override fun&lt;/b&gt; calculate() = x
  }

  &lt;b&gt;fun&lt;/b&gt; testIt() {
      println(Derived(42).code) &lt;i&gt;// 预期值：42，实际值：0&lt;/i&gt;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SuspendFunctionOnCoroutineScope" defaultSeverity="WARNING" displayName="由于挂起函数的 CoroutineScope 接收器，coroutineContext 不明确" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告带有 &lt;code&gt;CoroutineScope&lt;/code&gt; 接收器的 suspend 函数内 &lt;code&gt;CoroutineScope&lt;/code&gt; 扩展或成员的调用和访问。
&lt;p&gt;当函数为 &lt;code&gt;suspend&lt;/code&gt; 且具有 &lt;code&gt;CoroutineScope&lt;/code&gt; 接收器时，它通过 &lt;code&gt;kotlin.coroutines.coroutineContext&lt;/code&gt; 和 &lt;code&gt;CoroutineScope.coroutineContext&lt;/code&gt; 访问 &lt;code&gt;CoroutineContext&lt;/code&gt; 的权限不明确，而且这两个上下文通常不同。&lt;/p&gt;
&lt;p&gt;
为了改善这种状况，可以将可疑的调用包装在 &lt;code&gt;coroutineScope { ... }&lt;/code&gt; 中，或者去除 &lt;code&gt;CoroutineScope&lt;/code&gt; 函数接收器。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="KotlinCovariantEquals" defaultSeverity="WARNING" displayName="协变 'equals()'" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告当该类没有另一个采用 &lt;code&gt;Any?&lt;/code&gt; 作为其实参类型的 &lt;code&gt;equals()&lt;/code&gt; 时，采用除 &lt;code&gt;Any?&lt;/code&gt; 以外的实参类型的 &lt;code&gt;equals()&lt;/code&gt;。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
      fun equals(other: Foo?): Boolean {
          return true
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;要修正此问题，请创建采用 &lt;code&gt;Any?&lt;/code&gt; 类型实参的 &lt;code&gt;equals()&lt;/code&gt; 方法。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RecursiveEqualsCall" defaultSeverity="WARNING" displayName="递归 equals 调用" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告递归 &lt;code&gt;equals&lt;/code&gt;(&lt;code&gt;==&lt;/code&gt;) 调用。&lt;/p&gt;
&lt;p&gt;
    在 Kotlin 中，&lt;code&gt;==&lt;/code&gt; 会通过在后台调用 &lt;code&gt;equals&lt;/code&gt; 方法来比较对象值。
    另一方面，&lt;code&gt;===&lt;/code&gt; 则通过引用来比较对象。
&lt;/p&gt;
&lt;p&gt;
    &lt;code&gt;===&lt;/code&gt; 通常用于 &lt;code&gt;equals&lt;/code&gt; 方法实现。
    但 &lt;code&gt;===&lt;/code&gt; 可能会错误地与 &lt;code&gt;==&lt;/code&gt; 混淆，从而导致无限递归。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class X {
      override fun equals(other: Any?): Boolean {
          if (&lt;b&gt;this == other&lt;/b&gt;) return true
          return false
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class X {
      override fun equals(other: Any?): Boolean {
          if (&lt;b&gt;this === other&lt;/b&gt;) return true
          return false
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="UnusedEquals" defaultSeverity="WARNING" displayName="未使用的 equals 表达式" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告未使用的 &lt;code&gt;equals&lt;/code&gt;(&lt;code&gt;==&lt;/code&gt;) 表达式。
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SuspiciousCollectionReassignment" defaultSeverity="WEAK WARNING" displayName="增强赋值在后台创建新集合" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告只读 &lt;code&gt;Collection&lt;/code&gt; 上的增强型赋值 (&lt;code&gt;+=&lt;/code&gt;) 表达式。
&lt;p&gt;只读 &lt;code&gt;Collection&lt;/code&gt; 上的增强型赋值 (&lt;code&gt;+=&lt;/code&gt;) 表达式临时分配新集合，这可能会影响性能。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;将类型更改为可变&lt;/b&gt;快速修复可用于自动修正代码。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test() {
      var list = listOf(0)
      list += 42 // 此处分配了一个新列表，相当于 list = list + 42
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test() {
      val list = mutableListOf(0)
      list += 42
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="DestructuringWrongName" defaultSeverity="WARNING" displayName="析构声明中的变量使用错误数据类属性的名称" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告与析构数据类的不同属性名称匹配的析构声明条目。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  data class Foo(val a: String, val b: Int, val c: String)

  fun bar(f: Foo) {
      val (a, c) = f
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该快速修复会更改变量的名称以匹配相应类字段的名称：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  data class Foo(val a: String, val b: Int, val c: String)

  fun bar(f: Foo) {
      val (a, b) = f
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ImplicitNullableNothingType" defaultSeverity="WEAK WARNING" displayName="隐式 'Nothing?' 类型" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告具有隐式 &lt;b&gt;Nothing?&lt;/b&gt; 类型的变量和函数。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo() = null
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该快速修复会显式指定返回类型：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(): Nothing? = null
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="LateinitVarOverridesLateinitVar" defaultSeverity="WARNING" displayName="'lateinit var' 属性重写 'lateinit var' 属性" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告重写其他 &lt;code&gt;lateinit var&lt;/code&gt; 属性的 &lt;code&gt;lateinit var&lt;/code&gt; 属性。
&lt;p&gt;一个子类实例的单个属性会有两个字段，而来自超类的那个将保持不使用。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    open class BaseClass {
      open lateinit var name: String
    }

    class RealClass : BaseClass() {
      override lateinit var name: String
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MainFunctionReturnUnit" defaultSeverity="WARNING" displayName="main 函数应返回 'Unit'" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
当 main 函数没有 &lt;code&gt;Unit&lt;/code&gt; 的返回值类型值时报告。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;code&gt;fun main() = "Hello world!"&lt;/code&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ReplaceArrayEqualityOpWithArraysEquals" defaultSeverity="WARNING" displayName="通过 '==' 和 '!=' 进行数组比较" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;==&lt;/code&gt; 或 &lt;code&gt;!=&lt;/code&gt; 运算符的用法，用于应替换为 &lt;code&gt;contentEquals()&lt;/code&gt; 的数组。
&lt;p&gt;
    &lt;code&gt;==&lt;/code&gt; 和 &lt;code&gt;!=&lt;/code&gt; 运算符比较数组引用而不是它们的内容。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  fun test() {
      val a = arrayOf(1, 2, 3)
      val b = arrayOf(1, 2, 3)
      println(a == b) // 参考比较
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  fun test() {
      val a = arrayOf(1, 2, 3)
      val b = arrayOf(1, 2, 3)
      println(a.contentEquals(b))
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="比较" path="Scala，集合"><inspection shortName="EqualityToSameElements" defaultSeverity="WARNING" displayName="数组和迭代器上的 equals" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告数组和迭代器上 "equals" 的用法。&lt;/p&gt;
&lt;p&gt;数组和迭代器上的相等会检查引用相等性（很少有用）。
    此检查建议通过 &lt;code&gt;sameElements&lt;/code&gt; 比较内容。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Array(1) == Array(1) //false
  Iterator(1) == Iterator(1) //false
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Array(1) sameElements Array(1) //true
  Iterator(1) sameElements Iterator(1) //true
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ComparingLength" defaultSeverity="WARNING" displayName="将比较 length 转换为 lengthCompare" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告比较 &lt;code&gt;.length&lt;/code&gt; 或 &lt;code&gt;.size&lt;/code&gt;，并建议将其替换为 &lt;code&gt;.sizeIs&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  var seq: Seq[Int]
  seq.length == n
  seq.length != n
  seq.length &lt; n
  seq.length &gt; n

  seq.size == n
  seq.size != n
  seq.size &lt; n
  seq.size &gt; n
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  var seq: Seq[Int]
  seq.sizeIs == n
  seq.sizeIs != n
  seq.sizeIs &lt; n
  seq.sizeIs &gt; n

  seq.sizeIs == n
  seq.sizeIs != n
  seq.sizeIs &lt; n
  seq.sizeIs &gt; n
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CorrespondsUnsorted" defaultSeverity="WARNING" displayName="未排序集合中的 Corresponds/sameElements" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 &lt;code&gt;sameElements&lt;/code&gt; 和 &lt;code&gt;corresponds&lt;/code&gt; 与未排序集合的用法。&lt;/p&gt;

&lt;p&gt;方法 &lt;code&gt;sameElements&lt;/code&gt; 和 &lt;code&gt;corresponds&lt;/code&gt; 使用给定集合的迭代器根据元素在集合中的位置顺序来比较元素。
    因此，如果元素的顺序没有明确定义，结果是不可预测的，就像无序 Set 或 Map 的情况一样。&lt;/p&gt;
&lt;p&gt;要解决此问题，请考虑使用 &lt;code&gt;==&lt;/code&gt;、&lt;code&gt;subsetOf&lt;/code&gt;，或按某种顺序排序元素。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Set(3,2,1) sameElements Set(1, 2, 3) // 为 false

  // 但

  Set(1, 2, 3, 4, 5) sameElements Set(5, 4, 3, 2, 1) // 为 true
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SameElementsToEquals" defaultSeverity="WARNING" displayName="相同种类的 SameElements onCollections" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 &lt;code&gt;sameElements&lt;/code&gt; 或 &lt;code&gt;corresponds&lt;/code&gt; 的用法以比较相同种类的集合（Seq、Set 或 Map）。
&lt;/p&gt;

&lt;p&gt;该快速修复改用相等。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  seq sameElements list
  hashSet sameElements treeSet
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  seq == list
  hashSet == treeSet
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ComparingDiffCollectionKinds" defaultSeverity="WARNING" displayName="不同种类集合上的 Equals" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告比较不同类别的 Scala 集合的情况。&lt;/p&gt;
&lt;p&gt;不同类别（Set、Seq、Map 或 Iterator）的 Scala 集合不能相等，也不应与数组进行比较。 此检查建议将其中一个集合转换为同一类别。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  seq == iterator
  seq != array
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  seq.toIterator == iterator or seq == iterator.toSeq
  seq != array.toSeq
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Docker-compose" path=""><inspection shortName="ComposeMissingKeys" defaultSeverity="ERROR" displayName="缺少 docker-compose YAML 键" enabled="false" language="yaml" pluginId="Docker" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 Docker Compose 文件中缺少必需键。&lt;br&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ComposeUnquotedPorts" defaultSeverity="WEAK WARNING" displayName="未加引号的端口映射" enabled="false" language="yaml" pluginId="Docker" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 Docker Compose 文件中未加引号的端口映射。&lt;/p&gt;
&lt;p&gt;
  根据 &lt;a href="https://docs.docker.com/compose/compose-file/compose-file-v3/#short-syntax-1"&gt;Compose 文件规范&lt;/a&gt;，&lt;code&gt;HOST:CONTAINER&lt;/code&gt; 格式的映射端口在使用小于 60 的容器端口时可能会导致错误的结果，因为 YAML 会将格式为 &lt;code&gt;xx:yy&lt;/code&gt; 的数字解析为六十进制值。
  因此，我们建议始终将端口映射明确指定为字符串。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  ports:
    - 3000
    - 3000-3005
    - 22:22
    - 8080:8080
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  ports:
    - "3000"
    - "3000-3005"
    - "22:22"
    - "8080:8080"
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ComposeUnknownValues" defaultSeverity="ERROR" displayName="未知 docker-compose YAML 值" enabled="false" language="yaml" pluginId="Docker" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 Docker Compose 文件中无法识别的值。&lt;br&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ComposeUnknownKeys" defaultSeverity="ERROR" displayName="未知 docker-compose YAML 键" enabled="false" language="yaml" pluginId="Docker" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 Docker Compose 文件中无法识别的键。&lt;br&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="控制流问题" path="JavaScript and TypeScript"><inspection shortName="JSObjectNullOrUndefined" defaultSeverity="WARNING" displayName="对象为 'null' 或 'undefined'" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对 &lt;code&gt;undefined&lt;/code&gt; 或 &lt;code&gt;null&lt;/code&gt; 对象调用方法、访问属性或调用函数所导致的错误。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnreachableCodeJS" defaultSeverity="WARNING" displayName="无法访问的代码" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告永远无法执行的代码，这几乎肯定表明有错误
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryLabelOnContinueStatementJS" defaultSeverity="WARNING" displayName="'continue' 语句上的不必要标签" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以在不更改控制流的情况下移除其标签的 &lt;code&gt;continue&lt;/code&gt; 标签语句。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TrivialConditionalJS" defaultSeverity="WARNING" displayName="冗余条件表达式" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告如下格式的条件表达式
&lt;pre&gt;&lt;code&gt;
condition ? true : false
condition ? false : true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  这些表达式可以安全地转换为
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
condition
!condition
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SuspiciousTypeOfGuard" defaultSeverity="WARNING" displayName="类型防护检查不健全" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;typeof&lt;/code&gt; 或 &lt;code&gt;instanceof&lt;/code&gt; 不健全的类型防护检查。
在以下两种情况下，&lt;code&gt;typeof x&lt;/code&gt; 类型防护可能不健全：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;typeof x&lt;/code&gt; 不对应于指定的值（例如，当 &lt;code&gt;x&lt;/code&gt; 为 'string | boolean' 类型时，&lt;code&gt;typeof x === 'number'&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;typeof x&lt;/code&gt; 始终对应于指定的值（例如，当 &lt;code&gt;x&lt;/code&gt; 为 'string' 类型时，&lt;code&gt;typeof x === 'string'&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
在以下两种情况下，&lt;code&gt;x instanceof A&lt;/code&gt; 类型防护可能不健全：
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;x&lt;/code&gt; 的类型与 &lt;code&gt;A&lt;/code&gt; 不相关&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;x&lt;/code&gt; 的类型是 &lt;code&gt;A&lt;/code&gt; 或 &lt;code&gt;A&lt;/code&gt; 的子类型&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryReturnJS" defaultSeverity="WARNING" displayName="不必要的 'return' 语句" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告不必要的 &lt;code&gt;return&lt;/code&gt; 语句，即不返回值并且刚好在函数'贯穿'底部之前发生的 &lt;code&gt;return&lt;/code&gt; 语句。
这些语句可以安全移除。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="IfStatementWithIdenticalBranchesJS" defaultSeverity="WARNING" displayName="'if' 语句的分支相同" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告具有相同的 &lt;code&gt;then&lt;/code&gt; 和 &lt;code&gt;else&lt;/code&gt; 分支的 &lt;code&gt;if&lt;/code&gt; 语句。 此类语句几乎
肯定有错误。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryLabelJS" defaultSeverity="WARNING" displayName="不必要的标签" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告未使用的标签。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DuplicateConditionJS" defaultSeverity="WARNING" displayName="'if' 语句中的重复条件" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;if&lt;/code&gt; 语句的不同分支中的重复条件。 重复条件通常因程序员疏忽大意所致。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (a) {
    ...
  } else if (a) {
    ...
  }
&lt;/code&gt;
&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryLabelOnBreakStatementJS" defaultSeverity="WARNING" displayName="'break' 语句上的标签不必要" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以在不更改控制流的情况下移除其标签的 &lt;code&gt;break&lt;/code&gt; 标签语句。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ForLoopReplaceableByWhileJS" defaultSeverity="WARNING" displayName="'for' 循环可被替换为 'while' 循环" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告既不包含初始化也不包含更新组件的
&lt;code&gt;for&lt;/code&gt; 循环。 建议将该循环替换为更简单的 &lt;code&gt;while&lt;/code&gt; 语句。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  for(; exitCondition(); ) {
    process();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;应用快速修复后，结果如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  while(exitCondition()) {
    process();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;如果希望此检查忽略包含普通条件或不存在条件的 &lt;b&gt;for&lt;/b&gt; 循环，请使用下面的复选框。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="IfStatementWithTooManyBranchesJS" defaultSeverity="WARNING" displayName="'if' 语句的分支过多" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告分支过多的 &lt;code&gt;if&lt;/code&gt; 语句。 此类语句可能令人困惑，并且通常表明设计抽象级别不足。
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用下面的字段可指定预期的最大分支数。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PointlessBooleanExpressionJS" defaultSeverity="WARNING" displayName="无意义的语句或布尔表达式" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告无意义或复杂的没有意义的布尔表达式或语句。
&lt;p&gt;示例：
&lt;pre&gt;&lt;code&gt;
  let a = !(false &amp;&amp; x);
  let b = false || x;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;应用快速修复后，结果如下所示：
&lt;pre&gt;&lt;code&gt;
  let a = true;
  let b = x;
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LoopStatementThatDoesntLoopJS" defaultSeverity="WARNING" displayName="不循环的循环语句" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告语句体最多可以执行一次的 &lt;code&gt;for&lt;/code&gt; 、
&lt;code&gt;while&lt;/code&gt; 或 &lt;code&gt;do&lt;/code&gt; 语句。 这通常表示有错误。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TrivialIfJS" defaultSeverity="WARNING" displayName="冗余的 'if' 语句" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以简化为单个赋值
或 &lt;code&gt;return&lt;/code&gt; 语句的
&lt;code&gt;if&lt;/code&gt; 语句。  &lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
if(foo())
 {
  return true;
 }
 else
 {
   return false;
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;应用快速修复后，代码如下所示：&lt;/p&gt;
&lt;pre&gt;
 &lt;code&gt;return foo();&lt;/code&gt;
&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryContinueJS" defaultSeverity="WARNING" displayName="不必要的 'continue' 语句" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告循环末尾不必要的 &lt;code&gt; continue&lt;/code&gt; 语句。 建议移除这些语句。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConditionalExpressionWithIdenticalBranchesJS" defaultSeverity="WARNING" displayName="具有相同分支的条件表达式" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告具有相同的 &lt;code&gt;then&lt;/code&gt; 和 &lt;code&gt;else&lt;/code&gt; 分支的三元条件表达式。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TailRecursionJS" defaultSeverity="WARNING" displayName="尾递归" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告尾递归，即报告函数在返回之前
调用自身作为最后操作的情况。  尾递归总是可以替换为循环，循环的速度快得多。
一些 JavaScript 引擎执行这种优化，而另一些则不执行。  因此，尾递归解决方案在不同环境下
可能具有截然不同的性能特点。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConstantConditionalExpressionJS" defaultSeverity="WARNING" displayName="常量条件表达式" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告格式为 &lt;code&gt;true? 的条件表达式 result1: result2&lt;/code&gt; 或 &lt;code&gt;false? result1: result2&lt;/b&gt;。
建议简化该表达式。
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="HTTP 客户端" path=""><inspection shortName="HttpRequestContentLengthIsIgnored" defaultSeverity="WARNING" displayName="冗余的 'Content-Length'" enabled="false" language="HTTP Request" pluginId="com.jetbrains.restClient" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告显式设置的 &lt;code&gt;Content-Length&lt;/code&gt; 标头。 此标头冗余，因为 HTTP 客户端使用实际的请求主体长度。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="HttpClientUnresolvedVariable" defaultSeverity="WARNING" displayName="未解析的环境变量" enabled="false" language="HTTP Request" pluginId="com.jetbrains.restClient" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告当前环境中未声明的 HTTP 客户端变量。&lt;/p&gt;
&lt;p&gt;
  使用未声明的变量执行请求可能会失败。
  考虑向环境中添加一个变量，或使用从变量打开一个环境。
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;检查不会报告请求正文中的变量，因为它可能是正文的有效语法。&lt;/p&gt;
&lt;p&gt;
  某些变量可能不会被报告为未解析，因为它们是通过 &lt;code&gt;client.global.set&lt;/code&gt; 函数调用在响应处理程序脚本中声明的。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="HttpRequestPlaceholder" defaultSeverity="WARNING" displayName="HTTP 请求中的 '$placeholder'" enabled="false" language="HTTP Request" pluginId="com.jetbrains.restClient" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告请求内部的 &lt;code&gt;$placeholder&lt;/code&gt;。 
&lt;p&gt;当工具无法识别请求的一部分时，将自动创建要由用户替换的 &lt;code&gt;$placeholder&lt;/code&gt;。 例如，请求映射 &lt;code&gt;/aaaa/*/bbb&lt;/code&gt; 将生成为 &lt;code&gt;GET localhost/aaaa/{{$placeholder}}/bbb&lt;/code&gt;。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="IncorrectHttpHeaderInspection" defaultSeverity="WARNING" displayName="不正确的 HTTP 标头" enabled="false" language="HTTP Request" pluginId="com.jetbrains.restClient" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;
  报告与任何&lt;a href="https://www.iana.org/assignments/message-headers/message-headers.xml"&gt;公共已知标头&lt;/a&gt;不匹配的未知 HTTP 标头。 快速修复建议在启用&lt;b&gt;使用自定义 HTTP 标题&lt;/b&gt;选项时，将该标题添加到自定义标题列表中。 自定义标头列表中的 HTTP 标头将不会触发检查。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="HttpRequestWhitespaceInsideRequestTargetPath" defaultSeverity="WEAK WARNING" displayName="URL 中存在空格" enabled="false" language="HTTP Request" pluginId="com.jetbrains.restClient" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
高亮显示 URL 路径段内的空格。 HTTP 客户端将忽略它们。 要获得更好的组合，请使用“拆分行”操作。
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Scaladoc" path="Scala"><inspection shortName="ScalaDocUnknownTag" defaultSeverity="WARNING" displayName="未知标记" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 Scaladoc 文档中的未知标记并建议将其移除。&lt;/p&gt;
&lt;p&gt;在以下示例中，标记了 &lt;code&gt;blubquam&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  /**
   *
   * @blubquam 这是一个未知标记
   */
  def test(i: Int): Unit = ()
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ScalaDocUnclosedTagWithoutParser" defaultSeverity="WARNING" displayName="标记未结束" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;在 Scaladoc 中报告未关闭的标记。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  /**
   * ''
   *
   * [[
   *
   * `
   */
  class A
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  /**
   * &amp;#39;&amp;#39;
   *
   * &amp;#91;&amp;#91;
   *
   * &amp;#96;
   */
  class A
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ScalaDocParserErrorInspection" defaultSeverity="WARNING" displayName="错误的 scaladoc 元素" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告错误的 Scaladoc 元素。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ScalaDocUnknownParameter" defaultSeverity="WARNING" displayName="未知形参" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告有关不存在的形参的 Scaladoc 文档。&lt;/p&gt;
&lt;p&gt;
 在以下示例中，标记了 &lt;code&gt;x&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  /**
   *
   * @param x 函数 `test` 上不存在此形参
   */
  def test(i: Int): Unit = {

  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ScalaDocInlinedTag" defaultSeverity="WARNING" displayName="内联标记" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 Scaladoc 中使用的内联标记。&lt;/p&gt;

&lt;p&gt;Scaladoc 将内联标记视为等宽文本。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  /**
   * Text 1&lt;br&gt;
   * Text 2 {@code some text}&lt;br&gt;
   * Text 3 {@link java.lang.String}&lt;br&gt;
   * Text 4 {@qwewqe some text}&lt;br&gt;
   * @note text
   */
  class A
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ScalaDocMissingParameterDescription" defaultSeverity="WARNING" displayName="缺少标记形参描述" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告缺少的形参描述。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  /**
   * 形参 x 缺少描述
   * @param x
   */
  def test(x: Int): Int = x
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ScalaDocUnbalancedHeader" defaultSeverity="WARNING" displayName="标头标记不平衡" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告不平衡的 wiki 语法标题和 Scaladocs 中此类标题后被忽略的文本。&lt;/p&gt;
&lt;p&gt;在以下示例中，标记了 &lt;code&gt;====&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  /**
   * == I'm a wiki style header ====
   */
  def test(i: Int): Unit = {

  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在以下示例中，标记了 &lt;code&gt;Ignored text&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  /**
   * == I'm a wiki style header == Ignored text
   */
  def test(i: Int): Unit = {

  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Ant" path=""><inspection shortName="AntDuplicateTargetsInspection" defaultSeverity="ERROR" displayName="重复的目标" enabled="false" language="XML" pluginId="AntSupport" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;table&gt;
  &lt;tr&gt;
    &lt;td valign="top"&gt;
        报告当前构建文件中的重复 &lt;code&gt;targets&lt;/code&gt;。
      &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AntResolveInspection" defaultSeverity="ERROR" displayName="Ant 引用解析问题" enabled="false" language="XML" pluginId="AntSupport" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;table&gt;
  &lt;tr&gt;
    &lt;td valign="top"&gt;
      报告无法解析的属性和自定义类型定义上的未解析引用。
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AntMissingPropertiesFileInspection" defaultSeverity="ERROR" displayName="缺少属性文件" enabled="false" language="XML" pluginId="AntSupport" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;table&gt;
  &lt;tr&gt;
    &lt;td valign="top"&gt;
        报告缺失的 .properties 文件。
      &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="记录" path="Java"><inspection shortName="StringConcatenationArgumentToLogCall" defaultSeverity="WARNING" displayName="非常量字符串串联作为日志调用的实参" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告用作 &lt;b&gt;SLF4J&lt;/b&gt; 和 &lt;b&gt;Log4j 2&lt;/b&gt; 日志记录方法实参的非常量字符串串联。
即使未记录日志消息，也会在运行时评估非常量串联；这会对性能产生负面影响。
建议改用形参化日志消息，禁用日志记录时不会对其进行评估。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;public class&lt;/b&gt; Vital {
    &lt;b&gt;private static final&lt;/b&gt; Logger LOG = LoggerFactory.getLogger(Vital.class);

    &lt;b&gt;public void&lt;/b&gt; saveTheWorld(&lt;b&gt;int&lt;/b&gt; i, String s, &lt;b&gt;boolean&lt;/b&gt; b) {
      LOG.info("saveTheWorld(" + i + ", " + s + ", "  + b + ")");
      // todo
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;public class&lt;/b&gt; Vital {
    &lt;b&gt;private static final&lt;/b&gt; Logger LOG = LoggerFactory.getLogger(Vital.class);

    &lt;b&gt;public void&lt;/b&gt; saveTheWorld(&lt;b&gt;int&lt;/b&gt; i, String s, &lt;b&gt;boolean&lt;/b&gt; b) {
      LOG.info("saveTheWorld({}, {}, {})", i, s, b);
      // todo
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  配置检查：
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    使用&lt;b&gt;警告对象&lt;/b&gt;列表可以忽略某些更高的日志记录级别。 即使在生产中也可以启用更高的日志记录级别，并且始终会评估实参。
  &lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PublicMethodWithoutLogging" defaultSeverity="WARNING" displayName="'public' 方法没有日志记录" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告任何不包含日志记录语句的 public 方法。 此检查不报告简单的 getter 和 setter。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;public class&lt;/b&gt; Crucial {
    &lt;b&gt;private static final &lt;/b&gt;Logger LOG = LoggerFactory.getLogger(Crucial.class);
    &lt;b&gt;public void&lt;/b&gt; doImportantStuff() {
      // 对此方法发出警告
    }

    &lt;b&gt;public void&lt;/b&gt; doOtherStuff() {
      LOG.info("do other stuff");
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
使用下表可指定 Logger 类名。
此检查将报告不使用指定类的实例方法的 public 方法。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ClassWithoutLogger" defaultSeverity="WARNING" displayName="不带记录器的类" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告没有声明记录器的类。
&lt;p&gt;确保每个类都有一个专用的记录器是为应用程序提供统一的日志记录实现的重要步骤。 此检查不报告接口、枚举、注解、内部类和 abstract 类。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;public class&lt;/b&gt; NoLoggerDeclared {

    &lt;b&gt;int&lt;/b&gt; calculateNthDigitOfPi(&lt;b&gt;int&lt;/b&gt; n) {
      // todo
      &lt;b&gt;return&lt;/b&gt; 1;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用 &lt;b&gt;Options&lt;/b&gt; 部分中的表可以指定记录器类名。
此检查将报告未声明具有指定类之一类型的字段的类。

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LogStatementGuardedByLogCondition" defaultSeverity="WARNING" displayName="日志调用不受日志条件保护" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告带有未被保护条件包围的非常量实参的日志记录调用。
对日志记录调用的实参的评估可能开销巨大。
当日志记录语句使用的级别禁用日志记录时，使用临界子句包围日志记录调用可避免这种开销。 这对于最不严重的日志记录调用级别（跟踪、调试、最精细）特别有用，因为这些调用在生产环境中最常被禁用。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;public class&lt;/b&gt; Principal {
    &lt;b&gt;void&lt;/b&gt; bad(Object object) {
      &lt;b&gt;if&lt;/b&gt; (true) {
        LOG.debug("log log log " + expensiveCalculation(object));
      }
      LOG.debug("some more logging " + expensiveCalculation(1));
    }

    &lt;b&gt;void&lt;/b&gt; good(Object) {
      &lt;b&gt;if&lt;/b&gt; (LOG.isDebug()) {
        LOG.debug("value: " + expensiveCalculation(object));
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  配置检查：
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
      使用&lt;b&gt;记录器类名&lt;/b&gt;字段可以指定使用的记录器类名。
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;
      使用该表可以指定此检查应警告的日志记录方法，以及相应的日志条件文本。
  &lt;/li&gt;
  &lt;li&gt;
      使用&lt;b&gt;标记所有不受保护的日志调用&lt;/b&gt;选项可让检查标记所有不受保护的日志调用，而不仅仅是那些具有非常量实参的调用。
  &lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PlaceholderCountMatchesArgumentCount" defaultSeverity="WARNING" displayName="占位符数量与日志调用中的实参数量不匹配" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 SLF4J 或 Log4j 2 日志记录调用，例如 &lt;code&gt;logger.info("{}: {}", key)&lt;/code&gt;，其中记录器消息中 &lt;code&gt;{}&lt;/code&gt; 占位符的数量与日志调用的其他实参的数量不匹配。
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LoggerInitializedWithForeignClass" defaultSeverity="WARNING" displayName="使用外类初始化记录器" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告用来初始化的 &lt;code&gt;class&lt;/code&gt; 文字所属的类与 &lt;code&gt;Logger&lt;/code&gt; 所属的类不同的 &lt;code&gt;Logger&lt;/code&gt; 实例。 从另一个类复制粘贴某些代码时，很容易发生这种情况，并可能导致在意外类别下记录事件，并导致筛选器应用不正确。
&lt;p&gt;提供了一个快速修复来用周围类中的文字替换外类文字。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;public class&lt;/b&gt; Paramount {
    &lt;b&gt;protected static final&lt;/b&gt; Logger LOG = Logger.getLogger(Critical.class);

    // …其他字段和方法
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;public class&lt;/b&gt; Paramount {
    &lt;b&gt;protected static final&lt;/b&gt; Logger LOG = Logger.getLogger(Paramount.class);

    // …其他字段和方法
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  配置检查：
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;使用该表可以指定此检查识别的记录器工厂类和记录器工厂方法。&lt;/li&gt;
  &lt;li&gt;使用&lt;b&gt;忽略使用超类初始化的记录器&lt;/b&gt;选项可以忽略使用包含该记录器的类的超类初始化的记录器。&lt;/li&gt;
  &lt;li&gt;使用&lt;b&gt;忽略非 public 类中的记录器&lt;/b&gt;，仅对 &lt;code&gt;public&lt;/code&gt; 类中的记录器发出警告。&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ClassWithMultipleLoggers" defaultSeverity="WARNING" displayName="具有多个记录器的类" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告声明了多个记录器的类。
为应用程序提供统一的日志记录实现的一大重要步骤，是确保每个类都有一个专用的记录器。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;public class&lt;/b&gt; Critical {
    &lt;b&gt;protected static final&lt;/b&gt; Logger LOG = Logger.getLogger(Critical.class);

    &lt;b&gt;protected static final&lt;/b&gt; Logger myLogger = Logger.getLogger(getClass());
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
使用下表可指定 Logger 类名。
此检查将报告声明多个字段具有所指定类的类型之一的类。
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LoggingConditionDisagreesWithLogStatement" defaultSeverity="WARNING" displayName="日志条件与日志记录调用不匹配" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告与包含的日志记录调用的日志级别不匹配的 &lt;code&gt;if&lt;/code&gt; 语句的 &lt;em&gt;is log enabled for&lt;/em&gt; 条件。
&lt;p&gt;
示例：
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;if&lt;/b&gt; (LOG.isTraceEnabled()) {
    // 已记录调试级别，但已检查跟踪级别
    LOG.debug("some log message");
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;此检查能够理解 &lt;em&gt;java.util.logging&lt;/em&gt;、&lt;em&gt;log4j&lt;/em&gt;、&lt;em&gt;Log4j 2&lt;/em&gt;、&lt;em&gt;Apache Commons Logging&lt;/em&gt; 和 &lt;em&gt;SLF4J&lt;/em&gt; 日志记录框架。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NonStaticFinalLogger" defaultSeverity="WARNING" displayName="非常量记录器" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告未被声明为 &lt;code&gt;static&lt;/code&gt; 和/或 &lt;code&gt;final&lt;/code&gt; 的记录器字段。
确保每个类记录器都是有效的常量并绑定到该类可以简化为应用程序提供统一日志记录实现的任务。
&lt;p&gt;提供了一个快速修复来将记录器修饰符更改为 &lt;code&gt;static final&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;public class&lt;/b&gt; Significant {
    &lt;b&gt;private&lt;/b&gt; Logger LOG = Logger.getLogger(Critical.class);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;public class&lt;/b&gt; Significant {
    &lt;b&gt;private static final&lt;/b&gt; Logger LOG = Logger.getLogger(Critical.class);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  配置检查：
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;使用&lt;b&gt;记录器类名&lt;/b&gt;表可以指定记录器类名。 该检查将报告不是 &lt;code&gt;static&lt;/code&gt; 和 &lt;code&gt;final&lt;/code&gt; 并且类型等同于指定类名之一的字段。
  &lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Maven" path=""><inspection shortName="MavenRedundantGroupId" defaultSeverity="WARNING" displayName="冗余 groupId" enabled="false" language="XML" pluginId="org.jetbrains.idea.maven" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告不必要的 &amp;lt;groupId&amp;gt; 定义，因为它已经在父 pom.xml 中定义&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MavenDuplicateDependenciesInspection" defaultSeverity="WARNING" displayName="重复的依赖项" enabled="false" language="XML" pluginId="org.jetbrains.idea.maven" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告重复的依赖项&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MavenModelInspection" defaultSeverity="ERROR" displayName="Maven 模型检查" enabled="false" language="XML" pluginId="org.jetbrains.idea.maven" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 Maven 模型中的解析问题&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MavenParentMissedVersionInspection" defaultSeverity="ERROR" displayName="缺少父版本" enabled="false" language="XML" pluginId="org.jetbrains.idea.maven" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告不支持使用者 POM 功能的版本缺少父版本元素&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MavenPropertyInParent" defaultSeverity="WARNING" displayName="在父描述中使用属性" enabled="false" language="XML" pluginId="org.jetbrains.idea.maven" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告使用父模块中定义的属性是被禁止的。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MavenDuplicatePluginInspection" defaultSeverity="WARNING" displayName="重复的插件声明" enabled="false" language="XML" pluginId="org.jetbrains.idea.maven" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 pom.xml 中插件声明的重复&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Shrinker" path="Android"><inspection shortName="ShrinkerArrayType" defaultSeverity="ERROR" displayName="Invalid using of array type" enabled="false" language="SHRINKER_CONFIG" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;
  报告数组类型表示法的不正确用法。
  &lt;br&gt;
  &lt;code&gt;type[]&lt;/code&gt; 应用于数组类型，不包含任何空格。
  &lt;br&gt;
  &lt;br&gt;
 示例：&lt;code&gt;java.lang.Object[]&lt;/code&gt;。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ShrinkerInvalidFlags" defaultSeverity="ERROR" displayName="Invalid flag in shrinker config" enabled="false" language="SHRINKER_CONFIG" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 Shrinker 配置中的无效标志。
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ShrinkerInnerClassSeparator" defaultSeverity="ERROR" displayName="Invalid separator between class and inner class" enabled="false" language="SHRINKER_CONFIG" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 Shrinker 配置文件中类和内部类之间的无效分隔符。
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="R8IgnoredFlags" defaultSeverity="WARNING" displayName="Flags ignored by R8" enabled="false" language="SHRINKER_CONFIG" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告被 R8 忽略的标志。
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ShrinkerUnresolvedReference" defaultSeverity="ERROR" displayName="Unresolved reference in Shrinker Config file" enabled="false" language="SHRINKER_CONFIG" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对 Shrinker 配置中的类成员的未解析引用。
&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="命名约定" path="Java"><inspection shortName="DollarSignInName" defaultSeverity="WARNING" displayName="在标识符中使用 '$'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告名称中带有美元符号 (&lt;code&gt;$&lt;/code&gt;) 的变量、方法和类。 虽然此类名称是合法的 Java，但强烈建议不要在生成的 Java 代码之外使用它们。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class SalaryIn${}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;仅在编辑器中建议重命名快速修复。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UpperCaseFieldNameNotConstant" defaultSeverity="WARNING" displayName="具有大写名称的非常量字段" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告名称全部为大写的非 &lt;code&gt;static&lt;/code&gt; 非 &lt;code&gt;final&lt;/code&gt; 字段。
&lt;p&gt;此类字段可能会因违反通用命名约定而引起混淆，并且经常被错误使用。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt; &lt;pre&gt;&lt;code&gt;
  public static int THE_ANSWER = 42; // 此处警告：final 修饰符缺失
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;只能在编辑器中使用重命名此类字段的快速修复。&lt;/p&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StandardVariableNames" defaultSeverity="WARNING" displayName="标准变量名称" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告具有与其类型不对应的“标准”名称的变量。
此类名称可能令人困惑。 特定类型有以下标准名称：
&lt;ul&gt;
  &lt;li&gt;i, j, k, m, n - &lt;code&gt;int&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;f - &lt;code&gt;float&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;d - &lt;code&gt;double&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;b - &lt;code&gt;byte&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;c, ch - &lt;code&gt;char&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;l - &lt;code&gt;long&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;s, str - &lt;code&gt;String&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;仅在编辑器中建议重命名快速修复。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用该选项可以忽略与直接 super 方法中的形参名称相同的形参名称。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LocalVariableNamingConvention" defaultSeverity="WARNING" displayName="局部变量命名约定" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告名称太短、太长或不遵循指定正则表达式模式的局部变量。
&lt;p&gt;&lt;b&gt;示例&lt;/b&gt;：如果在默认设置下启用该检查，其中变量名称应以小写字母开头，则报告 &lt;code&gt;int X = 42;&lt;/code&gt;。&lt;/p&gt;

&lt;!-- tooltip end --&gt;
&lt;p&gt;配置检查：&lt;/p&gt;
&lt;p&gt;
使用&lt;b&gt;选项&lt;/b&gt;部分中的字段可指定局部变量名称的最小长度、最大长度以及预期的正则表达式。
指定 &lt;b&gt;0&lt;/b&gt; 以便不检查名称的长度。 正则表达式应以标准 &lt;b&gt;java.util.regex&lt;/b&gt; 格式指定。
&lt;p&gt;使用复选框来忽略 &lt;code&gt;for&lt;/code&gt; 循环和 &lt;code&gt;catch&lt;/code&gt; 部分的形参。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JavaModuleNaming" defaultSeverity="WARNING" displayName="Java 模块名称与约定相矛盾" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告模块名称与 Java Platform Module System 建议相矛盾的情况。
&lt;p&gt;其中一种&lt;a href="http://mail.openjdk.org/pipermail/jpms-spec-experts/2017-March/000659.html"&gt;建议&lt;/a&gt;是避免在模块名称末尾使用数字。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
module foo1.bar2 {}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="PackageNamingConvention" defaultSeverity="WARNING" displayName="软件包命名约定" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
报告名称太短、太长或不遵循指定正则表达式模式的软件包。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  package io;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用选项可以指定软件包名称的最小长度和最大长度，以及匹配有效软件包名称的正则表达式（正则表达式采用标准 &lt;code&gt;java.util.regex&lt;/code&gt; 格式）。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LambdaParameterNamingConvention" defaultSeverity="WARNING" displayName="lambda 形参命名约定" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告名称太短、太长或不遵循指定正则表达式模式的 lambda 形参。
&lt;p&gt;&lt;b&gt;示例&lt;/b&gt;：如果使用默认设置（其中形参名称应以小写字母开头）启用检查，则应报告 &lt;code&gt;Function&amp;lt;String, String&amp;gt; id = X -&amp;gt; X;&lt;/code&gt;。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;配置检查：&lt;/p&gt;
&lt;p&gt;
使用&lt;b&gt;选项&lt;/b&gt;部分中的字段可指定 lambda 形参名称的最小长度、最大长度以及预期的正则表达式。
  指定 &lt;b&gt;0&lt;/b&gt; 以便不检查名称的长度。&lt;/p&gt;
&lt;p&gt;正则表达式应以标准 &lt;code&gt;java.util.regex&lt;/code&gt; 格式指定。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FieldNamingConvention" defaultSeverity="WARNING" displayName="字段命名约定" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告名称太短、太长或不遵循指定正则表达式模式的字段。
&lt;p&gt;&lt;b&gt;示例&lt;/b&gt;：如果对常量启用了检查，并且字段名称的最小指定长度为 5（默认值），由于以下常量的名称长度为 3，即小于 5，因此将生成警告：&lt;code&gt;public static final int MAX = 42;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;只能在编辑器中使用重命名此类字段的快速修复。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;配置检查：&lt;/p&gt;
&lt;p&gt;使用&lt;b&gt;选项&lt;/b&gt;部分中的列表来指定应检查哪些字段。 取消选中要为之跳过检查的字段对应的复选框。&lt;/p&gt;
&lt;p&gt;对于每种字段类型，请使用所提供的输入字段指定字段名称的最小长度、最大长度和正则表达式。
  在长度字段中指定 &lt;b&gt;0&lt;/b&gt; 可跳过相应检查。&lt;/p&gt;
&lt;p&gt;正则表达式应以标准 &lt;code&gt;java.util.regex&lt;/code&gt; 格式指定。&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ParameterNameDiffersFromOverriddenParameter" defaultSeverity="WARNING" displayName="形参名称与重写或重载方法中的参数不同" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告名称与其重写或重载方法的相应形参不同的形参。 虽然在 Java 中是合法的，但这种不一致的名称可能令人困惑，并减少具有良好命名做法的文档优势。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Person {
    Person(String fullName) {}
  }
  class Child extends Person {
    Child(String name) { super(name); }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Person {
    Person(String fullName) {}
  }
  class Child extends Person {
    Child(String fullName) { super(fullName); }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用选项可以指示是否忽略只有单个字符长度或来自库方法的重写的形参名称。 如果您不希望受到库中使用的可疑命名约定的约束，那么两者都会很有用。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ParameterNamingConvention" defaultSeverity="WARNING" displayName="方法形参命名约定" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告名称太短、太长或不遵循指定正则表达式模式的方法形参。
&lt;p&gt;&lt;b&gt;示例&lt;/b&gt;：如果使用默认设置（其中形参名称应以小写字母开头）启用检查，则应报告  &lt;code&gt;void fooBar(int X)&lt;/code&gt;。&lt;/p&gt;

&lt;!-- tooltip end --&gt;
&lt;p&gt;配置检查：&lt;/p&gt;
&lt;p&gt;
  使用&lt;b&gt;选项&lt;/b&gt;部分中的字段可指定方法形参名称的最小长度、最大长度以及预期的正则表达式。 指定 &lt;b&gt;0&lt;/b&gt; 以便不检查名称的长度。&lt;/p&gt;
&lt;p&gt;正则表达式应以标准 &lt;code&gt;java.util.regex&lt;/code&gt; 格式指定。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="QuestionableName" defaultSeverity="WARNING" displayName="可疑名称" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告名称有问题，而不是真正的描述性名称的变量、方法或类。
此类名称无助于理解代码，而且很可能是临时创建，但后来被遗忘了。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int aa = 42;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;仅在编辑器中建议重命名快速修复。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用该选项可以列出应被报告的名称。
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="索引" path="Scala，集合"><inspection shortName="ZipWithIndex" defaultSeverity="WARNING" displayName="使用索引进行手动压缩" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告索引的手动压缩，而不是使用 &lt;code&gt;zipWithIndex&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  var seq: Seq[Int]
  seq.zip(seq.indices)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  var seq: Seq[Int]
  seq.zipWithIndex
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LastIndexToLast" defaultSeverity="WARNING" displayName="按索引访问最后一个元素" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 &lt;code&gt;seq(seq.size - 1)&lt;/code&gt; 或 &lt;code&gt;seq.apply(seq.size - 1)&lt;/code&gt;，并且如果 &lt;code&gt;seq&lt;/code&gt; 不是 &lt;code&gt;IndexedSeq&lt;/code&gt; 的实例，建议将其替换为 &lt;code&gt;seq.last&lt;/code&gt;。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ZeroIndexToHead" defaultSeverity="WARNING" displayName="按索引访问第一个元素" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告按索引而不是 &lt;code&gt;head&lt;/code&gt; 访问集合的第一个元素。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  var seq: Seq[Int]
  seq(0)
  seq.apply(0)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  var seq: Seq[Int]
  seq.head
  seq.head
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RangeToIndices" defaultSeverity="WARNING" displayName="正在构建序列索引的范围" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告手动构建集合索引的范围，而不是使用 &lt;code&gt;.indices&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  var x: Seq[Int]
  Range(0, x.size)
  0 until x.size
  0.to(x.size - 1)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  var x: Seq[Int]
  x.indices
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="模式验证" path=""><inspection shortName="PatternNotApplicable" defaultSeverity="ERROR" displayName="模式注解不适用" enabled="false" language="JAVA" pluginId="org.intellij.intelliLang" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告将 &lt;code&gt;@Pattern&lt;/code&gt; 注解应用于 &lt;code&gt;String&lt;/code&gt; 之外类型的元素的情况。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Pattern("\\d\\d") &lt;b&gt;int&lt;/b&gt; i;
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="PatternValidation" defaultSeverity="WARNING" displayName="验证已注解模式" enabled="false" language="JAVA" pluginId="org.intellij.intelliLang" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告作为 &lt;code&gt;@Pattern&lt;/code&gt; 形参的实参传递并从与指定模式不匹配的 &lt;code&gt;@Pattern&lt;/code&gt; 注解方法返回的表达式。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Pattern("\\d\\d-\\d\\d\\d") String getId() {
    &lt;b&gt;return&lt;/b&gt; "1";
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="PatternOverriddenByNonAnnotatedMethod" defaultSeverity="WARNING" displayName="无注解的方法重写 @Pattern 方法" enabled="false" language="JAVA" pluginId="org.intellij.intelliLang" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告不带 &lt;code&gt;@Pattern&lt;/code&gt; 注解的方法重写带 &lt;code&gt;@Pattern&lt;/code&gt; 注解方法的情况。
这不会阻止在编辑器中高亮显示错误，但重写方法在运行时将不会被检查。
&lt;p&gt;
提供了快速修复，用于添加与超类方法中注解相匹配的 &lt;code&gt;@Pattern&lt;/code&gt; 注解。 这确保
运行时检查检测正常工作。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  abstract class Parent {
    abstract @Pattern("\\d\\d-\\d\\d\\d") String getId();
  }
  class Child extends Parent {
    @Override String getId() { // 此处为警告
      return "12-345";
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="Java 语言级迁移帮助" path="Java"><inspection shortName="EnumerationCanBeIteration" defaultSeverity="WARNING" displayName="枚举可以是迭代" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对集合使用的可以替换为等效 &lt;code&gt;Iterator&lt;/code&gt; 结构的 &lt;code&gt;Enumeration&lt;/code&gt; 方法的调用。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Enumeration&amp;lt;String&amp;gt; keys = map.keys();
  while (keys.hasMoreElements()) {
    String name = keys.nextElement();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Iterator&amp;lt;String&amp;gt; iterator = map.keySet().iterator();
  while (iterator.hasNext()) {
    String name = iterator.next();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="IfCanBeSwitch" defaultSeverity="WARNING" displayName="'if' 可被替换为 'switch'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以替换为 &lt;code&gt;switch&lt;/code&gt; 语句的 &lt;code&gt;if&lt;/code&gt; 语句。
&lt;p&gt;替换结果通常更简短、更清晰。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void test(String str) {
    if (str.equals("1")) {
      System.out.println(1);
    } else if (str.equals("2")) {
      System.out.println(2);
    } else if (str.equals("3")) {
      System.out.println(3);
    } else {
      System.out.println(4);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void test(String str) {
    switch (str) {
      case "1" -&amp;gt; System.out.println(1);
      case "2" -&amp;gt; System.out.println(2);
      case "3" -&amp;gt; System.out.println(3);
      default -&amp;gt; System.out.println(4);
    }
  }
  &lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;仅当项目或模块的语言级别为 7 或更高时，此检查才会报告。&lt;/p&gt;
&lt;p&gt;使用 &lt;b&gt;'if' 条件分支的最小数量&lt;/b&gt;字段可指定必须报告 &lt;code&gt;if&lt;/code&gt; 语句的最小 &lt;code&gt;if&lt;/code&gt; 条件分支数。 注意，不计入终端 &lt;code&gt;else&lt;/code&gt; 分支（无 &lt;code&gt;if&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;
使用&lt;b&gt;对数字启用 switch 建议&lt;/b&gt;选项，可以对基元和装箱的数字及字符启用 &lt;code&gt;switch&lt;/code&gt; 语句建议。
&lt;p&gt;
使用&lt;b&gt;对枚举启用 switch 建议&lt;/b&gt;选项，可以对 &lt;code&gt;enum&lt;/code&gt; 常量启用 &lt;code&gt;switch&lt;/code&gt; 语句建议。
&lt;p&gt;
  使用&lt;b&gt;仅对 null-safe 表达式启用建议&lt;/b&gt;选项，可仅建议不能引入 &lt;code&gt;NullPointerException&lt;/code&gt; 的 &lt;code&gt;switch&lt;/code&gt; 语句。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UseCompareMethod" defaultSeverity="WARNING" displayName="可以使用 'compare()' 方法比较数值" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可被替换为对 &lt;code&gt;Integer.compare()&lt;/code&gt; 方法或来自 &lt;code&gt;Long&lt;/code&gt;、&lt;code&gt;Short&lt;/code&gt;、&lt;code&gt;Byte&lt;/code&gt;、&lt;code&gt;Double&lt;/code&gt; 或 &lt;code&gt;Float&lt;/code&gt; 类的类似方法（而非更冗长或更低效构造）的调用的表达式。
&lt;p&gt;如果 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 是已装箱整数，则建议使用 &lt;code&gt;x.compareTo(y)&lt;/code&gt;；如果它们是基元，则建议使用 &lt;code&gt;Integer.compare(x, y)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public int compare(int x, int y) {
    return x &gt; y ? 1 : x &amp;lt; y ? -1 : 0;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public int compare(int x, int y) {
    return Integer.compare(x, y);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  请注意，&lt;code&gt;Double.compare&lt;/code&gt; 和 &lt;code&gt;Float.compare&lt;/code&gt; 会略微更改代码语义。 特别是，它们会使 &lt;code&gt;-0.0&lt;/code&gt; 和 &lt;code&gt;0.0&lt;/code&gt; 可以区分（&lt;code&gt;Double.compare(-0.0, 0.0)&lt;/code&gt; 生成 -1）。
  此外，它们会一致地处理 &lt;code&gt;NaN&lt;/code&gt; 值。 在大多数情况下，这种语义更改实际上会改进代码。 如果您的情况无法接受语义更改，请使用复选框禁用此项对浮点数的检查。
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;2017.2 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="声明冗余" path="Java"><inspection shortName="ProtectedMemberInFinalClass" defaultSeverity="WARNING" displayName="'protected' 成员位于 'final' 类中" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;final&lt;/code&gt; 类中的 &lt;code&gt;protected&lt;/code&gt; 成员。
&lt;p&gt;由于无法继承 &lt;code&gt;final&lt;/code&gt; 类，将方法标记为 &lt;code&gt;protected&lt;/code&gt; 可能令人困惑。 最好将此类成员声明为 &lt;code&gt;private&lt;/code&gt; 或软件包可见。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;record Bar(int a, int b) {
  protected int sum() { 
     return a + b;
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;record Bar(int a, int b) {
  int sum() { 
     return a + b;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如本例所示，可以显式或隐式地将类标记为 &lt;code&gt;final&lt;/code&gt;。&lt;/p&gt;

&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="EmptyMethod" defaultSeverity="WARNING" displayName="空方法" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
报告可以移除的空方法。
&lt;p&gt;如果方法本身是空的并且仅被空方法重写或实现，则方法被视为空。 请注意，仅包含注释的方法和带有自己形参的 &lt;code&gt;super()&lt;/code&gt; 调用也被视为空。&lt;/p&gt;
&lt;p&gt;该检查会忽略带有特殊注解的方法，例如 &lt;code&gt;javax.ejb.Init&lt;/code&gt; 和 &lt;code&gt;javax.ejb.Remove&lt;/code&gt; EJB 注释。&lt;/p&gt;
&lt;p&gt;该快速修复会安全地移除不必要的方法。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;配置检查：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;使用&lt;b&gt;注释和 javadoc 计为内容&lt;/b&gt;选项可选择是否应将带有注释的方法视为非空方法。&lt;/li&gt;
  &lt;li&gt;使用&lt;b&gt;额外的特别注解&lt;/b&gt;选项可配置此检查应忽略的其他注解。&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantThrows" defaultSeverity="WARNING" displayName="冗余 'throws' 子句" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
报告在方法签名中声明但方法本身或其实现和重写方法从未抛出的异常。
&lt;p&gt;该检查会忽略与序列化相关的方法，例如方法 &lt;code&gt;readObject()&lt;/code&gt; 和 &lt;code&gt;writeObject()&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void method() throws InterruptedException {
    System.out.println();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该快速修复会移除声明中不必要的异常，并规范化冗余的 &lt;code&gt;try&lt;/code&gt;-&lt;code&gt;catch&lt;/code&gt; 语句：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void method() {
    System.out.println();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  &lt;b&gt;注意&lt;/b&gt;：由于性能原因，在编辑器中高亮显示时可能不会报告某些异常。
  要查看所有结果，请从主菜单中选择&lt;b&gt;代码 | 检查代码&lt;/b&gt;或&lt;b&gt;代码 | 分析代码 | 按名称运行检查&lt;/b&gt;来运行检查。
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;使用&lt;b&gt;忽略由入口点方法抛出的异常&lt;/b&gt;选项可以不报告由 &lt;code&gt;main()&lt;/code&gt; 等方法抛出的异常。
  可以在 &lt;a href="settings://Errors?Unused%20Declaration%20entry%20point"&gt;Java | 声明冗余 | 未使用的声明&lt;/a&gt;检查的设置中配置入口点方法。
  &lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="WeakerAccess" defaultSeverity="WARNING" displayName="声明访问可能较弱" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
报告可能缩小其访问修饰符范围的字段、方法或类。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Sample {
    void foo() {
        bar("foo", "foo");
    }
    void bar(String x, String y) { } // 可以为 private
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Sample {
    void foo() {
        bar("foo", "foo");
    }
    private void bar(String x, String y) { }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;使用检查选项可以定义修饰符更改建议的规则。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="AccessStaticViaInstance" defaultSeverity="WARNING" displayName="通过实例引用访问 static 成员" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告通过类实例而非类本身对 &lt;code&gt;static&lt;/code&gt; 方法和字段的引用。
&lt;p&gt;虽然 Java 语言规范允许使用实例变量引用 static 成员，但读者可能会误认为该方法依赖于实例，从而使代码令人困惑。&lt;/p&gt;
&lt;p&gt;该快速修复会将实例变量替换为类名。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String s1 = s.valueOf(0);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String s = String.valueOf(0);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SameParameterValue" defaultSeverity="WARNING" displayName="方法形参始终是相同的值" enabled="false" language="UAST" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
报告始终具有相同常量值的方法形参。

&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  static void printPoint(int x, int y) { // x 始终为 0
    System.out.println(x + ", " + y);
  }

  public static void main(String[] args) {
    printPoint(0, 1);
    printPoint(0, 2);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该快速修复会内联常量值。 这可能会简化方法实现。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  在以下情况下，使用&lt;b&gt;内联形参初始值设定项不成功时忽略&lt;/b&gt;选项来禁止检查：
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;形参在方法内部被修改。&lt;/li&gt;
  &lt;li&gt;传递的形参值引用了不可访问的字段（仅在 Java 中）。&lt;/li&gt;
  &lt;li&gt;形参为 vararg（仅在 Java 中）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
  使用&lt;b&gt;报告方法最大可见性&lt;/b&gt;选项可以控制要报告的方法的最大可见性。
&lt;/p&gt;
&lt;p&gt;
  使用&lt;b&gt;报告方法最小使用计数&lt;/b&gt;字段可以指定具有相同形参值的最小方法使用数。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="UnusedReturnValue" defaultSeverity="WARNING" displayName="方法可以为 'void'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
报告调用时从不使用其返回值的方法。
此类方法的返回类型可以设置为 &lt;code&gt;void&lt;/code&gt;。
&lt;p&gt;不会报告使用 Error Prone 或 AssertJ 的 &lt;code&gt;@CanIgnoreReturnValue&lt;/code&gt; 注解进行注解的方法。
  该快速修复会更新方法签名，并移除方法中的 &lt;code&gt;return&lt;/code&gt; 语句。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  // 可见性设置为 Protected 或 Public 时报告
  protected String myToUpperCase(String s) {
    return s.toUpperCase();
  }

  // 简单的 setter，根据设置进行报告
  public String setStr(String str) {
    myStr = str;
    return myStr;
  }

  void test() {
    setStr("value");          // 未使用返回值
    myToUpperCase("result");  // 未使用返回值
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对这两种方法应用该快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    protected void myToUpperCase(String s) {
      // 完全移除了 'return'
      // 因为 's.toUpperCase()' 没有任何副作用
    }

    public void setStr(String str) {
      myStr = str;
      // 移除了 'return'
    }
  ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  &lt;b&gt;注意&lt;/b&gt;：由于性能原因，在编辑器中高亮显示时可能不会报告某些方法。
  要查看所有结果，请通过&lt;b&gt;代码 | 检查代码&lt;/b&gt;或&lt;b&gt;代码 | 分析代码 | 按名称运行检查&lt;/b&gt;来运行检查&gt;
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;使用&lt;b&gt;忽略简单的 setter&lt;/b&gt; 选项可以忽略简单 setter 调用中未使用的返回值。&lt;/p&gt;
&lt;p&gt;使用&lt;b&gt;报告方法最大可见性&lt;/b&gt;选项可以控制要报告的方法的最大可见性。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SameReturnValue" defaultSeverity="WARNING" displayName="方法始终返回相同的值" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
报告始终返回相同常量的方法和方法层次结构。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class X {
    int xxx() {
      return 0;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="CanBeFinal" defaultSeverity="WARNING" displayName="声明可以有 'final' 修饰符" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
报告可能在其声明中添加了 &lt;code&gt;final&lt;/code&gt; 修饰符的字段、方法或类。
&lt;p&gt;final 类不能被扩展，final 方法不能被重写，final 字段不能被重新分配。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Person {
    private String name;

    Person(String name) {
      this.name = name;
    }

    public String getName() {
      return name;
    }

    public String toString() {
      return getName();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public final class Person {
    private final String name;

    Person(String name) {
      this.name = name;
    }

    public final String getName() {
      return name;
    }

    public final String toString() {
      return getName();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;使用&lt;b&gt;报告类&lt;/b&gt;和&lt;b&gt;报告方法&lt;/b&gt;选项可定义要报告的声明。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="UnusedLibrary" defaultSeverity="WARNING" displayName="未使用的库" enabled="false" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
报告附加到指定检查范围但未直接在代码中使用的库。
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="unused" defaultSeverity="WARNING" displayName="未使用的声明" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
报告未使用或无法从入口点访问的类、方法或字段。
&lt;p&gt; 入口点可以是 main 方法、测试、来自指定范围之外的类、可从 &lt;code&gt;module-info.java&lt;/code&gt; 访问的类，等等。 可以通过使用名称模式或注解来配置自定义入口点。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Department {
    private Organization myOrganization;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在本例中，&lt;code&gt;Department&lt;/code&gt; 显式引用 &lt;code&gt;Organization&lt;/code&gt;，但如果 &lt;code&gt;Department&lt;/code&gt; 类本身未使用，那么该检查将报告这两个类。 &lt;/p&gt;
&lt;p&gt;
  该检查还会报告其方法、所有方法实现和重写器未使用的形参，以及已声明但未使用的局部变量。
&lt;/p&gt;
&lt;p&gt;
  &lt;b&gt;注意&lt;/b&gt;：在编辑器中高亮显示代码期间可能不会报告某些未使用的成员。 由于性能原因，仅当非 private 成员的名称很少出现在项目中时，才会对其进行检查。
  要查看所有结果，请从主菜单中选择&lt;b&gt;代码 | 检查代码&lt;/b&gt;或&lt;b&gt;代码 | 分析代码 | 按名称运行检查&lt;/b&gt;来运行检查。
&lt;/p&gt;

&lt;!-- tooltip end --&gt;
&lt;p&gt;使用下面的可见性设置可以配置要报告的成员。 例如，配置报告 &lt;code&gt;private&lt;/code&gt; 方法只表明将报告 &lt;code&gt;private&lt;/code&gt; 内部类的 &lt;code&gt;public&lt;/code&gt; 方法，顶层类的 &lt;code&gt;protected&lt;/code&gt; 方法将被忽略。&lt;/p&gt;
&lt;p&gt;
  使用&lt;b&gt;入口点&lt;/b&gt;选项卡可以配置检查运行期间要考虑的入口点。&lt;/p&gt;
&lt;p&gt; 在检查结果准备就绪后，可以手动添加入口点。&lt;/p&gt;
&lt;p&gt; 如果您的代码使用不受支持的框架，可以选择以下几个选项：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;如果框架依赖于注解，使用&lt;b&gt;注解…&lt;/b&gt;按钮可配置框架注解。&lt;/li&gt;
  &lt;li&gt;如果框架不依赖于注解，可尝试配置框架应有的类名模式。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这样，框架内部项可访问的注解代码将被视为已使用。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnusedLabel" defaultSeverity="WARNING" displayName="未使用的标签" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告不是任何 &lt;code&gt;break&lt;/code&gt; 或 &lt;code&gt;continue&lt;/code&gt; 语句目标的标签。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  label: &lt;b&gt;for&lt;/b&gt; (int i = 0; i &amp;lt; 10; i++) {
    &lt;b&gt;if&lt;/b&gt; (i == 3) {
      &lt;b&gt;break&lt;/b&gt;;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;应用快速修复后，该标签将被移除：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;for&lt;/b&gt; (int i = 0; i &amp;lt; 10; i++) {
    &lt;b&gt;if&lt;/b&gt; (i == 3) {
      &lt;b&gt;break&lt;/b&gt;;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FinalMethodInFinalClass" defaultSeverity="WARNING" displayName="'final' 类位于 'final' 方法中" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;final&lt;/code&gt; 类中的 &lt;code&gt;final&lt;/code&gt; 方法。
&lt;p&gt;由于不能继承 &lt;code&gt;final&lt;/code&gt; 类，将方法标记为 &lt;code&gt;final&lt;/code&gt; 可能是多余之举，而且令人困惑。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;record Bar(int a, int b) {
  public final int sum() { 
     return a + b;
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;record Bar(int a, int b) {
  public int sum() { 
     return a + b;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如本例所示，可以显式或隐式地将类标记为 &lt;code&gt;final&lt;/code&gt;。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SillyAssignment" defaultSeverity="WARNING" displayName="变量被赋值给自己" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告变量对自身的赋值。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  a = a;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该快速修复会移除赋值。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryModuleDependencyInspection" defaultSeverity="WARNING" displayName="不必要的模块依赖" enabled="false" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
报告对未使用的模块的依赖。 该快速修复可以安全移除这些未使用的依赖项。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FunctionalExpressionCanBeFolded" defaultSeverity="WARNING" displayName="函数表达式可以折叠" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告指向具有自己的函数接口类型的方法的方法引用或 lambda 表达式，因此您可以通过替换为它们的限定符来移除不必要的对象分配。

&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  SwingUtilities.invokeLater(r::run);
  SwingUtilities.invokeAndWait(() -&gt; r.run());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  SwingUtilities.invokeLater(r);
  SwingUtilities.invokeAndWait(r);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;仅当项目或模块的语言级别为 8 或更高时，此检查才会报告。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DuplicateThrows" defaultSeverity="WARNING" displayName="重复抛出" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告方法 &lt;code&gt;throws&lt;/code&gt; 列表中的重复异常。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void f() throws Exception, Exception {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void f() throws Exception {}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用&lt;b&gt;忽略子类化其他异常的异常&lt;/b&gt;选项可以忽略子类化其他异常的异常。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RedundantLambdaParameterType" defaultSeverity="INFORMATION" displayName="冗余 lambda 形参类型" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告由于可以从上下文中推断而冗余的 lambda 形参类型。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Map&amp;lt;String, Integer&amp;gt; map = ...
  map.forEach((String s, Integer i) -&gt; log.info(s + "=" + i));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该快速修复会从 lambda 中移除这些形参类型。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Map&amp;lt;String, Integer&amp;gt; map = ...
  map.forEach((s, i) -&gt; log.info(s + "=" + i));
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantRecordConstructor" defaultSeverity="WARNING" displayName="冗余记录构造函数" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在 Java 记录中声明的冗余构造函数。
&lt;p&gt;&lt;b&gt;示例 1：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  record Point(int x, int y) {
    public Point {} // 可以移除
  }
  
  record Point(int x, int y) {
    public Point(int x, int y) { // 可以移除
      this.x = x;
      this.y = y;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该快速修复会移除冗余的构造函数。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例 2：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
   // 可以转换为压缩构造函数
  record Range(int from, int to) {
    public Range(int from, int to) {
      if (from &gt; to) throw new IllegalArgumentException();
      this.from = from;
      this.to = to;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该快速修复会将此代码转换为紧凑构造函数。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;仅当项目或模块的语言级别为 16 或更高时，此检查才会报告。&lt;/p&gt;
&lt;p&gt;&lt;small&gt;2020.1 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DefaultAnnotationParam" defaultSeverity="WARNING" displayName="默认注解形参值" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告被赋值给其 &lt;code&gt;default&lt;/code&gt; 值的注解形参。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @interface Test {
      Class&amp;lt;?&gt; expected() default Throwable.class;
  }

  @Test(expected = Throwable.class)
  void testSmth() {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Test()
  void testSmth() {}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantImplements" defaultSeverity="WARNING" displayName="冗余接口声明" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
当接口已被超类声明为 &lt;code&gt;implemented&lt;/code&gt; 或由该类的另一个接口扩展时，报告声明它们实现或扩展接口的类。 此类声明不必要，并且可以安全移除。
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="Java9RedundantRequiresStatement" defaultSeverity="WARNING" displayName="module-info 中的冗余 'requires' 指令" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
报告 Java Platform Module System &lt;code&gt;module-info.java&lt;/code&gt; 文件中的冗余 &lt;code&gt;requires&lt;/code&gt; 指令。
当模块 &lt;code&gt;A&lt;/code&gt; 需要模块 &lt;code&gt;B&lt;/code&gt;，但模块 &lt;code&gt;A&lt;/code&gt; 中的代码不从 &lt;code&gt;B&lt;/code&gt; 导入任何软件包或类时，则 &lt;code&gt;requires&lt;/code&gt; 指令冗余。
此外，所有模块都具有对 &lt;code&gt;java.base&lt;/code&gt; 模块的隐式声明依赖，因此 &lt;code&gt;requires java.base;&lt;/code&gt; 指令始终冗余。
&lt;p&gt;
  该快速修复会删除冗余的 &lt;code&gt;requires&lt;/code&gt; 指令。
  如果删除的依赖项重新导出了实际使用的模块，则修复会为这些模块添加 &lt;code&gt;requires&lt;/code&gt; 指令。
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;仅当项目或模块的语言级别为 9 或更高时，此检查才会报告。&lt;/p&gt;
&lt;p&gt;&lt;small&gt;2017.1 最新变化&lt;/small&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TrivialFunctionalExpressionUsage" defaultSeverity="WARNING" displayName="函数表达式的普通用法" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在 lambda、方法引用或匿名类的定义中直接调用的函数接口方法调用。
此类方法调用可以替换为函数接口实现体。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean contains(List&amp;lt;String&amp;gt; names, String name) {
    return ((Predicate&amp;lt;String&amp;gt;)x -&gt; {
      return names.contains(x);
    }).test(name);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;应用快速修复后，方法调用变为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean contains(List&amp;lt;String&amp;gt; names, String name) {
    return names.contains(name);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantExplicitClose" defaultSeverity="WARNING" displayName="冗余 'close()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在 try-with-resources 块的末尾对 &lt;code&gt;close()&lt;/code&gt; 的不必要调用，并建议移除它们。
&lt;p&gt;&lt;b&gt;示例&lt;/b&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  try(MyAutoCloseable ac = new MyAutoCloseable()) {
    foo();
    ac.close();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  try(MyAutoCloseable ac = new MyAutoCloseable()) {
    foo();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2018.1 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="EmptyInitializer" defaultSeverity="WARNING" displayName="空类初始值设定项" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告空类初始值设定项块。
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="EditorConfig" path=""><inspection shortName="EditorConfigMissingRequiredDeclaration" defaultSeverity="ERROR" displayName="缺少必需声明" enabled="false" language="EditorConfig" pluginId="org.editorconfig.editorconfigjetbrains" pluginVersion="223.8836.41" isGlobalTool="false">&lt;!-- Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file. --&gt;
&lt;html&gt;
&lt;body&gt;
报告缺少所需声明的属性。 有关更多信息，请参阅文档。
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="EditorConfigHeaderUniqueness" defaultSeverity="WARNING" displayName="EditorConfig 部分不唯一" enabled="false" language="EditorConfig" pluginId="org.editorconfig.editorconfigjetbrains" pluginVersion="223.8836.41" isGlobalTool="false">&lt;!-- Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file. --&gt;
&lt;html&gt;
&lt;body&gt;
报告定义与其他部分相同的文件模式的部分。
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="EditorConfigRootDeclarationCorrectness" defaultSeverity="ERROR" displayName="意外的顶层声明" enabled="false" language="EditorConfig" pluginId="org.editorconfig.editorconfigjetbrains" pluginVersion="223.8836.41" isGlobalTool="false">&lt;!-- Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file. --&gt;
&lt;html&gt;
&lt;body&gt;
报告非预期的顶层声明。 EditorConfig 文件中不允许使用除 “root=true” 之外的顶级声明。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="EditorConfigListAcceptability" defaultSeverity="ERROR" displayName="意外的值列表" enabled="false" language="EditorConfig" pluginId="org.editorconfig.editorconfigjetbrains" pluginVersion="223.8836.41" isGlobalTool="false">&lt;!-- Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file. --&gt;
&lt;html&gt;
&lt;body&gt;
报告在不支持列表的属性中使用的值列表。 在这种情况下，只能指定一个值。
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="EditorConfigReferenceCorrectness" defaultSeverity="ERROR" displayName="无效引用" enabled="false" language="EditorConfig" pluginId="org.editorconfig.editorconfigjetbrains" pluginVersion="223.8836.41" isGlobalTool="false">&lt;!-- Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file. --&gt;
&lt;html&gt;
&lt;body&gt;
报告未知或类型错误的标识符。
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="EditorConfigShadowingOption" defaultSeverity="WARNING" displayName="重写属性" enabled="false" language="EditorConfig" pluginId="org.editorconfig.editorconfigjetbrains" pluginVersion="223.8836.41" isGlobalTool="false">&lt;!-- Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file. --&gt;
&lt;html&gt;
&lt;body&gt;
报告覆盖文件中先前定义的相同属性的属性。
&lt;p&gt;示例：
&lt;pre&gt;&lt;code&gt;
[*.java]
indent_size=4
[{*.java,*.js}]
indent_size=2
&lt;/code&gt;&lt;/pre&gt;
第二部分同样包含 &lt;code&gt;[*.java]&lt;/code&gt; 文件，但还将 indent_size 设置为值 2。
因此第一个声明 &lt;code&gt;indent_size=4&lt;/code&gt; 将被忽略。
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="EditorConfigWildcardRedundancy" defaultSeverity="WARNING" displayName="冗余通配符" enabled="false" language="EditorConfig" pluginId="org.editorconfig.editorconfigjetbrains" pluginVersion="223.8836.41" isGlobalTool="false">&lt;!-- Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file. --&gt;
&lt;html&gt;
&lt;body&gt;
报告在同一部分中使用 “**” 通配符时变得冗余的通配符。
&lt;p&gt;
“**” 通配符定义了比其他通配符更广泛的文件集。
因此，同一部分中使用的任何其他通配符都是无效的，可以删除。
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="EditorConfigEncoding" defaultSeverity="WARNING" displayName="文件编码与 EditorConfig 字符集不匹配" enabled="false" pluginId="org.editorconfig.editorconfigjetbrains" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
检查当前文件编码是否与 .editorconfig 文件 "charset" 属性中定义的编码匹配。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="EditorConfigPatternEnumerationRedundancy" defaultSeverity="ERROR" displayName="不必要的大括号" enabled="false" language="EditorConfig" pluginId="org.editorconfig.editorconfigjetbrains" pluginVersion="223.8836.41" isGlobalTool="false">&lt;!-- Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file. --&gt;
&lt;html&gt;
&lt;body&gt;
报告空 &lt;code&gt;{}&lt;/code&gt; 或仅包含一种模式的模式列表，例如 &lt;code&gt;{foo}&lt;/code&gt;。
只有在有两个或多个模式时才需要大括号，例如 &lt;code&gt;{foo,bar}&lt;/code&gt;。
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="EditorConfigValueCorrectness" defaultSeverity="ERROR" displayName="无效属性值" enabled="false" language="EditorConfig" pluginId="org.editorconfig.editorconfigjetbrains" pluginVersion="223.8836.41" isGlobalTool="false">&lt;!-- Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file. --&gt;
&lt;html&gt;
&lt;body&gt;
报告不符合值限制的属性值。 例如，某些属性可能只能为 “true” 或 “false”、其他属性仅包含整数等。 如果一个值的变体集合有限，请使用代码完成来查看所有变体。
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="EditorConfigPatternRedundancy" defaultSeverity="WARNING" displayName="重复或冗余模式" enabled="false" language="EditorConfig" pluginId="org.editorconfig.editorconfigjetbrains" pluginVersion="223.8836.41" isGlobalTool="false">&lt;!-- Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file. --&gt;
&lt;html&gt;
&lt;body&gt;
报告已经有另一个模式定义了具有相同或更广泛文件范围的冗余的文件模式。
例如，在 &lt;code&gt;[{*.java,*}]&lt;/code&gt; 中，第一个 &lt;code&gt;*.java&lt;/code&gt; 模式定义了比 &lt;code&gt;*&lt;/code&gt; 更窄的范围。
这使得第一个模式变得多余并且可以被移除。
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="EditorConfigKeyCorrectness" defaultSeverity="WARNING" displayName="未知属性" enabled="false" language="EditorConfig" pluginId="org.editorconfig.editorconfigjetbrains" pluginVersion="223.8836.41" isGlobalTool="false">&lt;!-- Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file. --&gt;
&lt;html&gt;
&lt;body&gt;
报告 IDE 不支持的属性。 注意：一些 “ij” 域属性可能需要特定的语言插件。
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="EditorConfigOptionRedundancy" defaultSeverity="WARNING" displayName="冗余属性" enabled="false" language="EditorConfig" pluginId="org.editorconfig.editorconfigjetbrains" pluginVersion="223.8836.41" isGlobalTool="false">&lt;!-- Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file. --&gt;
&lt;html&gt;
&lt;body&gt;
报告另一个适用的部分已经包含相同的属性和值的冗余的属性。
&lt;p&gt;
示例：
&lt;pre&gt;&lt;code&gt;
[*]
indent_size=4
[*.java]
indent_size=4
&lt;/code&gt;&lt;/pre&gt;
都适用于 &lt;code&gt;*.java&lt;/code&gt; 文件并定义相同的 &lt;code&gt;indent_size&lt;/code&gt; 值。
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="EditorConfigCharClassRedundancy" defaultSeverity="WARNING" displayName="不必要的字符类" enabled="false" language="EditorConfig" pluginId="org.editorconfig.editorconfigjetbrains" pluginVersion="223.8836.41" isGlobalTool="false">&lt;!-- Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file. --&gt;
&lt;html&gt;
&lt;body&gt;
报告由单个字符组成的字符类。
这种类可以简化为一个字符，例如 &lt;code&gt;[a]&lt;/code&gt;&amp;rarr;&lt;code&gt;a&lt;/code&gt;。
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="EditorConfigUnusedDeclaration" defaultSeverity="WARNING" displayName="未使用的声明" enabled="false" language="EditorConfig" pluginId="org.editorconfig.editorconfigjetbrains" pluginVersion="223.8836.41" isGlobalTool="false">&lt;!-- Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file. --&gt;
&lt;html&gt;
&lt;body&gt;
报告未使用的声明。 可以删除此类声明。
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="EditorConfigDeprecatedDescriptor" defaultSeverity="WARNING" displayName="弃用的属性" enabled="false" language="EditorConfig" pluginId="org.editorconfig.editorconfigjetbrains" pluginVersion="223.8836.41" isGlobalTool="false">&lt;!-- Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file. --&gt;
&lt;html&gt;
&lt;body&gt;
报告不再支持的 EditorConfig 属性。
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="EditorConfigSpaceInHeader" defaultSeverity="WEAK WARNING" displayName="文件模式中的空格" enabled="false" language="EditorConfig" pluginId="org.editorconfig.editorconfigjetbrains" pluginVersion="223.8836.41" isGlobalTool="false">&lt;!-- Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file. --&gt;
&lt;html&gt;
&lt;body&gt;
报告影响模式匹配的通配符模式中的空格字符。
如果这些字符不是故意的，则应将其删除。
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="EditorConfigRootDeclarationUniqueness" defaultSeverity="ERROR" displayName="额外顶层声明" enabled="false" language="EditorConfig" pluginId="org.editorconfig.editorconfigjetbrains" pluginVersion="223.8836.41" isGlobalTool="false">&lt;!-- Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file. --&gt;
&lt;html&gt;
&lt;body&gt;
报告多个顶层声明。 EditorConfig 文件中只能有一个可选的 “root=true” 顶级声明。
不允许使用多个顶级声明。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="EditorConfigEmptySection" defaultSeverity="WARNING" displayName="空部分" enabled="false" language="EditorConfig" pluginId="org.editorconfig.editorconfigjetbrains" pluginVersion="223.8836.41" isGlobalTool="false">&lt;!-- Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file. --&gt;
&lt;html&gt;
&lt;body&gt;
报告不包含任何 EditorConfig 属性的部分。
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="EditorConfigEmptyHeader" defaultSeverity="ERROR" displayName="空标头" enabled="false" language="EditorConfig" pluginId="org.editorconfig.editorconfigjetbrains" pluginVersion="223.8836.41" isGlobalTool="false">&lt;!-- Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file. --&gt;
&lt;html&gt;
&lt;body&gt;
报告带有空标题的部分。 部分标题必须包含格式类似于 &lt;code&gt;gitignore&lt;/code&gt; 支持的格式的文件路径 glob。
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="EditorConfigValueUniqueness" defaultSeverity="ERROR" displayName="非唯一列表值" enabled="false" language="EditorConfig" pluginId="org.editorconfig.editorconfigjetbrains" pluginVersion="223.8836.41" isGlobalTool="false">&lt;!-- Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file. --&gt;
&lt;html&gt;
&lt;body&gt;
报告值列表中的重复项。
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="EditorConfigPairAcceptability" defaultSeverity="ERROR" displayName="意外的键值对" enabled="false" language="EditorConfig" pluginId="org.editorconfig.editorconfigjetbrains" pluginVersion="223.8836.41" isGlobalTool="false">&lt;!-- Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file. --&gt;
&lt;html&gt;
&lt;body&gt;
报告当前上下文中不允许的键值对。
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="EditorConfigNumerousWildcards" defaultSeverity="WEAK WARNING" displayName="过多通配符" enabled="false" language="EditorConfig" pluginId="org.editorconfig.editorconfigjetbrains" pluginVersion="223.8836.41" isGlobalTool="false">&lt;!-- Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file. --&gt;
&lt;html&gt;
&lt;body&gt;
报告包含过多通配符的部分。 使用大量通配符可能会导致性能问题。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="EditorConfigShadowedOption" defaultSeverity="WARNING" displayName="被重写的属性" enabled="false" language="EditorConfig" pluginId="org.editorconfig.editorconfigjetbrains" pluginVersion="223.8836.41" isGlobalTool="false">&lt;!-- Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file. --&gt;
&lt;html&gt;
&lt;body&gt;
报告已在其他部分中定义的属性。
&lt;p&gt;示例：
&lt;pre&gt;&lt;code&gt;
[*.java]
indent_size=4
[{*.java,*.js}]
indent_size=2
&lt;/code&gt;&lt;/pre&gt;
第二部分也包括所有 &lt;code&gt;*.java&lt;/code&gt; 文件，但它也重新定义了 indent_size。
因此，值 "2" 将用于匹配 &lt;code&gt;*.java&lt;/code&gt; 的文件。
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="EditorConfigCharClassLetterRedundancy" defaultSeverity="WARNING" displayName="重复的字符类字母" enabled="false" language="EditorConfig" pluginId="org.editorconfig.editorconfigjetbrains" pluginVersion="223.8836.41" isGlobalTool="false">&lt;!-- Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file. --&gt;
&lt;html&gt;
&lt;body&gt;
报告 EditorConfig 部分中在字符类中包含重复字符的通配符模式，例如 &lt;code&gt;[aa]&lt;/code&gt;。
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="EditorConfigNoMatchingFiles" defaultSeverity="WARNING" displayName="无匹配文件" enabled="false" language="EditorConfig" pluginId="org.editorconfig.editorconfigjetbrains" pluginVersion="223.8836.41" isGlobalTool="false">&lt;!-- Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file. --&gt;
&lt;html&gt;
&lt;body&gt;
报告通配符模式与 &lt;code&gt;.editorconfig&lt;/code&gt; 文件所在目录下的任何文件都不匹配的部分。
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="EditorConfigPartialOverride" defaultSeverity="WEAK WARNING" displayName="重叠的部分" enabled="false" language="EditorConfig" pluginId="org.editorconfig.editorconfigjetbrains" pluginVersion="223.8836.41" isGlobalTool="false">&lt;!-- Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file. --&gt;
&lt;html&gt;
&lt;body&gt;
报告当前部分中指定的文件子集与其他部分中的其他子集重叠。 例如：&lt;code&gt;[{foo,bar}]&lt;/code&gt; 和 &lt;code&gt;[{foo,bas}]&lt;/code&gt; 都包含 “foo”。
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="EditorConfigUnexpectedComma" defaultSeverity="ERROR" displayName="意外逗号" enabled="false" language="EditorConfig" pluginId="org.editorconfig.editorconfigjetbrains" pluginVersion="223.8836.41" isGlobalTool="false">&lt;!-- Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file. --&gt;
&lt;html&gt;
&lt;body&gt;
报告不能在当前上下文中使用的逗号。 逗号只能用作分隔符来分隔列表中的值。
&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="属性文件" path="Scala"><inspection shortName="ScalaUnresolvedPropertyKey" defaultSeverity="ERROR" displayName="无效属性健" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告未解析或错误使用的 &lt;b&gt;I18n&lt;/b&gt; 属性键。&lt;/p&gt;
&lt;p&gt;关联的 &lt;b&gt;I18n 捆绑包&lt;/b&gt; 中不存在的属性键将导致运行时错误。
    这同样适用于带实参的属性，这些实参不是由代码提供的。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Spring Security" path="Spring"><inspection shortName="SpringSecurityModelInspection" defaultSeverity="ERROR" displayName="不正确的 Spring Security 基于 XML 的应用程序上下文" enabled="false" language="XML" pluginId="com.intellij.spring.security" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 &lt;a href="https://spring.io/projects/spring-security"&gt;Spring Security&lt;/a&gt; 基于 XML 的上下文的问题：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;未解析的 Bean 引用&lt;/li&gt;
  &lt;li&gt;缺少必需的标记或特性&lt;/li&gt;
  &lt;li&gt;属性类型不正确&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;enum&lt;/code&gt; 属性不一致&lt;/li&gt;
  &lt;li&gt;引用 Bean 的类型不正确&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;也报告以下问题：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&amp;lt;https&amp;gt; 配置错误
    &lt;ul&gt;
      &lt;li&gt;带 '/**' 模式的 &amp;lt;http&amp;gt; 必须位于最后&lt;/li&gt;
      &lt;li&gt;不允许使用多个无 'pattern' 的 &amp;lt;http&amp;gt; 元素&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&amp;lt;http&amp;gt; 配置错误
    &lt;ul&gt;
      &lt;li&gt;如果 &lt;code&gt;security='none'&lt;/code&gt;，则为空标记&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&amp;lt;user-service&amp;gt;
    &lt;ul&gt;
      &lt;li&gt;必须具有特性 'properties' 或 &amp;lt;user&amp;gt; 元素列表&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&amp;lt;ldap-server&amp;gt;
    &lt;ul&gt;
      &lt;li&gt;使用 'manager-dn' 时需要 'manager-password'&lt;/li&gt;
      &lt;li&gt;必须具有 'user-context-mapper-ref' 或 'user-details-class'&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt; &amp;lt;authentication-provider&amp;gt;
    &lt;ul&gt;
      &lt;li&gt;仅允许使用一种用户服务&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&amp;lt;global-method-security&amp;gt;
    &lt;ul&gt;
      &lt;li&gt;'pre-post-annotations' 的值必须为 'enabled' 才能使用 &amp;lt;pre-post-annotation-handling&amp;gt;&lt;/li&gt;
      &lt;li&gt;无法为 &amp;lt;protect-pointcut&amp;gt; 和 &amp;lt;intercept-url&amp;gt; 使用值为 'aspectj' 的 'mode'&lt;/li&gt;
      &lt;li&gt;仅对父 &amp;lt;http&amp;gt; 允许 'requires-channel' 特性&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&amp;lt;protect&amp;gt;
    &lt;ul&gt;
      &lt;li&gt;不建议将 &amp;lt;protect&amp;gt; 与 &amp;lt;global-method-security&amp;gt; 混用&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SpringSecurityDebugActivatedInspection" defaultSeverity="WARNING" displayName="Spring Security 配置中激活了调试模式" enabled="false" language="XML" pluginId="com.intellij.spring.security" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告可能会公开敏感信息的激活的 &lt;strong&gt;&amp;lt;debug&amp;gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SpringSecurityAnnotationBeanPointersResolveInspection" defaultSeverity="ERROR" displayName="Spring Security 注解中引用的 Spring Bean 配置不正确" enabled="false" language="JAVA" pluginId="com.intellij.spring.security" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 &lt;a href="https://spring.io/projects/spring-security"&gt;Spring Security&lt;/a&gt; 注解中引用的未解析 Spring Bean。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;pre&gt;&lt;code&gt;@WithUserDetails(value = "admin", userDetailsServiceBeanName = "unknownUserDetailsService")
      // 如果 Spring 模型中没有定义 'unknownUserDetailsService'，将报告 "无法解析 'unknownUserDetailsService' Bean"
    &lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;pre&gt;&lt;code&gt;@WithUserDetails(value = "admin", userDetailsServiceBeanName = "jpaUserDetailsService")
      //"Bean 必须为 'org.springframework.security.core.userdetails.UserDetailsService' 类型"
      // 如果 "jpaUserDetailsService" Bean 不是 'UserDetailsService' 类型，将报告
    &lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="安全性" path=""><inspection shortName="HttpUrlsUsage" defaultSeverity="WEAK WARNING" displayName="采用未加密协议的链接" enabled="false" pluginId="com.jetbrains.restClient" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告使用未加密协议（如 HTTP）的链接，这些链接可能会使您的数据暴露在中间人的攻击之下。 这些攻击一般是危险的，对工件存储库可能特别有害。 使用加密协议取而代之，例如 HTTPS。&lt;/p&gt;
&lt;p&gt;请参阅 &lt;a href="https://en.wikipedia.org/wiki/HTTPS#Difference_from_HTTP"&gt;HTTPS: 与 HTTP 的区别(wikipedia.org) &lt;/a&gt;。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="TOML" path=""><inspection shortName="TomlUnresolvedReference" defaultSeverity="WARNING" displayName="未解析的引用" enabled="false" language="TOML" pluginId="org.toml.lang" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 TOML 文件中未解析的引用。
&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="序列化问题" path="Java"><inspection shortName="NonSerializableWithSerializationMethods" defaultSeverity="WARNING" displayName="具有 'readObject()' 或 'writeObject()' 的不可序列化类" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告定义 &lt;code&gt;readObject()&lt;/code&gt; 或 &lt;code&gt;writeObject()&lt;/code&gt; 方法的非 &lt;code&gt;Serializable&lt;/code&gt; 类。 该上下文中的此类方法通常表明有错误。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class SampleClass {
    private void readObject(ObjectInputStream str) {}
    private void writeObject(ObjectOutputStream str) {}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TransientFieldInNonSerializableClass" defaultSeverity="WARNING" displayName="不可序列化类中存在 transient 字段" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告未实现 &lt;code&gt;java.io.Serializable&lt;/code&gt; 的类中的 &lt;code&gt;transient&lt;/code&gt; 字段。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class NonSerializableClass {
    private transient String password;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class NonSerializableClass {
    private String password;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NonSerializableFieldInSerializableClass" defaultSeverity="WARNING" displayName="'Serializable' 类中有不可序列化的字段" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告实现 &lt;code&gt;java.io.Serializable&lt;/code&gt; 的类中的不可序列化字段。 如果对象被序列化，此类字段将导致运行时异常。
&lt;p&gt;
  不报告被声明为 &lt;code&gt;transient&lt;/code&gt; 或 &lt;code&gt;static&lt;/code&gt; 的字段，也不报告定义了 &lt;code&gt;writeObject&lt;/code&gt; 方法的类的字段。
&lt;/p&gt;
&lt;p&gt;
  此检查假定 &lt;code&gt;java.util.Collection&lt;/code&gt; 和 &lt;code&gt;java.util.Map&lt;/code&gt; 类型的字段为 &lt;code&gt;Serializable&lt;/code&gt;，除非声明它们的类型为非 &lt;code&gt;Serializable&lt;/code&gt;。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class NonSerializableClass {}

  public class SerializableClass implements Serializable {
      NonSerializableClass clazz; // //警告：可序列化类中存在不可序列化字段 'clazz'
      static NonSerializableClass staticClazz; // 无警告
  }
  &lt;/code&gt;
&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用以下选项配置检查：
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    列出此检查不应报告其继承者的类。
    这适用于从超类继承 &lt;code&gt;Serializable&lt;/code&gt; 但不用于序列化的类。
  &lt;/li&gt;
  &lt;li&gt;
    列出会使检查忽略注解字段的注解。
  &lt;/li&gt;
  &lt;li&gt;
    是否忽略使用匿名类初始化的字段。
  &lt;/li&gt;
&lt;/ul&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MissingSerialAnnotation" defaultSeverity="WARNING" displayName="可以使用 '@Serial' 注解" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;Serializable&lt;/code&gt; 和 &lt;code&gt;Externalizable&lt;/code&gt; 类中适合使用 &lt;code&gt;java.io.Serial&lt;/code&gt; 注解进行注解的方法和字段。 该快速修复会添加注解。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
class Main implements Serializable {
  private static final long serialVersionUID = 7874493593505141603L;

  private void writeObject(ObjectOutputStream out) throws IOException {
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Main implements Serializable {
    @Serial
    private static final long serialVersionUID = 7874493593505141603L;

    @Serial
    private void writeObject(ObjectOutputStream out) throws IOException {
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Main implements Externalizable {
    protected Object readResolve() throws ObjectStreamException {
      return "SomeObject";
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Main implements Externalizable {
    @Serial
    protected Object readResolve() throws ObjectStreamException {
        return "SomeObject";
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有关所有可能情况的更多信息，请参阅 &lt;code&gt;java.io.Serial&lt;/code&gt; 的文档。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;仅当项目或模块的语言级别为 14 或更高时，此检查才会报告。&lt;/p&gt;
&lt;p&gt;&lt;small&gt;2020.3 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReadObjectInitialization" defaultSeverity="WARNING" displayName="实例字段可能无法被 'readObject()' 初始化" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在 &lt;code&gt;readObject()&lt;/code&gt; 方法反序列化对象后不保证被初始化的字段。
&lt;p&gt;该检查不报告 transient 字段。&lt;/p&gt;
&lt;p&gt;
  注意：此检查使用非常保守的控制流算法，可能会将字段误报告为未初始化。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
class DataObject implements Serializable {
  String s; // s 在 readObject 中未初始化
  int i;

  private void readObject(ObjectInputStream stream) throws IOException {
    i = stream.readInt();
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SerializableInnerClassWithNonSerializableOuterClass" defaultSeverity="WARNING" displayName="可序列化非 'static' 内部类具有不可序列化外部类" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告实现 &lt;code&gt;Serializable&lt;/code&gt; 并在未实现 &lt;code&gt;Serializable&lt;/code&gt; 的类中声明的非 static 内部类。
&lt;p&gt;
  由于对外部类的隐式引用，这种类不太可能正确序列化。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class A {
      class Main implements Serializable {
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;使用以下选项配置检查：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    列出此检查不应报告其继承者的类。
    这适用于从超类继承 &lt;code&gt;Serializable&lt;/code&gt; 但不用于序列化的类。
  &lt;/li&gt;
  &lt;li&gt;
    是否忽略 &lt;code&gt;Serializable&lt;/code&gt; 匿名类。
  &lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ExternalizableWithoutPublicNoArgConstructor" defaultSeverity="WARNING" displayName="没有 'public' 无实参构造函数的 'Externalizable' 类" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告没有 public 无实参构造函数的 &lt;code&gt;Externalizable&lt;/code&gt; 类。
&lt;p&gt;在重新构造 &lt;code&gt;Externalizable&lt;/code&gt; 对象时，将在调用 &lt;code&gt;readExternal&lt;/code&gt; 方法前使用 public 无实参构造函数创建一个实例。 如果 public 无实参构造函数不可用，在运行时会抛出 &lt;code&gt;java.io.InvalidClassException&lt;/code&gt;。
  &lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NonSerializableWithSerialVersionUIDField" defaultSeverity="WARNING" displayName="具有 'serialVersionUID' 的不可序列化类" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告定义 &lt;code&gt;serialVersionUID&lt;/code&gt; 字段的非 &lt;code&gt;Serializable&lt;/code&gt; 类。 该上下文中的 &lt;code&gt;serialVersionUID&lt;/code&gt; 字段通常表明有错误，因为该字段将被忽略，且该类将不会被序列化。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class IWantToSerializeThis {
    private static final long serialVersionUID = 2669293150219020249L;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SerializableStoresNonSerializable" defaultSeverity="WARNING" displayName="'Serializable' 对象隐式存储非 'Serializable' 对象" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告任何对 &lt;code&gt;Serializable&lt;/code&gt; lambda、局部类和匿名类外部的非 &lt;code&gt;Serializable&lt;/code&gt; 局部变量的引用。
&lt;p&gt;
  从匿名类引用局部变量时，它的值存储在该类的隐式字段中。 对于局部类和 lambda 也是如此。 如果变量类型为非 &lt;code&gt;Serializable&lt;/code&gt;，序列化将失败。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  interface A extends Serializable {
      abstract void foo();
  }
  class B {}
  class C {
      void foo() {
          B b = new B();
          A a = new A() {
              @Override
              public void foo() {
                  System.out.println(b); // 警告
              }
          };
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SerializableWithUnconstructableAncestor" defaultSeverity="WARNING" displayName="具有不可构造上级的可序列化类" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告最近的不可序列化祖先没有无实参构造函数的 &lt;code&gt;Serializable&lt;/code&gt; 类。 这种类无法反序列化，将失败并抛出 &lt;code&gt;InvalidClassException&lt;/code&gt;。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Ancestor {
    private String name;
    Ancestor(String name) {
      this.name = name;
    }
  }

  //对此类发出警告，因为超类并非
//可序列化，并且其构造函数接受实参
  class Descendant extends Ancestor implements Serializable {
    Descendant() {
      super("Bob");
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SerialVersionUIDNotStaticFinal" defaultSeverity="WARNING" displayName="'serialVersionUID' 字段未被声明为 'private static final long'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;serialVersionUID&lt;/code&gt; 字段未被声明为 &lt;code&gt;private static final long&lt;/code&gt; 的 &lt;code&gt;Serializable&lt;/code&gt; 类。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class SampleClass implements Serializable {
    private long serialVersionUID = 1; // Serializable 类的字段未声明为 'private static final long'

    public SampleClass() {
        System.out.println(serialVersionUID);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SerializableHasSerializationMethods" defaultSeverity="WARNING" displayName="不带 'readObject()' 和 'writeObject()' 的可序列化类" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告不实现 &lt;code&gt;readObject()&lt;/code&gt; 和 &lt;code&gt;writeObject()&lt;/code&gt; 方法的 &lt;code&gt;Serializable&lt;/code&gt; 类。
&lt;p&gt;
  如果没有实现 &lt;code&gt;readObject()&lt;/code&gt; 和 &lt;code&gt;writeObject()&lt;/code&gt; 方法，将使用默认的序列化算法，在许多环境中，这对于性能和兼容性而言或许是次优选择。
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用以下选项配置检查：
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    列出此检查不应报告其继承者的类。
    这适用于从超类继承 &lt;code&gt;Serializable&lt;/code&gt; 但不用于序列化的类。
  &lt;/li&gt;
  &lt;li&gt;
    是否忽略没有非 static 字段的 &lt;code&gt;Serializable&lt;/code&gt; 类。
  &lt;/li&gt;
  &lt;li&gt;
    是否忽略 &lt;code&gt;Serializable&lt;/code&gt; 匿名类。
  &lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SerialAnnotationUsedOnWrongMember" defaultSeverity="WARNING" displayName="对错误的成员使用了 '@Serial' 注解" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;Serializable&lt;/code&gt; 和 &lt;code&gt;Externalizable&lt;/code&gt; 类中不适合使用 &lt;code&gt;java.io.Serial&lt;/code&gt; 注解进行注解的方法和字段。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
class Test implements Serializable {
  @Serial // 注解的字段不是序列化机制的一部分，因为它并非 final
  private static long serialVersionUID = 7874493593505141603L;

  @Serial // 注解的方法不是序列化机制的一部分，因为它并非 private
  void writeObject(ObjectOutputStream out) throws IOException {
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;
class Test implements Externalizable {
  @Serial // 该注解方法不是序列化机制的一部分，因为它在 Externalizable 类内部
  private void writeObject(ObjectOutputStream out) throws IOException {
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有关所有有效情况的信息，请参阅 &lt;code&gt;java.io.Serial&lt;/code&gt; 的文档。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;仅当项目或模块的语言级别为 14 或更高时，此检查才会报告。
&lt;p&gt;&lt;small&gt;2020.3 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TransientFieldNotInitialized" defaultSeverity="WARNING" displayName="transient 字段在反序列化时未初始化" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在正常对象构造过程中初始化，但其类没有 &lt;code&gt;readObject&lt;/code&gt; 方法的 &lt;code&gt;transient&lt;/code&gt; 字段。
&lt;p&gt;
  &lt;code&gt;transient&lt;/code&gt; 字段未被序列化，因此在反序列化期间，需要在 &lt;code&gt;readObject()&lt;/code&gt; 方法中单独初始化。
&lt;/p&gt;
&lt;p&gt;
  任何在正常对象构造过程中未被初始化的 &lt;code&gt;transient&lt;/code&gt; 字段都被视为使用默认初始化，并且不会被此检查报告。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Person implements Serializable {
    transient String name = "Default"; //警告，反序列化后实际上可能为 null
    transient String surname; //null 被视为默认值，不予报告
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SerializableRecordContainsIgnoredMembers" defaultSeverity="WARNING" displayName="'record' 包含被忽略的成员" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在 &lt;code&gt;record&lt;/code&gt; 类中定义的序列化方法或字段。
序列化方法包括 &lt;code&gt;writeObject()&lt;/code&gt;、&lt;code&gt;readObject()&lt;/code&gt;、&lt;code&gt;readObjectNoData()&lt;/code&gt;、&lt;code&gt;writeExternal()&lt;/code&gt; 和 &lt;code&gt;readExternal()&lt;/code&gt;，以及字段 &lt;code&gt;serialPersistentFields&lt;/code&gt;。
  这些成员不用于记录的序列化或反序列化，因此不必要使用。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  record R1() implements Serializable {
    // 该字段在记录序列化期间被忽略
    @Serial
    private static final ObjectStreamField[] serialPersistentFields = new ObjectStreamField[0];

    // 该方法在记录序列化期间被忽略
    @Serial
    private void writeObject(ObjectOutputStream out) throws IOException {
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;
  record R2() implements Externalizable {
    // 该方法在记录序列化期间被忽略
    @Override
    public void writeExternal(ObjectOutput out) throws IOException {
    }

    // 该方法在记录序列化期间被忽略
    @Override
    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;仅当项目或模块的语言级别为 14 或更高时，此检查才会报告。&lt;/p&gt;
&lt;p&gt;&lt;small&gt;2020.3 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SerializableInnerClassHasSerialVersionUIDField" defaultSeverity="WARNING" displayName="没有 'serialVersionUID' 的可序列化非 static 内部类" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告实现 &lt;code&gt;java.io.Serializable&lt;/code&gt; 但不定义 &lt;code&gt;serialVersionUID&lt;/code&gt; 字段的非 static 内部类。
&lt;p&gt;
  如果没有 &lt;code&gt;serialVersionUID&lt;/code&gt; 字段，对该类做出的任何更改都将导致以前序列化的版本不可读。 强烈建议 &lt;code&gt;Serializable&lt;/code&gt; 非 static 内部类包含 &lt;code&gt;serialVersionUID&lt;/code&gt; 字段，否则由于合成访问器方法的差异，默认序列化算法可能导致编译器之间的序列化版本不兼容。
&lt;/p&gt;
&lt;p&gt;
  建议通过快速修复添加缺失的 &lt;code&gt;serialVersionUID&lt;/code&gt; 字段。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Outer {
      class Inner implements Serializable {}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Outer {
      class Inner implements Serializable {
          private static final long serialVersionUID = -7004458730436243902L;
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;使用以下选项配置检查：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    列出此检查不应报告其继承者的类。
    这适用于从超类继承 &lt;code&gt;Serializable&lt;/code&gt; 但不用于序列化的类。
  &lt;/li&gt;
  &lt;li&gt;
    是否忽略 &lt;code&gt;Serializable&lt;/code&gt; 匿名类。
  &lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NonSerializableObjectPassedToObjectStream" defaultSeverity="WARNING" displayName="不可序列化的对象被传递给了 'ObjectOutputStream'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告用作 &lt;code&gt;java.io.ObjectOutputStream.write()&lt;/code&gt; 实参的非 &lt;code&gt;Serializable&lt;/code&gt; 对象。 此类调用将导致运行时异常。
&lt;p&gt;
  此检查假定 &lt;code&gt;java.util.Collection&lt;/code&gt; 和 &lt;code&gt;java.util.Map&lt;/code&gt; 类型的对象为 &lt;code&gt;Serializable&lt;/code&gt;，除非声明它们的类型为非 &lt;code&gt;Serializable&lt;/code&gt;。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class IWantToSerializeThis {
    public static void main(String[] args) throws IOException {
      try(var stream = new ObjectOutputStream(Files.newOutputStream(Paths.get("output")))) {
        // 警告 -- 将会失败并抛出 NotSerializableException
        stream.writeObject(new IWantToSerializeThis());
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReadResolveAndWriteReplaceProtected" defaultSeverity="WARNING" displayName="'readResolve()' 或 'writeReplace()' 未被声明为 'protected'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告实现 &lt;code&gt;java.io.Serializable&lt;/code&gt; 且其中的 &lt;code&gt;readResolve()&lt;/code&gt; 或 &lt;code&gt;writeReplace()&lt;/code&gt; 方法未被声明为 &lt;code&gt;protected&lt;/code&gt; 的类。
&lt;p&gt;
  将 &lt;code&gt;readResolve()&lt;/code&gt; 和 &lt;code&gt;writeReplace()&lt;/code&gt; 方法声明为 &lt;code&gt;private&lt;/code&gt; 可以强制子类无提示地忽略它们，而声明为 &lt;code&gt;public&lt;/code&gt; 则允许不受信任的代码调用它们。
&lt;/p&gt;
&lt;p&gt;
  如果包含类被声明为 &lt;code&gt;final&lt;/code&gt;，这些方法就可以被声明为 &lt;code&gt;private&lt;/code&gt;。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class ClassWithSerialization implements Serializable {
    public Object writeReplace() { // 警告：'writeReplace()' 未被声明为 protected
        ...
    }
  }
  &lt;/code&gt;
&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReadObjectAndWriteObjectPrivate" defaultSeverity="WARNING" displayName="'readObject()' 或 'writeObject()' 未被声明为 'private'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;readObject&lt;/code&gt; 或 &lt;code&gt;writeObject&lt;/code&gt; 方法未被声明为 private 的 &lt;code&gt;Serializable&lt;/code&gt; 类。
这些方法的可见性没有理由比 &lt;code&gt;private&lt;/code&gt; 更高。
&lt;p&gt;
  建议通过快速修复将相应的方法设为 &lt;code&gt;private&lt;/code&gt;。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Test implements Serializable {
    public void readObject(ObjectInputStream stream) {
      /* ... */
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Test implements Serializable {
    private void readObject(ObjectInputStream stream) {
      /* ... */
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SerialPersistentFieldsWithWrongSignature" defaultSeverity="WARNING" displayName="'serialPersistentFields' 字段未被声明为 'private static final ObjectStreamField[]'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;serialPersistentFields&lt;/code&gt; 字段未被声明为 &lt;code&gt;private static final ObjectStreamField[]&lt;/code&gt; 的 &lt;code&gt;Serializable&lt;/code&gt; 类。
&lt;p&gt;
  如果 &lt;code&gt;serialPersistentFields&lt;/code&gt; 字段未使用这些修饰符进行声明，序列化行为将与根本未声明该字段如出一辙。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class List implements Serializable {
    private List next;

    ObjectStreamField[] serialPersistentFields = {new ObjectStreamField("next", List.class)};

  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NonSerializableObjectBoundToHttpSession" defaultSeverity="WARNING" displayName="不可序列化的对象被绑定到了 'HttpSession'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告未实现用作 &lt;code&gt;javax.servlet.http.HttpSession.setAttribute()&lt;/code&gt; 或 &lt;code&gt;javax.servlet.http.HttpSession.putValue()&lt;/code&gt; 实参的 &lt;code&gt;java.io.Serializable&lt;/code&gt; 的类对象。
&lt;p&gt;
  如果 &lt;code&gt;HttpSession&lt;/code&gt; 被钝化或迁移，则不会序列化此类对象，并且可能导致难以诊断的错误。
&lt;/p&gt;
&lt;p&gt;
  此检查假定 &lt;code&gt;java.util.Collection&lt;/code&gt; 和
&lt;code&gt;java.util.Map&lt;/code&gt; 类型的对象为 &lt;code&gt;Serializable&lt;/code&gt;，除非类型形参为非 &lt;code&gt;Serializable&lt;/code&gt;。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void foo(HttpSession session) {
      session.setAttribute("foo", new NonSerializable());
  }
  static class NonSerializable {}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ExternalizableWithSerializationMethods" defaultSeverity="WARNING" displayName="具有 'readObject()' 或 'writeObject()' 的可外部化类" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告定义 &lt;code&gt;readObject()&lt;/code&gt; 或 &lt;code&gt;writeObject()&lt;/code&gt; 方法的 &lt;code&gt;Externalizable&lt;/code&gt; 类。 这些方法并非为了序列化 &lt;code&gt;Externalizable&lt;/code&gt; 对象而调用。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  abstract class Crucial implements Externalizable {
    int value;
    private void readObject(ObjectInputStream in) {
      value = in.readInt();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ComparatorNotSerializable" defaultSeverity="WARNING" displayName="'Comparator' 类未被声明为 'Serializable'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告实现 &lt;code&gt;java.lang.Comparator&lt;/code&gt; 但不实现 &lt;code&gt;java.io.Serializable&lt;/code&gt; 的类。
&lt;p&gt;
  如果使用不可序列化的比较器来构建 &lt;code&gt;java.util.TreeMap&lt;/code&gt; 或 &lt;code&gt;java.util.TreeSet&lt;/code&gt; 之类的有序集合，那么该集合也将不可序列化。 这可能会导致意外且难以诊断的错误。
&lt;/p&gt;
&lt;p&gt;
  &lt;code&gt;java.lang.Comparator&lt;/code&gt; 的子类通常无状态，因此只需将它们标记为可序列化，即可轻松避免此类问题。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo implements Comparator { // 警告
      @Override
      public int compare(Object o1, Object o2) {
          /* ... */
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo implements Comparator, Serializable { // 此处无警告
      @Override
      public int compare(Object o1, Object o2) {
          /* ... */
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="可能不合需要的代码结构" path="JavaScript and TypeScript"><inspection shortName="VoidExpressionJS" defaultSeverity="WARNING" displayName="'void' 表达式" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;void&lt;/code&gt; 表达式。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LabeledStatementJS" defaultSeverity="WARNING" displayName="标记语句" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告标签语句。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ContinueStatementJS" defaultSeverity="WARNING" displayName="'continue' 语句" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;continue&lt;/code&gt; 语句。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="BreakStatementJS" defaultSeverity="WARNING" displayName="'break' 语句" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;break&lt;/code&gt; 语句。 忽略结束 case 块的 &lt;code&gt;break&lt;/code&gt; 语句。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ContinueStatementWithLabelJS" defaultSeverity="WARNING" displayName="带标签的 'continue' 语句" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
添加 &lt;code&gt;continue&lt;/code&gt; 标签语句。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DebuggerStatementJS" defaultSeverity="WARNING" displayName="'debugger' 语句" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告用于与 Javascript 调试器交互的 &lt;code&gt;debugger&lt;/code&gt; 语句。  此类语句不应出现在生产代码中。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="BreakStatementWithLabelJS" defaultSeverity="WARNING" displayName="带标签的 'break' 语句" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;break&lt;/code&gt; 标签语句。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConditionalExpressionJS" defaultSeverity="WARNING" displayName="条件表达式" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告三元条件表达式。  有些编码标准禁止此类表达式，
而是支持显式的 &lt;code&gt;if&lt;/code&gt; 语句。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AnonymousFunctionJS" defaultSeverity="WARNING" displayName="匿名函数" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告匿名函数。 函数表达式的显式名称可能有助于调试。
如果 ECMAScript 6 标准中指定了 &lt;code&gt;name&lt;/code&gt; 属性，则忽略没有名称的函数表达式。
例如，不会报告 &lt;code&gt;var bar = function() {};&lt;/code&gt;。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CommaExpressionJS" defaultSeverity="WARNING" displayName="逗号表达式" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告逗号表达式。 此类表达式通常表明代码过于巧妙，并且可能导致难以捉摸的错误。
初始值设定项中的逗号表达式或 &lt;code&gt;for&lt;/code&gt; 循环的 update 部分中的逗号表达式
被忽略。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="WithStatementJS" defaultSeverity="WARNING" displayName="'with' 语句" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;with&lt;/code&gt; 语句。 此类语句会导致可能令人困惑的隐式绑定，并且在设置新变量时可能会表现出奇怪的行为。
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="TestNG" path="Java"><inspection shortName="ConvertJavadoc" defaultSeverity="WARNING" displayName="TestNG Javadoc 可以转换为注解" enabled="false" language="JAVA" pluginId="TestNG-J" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;&lt;body&gt;
使用 Javadoc 注解断言您的 TestNG 测试并将它们转换为 JDK 注解。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  /**
    * @testng.before-test
  */
  public void sample() {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @BeforeTest
  public void sample() {}
&lt;/code&gt;&lt;/pre&gt;
    &lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="MalformedDataProvider" defaultSeverity="WARNING" displayName="数据提供程序问题" enabled="false" language="JAVA" pluginId="TestNG-J" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;&lt;body&gt;
报告对不存在或不可访问的数据提供者方法的引用。
&lt;!-- tooltip end --&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
public class InstanceDataProviderFromForeignClass {
  // 方法 data() 在类 A 中不存在
  @Test(dataProvider = "data", dataProviderClass = A.class)
  public void test() {
  }
}
class A { }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
//所需的 data() 方法在类 A 中创建
class A {
  @DataProvider
  public Object[][] data() {
    return new Object[][]{};
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="ExpectedExceptionNeverThrownTestNG" defaultSeverity="WARNING" displayName="从未在测试方法正文中抛出预期异常" enabled="false" language="JAVA" pluginId="TestNG-J" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 TestNG 测试方法预期但从未在方法主体内抛出的已检查的异常。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Test(expectedExceptions = Exception.class) // 警告：从未抛出预期的 ‘Exception'
  public void testEngineIsRunning() {
    assertTrue(engine.isRunning());
  }
  &lt;/code&gt;
&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DuplicatedDataProviderNames" defaultSeverity="ERROR" displayName="数据提供程序名称重复" enabled="false" language="JAVA" pluginId="TestNG-J" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
如果发生 &lt;code&gt;org.testng.TestNGException&lt;/code&gt;，则报告具有相同名称的 &lt;code&gt;TestNG&lt;/code&gt; 数据提供者。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class DuplicatedDataProviders {
    @DataProvider
    public Object[][] intTestData() { // 重复项 1
      return new Integer[][]{
        new Integer[]{1, 1},
      };
    }

    @DataProvider(name = "intTestData")
    public Object[][] someTestData() { // 重复项 2
      return new Integer[][]{
        new Integer[]{1, 1},
      };
    }

    @Test(dataProvider = "intTestData")
    public void testIsOK(Integer key, Integer value) {
      assertEquals(key, value);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JUnitTestNG" defaultSeverity="WARNING" displayName="JUnit 测试可以转换为 TestNG" enabled="false" language="JAVA" pluginId="TestNG-J" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以转换为基于 TestNG 的单元测试的任何基于 JUnit 的测试类。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
import org.junit.Test;
import static org.junit.Assert.*;

public class ExampleTest {
  @Test
  public void testExample(){
    assertEquals(2 + 2, 4);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
import org.testng.Assert;
import org.testng.annotations.Test;

public class ExampleTest {
  @Test
  public void testExample(){
    Assert.assertEquals(4, 2 + 2);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="groupsTestNG" defaultSeverity="WARNING" displayName="未定义的组名" enabled="false" language="JAVA" pluginId="TestNG-J" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;&lt;body&gt;
报告传递给 &lt;code&gt;@Test&lt;/code&gt; 注解中的 &lt;code&gt;dependsOnGroups&lt;/code&gt; 或 &lt;code&gt;groups&lt;/code&gt; 特性的未定义组名称。
&lt;p&gt;快速修复将未定义的名称添加到已知组列表中。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;使用 &lt;b&gt; 定义的组 &lt;/b&gt; 字段定义现有组的逗号分隔列表。&lt;/p&gt;
&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="UndeclaredTests" defaultSeverity="WARNING" displayName="未声明的测试" enabled="false" language="JAVA" pluginId="TestNG-J" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告未在 &lt;code&gt;testing.xml&lt;/code&gt; 中注册的测试类。 这通常是一个错误，因为此类测试不会被执行。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConvertOldAnnotations" defaultSeverity="WARNING" displayName="使用了旧的 TestNG 注解 @Configuration" enabled="false" language="JAVA" pluginId="TestNG-J" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 TestNG &lt;code&gt;org.testng.annotations.Configuration&lt;/code&gt; 注解。
&lt;p&gt;最好使用现代 &lt;code&gt;@BeforeXXX&lt;/code&gt;/&lt;code&gt;@AfterXXX&lt;/code&gt; 注解来配置测试套件。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Test {
    @Configuration(beforeSuite = true, afterTest = true)
    public void afterBefore(){
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Test {
    @AfterTest()
    @BeforeSuite()
    public void afterBefore(){
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="dependsOnMethodTestNG" defaultSeverity="WARNING" displayName="传递给 'dependsOnMethods' 的方法名称非法" enabled="false" language="JAVA" pluginId="TestNG-J" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;&lt;body&gt;
报告传递给 &lt;code&gt;@Test&lt;/code&gt; 注解中的 &lt;code&gt;dependsOnMethods&lt;/code&gt; 特性的非法方法名称。
&lt;p&gt;如果方法名称不能解析为当前类或其任何父类中的有效、可访问的 &lt;code&gt;@Test&lt;/code&gt; 注解方法，则该方法名称被认为是非法的。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class SampleTest {
    @Test(dependsOnMethods = "testSpellignError")
    public void testSample() {}
    @Test
    public void testSpellingError(){}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;&lt;/html&gt;
</inspection><inspection shortName="DataProviderReturnType" defaultSeverity="ERROR" displayName="数据提供程序返回值类型无效" enabled="false" language="JAVA" pluginId="TestNG-J" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告不返回 &lt;code&gt;Object[][]&lt;/code&gt; 或 &lt;code&gt;Iterator&amp;lt;Object&amp;gt;&lt;/code&gt; 的用 &lt;code&gt;@DataProvider&lt;/code&gt; 注解标记的方法。
如果返回另一种类型，TestNG 将抛出异常。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
public class TestNgTest {
  @DataProvider(name = "Languages")
  List&amp;ltString&amp;gt getData() {
    return List.of("Java", "Kotlin");
  }

  @Test(dataProvider = "Languages")
  public void testData(String language) {
    System.out.println(language);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="测试框架" path="JVM 语言"><inspection shortName="JUnit5Converter" defaultSeverity="WARNING" displayName="JUnit 4 测试可以为 JUnit 5" enabled="false" language="UAST" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以自动迁移到 JUnit 5 的 JUnit 4 测试。
虽然默认运行程序可以自动转换，但自定义运行程序、方法规则和字段规则不能自动转换，需要手动更改。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  import org.junit.Assert;
  import org.junit.Test;

  public class RelevantTest {
    @Test
    public void testIt() {
      Assert.assertEquals("expected", "actual");
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  import org.junit.jupiter.api.Assertions;
  import org.junit.jupiter.api.Test;

  public class RelevantTest {
    @Test
    public void testIt() {
      Assertions.assertEquals("expected", "actual");
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;此检查要求类路径中提供 JUnit 5 库，并且为项目配置了 JDK 1.8 或更高版本。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AssertBetweenInconvertibleTypes" defaultSeverity="WARNING" displayName="'assertEquals()' 位于不可转换类型的对象之间" enabled="false" language="UAST" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告“预期”实参和“实际”实参的类型不兼容时对断言方法的调用。
&lt;p&gt;此类调用通常表明测试中存在错误。
  该检查会检查相关的 JUnit、TestNG 和 AssertJ 方法。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  assertEquals("1", 1);
  assertNotSame(new int[0], 0);

  // 弱警告，可能只测试 equals() 约定
  assertThat(foo).as("user type").isNotEqualTo(bar);
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="TestCaseWithConstructor" defaultSeverity="WARNING" displayName="具有非普通构造函数的 TestCase" enabled="false" language="UAST" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在其构造函数中具有初始化逻辑的测试用例。
如果构造函数失败，将不会调用 &lt;code&gt;@After&lt;/code&gt; 注解方法或 &lt;code&gt;tearDown()&lt;/code&gt; 方法。
这可能导致测试环境部分初始化，因而对其他测试产生不利影响。
相反，测试用例初始化应在 &lt;code&gt;setUp()&lt;/code&gt; 或 &lt;code&gt;@Before&lt;/code&gt; 注解方法中完成。
&lt;p&gt;不良示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class ImportantTest {
    private File file;

    public ImportantTest() throws IOException {
      file = File.createTempFile("xyz", ".tmp");
    }

    // ... tests go here
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MigrateAssertToMatcherAssert" defaultSeverity="WARNING" displayName="JUnit 断言可以是 'assertThat()' 调用" enabled="false" language="UAST" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对可以迁移到 Hamcrest 声明式样式 &lt;code&gt;Assert.assertThat()&lt;/code&gt; 调用的 &lt;code&gt;Assert.assertEquals()&lt;/code&gt;、&lt;code&gt;Assert.assertTrue()&lt;/code&gt; 等方法的调用。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;public class&lt;/b&gt; SubstantialTest {
    @Test
    &lt;b&gt;public void&lt;/b&gt; testContents(Collection&amp;lt;String&gt; c, String s) {
      Assert.assertTrue(c.contains(s));
      Assert.assertEquals(c, s);
      Assert.assertNotNull(c);
      Assert.assertNull(c);
      Assert.assertFalse(c.contains(s));
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为执行迁移提供了快速修复：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;public class&lt;/b&gt; SubstantialTest {
    @Test
    &lt;b&gt;public void&lt;/b&gt; testContents(Collection&amp;lt;String&gt; c, String s) {
      assertThat(c, hasItem(o));
      assertThat(o, is(c));
      assertThat(c, notNullValue());
      assertThat(c, nullValue());
      assertThat(c, not(hasItem(o)));
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;此检查要求类路径上有可用的 Hamcrest 库。
&lt;p&gt;使用&lt;b&gt;静态导入匹配程序的方法&lt;/b&gt;选项，可指定是否希望该快速修复静态导入 Hamcrest 匹配程序方法。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="IgnoredJUnitTest" defaultSeverity="WARNING" displayName="使用 '@Ignore'/'@Disabled' 注解的 JUnit 测试" enabled="false" language="UAST" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 JUnit 4 的 &lt;code&gt;@Ignore&lt;/code&gt; 或 JUnit 5 的 &lt;code&gt;@Disabled&lt;/code&gt; 注解的用法。
长时间使用这些注解来注解测试会被认为是代码异味，特别是在没有指定原因的情况下。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Ignore
  &lt;b&gt;public class&lt;/b&gt; UrgentTest {

    @Test
    &lt;b&gt;public void&lt;/b&gt; testIt() {
      Assert.assertEquals("expected", "actual");
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  配置检查：
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    使用&lt;b&gt;仅报告没有原因的注解&lt;/b&gt;选项可以仅报告没有原因被指定为注解的 &lt;code&gt;value&lt;/code&gt; 特性的情况。
  &lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnconstructableTestCase" defaultSeverity="WARNING" displayName="JUnit 不可构造的测试用例" enabled="false" language="UAST" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告无法由标准的 JUnit 测试运行程序构建的 JUnit 测试类。
&lt;p&gt;
  JUnit 4 测试类需要为 &lt;code&gt;public&lt;/code&gt; 并包含一个 &lt;code&gt;public&lt;/code&gt; 无实参构造函数或完全不包含构造函数（隐式的默认构造函数），且没有其他 &lt;code&gt;public&lt;/code&gt; 构造函数。
  JUnit 3 测试类需要为 &lt;code&gt;public&lt;/code&gt;，并且需要 &lt;code&gt;public&lt;/code&gt; 无实参构造函数或者带有单个 &lt;code&gt;String&lt;/code&gt; 类型形参的 &lt;code&gt;public&lt;/code&gt; 构造函数（调用匹配的超构造函数）。
  否则，测试类无法由标准的 JUnit 测试运行程序运行。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
public class MyTest {

  private MyTest() {} // no-arg 构造函数为 private

  @Test
  public void testSomething() {
    assertEquals(1, 1);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TestOnlyProblems" defaultSeverity="WARNING" displayName="生产代码中的纯测试用法" enabled="false" language="UAST" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告生产代码中使用的 &lt;code&gt;@TestOnly&lt;/code&gt; 和 &lt;code&gt;@VisibleForTesting&lt;/code&gt; 注解的方法和类。 还报告将 &lt;code&gt;@TestOnly&lt;/code&gt; &lt;code&gt;@VisibleForTesting&lt;/code&gt; 应用于同一元素的用法。

&lt;p&gt;如果引用了以下位置中的方法或类，则不报告这些问题：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;b&gt;Test Sources&lt;/b&gt; 文件夹下的代码
  &lt;li&gt;测试类 (JUnit/TestNG)
  &lt;li&gt;另一个 &lt;code&gt;@TestOnly&lt;/code&gt; 注解的方法
&lt;/ul&gt;
&lt;p&gt;&lt;b&gt;（生产代码中的）示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @TestOnly
  fun foo() { ... }

  fun main () {
    foo()
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="TestMethodWithoutAssertion" defaultSeverity="WARNING" displayName="不带断言的测试方法" enabled="false" language="UAST" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告不包含任何断言的测试方法。 此类方法可能表示测试用例不完整或薄弱。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;public class&lt;/b&gt; ExtensiveTest {

    @Test
    &lt;b&gt;public void&lt;/b&gt; testAlive() {
      System.out.println("nothing");
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  配置检查：
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
      使用该表可以指定应作为断言的完全限定类名和方法名正则表达式的组合。 类名也匹配子类。
  &lt;/li&gt;
  &lt;li&gt;
      使用 &lt;b&gt;'assert' 关键字被视为断言&lt;/b&gt;选项可以指定是否应将使用 &lt;code&gt;assert&lt;/code&gt; 关键字的 Java &lt;code&gt;assert&lt;/code&gt; 语句视为断言。
  &lt;/li&gt;
  &lt;li&gt;
      使用&lt;b&gt;忽略声明异常的测试方法&lt;/b&gt;选项可以忽略声明异常的测试方法。
      当您的测试会在失败时抛出异常并因此不需要任何断言时，这会很有用。
  &lt;/li&gt;
&lt;/ul&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SuperTearDownInFinally" defaultSeverity="WARNING" displayName="未从 'finally' 块调用 JUnit 3 'super.tearDown()'" enabled="false" language="UAST" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告未在 &lt;code&gt;finally&lt;/code&gt; 块内执行的 JUnit 3 的 &lt;code&gt;super.tearDown()&lt;/code&gt; 方法的调用。
如果在调用 &lt;code&gt;super.tearDown()&lt;/code&gt; 之前抛出异常，可能会导致不一致和泄露。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class AnotherTest extends CompanyTestCase {
    private Path path;

    @Override
    protected void setUp() throws Exception {
      super.setUp();
      path = Files.createTempFile("File", ".tmp");
    }

    @Override
    protected void tearDown() throws Exception {
      Files.delete(path);
      super.tearDown();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;改进后的代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class AnotherTest extends CompanyTestCase {
    private Path path;

    @Override
    protected void setUp() throws Exception {
      super.setUp();
      path = Files.createTempFile("File", ".tmp");
    }

    @Override
    protected void tearDown() throws Exception {
      try {
        Files.delete(path);
      } finally {
        super.tearDown();
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
  &lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AssertEqualsMayBeAssertSame" defaultSeverity="WARNING" displayName="'assertEquals()' 可能是 'assertSame()'" enabled="false" language="UAST" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可被替换为等效 &lt;code&gt;assertSame()&lt;/code&gt; 调用的 JUnit &lt;code&gt;assertEquals()&lt;/code&gt; 调用。
当实参是不重写 &lt;code&gt;Object.equals()&lt;/code&gt; 方法并显式比较对象标识的 &lt;code&gt;final&lt;/code&gt; 类的实例时，可能发生这种情况。
&lt;p&gt;建议将 &lt;code&gt;assertEquals()&lt;/code&gt; 替换为 &lt;code&gt;assertSame()&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Test
  public void testObjectType() {
    Object o = getObject();
    Assert.assertEquals(String.class, o.getClass());
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Test
  public void testSort() {
    Object o = getObject();
    Assert.assertSame(String.class, o.getClass());
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JUnitMalformedDeclaration" defaultSeverity="WARNING" displayName="JUnit 格式错误的声明" enabled="false" language="UAST" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告格式错误且可能无法被 JUnit 测试框架识别的 JUnit 测试成员声明。
此检查会报告的问题如下：
&lt;ul&gt;
  &lt;li&gt;由 &lt;code&gt;@RegisterExtension&lt;/code&gt; 注解的类型错误或在需要时未被声明为 static 的字段&lt;/li&gt;
  &lt;li&gt;使用 &lt;code&gt;@Nested&lt;/code&gt; 注解的 static 或 private 内部类&lt;/li&gt;
  &lt;li&gt;在没有源的情况下定义的形参化测试&lt;/li&gt;
  &lt;li&gt;具有包含未知、非 static 或无实参目标的 &lt;code&gt;@MethodSource&lt;/code&gt; 的形参化测试。&lt;/li&gt;
  &lt;li&gt;形参化测试方法形参与指定的 &lt;code&gt;@ValueSource&lt;/code&gt; 或 &lt;code&gt;@EnumSource&lt;/code&gt; 值之间的类型不匹配&lt;/li&gt;
  &lt;li&gt;由 &lt;code&gt;@Test&lt;/code&gt;、&lt;code&gt;@ParameterizedTest&lt;/code&gt; 或 &lt;code&gt;@RepeatedTest&lt;/code&gt; 中的多个注解的测试&lt;/li&gt;
  &lt;li&gt;非 public 的 &lt;code&gt;setup()&lt;/code&gt; 或 &lt;code&gt;tearDown()&lt;/code&gt;方法，其返回值类型不是 void 或接受实参&lt;/li&gt;
  &lt;li&gt;为 private，接受实参或为非 static 的 &lt;code&gt;suite()&lt;/code&gt; 方法&lt;/li&gt;
  &lt;li&gt;
    由 &lt;code&gt;@BeforeClass&lt;/code&gt;、&lt;code&gt;@AfterClass&lt;/code&gt;、&lt;code&gt;@BeforeAll&lt;/code&gt; 或 &lt;code&gt;@AfterAll&lt;/code&gt; 注解的非 public、非 static 方法，其返回值类型不是 void 或没有有效的形参列表
  &lt;/li&gt;
  &lt;li&gt;
    由 &lt;code&gt;@Before&lt;/code&gt;、&lt;code&gt;@After&lt;/code&gt;、&lt;code&gt;@BeforeEach&lt;/code&gt; 或 &lt;code&gt;@AfterEach&lt;/code&gt; 注解的非 public 方法，其返回值类型不是 void 或接受实参。
  &lt;/li&gt;
  &lt;li&gt;在 &lt;code&gt;@BeforeAll&lt;/code&gt; 或 &lt;code&gt;@AfterAll&lt;/code&gt; 方法中注入的 &lt;code&gt;RepetitionInfo&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;
    由 &lt;code&gt;@Test&lt;/code&gt; 注解测试使用，在 &lt;code&gt;@BeforeEach&lt;/code&gt; 或 &lt;code&gt;@AfterEach&lt;/code&gt;方法中注入的 &lt;code&gt;RepetitionInfo&lt;/code&gt;
  &lt;/li&gt;
  &lt;li&gt;由 &lt;code&gt;@DataPoint&lt;/code&gt; 或 &lt;code&gt;@DataPoints&lt;/code&gt; 注解的非 public 或非 static 字段和方法&lt;/li&gt;
  &lt;li&gt;
    由 &lt;code&gt;@Rule&lt;/code&gt; 注解的非 public 或者非 &lt;code&gt;TestRule&lt;/code&gt; 或 &lt;code&gt;MethodRule&lt;/code&gt; 的子类型的字段和方法
  &lt;/li&gt;
  &lt;li&gt;由 &lt;code&gt;@ClassRule&lt;/code&gt; 注解的非 public、非 static 或非 &lt;code&gt;TestRule&lt;/code&gt; 的子类型的字段和方法&lt;/li&gt;
  &lt;li&gt;
    &lt;code&gt;TestCase&lt;/code&gt; 子类内带有 &lt;code&gt;test&lt;/code&gt; 前缀的非 public 方法，其返回值类型不是 void，接受实参或为 static。
  &lt;/li&gt;
  &lt;li&gt;
    由 &lt;code&gt;@Test&lt;/code&gt; 注解的非 public 方法，其返回值类型不是 void，接受实参或为 static
  &lt;/li&gt;
&lt;/ul&gt;

请注意，在 Kotlin 中，挂起函数确实有实参和非 void 返回值类型。 因此，它们也不会由 JUnit 测试运行程序执行。 此检查也将报告这一问题。

&lt;p&gt;&lt;b&gt;格式错误的 &lt;code&gt;@Before&lt;/code&gt; 方法示例 (Java)：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Before private int foo(int arg) { ... } &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Before public void foo() { ... } &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;b&gt;缺少方法源代码示例 (Kotlin)：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Example {
    @MethodSource("parameters")
    @ParameterizedTest
    fun foo(param: String) { ... }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Example {
    @MethodSource("parameters")
    @ParameterizedTest
    fun foo(param: String) { ... }

    companion object {
      @JvmStatic
      fun parameters(): Stream&amp;lt;Arguments&amp;gt; {
        TODO("Not yet implemented")
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- tooltip end --&gt;
&lt;p&gt;使用检查选项可以指定注解。 不会报告任何使用其中一种注解进行注解的形参。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AssertEqualsCalledOnArray" defaultSeverity="WARNING" displayName="在数组上调用了 'assertEquals()'" enabled="false" language="UAST" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告带有数组类型实参的 JUnit &lt;code&gt;assertEquals()&lt;/code&gt; 调用。
此类方法会比较数组的标识，而不是数组的内容。
应使用 &lt;code&gt;assertArrayEquals()&lt;/code&gt; 方法检查数组内容。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Test
  public void testSort() {
    int[] actual = {248, 496, 0, 56};
    Arrays.sort(actual);
    Assert.assertEquals(new int[] {0, 56, 248, 496}, actual);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Test
  public void testSort() {
    int[] actual = {248, 496, 0, 56};
    Arrays.sort(actual);
    Assert.assertArrayEquals(new int[] {0, 56, 248, 496}, actual);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JUnit5AssertionsConverter" defaultSeverity="WARNING" displayName="JUnit 5 obsolete assertions" enabled="false" language="UAST" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 JUnit 5 测试中对任何&lt;code&gt;junit.framework.Assert&lt;/code&gt;、&lt;code&gt;org.junit.Assert&lt;/code&gt; 或 &lt;code&gt;org.junit.Assume&lt;/code&gt; 类中的方法的调用。&lt;/p&gt;
&lt;p&gt;尽管这些测试正常工作，但迁移到 &lt;code&gt;org.junit.jupiter.api.Assertions&lt;/code&gt;/&lt;code&gt;org.junit.jupiter.api.Assumptions&lt;/code&gt; 有助于避免对旧版 JUnit 的依赖。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  import org.junit.Assert;
  import org.junit.jupiter.api.Test;

  public class MyTest {
    @Test
    public void simpleTest() {
      Assert.assertEquals(4, 2 + 2);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  import org.junit.jupiter.api.Assertions;
  import org.junit.jupiter.api.Test;

  public class MyTest {
    @Test
    public void simpleTest() {
      Assertions.assertEquals(4, 2 + 2);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TestFailedLine" defaultSeverity="WARNING" displayName="测试中失败的行" enabled="false" language="UAST" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告测试中失败的方法调用或断言。 它有助于更快地检测代码中失败的行，并立即开始调试。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Test
  fun foo() {
    assertEquals(1, 0) // 高亮显示
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TestInProductSource" defaultSeverity="WARNING" displayName="产品源中的测试" enabled="false" language="UAST" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告位于生产源树中的测试类和测试方法。
这很可能表示有错误，并且可能导致测试代码被投入生产。
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Android Lint: Security" path=""><inspection shortName="AndroidLintGetInstance" defaultSeverity="WARNING" displayName="Cipher.getInstance with ECB" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Cipher.getInstance with ECB&lt;br&gt;&lt;br&gt;&lt;code&gt;Cipher#getInstance&lt;/code&gt; should not be called with ECB as the cipher mode or without setting the cipher mode because the default mode on android is ECB, which is insecure.&lt;br&gt;&lt;br&gt;Issue id: GetInstance&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintHardcodedDebugMode" defaultSeverity="ERROR" displayName="Hardcoded value of android:debuggable in the manifest" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Hardcoded value of &lt;code&gt;android:debuggable&lt;/code&gt; in the manifest&lt;br&gt;&lt;br&gt;It's best to leave out the &lt;code&gt;android:debuggable&lt;/code&gt; attribute from the manifest. If you do, then the tools will automatically insert &lt;code&gt;android:debuggable=true&lt;/code&gt; when building an APK to debug on an emulator or device. And when you perform a release build, such as Exporting APK, it will automatically set it to &lt;code&gt;false&lt;/code&gt;.&lt;br/&gt;
&lt;br/&gt;
If on the other hand you specify a specific value in the manifest file, then the tools will always use it. This can lead to accidentally publishing your app with debug information.&lt;br&gt;&lt;br&gt;Issue id: HardcodedDebugMode&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintAcceptsUserCertificates" defaultSeverity="WARNING" displayName="Allowing User Certificates" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Allowing User Certificates&lt;br&gt;&lt;br&gt;Allowing user certificates could allow eavesdroppers to intercept data sent by your app, 'which could impact the privacy of your users. Consider nesting your app's &lt;code&gt;trust-anchors&lt;/code&gt; inside a &lt;code&gt;&amp;lt;debug-overrides&gt;&lt;/code&gt; element to make sure they are only available when &lt;code&gt;android:debuggable&lt;/code&gt; is set to &lt;code&gt;"true"&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: AcceptsUserCertificates&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/training/articles/security-config#TrustingDebugCa"&gt;https://developer.android.com/training/articles/security-config#TrustingDebugCa&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintSystemPermissionTypo" defaultSeverity="WARNING" displayName="Permission appears to be a standard permission with a typo" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Permission appears to be a standard permission with a typo&lt;br&gt;&lt;br&gt;This check looks for required permissions that &lt;i&gt;look&lt;/i&gt; like well-known system permissions or permissions from the Android SDK, but aren't, and may be typos.&lt;br/&gt;
&lt;br/&gt;
Please double check the permission value you have supplied.&lt;br&gt;&lt;br&gt;Issue id: SystemPermissionTypo&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintExportedContentProvider" defaultSeverity="WARNING" displayName="Content provider does not require permission" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Content provider does not require permission&lt;br&gt;&lt;br&gt;Content providers are exported by default and any application on the system can potentially use them to read and write data. If the content provider provides access to sensitive data, it should be protected by specifying &lt;code&gt;export=false&lt;/code&gt; in the manifest or by protecting it with a permission that can be granted to other applications.&lt;br&gt;&lt;br&gt;Issue id: ExportedContentProvider&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintSignatureOrSystemPermissions" defaultSeverity="WARNING" displayName="Declaring signatureOrSystem permissions" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Declaring signatureOrSystem permissions&lt;br&gt;&lt;br&gt;The &lt;code&gt;signature&lt;/code&gt; protection level should probably be sufficient for most needs and works regardless of where applications are installed. The &lt;code&gt;signatureOrSystem&lt;/code&gt; level is used for certain situations where multiple vendors have applications built into a system image and need to share specific features explicitly because they are being built together.&lt;br&gt;&lt;br&gt;Issue id: SignatureOrSystemPermissions&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintGrantAllUris" defaultSeverity="WARNING" displayName="Content provider shares everything" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Content provider shares everything&lt;br&gt;&lt;br&gt;The &lt;code&gt;&amp;lt;grant-uri-permission&gt;&lt;/code&gt; element allows specific paths to be shared. This detector checks for a path URL of just '/' (everything), which is probably not what you want; you should limit access to a subset.&lt;br&gt;&lt;br&gt;Issue id: GrantAllUris&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintSecureRandom" defaultSeverity="WARNING" displayName="Using a fixed seed with SecureRandom" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using a fixed seed with &lt;code&gt;SecureRandom&lt;/code&gt;&lt;br&gt;&lt;br&gt;Specifying a fixed seed will cause the instance to return a predictable sequence of numbers. This may be useful for testing but it is not appropriate for secure use.&lt;br&gt;&lt;br&gt;Issue id: SecureRandom&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/reference/java/security/SecureRandom.html"&gt;https://developer.android.com/reference/java/security/SecureRandom.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintCustomX509TrustManager" defaultSeverity="WARNING" displayName="Implements custom TLS trust manager" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Implements custom TLS trust manager&lt;br&gt;&lt;br&gt;This check looks for custom &lt;code&gt;X509TrustManager&lt;/code&gt; implementations.&lt;br&gt;&lt;br&gt;Issue id: CustomX509TrustManager&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintReservedSystemPermission" defaultSeverity="ERROR" displayName="Permission name is a reserved Android permission" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Permission name is a reserved Android permission&lt;br&gt;&lt;br&gt;This check looks for custom permission declarations whose names are reserved values for system or Android SDK permissions, or begin with the reserved string &lt;code&gt;android.&lt;/code&gt;&lt;br/&gt;
&lt;br/&gt;
Please double check the permission name you have supplied. Attempting to redeclare a system or Android SDK permission will be ignored.  Using the prefix &lt;code&gt;android.&lt;/code&gt; is a violation of the Android Compatibility Definition Document.&lt;br&gt;&lt;br&gt;Issue id: ReservedSystemPermission&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintAddJavascriptInterface" defaultSeverity="WARNING" displayName="addJavascriptInterface Called" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;&lt;code&gt;addJavascriptInterface&lt;/code&gt; Called&lt;br&gt;&lt;br&gt;For applications built for API levels below 17, &lt;code&gt;WebView#addJavascriptInterface&lt;/code&gt; presents a security hazard as JavaScript on the target web page has the ability to use reflection to access the injected object's public fields and thus manipulate the host application in unintended ways.&lt;br&gt;&lt;br&gt;Issue id: AddJavascriptInterface&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/reference/android/webkit/WebView.html#addJavascriptInterface(java.lang.Object,%20java.lang.String)"&gt;https://developer.android.com/reference/android/webkit/WebView.html#addJavascriptInterface(java.lang.Object,%20java.lang.String)&lt;/a&gt;&lt;br&gt;&lt;a href="https://support.google.com/faqs/answer/9095419?hl=en"&gt;https://support.google.com/faqs/answer/9095419?hl=en&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUnsafeProtectedBroadcastReceiver" defaultSeverity="WARNING" displayName="Unsafe Protected BroadcastReceiver" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Unsafe Protected &lt;code&gt;BroadcastReceiver&lt;/code&gt;&lt;br&gt;&lt;br&gt;`BroadcastReceiver`s that declare an intent-filter for a protected-broadcast action string must check that the received intent's action string matches the expected value, otherwise it is possible for malicious actors to spoof intents.&lt;br&gt;&lt;br&gt;Issue id: UnsafeProtectedBroadcastReceiver&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintExportedReceiver" defaultSeverity="WARNING" displayName="Receiver does not require permission" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Receiver does not require permission&lt;br&gt;&lt;br&gt;Exported receivers (receivers which either set &lt;code&gt;exported=true&lt;/code&gt; or contain an intent-filter and do not specify &lt;code&gt;exported=false&lt;/code&gt;) should define a permission that an entity must have in order to launch the receiver or bind to it. Without this, any application can use this receiver.&lt;br&gt;&lt;br&gt;Issue id: ExportedReceiver&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintEasterEgg" defaultSeverity="WARNING" displayName="Code contains easter egg" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Code contains easter egg&lt;br&gt;&lt;br&gt;An "easter egg" is code deliberately hidden in the code, both from potential users and even from other developers. This lint check looks for code which looks like it may be hidden from sight.&lt;br&gt;&lt;br&gt;Issue id: EasterEgg&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUnsafeNativeCodeLocation" defaultSeverity="WARNING" displayName="Native code outside library directory" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Native code outside library directory&lt;br&gt;&lt;br&gt;In general, application native code should only be placed in the application's library directory, not in other locations such as the res or assets directories. Placing the code in the library directory provides increased assurance that the code will not be tampered with after application installation. Application developers should use the features of their development environment to place application native libraries into the lib directory of their compiled APKs. Embedding non-shared library native executables into applications should be avoided when possible.&lt;br&gt;&lt;br&gt;Issue id: UnsafeNativeCodeLocation&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUseCheckPermission" defaultSeverity="WARNING" displayName="Using the result of check permission calls" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using the result of check permission calls&lt;br&gt;&lt;br&gt;You normally want to use the result of checking a permission; these methods return whether the permission is held; they do not throw an error if the permission is not granted. Code which does not do anything with the return value probably meant to be calling the enforce methods instead, e.g. rather than &lt;code&gt;Context#checkCallingPermission&lt;/code&gt; it should call &lt;code&gt;Context#enforceCallingPermission&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: UseCheckPermission&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintPackagedPrivateKey" defaultSeverity="ERROR" displayName="Packaged private key" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Packaged private key&lt;br&gt;&lt;br&gt;In general, you should not package private key files inside your app.&lt;br&gt;&lt;br&gt;Issue id: PackagedPrivateKey&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUnsafeDynamicallyLoadedCode" defaultSeverity="WARNING" displayName="load used to dynamically load code" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;&lt;code&gt;load&lt;/code&gt; used to dynamically load code&lt;br&gt;&lt;br&gt;Dynamically loading code from locations other than the application's library directory or the Android platform's built-in library directories is dangerous, as there is an increased risk that the code could have been tampered with. Applications should use &lt;code&gt;loadLibrary&lt;/code&gt; when possible, which provides increased assurance that libraries are loaded from one of these safer locations. Application developers should use the features of their development environment to place application native libraries into the lib directory of their compiled APKs.&lt;br&gt;&lt;br&gt;Issue id: UnsafeDynamicallyLoadedCode&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintSetWorldReadable" defaultSeverity="WARNING" displayName="File.setReadable() used to make file world-readable" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;&lt;code&gt;File.setReadable()&lt;/code&gt; used to make file world-readable&lt;br&gt;&lt;br&gt;Setting files world-readable is very dangerous, and likely to cause security holes in applications. It is strongly discouraged; instead, applications should use more formal mechanisms for interactions such as &lt;code&gt;ContentProvider&lt;/code&gt;, &lt;code&gt;BroadcastReceiver&lt;/code&gt;, and &lt;code&gt;Service&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: SetWorldReadable&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintCustomPermissionTypo" defaultSeverity="WARNING" displayName="Permission appears to be a custom permission with a typo" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Permission appears to be a custom permission with a typo&lt;br&gt;&lt;br&gt;This check looks for required permissions that &lt;i&gt;look&lt;/i&gt; like custom permissions defined in the same manifest, but aren't, and may be typos.&lt;br/&gt;
&lt;br/&gt;
Please double check the permission value you have supplied.&lt;br&gt;&lt;br&gt;Issue id: CustomPermissionTypo&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUnspecifiedImmutableFlag" defaultSeverity="WARNING" displayName="Missing PendingIntent mutability flag" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing &lt;code&gt;PendingIntent&lt;/code&gt; mutability flag&lt;br&gt;&lt;br&gt;Apps targeting Android 12 and higher must specify either &lt;code&gt;FLAG_IMMUTABLE&lt;/code&gt; or &lt;code&gt;FLAG_MUTABLE&lt;/code&gt; when constructing a &lt;code&gt;PendingIntent&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: UnspecifiedImmutableFlag&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/about/versions/12/behavior-changes-12#pending-intent-mutability"&gt;https://developer.android.com/about/versions/12/behavior-changes-12#pending-intent-mutability&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintAllowAllHostnameVerifier" defaultSeverity="WARNING" displayName="Insecure HostnameVerifier" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Insecure &lt;code&gt;HostnameVerifier&lt;/code&gt;&lt;br&gt;&lt;br&gt;This check looks for use of HostnameVerifier implementations whose &lt;code&gt;verify&lt;/code&gt; method always returns true (thus trusting any hostname) which could result in insecure network traffic caused by trusting arbitrary hostnames in TLS/SSL certificates presented by peers.&lt;br&gt;&lt;br&gt;Issue id: AllowAllHostnameVerifier&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintTileProviderPermissions" defaultSeverity="WARNING" displayName="TileProvider should declare BIND_TILE_PROVIDER permission" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;TileProvider does not set permission&lt;br&gt;&lt;br&gt;TileProviders should require the &lt;code&gt;com.google.android.wearable.permission.BIND_TILE_PROVIDER&lt;/code&gt; permission to prevent arbitrary apps from binding to it.&lt;br&gt;&lt;br&gt;Issue id: TileProviderPermissions&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintExportedPreferenceActivity" defaultSeverity="WARNING" displayName="PreferenceActivity should not be exported" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;PreferenceActivity should not be exported&lt;br&gt;&lt;br&gt;Fragment injection gives anyone who can send your &lt;code&gt;PreferenceActivity&lt;/code&gt; an intent the ability to load any fragment, with any arguments, in your process.&lt;br&gt;&lt;br&gt;Issue id: ExportedPreferenceActivity&lt;br&gt;&lt;br&gt;&lt;a href="http://securityintelligence.com/new-vulnerability-android-framework-fragment-injection"&gt;http://securityintelligence.com/new-vulnerability-android-framework-fragment-injection&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintAuthLeak" defaultSeverity="WARNING" displayName="Code might contain an auth leak" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Code might contain an auth leak&lt;br&gt;&lt;br&gt;Strings in java apps can be discovered by decompiling apps, this lint check looks for code which looks like it may contain an url with a username and password&lt;br&gt;&lt;br&gt;Issue id: AuthLeak&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintInsecureBaseConfiguration" defaultSeverity="WARNING" displayName="Insecure Base Configuration" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Insecure Base Configuration&lt;br&gt;&lt;br&gt;Permitting cleartext traffic could allow eavesdroppers to intercept data sent by your app, which impacts the privacy of your users. Consider only allowing encrypted traffic by setting the &lt;code&gt;cleartextTrafficPermitted&lt;/code&gt; tag to &lt;code&gt;"false"&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: InsecureBaseConfiguration&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/preview/features/security-config.html"&gt;https://developer.android.com/preview/features/security-config.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintDeprecatedProvider" defaultSeverity="WARNING" displayName="Using BC Provider" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using BC Provider&lt;br&gt;&lt;br&gt;The &lt;code&gt;BC&lt;/code&gt; provider has been deprecated and will not be provided when &lt;code&gt;targetSdkVersion&lt;/code&gt; is P or higher.&lt;br&gt;&lt;br&gt;Issue id: DeprecatedProvider&lt;br&gt;&lt;br&gt;&lt;a href="https://android-developers.googleblog.com/2018/03/cryptography-changes-in-android-p.html"&gt;https://android-developers.googleblog.com/2018/03/cryptography-changes-in-android-p.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintPermissionNamingConvention" defaultSeverity="WARNING" displayName="Permission name does not follow recommended convention" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Permission name does not follow recommended convention&lt;br&gt;&lt;br&gt;Permissions should be prefixed with an app's package name, using reverse-domain-style naming. This prefix should be followed by &lt;code&gt;.permission.&lt;/code&gt;, and then a description of the capability that the permission represents, in upper SNAKE_CASE. For example, &lt;code&gt;com.example.myapp.permission.ENGAGE_HYPERSPACE&lt;/code&gt;.&lt;br/&gt;
&lt;br/&gt;
Following this recommendation avoids naming collisions, and helps clearly identify the owner and intention of a custom permission.&lt;br&gt;&lt;br&gt;Issue id: PermissionNamingConvention&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintSSLCertificateSocketFactoryCreateSocket" defaultSeverity="WARNING" displayName="Insecure call to SSLCertificateSocketFactory.createSocket()" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Insecure call to &lt;code&gt;SSLCertificateSocketFactory.createSocket()&lt;/code&gt;&lt;br&gt;&lt;br&gt;When &lt;code&gt;SSLCertificateSocketFactory.createSocket()&lt;/code&gt; is called with an &lt;code&gt;InetAddress&lt;/code&gt; as the first parameter, TLS/SSL hostname verification is not performed, which could result in insecure network traffic caused by trusting arbitrary hostnames in TLS/SSL certificates presented by peers. In this case, developers must ensure that the &lt;code&gt;InetAddress&lt;/code&gt; is explicitly verified against the certificate through other means, such as by calling `SSLCertificateSocketFactory.getDefaultHostnameVerifier() to get a &lt;code&gt;HostnameVerifier&lt;/code&gt; and calling &lt;code&gt;HostnameVerifier.verify()&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: SSLCertificateSocketFactoryCreateSocket&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintIntentFilterExportedReceiver" defaultSeverity="WARNING" displayName="Unspecified android:exported in manifest" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Unspecified &lt;code&gt;android:exported&lt;/code&gt; in manifest&lt;br&gt;&lt;br&gt;Apps targeting Android 12 and higher are required to specify an explicit value for &lt;code&gt;android:exported&lt;/code&gt; when the corresponding component has an intent filter defined. Otherwise, installation will fail. Set it to &lt;code&gt;true&lt;/code&gt; to make this activity accessible to other apps, and &lt;code&gt;false&lt;/code&gt; to limit it to be used only by this app or the OS. For launch activities, this should be set to true; otherwise, the app will fail to launch.&lt;br/&gt;
&lt;br/&gt;
Previously, &lt;code&gt;android:exported&lt;/code&gt; for components without any intent filters present used to default to &lt;code&gt;false&lt;/code&gt;, and when intent filters were present, the default was &lt;code&gt;true&lt;/code&gt;. Defaults which change value based on other values are confusing and lead to apps accidentally exporting components as a side-effect of adding intent filters. This is a security risk, and we have made this change to avoid introducing accidental vulnerabilities.&lt;br/&gt;
&lt;br/&gt;
While the default without intent filters remains unchanged, it is now required to explicitly specify a value when intent filters are present. Any app failing to meet this requirement will fail to install on any Android version after Android 11.&lt;br/&gt;
&lt;br/&gt;
We recommend setting &lt;code&gt;android:exported&lt;/code&gt; to false (even on previous versions of Android prior to this requirement) unless you have a good reason to export a particular component.&lt;br&gt;&lt;br&gt;Issue id: IntentFilterExportedReceiver&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintWorldReadableFiles" defaultSeverity="WARNING" displayName="openFileOutput() with MODE_WORLD_READABLE" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;&lt;code&gt;openFileOutput()&lt;/code&gt; with &lt;code&gt;MODE_WORLD_READABLE&lt;/code&gt;&lt;br&gt;&lt;br&gt;There are cases where it is appropriate for an application to write world readable files, but these should be reviewed carefully to ensure that they contain no private data that is leaked to other applications.&lt;br&gt;&lt;br&gt;Issue id: WorldReadableFiles&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintWebViewClientOnReceivedSslError" defaultSeverity="WARNING" displayName="Proceeds with the HTTPS connection despite SSL errors" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Proceeds with the HTTPS connection despite SSL errors&lt;br&gt;&lt;br&gt;This check looks for &lt;code&gt;onReceivedSslError&lt;/code&gt; implementations that invoke &lt;code&gt;SslErrorHandler#proceed&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: WebViewClientOnReceivedSslError&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintInvalidPermission" defaultSeverity="ERROR" displayName="Invalid Permission Attribute" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Invalid Permission Attribute&lt;br&gt;&lt;br&gt;Not all elements support the permission attribute. If a permission is set on an invalid element, it is a no-op and ignored. Ensure that this permission attribute was set on the correct element to protect the correct component.&lt;br&gt;&lt;br&gt;Issue id: InvalidPermission&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintProxyPassword" defaultSeverity="WARNING" displayName="Proxy Password in Cleartext" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Proxy Password in Cleartext&lt;br&gt;&lt;br&gt;Storing proxy server passwords in clear text is dangerous if this file is shared via version control. If this is deliberate or this is a truly private project, suppress this warning.&lt;br&gt;&lt;br&gt;Issue id: ProxyPassword&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintWorldWriteableFiles" defaultSeverity="WARNING" displayName="openFileOutput() with MODE_WORLD_WRITEABLE" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;&lt;code&gt;openFileOutput()&lt;/code&gt; with &lt;code&gt;MODE_WORLD_WRITEABLE&lt;/code&gt;&lt;br&gt;&lt;br&gt;There are cases where it is appropriate for an application to write world writeable files, but these should be reviewed carefully to ensure that they contain no private data, and that if the file is modified by a malicious application it does not trick or compromise your application.&lt;br&gt;&lt;br&gt;Issue id: WorldWriteableFiles&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintHardwareIds" defaultSeverity="WARNING" displayName="Hardware Id Usage" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Hardware Id Usage&lt;br&gt;&lt;br&gt;Using these device identifiers is not recommended other than for high value fraud prevention and advanced telephony use-cases. For advertising use-cases, use &lt;code&gt;AdvertisingIdClient$Info#getId&lt;/code&gt; and for analytics, use &lt;code&gt;InstanceId#getId&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: HardwareIds&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/training/articles/user-data-ids.html"&gt;https://developer.android.com/training/articles/user-data-ids.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUsingC2DM" defaultSeverity="ERROR" displayName="Using C2DM" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using C2DM&lt;br&gt;&lt;br&gt;The C2DM library does not work on Android P or newer devices; you should migrate to Firebase Cloud Messaging to ensure reliable message delivery.&lt;br&gt;&lt;br&gt;Issue id: UsingC2DM&lt;br&gt;&lt;br&gt;&lt;a href="https://developers.google.com/cloud-messaging/c2dm"&gt;https://developers.google.com/cloud-messaging/c2dm&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintDeletedProvider" defaultSeverity="ERROR" displayName="Using Deleted Provider" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using Deleted Provider&lt;br&gt;&lt;br&gt;The &lt;code&gt;Crypto&lt;/code&gt; provider has been completely removed in Android P (and was deprecated in an earlier release). This means that the code will throw a &lt;code&gt;NoSuchProviderException&lt;/code&gt; and the app will crash. Even if the code catches that exception at a higher level, this is not secure and should not be used.&lt;br&gt;&lt;br&gt;Issue id: DeletedProvider&lt;br&gt;&lt;br&gt;&lt;a href="https://android-developers.googleblog.com/2018/03/cryptography-changes-in-android-p.html"&gt;https://android-developers.googleblog.com/2018/03/cryptography-changes-in-android-p.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintShortAlarm" defaultSeverity="WARNING" displayName="Short or Frequent Alarm" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Short or Frequent Alarm&lt;br&gt;&lt;br&gt;Frequent alarms are bad for battery life. As of API 22, the &lt;code&gt;AlarmManager&lt;/code&gt; will override near-future and high-frequency alarm requests, delaying the alarm at least 5 seconds into the future and ensuring that the repeat interval is at least 60 seconds.&lt;br/&gt;
&lt;br/&gt;
If you really need to do work sooner than 5 seconds, post a delayed message or runnable to a Handler.&lt;br&gt;&lt;br&gt;Issue id: ShortAlarm&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintKnownPermissionError" defaultSeverity="ERROR" displayName="Value specified for permission is a known error" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Value specified for permission is a known error&lt;br&gt;&lt;br&gt;This check looks for values specified in component permissions that are known errors, such as &lt;code&gt;android:permission="true"&lt;/code&gt;.&lt;br/&gt;
&lt;br/&gt;
 Please double check the permission value you have supplied. The value is expected to be a  permission string from the system, another app, or your own, NOT a boolean.&lt;br&gt;&lt;br&gt;Issue id: KnownPermissionError&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintBidiSpoofing" defaultSeverity="ERROR" displayName="Bidirectional text spoofing" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Bidirectional text spoofing&lt;br&gt;&lt;br&gt;Unicode bidirectional text characters can alter the order in which the compiler processes tokens. However, this can also be used to hide malicious code, and can be difficult to spot. This lint check audits the source code and looks for cases where it looks like bidirectional text has the potential to be misleading.&lt;br&gt;&lt;br&gt;Issue id: BidiSpoofing&lt;br&gt;&lt;br&gt;&lt;a href="https://krebsonsecurity.com/2021/11/trojan-source-bug-threatens-the-security-of-all-code/"&gt;https://krebsonsecurity.com/2021/11/trojan-source-bug-threatens-the-security-of-all-code/&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintExportedService" defaultSeverity="WARNING" displayName="Exported service does not require permission" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Exported service does not require permission&lt;br&gt;&lt;br&gt;Exported services (services which either set &lt;code&gt;exported=true&lt;/code&gt; or contain an intent-filter and do not specify &lt;code&gt;exported=false&lt;/code&gt;) should define a permission that an entity must have in order to launch the service or bind to it. Without this, any application can use this service.&lt;br&gt;&lt;br&gt;Issue id: ExportedService&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintTrustAllX509TrustManager" defaultSeverity="WARNING" displayName="Insecure TLS/SSL trust manager" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Insecure TLS/SSL trust manager&lt;br&gt;&lt;br&gt;This check looks for X509TrustManager implementations whose &lt;code&gt;checkServerTrusted&lt;/code&gt; or &lt;code&gt;checkClientTrusted&lt;/code&gt; methods do nothing (thus trusting any certificate chain) which could result in insecure network traffic caused by trusting arbitrary TLS/SSL certificates presented by peers.&lt;br&gt;&lt;br&gt;Issue id: TrustAllX509TrustManager&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintBadHostnameVerifier" defaultSeverity="WARNING" displayName="Insecure HostnameVerifier" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Insecure HostnameVerifier&lt;br&gt;&lt;br&gt;This check looks for implementations of &lt;code&gt;HostnameVerifier&lt;/code&gt; whose &lt;code&gt;verify&lt;/code&gt; method always returns true (thus trusting any hostname) which could result in insecure network traffic caused by trusting arbitrary hostnames in TLS/SSL certificates presented by peers.&lt;br&gt;&lt;br&gt;Issue id: BadHostnameVerifier&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUsingHttp" defaultSeverity="WARNING" displayName="Using HTTP instead of HTTPS" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using HTTP instead of HTTPS&lt;br&gt;&lt;br&gt;The Gradle Wrapper is available both via HTTP and HTTPS. HTTPS is more secure since it protects against man-in-the-middle attacks etc. Older projects created in Android Studio used HTTP but we now default to HTTPS and recommend upgrading existing projects.&lt;br&gt;&lt;br&gt;Issue id: UsingHttp&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUnprotectedSMSBroadcastReceiver" defaultSeverity="WARNING" displayName="Unprotected SMS BroadcastReceiver" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Unprotected SMS &lt;code&gt;BroadcastReceiver&lt;/code&gt;&lt;br&gt;&lt;br&gt;BroadcastReceivers that declare an intent-filter for &lt;code&gt;SMS_DELIVER&lt;/code&gt; or &lt;code&gt;SMS_RECEIVED&lt;/code&gt; must ensure that the caller has the &lt;code&gt;BROADCAST_SMS&lt;/code&gt; permission, otherwise it is possible for malicious actors to spoof intents.&lt;br&gt;&lt;br&gt;Issue id: UnprotectedSMSBroadcastReceiver&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintJavascriptInterface" defaultSeverity="ERROR" displayName="Missing @JavascriptInterface on methods" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing @JavascriptInterface on methods&lt;br&gt;&lt;br&gt;As of API 17, you must annotate methods in objects registered with the &lt;code&gt;addJavascriptInterface&lt;/code&gt; method with a &lt;code&gt;@JavascriptInterface&lt;/code&gt; annotation.&lt;br&gt;&lt;br&gt;Issue id: JavascriptInterface&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/reference/android/webkit/WebView.html#addJavascriptInterface(java.lang.Object, java.lang.String)"&gt;https://developer.android.com/reference/android/webkit/WebView.html#addJavascriptInterface(java.lang.Object, java.lang.String)&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintDataExtractionRules" defaultSeverity="WARNING" displayName="Missing data extraction rules" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing data extraction rules&lt;br&gt;&lt;br&gt;Before Android 12, the attributes &lt;code&gt;android:allowBackup&lt;/code&gt; and &lt;code&gt;android:fullBackupContent&lt;/code&gt; were used to configure all forms of backup, including cloud backups, device-to-device transfers and adb backup.&lt;br/&gt;
&lt;br/&gt;
In Android 12 and higher, these attributes have been deprecated and will only apply to cloud backups. You should instead use the attribute &lt;code&gt;android:dataExtractionRules&lt;/code&gt;, specifying an &lt;code&gt;@xml&lt;/code&gt; resource that configures which files to back up, for cloud backups and for device-to-device transfers, separately. If your &lt;code&gt;minSdkVersion&lt;/code&gt; supports older versions, you'll still want to specify an &lt;code&gt;android:fullBackupContent&lt;/code&gt; resource if the default behavior is not right for your app.&lt;br&gt;&lt;br&gt;Issue id: DataExtractionRules&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/about/versions/12/backup-restore#xml-changes"&gt;https://developer.android.com/about/versions/12/backup-restore#xml-changes&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintRiskyLibrary" defaultSeverity="ERROR" displayName="Libraries with Privacy or Security Risks" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Libraries with Privacy or Security Risks&lt;br&gt;&lt;br&gt;Your app is using a version of a library that has been identified by the library developer as a potential source of privacy and/or security risks. This may be a violation of Google Play policies (see &lt;a href="https://play.google.com/about/monetization-ads/ads/"&gt;https://play.google.com/about/monetization-ads/ads/&lt;/a&gt;) and/or affect your app&amp;#8217;s visibility on the Play Store.&lt;br/&gt;
&lt;br/&gt;
When available, the individual error messages from lint will include details about the reasons for this advisory.&lt;br/&gt;
&lt;br/&gt;
Please try updating your app with an updated version of this library, or remove it from your app.&lt;br&gt;&lt;br&gt;Issue id: RiskyLibrary&lt;br&gt;&lt;br&gt;&lt;a href="https://play.google.com/sdks"&gt;https://play.google.com/sdks&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintSSLCertificateSocketFactoryGetInsecure" defaultSeverity="WARNING" displayName="Call to SSLCertificateSocketFactory.getInsecure()" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Call to &lt;code&gt;SSLCertificateSocketFactory.getInsecure()&lt;/code&gt;&lt;br&gt;&lt;br&gt;The &lt;code&gt;SSLCertificateSocketFactory.getInsecure()&lt;/code&gt; method returns an SSLSocketFactory with all TLS/SSL security checks disabled, which could result in insecure network traffic caused by trusting arbitrary TLS/SSL certificates presented by peers. This method should be avoided unless needed for a special circumstance such as debugging. Instead, &lt;code&gt;SSLCertificateSocketFactory.getDefault()&lt;/code&gt; should be used.&lt;br&gt;&lt;br&gt;Issue id: SSLCertificateSocketFactoryGetInsecure&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintPackageManagerGetSignatures" defaultSeverity="WARNING" displayName="Potential Multiple Certificate Exploit" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Potential Multiple Certificate Exploit&lt;br&gt;&lt;br&gt;Improper validation of app signatures could lead to issues where a malicious app submits itself to the Play Store with both its real certificate and a fake certificate and gains access to functionality or information it shouldn't have due to another application only checking for the fake certificate and ignoring the rest. Please make sure to validate all signatures returned by this method.&lt;br&gt;&lt;br&gt;Issue id: PackageManagerGetSignatures&lt;br&gt;&lt;br&gt;&lt;a href="https://bluebox.com/technical/android-fake-id-vulnerability/"&gt;https://bluebox.com/technical/android-fake-id-vulnerability/&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection></group><group name="Plugin DevKit" path=""><inspection shortName="DevKitPropertiesQuotesValidation" defaultSeverity="WARNING" displayName="属性文件中的带引号验证" enabled="false" language="Properties" pluginId="DevKit" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告属性值中形参两旁错误的引号数量。
&lt;p&gt;
  如果属性值中存在形参，则必须将该值作为模式传递给 &lt;code&gt;java.text.MessageFormat&lt;/code&gt;。
  也就是说为转义使用单引号。 因此，要让引号可见，必须使用重复的引号：
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;'{0}'&lt;/code&gt; &amp;rarr; &lt;code&gt;{0}&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;''{0}''&lt;/code&gt; &amp;rarr; &lt;code&gt;'$value$'&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
  使用 choice 格式时，会将嵌套格式评估为格式本身，因此必须添加第二个双引号。
  传递 &lt;code&gt;1&lt;/code&gt; 时：
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;{0, choice, 0#no|#1''{0}'' file}&lt;/code&gt; &amp;rarr; &lt;code&gt;{0} files&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;{0, choice, 0#no|#1''''{0}'''' file}&lt;/code&gt; &amp;rarr; &lt;code&gt;'$number_of_files$' files&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="语法简化" path="Scala"><inspection shortName="RedundantNewCaseClass" defaultSeverity="WARNING" displayName="case 类中冗余的 new" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html xmlns="http://www.w3.org/1999/html"&gt;
&lt;body&gt;
&lt;p&gt;报告用于实例化 case 类的 &lt;code&gt;new&lt;/code&gt; 并建议将其删除。&lt;/p&gt;

&lt;p&gt;会自动为 case 类提供 &lt;code&gt;apply&lt;/code&gt; 方法。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  case class Book(isbn: String)
  val guide = new Book("978-0345391803")
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  case class Book(isbn: String)
  val guide = Book("978-0345391803")
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ScalaUnnecessarySemicolon" defaultSeverity="WARNING" displayName="Scala 非必要分号检查" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告并移除不必要的分号。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;
&lt;pre&gt;&lt;code&gt;
  val x = 2;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  val x = 2
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantDefaultArgument" defaultSeverity="WARNING" displayName="实参重复对应形参的默认值" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告与默认值具有相同值的实参。&lt;/p&gt;

&lt;p&gt;该快速修复将移除冗余转换。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  def f(x: Int, y: Int = 0, z: Int) {}
  f(1, y = 0, z = 1)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  def f(x: Int, y: Int = 0, z: Int) {}
  f(1, z = 1)
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PostfixUnaryOperation" defaultSeverity="WARNING" displayName="后缀一元运算" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告对 &lt;code&gt;unary_!&lt;/code&gt;、&lt;code&gt;unary_~&lt;/code&gt; 等的非前缀调用。 建议将其替换为前缀运算符。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  val x = true.unary_!;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  val x = !true
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="AppliedTypeLambdaCanBeSimplified" defaultSeverity="WARNING" displayName="可以简化应用类型 Lambda" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;&lt;p&gt;报告可以简化的类型。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  def test: ({type l[a] = Either[String, a]})#l[Int] = ???
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  def test: Either[String, Int] = ???
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FunctionTupleSyntacticSugar" defaultSeverity="WEAK WARNING" displayName="语法糖" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;&lt;p&gt;报告对可以替换为语法糖的 FunctionN 和 TupleN 的显式引用。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  val func: Function1[Int, Int] =
    a =&gt; a + 4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  val func: (Int) =&gt; Int =
    a =&gt; a + 4
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RemoveRedundantReturn" defaultSeverity="WARNING" displayName="冗余 return" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告冗余 &lt;code&gt;return&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;方法中的最后一条语句会自动返回，在这种情况下使用 &lt;code&gt;return&lt;/code&gt; 关键字是冗余的。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  def test: Int = {
    return 3
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  def test: Int = {
    3
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConvertibleToMethodValue" defaultSeverity="WARNING" displayName="可转换为方法值的匿名函数" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告可以 eta 扩展的匿名函数，也报告可以从 eta 扩展中移除的占位符。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  def f(x: Any, y: Int): Unit = ()
  val x = f(_, _)
  val y: (Int, Int) =&gt; Unit = f _
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  def f(x: Any, y: Int): Unit = ()
  val x = f _
  val y: (Int, Int) =&gt; Unit = f
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="Android Lint: Productivity" path=""><inspection shortName="AndroidLintKtxExtensionAvailable" defaultSeverity="INFO" displayName="KTX Extension Available" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;KTX Extension Available&lt;br&gt;&lt;br&gt;Android KTX extensions augment some libraries with support for modern Kotlin language features like extension functions, extension properties, lambdas, named parameters, coroutines, and more.&lt;br/&gt;
&lt;br/&gt;
In Kotlin projects, use the KTX version of a library by replacing the dependency in your &lt;code&gt;build.gradle&lt;/code&gt; file. For example, you can replace &lt;code&gt;androidx.fragment:fragment&lt;/code&gt; with &lt;code&gt;androidx.fragment:fragment-ktx&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: KtxExtensionAvailable&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/kotlin/ktx"&gt;https://developer.android.com/kotlin/ktx&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection></group><group name="描述文件" path="Plugin DevKit"><inspection shortName="PostfixTemplateDescriptionNotFound" defaultSeverity="WARNING" displayName="后缀模板描述检查器" enabled="false" language="UAST" pluginId="DevKit" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告缺少 HTML 描述文件、&lt;code&gt;before.template&lt;/code&gt; 文件或 &lt;code&gt;after.template&lt;/code&gt; 文件的后缀模板。
它们显示在&lt;a href="settings://reference.settingsdialog.IDE.editor.postfix.templates"&gt;设置 | 编辑器 | 常规 | 后缀补全&lt;/a&gt;中。
&lt;p&gt;
  &lt;b&gt;创建描述文件&lt;/b&gt;快速修复会创建模板 HTML 描述文件。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="InspectionDescriptionNotFoundInspection" defaultSeverity="WARNING" displayName="检查描述检查器" enabled="false" language="UAST" pluginId="DevKit" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告缺少 HTML 描述文件（即包含此类文本的文件）的检查。
&lt;p&gt;
  &lt;b&gt;创建描述文件&lt;/b&gt;快速修复会创建模板 HTML 描述文件。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="IntentionDescriptionNotFoundInspection" defaultSeverity="WARNING" displayName="意图描述检查器" enabled="false" language="UAST" pluginId="DevKit" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告缺少 HTML 描述文件、&lt;code&gt;before.template&lt;/code&gt; 文件或 &lt;code&gt;after.template&lt;/code&gt; 文件的意图。
它们显示在&lt;a href="settings://preferences.intentionPowerPack"&gt;设置 | 编辑器 | 意图&lt;/a&gt;中。
&lt;p&gt;
  &lt;b&gt;创建描述文件&lt;/b&gt;快速修复会创建模板 HTML 描述文件。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="线程问题" path="Groovy"><inspection shortName="GroovyAccessToStaticFieldLockedOnInstance" defaultSeverity="WARNING" displayName="访问实例数据上锁定的 static 字段" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对在 &lt;code&gt;this&lt;/code&gt; 或 &lt;code&gt;this&lt;/code&gt; 的实例字段上锁定的非常量 static 字段的访问。
&lt;p&gt;
  在实例数据上锁定 static 字段并不能防止其他实例修改该字段，因此可能会导致意外的竞争条件。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  static String s;
  def foo() {
      synchronized (this) {
          System.out.println(s); // 警告
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovySynchronizedMethod" defaultSeverity="WARNING" displayName="synchronized 方法" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告方法上的 &lt;code&gt;synchronized&lt;/code&gt; 修饰符。
&lt;p&gt;
  某些编码标准禁止使用 &lt;code&gt;synchronized&lt;/code&gt; 修饰符，而是支持 &lt;code&gt;synchronized&lt;/code&gt; 语句。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovySynchronizationOnNonFinalField" defaultSeverity="WARNING" displayName="在非 final 字段上同步" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告其中的锁定表达式为非 &lt;code&gt;final&lt;/code&gt; 字段的 &lt;code&gt;synchronized&lt;/code&gt; 语句。
&lt;p&gt;
  此类语句不太可能包含有用的语义，因为不同的线程即便在对同一对象操作时也可能在不同的对象上锁定。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyDoubleCheckedLocking" defaultSeverity="WARNING" displayName="双重检查锁定" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告&lt;a href="https://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html"&gt;双重检查锁定&lt;/a&gt;。
&lt;p&gt;
  双重检查锁定会尝试以线程安全的方式按需初始化字段，同时避免同步的开销。
  遗憾的是，在未被声明为 &lt;code&gt;volatile&lt;/code&gt; 的字段上使用时，它不具备线程安全。
  在使用 Java 1.4 或更早的版本时，双重检查锁定即便对 &lt;code&gt;volatile&lt;/code&gt; 字段也不起作用。
  阅读上面的链接文章，了解该问题的详细说明。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
      private Helper helper = null

      Helper getHelper() {
          if (helper == null)
              synchronized(this) {
                  if (helper == null) {
                      helper = new Helper()
                  }
              }
          }
          return helper;
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyPublicFieldAccessedInSynchronizedContext" defaultSeverity="WARNING" displayName="在同步上下文中访问的非 private 字段" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在同步上下文中访问的非 &lt;code&gt;final&lt;/code&gt;、非 &lt;code&gt;private&lt;/code&gt; 字段。
&lt;p&gt;
  不能保证始终以同步方式访问非 private 字段，此类“部分同步的”访问可能意外导致不一致的数据结构。 出于此检查的目的，将忽略构造函数和初始值设定项中的访问。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyUnconditionalWait" defaultSeverity="WARNING" displayName="无条件的 'wait' 调用" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告在同步上下文中无条件调用的 &lt;b&gt;wait()&lt;/b&gt;。
通常，&lt;b&gt;wait()&lt;/b&gt; 用于在某个条件为 true 前阻塞线程。 如果是无条件调用 &lt;b&gt;wait()&lt;/b&gt;，则通常表示已在获取锁定之前检查条件。 在这种情况下，如果条件在检查的时间与获得锁定的时间之间变为 true，则可能会发生数据竞争。 虽然此检查发现的结构未必不正确，但肯定值得检查。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyWaitWhileNotSynchronized" defaultSeverity="WARNING" displayName="未同步时使用 'wait()'" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告不是在相应的 synchronized 语句或 synchronized 方法中进行的 &lt;code&gt;wait()&lt;/code&gt; 调用。&lt;/p&gt;
&lt;p&gt;在没有持有锁定的对象上调用 &lt;code&gt;wait()&lt;/code&gt; 会导致抛出 &lt;code&gt;IllegalMonitorStateException&lt;/code&gt;。
此类结构不一定错误，因为在调用该包含方法前可能已获取必要的锁定，但即便如此，还是要仔细查看。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyEmptySyncBlock" defaultSeverity="WARNING" displayName="空 'synchronized' 块" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告语句体为空的 &lt;code&gt;synchronized&lt;/code&gt; 语句。 虽然在理论上这种语义可能是有意为之，但此构造令人困惑，并且通常是由拼写错误所致。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
synchronized(lock) {
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovySynchronizationOnThis" defaultSeverity="WARNING" displayName="在 'this' 上同步" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告使用 &lt;code&gt;this&lt;/code&gt; 作为其锁定表达式的同步。
&lt;p&gt;
  报告的结构包括锁定 &lt;code&gt;this&lt;/code&gt; 的 &lt;code&gt;synchronized&lt;/code&gt; 块，以及对以 &lt;code&gt;wait()&lt;/code&gt; 为目标的 &lt;code&gt;wait()&lt;/code&gt; &lt;code&gt;notify()&lt;/code&gt; 或 &lt;code&gt;notifyAll()&lt;/code&gt; 的调用。
  此类结构（如 synchronized 方法）会导致难以跟踪给定对象上锁定的对象，并且可能导致对象遭到“拒绝服务”攻击。 替代做法是考虑在 private 实例变量上锁定，从而完全控制对该对象的访问。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovySystemRunFinalizersOnExit" defaultSeverity="WARNING" displayName="System.runFinalizersOnExit() 调用" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对 &lt;code&gt;System.runFinalizersOnExit()&lt;/code&gt; 的调用。
&lt;p&gt;
  此调用是 Java 语言中最危险的调用之一。 它本质上为非线程安全，可能导致数据损坏、死锁，并可能影响远离调用点的程序部分。
  已弃用，强烈建议不要使用。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyWaitCallNotInLoop" defaultSeverity="WARNING" displayName="'wait()' 不在循环中" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告不是在循环中进行的 &lt;code&gt;wait()&lt;/code&gt; 调用。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;wait()&lt;/code&gt; 通常用于挂起线程，直到某个条件变成 true 为止，并且应在 &lt;code&gt;wait()&lt;/code&gt; 返回后检查该条件。 使用循环很容易做到这一点。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyNotifyWhileNotSynchronized" defaultSeverity="WARNING" displayName="未同步时使用 'notify()' 或 'notifyAll()'" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告不是在相应的 synchronized 语句或 synchronized 方法中进行的 &lt;code&gt;notify()&lt;/code&gt; 和 &lt;code&gt;notifyAll()&lt;/code&gt; 调用。
&lt;p&gt;
  在没有持有锁定的对象上调用这些方法会导致抛出 &lt;code&gt;IllegalMonitorStateException&lt;/code&gt;。
  此类结构不一定错误，因为在调用该包含方法前可能已获取必要的锁定，但即便如此，还是要仔细查看。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyWhileLoopSpinsOnField" defaultSeverity="WARNING" displayName="While 循环在字段上自旋" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告在非 &lt;code&gt;volatile&lt;/code&gt; 字段值上自旋，等待它被另一个线程更改的 &lt;code&gt;while&lt;/code&gt; 循环。&lt;/p&gt;
&lt;p&gt;
除了在循环内完成少量工作时可能会非常耗费 CPU 之外，此类循环很可能具有与预期不同的语义。 即便另一个线程改变了该字段的值，Java 内存模型也允许该循环永不完成。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class SpinsOnField {
      boolean ready = false;

      void run() {
          // 即使在从其他线程调用 markAsReady 后，
          // 该循环也可能永不完成
          while (!ready) {
          }
          // 执行某些工作
      }

      void markAsReady() {
          ready = true;
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
此外，自 Java 9 起，建议在 &lt;code&gt;volatile&lt;/code&gt; 字段的自旋循环中调用 &lt;code&gt;Thread.onSpinWait()&lt;/code&gt;，这可能会显著提高在某些硬件上的性能。
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
使用下面的复选框可使此检查仅报告空 &lt;code&gt;while&lt;/code&gt; 循环。
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyUnsynchronizedMethodOverridesSynchronizedMethod" defaultSeverity="WARNING" displayName="未同步方法重写 synchronized 方法" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告重写 &lt;b&gt;synchronized&lt;/b&gt; 方法的非 &lt;b&gt;synchronized&lt;/b&gt; 方法。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  abstract class Base {
      &lt;b&gt;synchronized&lt;/b&gt; void foo() {
          // ...
      }
  }
  class Derived extends Base {
      @Override
      &lt;b&gt;void foo()&lt;/b&gt; {
          super.foo()
            // ...
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在这里，类 &lt;code&gt;Bar&lt;/code&gt; 中的非 synchronized 方法 &lt;code&gt;foo()&lt;/code&gt; 会重写 synchronized 方法。
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyBusyWait" defaultSeverity="WARNING" displayName="繁忙等待" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在循环内发生的对 &lt;code&gt;java.lang.Thread.sleep()&lt;/code&gt; 的调用。
&lt;p&gt;
  此类调用表示“繁忙-等待”。 忙等待通常效率低下，并且可能导致意外死锁，因为忙等待线程不会释放锁定的资源。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyNestedSynchronizedStatement" defaultSeverity="WARNING" displayName="嵌套 'synchronized' 语句" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告嵌套的 &lt;code&gt;synchronized&lt;/code&gt; 语句。
&lt;p&gt;
  嵌套的 &lt;code&gt;synchronized&lt;/code&gt; 语句要么冗余（如果锁定对象相同），要么容易导致死锁。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyThreadStopSuspendResume" defaultSeverity="WARNING" displayName="Thread.stop()、Thread.suspend() 或 Thread.resume() 调用" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对 &lt;code&gt;Thread.stop()&lt;/code&gt;、&lt;code&gt;Thread.suspend()&lt;/code&gt; 或 &lt;code&gt;Thread.resume()&lt;/code&gt; 的调用。
&lt;p&gt;
  这些调用在本质上容易导致数据损坏和死锁，因此强烈建议不使用。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovySynchronizationOnVariableInitializedWithLiteral" defaultSeverity="WARNING" displayName="在使用文字初始化的变量上同步" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在使用文字初始化的对象上锁定的 synchronized 块。
&lt;p&gt;
  字符串文字是暂存的，&lt;code&gt;Number&lt;/code&gt; 文字可以从缓存中分配。 正因为如此，可能系统的其他某些部分（使用通过相同文字初始化的对象）实际上会包含对完全相同的对象的引用。 如果字符串被认为是 private 对象，这可能会产生意外的死锁情况。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="按位运算问题" path="JavaScript and TypeScript"><inspection shortName="JSBitwiseOperatorUsage" defaultSeverity="WARNING" displayName="按位运算符用法" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告按位 AND ("&lt;code&gt;&amp;&lt;/code&gt;") 或 OR ("&lt;code&gt;|&lt;/code&gt;") 运算符的可疑用法。
通常这是拼写错误，应为应用布尔运算 AND ("&lt;code&gt;&amp;&amp;&lt;/code&gt;") 和 OR ("&lt;code&gt;||&lt;/code&gt;") 的结果。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PointlessBitwiseExpressionJS" defaultSeverity="WARNING" displayName="可以简化按位表达式" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;!-- Copied from community/plugins/InspectionGadgets/src/inspectionDescriptions/PointlessBitwiseExpression.html --&gt;
&lt;html&gt;
&lt;body&gt;
报告包含 &lt;code&gt;and&lt;/code&gt; 零、 &lt;code&gt; or&lt;/code&gt; 零或零移位的表达式。 此类表达式可能是由于没有完全完成自动化重构而造成。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ShiftOutOfRangeJS" defaultSeverity="WARNING" displayName="通过可能错误的常量进行移位运算" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;!-- Copied from community/plugins/InspectionGadgets/src/inspectionDescriptions/ShiftOutOfRange.html --&gt;
&lt;html&gt;
&lt;body&gt;
报告此类情况下的移位运算，即第二个操作数是合理范围外的常量，例如 &lt;code&gt;0..31&lt;/code&gt; 范围外的整数移位运算，移位的值为负值或过大的值。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="IncompatibleMaskJS" defaultSeverity="WARNING" displayName="不兼容的按位掩码运算" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;!-- Copied from community/plugins/InspectionGadgets/src/inspectionDescriptions/IncompatibleMask.html --&gt;
&lt;html&gt;
&lt;body&gt;
报告确定评估为 &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt;
的按位掩码表达式。
表达式的形式为 &lt;code&gt;(var &amp; constant1) == constant2&lt;/code&gt; 或
&lt;code&gt;(var | constant1) == constant2&lt;/code&gt;，其中 &lt;code&gt;constant1&lt;/code&gt; 
和 &lt;code&gt;constant2&lt;/code&gt; 是不兼容的位掩码常量。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;
// 不兼容的掩码：由于掩码中的最后一个字节为零，
// 因此 0x1200 是可能的，但 0x1234 不可能
if ((mask &amp; 0xFF00) == 0x1234) {...}
&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name=" Android Lint: Security" path=""><inspection shortName="AndroidLintSetWorldWritable" defaultSeverity="WARNING" displayName="File.setWritable() used to make file world-writable" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;&lt;code&gt;File.setWritable()&lt;/code&gt; used to make file world-writable&lt;br&gt;&lt;br&gt;Setting files world-writable is very dangerous, and likely to cause security holes in applications. It is strongly discouraged; instead, applications should use more formal mechanisms for interactions such as &lt;code&gt;ContentProvider&lt;/code&gt;, &lt;code&gt;BroadcastReceiver&lt;/code&gt;, and &lt;code&gt;Service&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: SetWorldWritable&lt;/body&gt;&lt;/html&gt;</inspection></group><group name="选项" path="Scala，集合"><inspection shortName="MapGetOrElse" defaultSeverity="WARNING" displayName="将 Map 和 getOrElse 转换为 fold" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 &lt;code&gt;Option&lt;/code&gt; 上的 &lt;code&gt;map&lt;/code&gt; 和 &lt;code&gt;getOrElse&lt;/code&gt;，并建议将其替换为 &lt;code&gt;fold&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  def p(x: Int): Boolean = ???
  Option(0).map(p).getOrElse(false)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  def p(x: Int): Boolean = ???
  Option(0).fold(false)(p)
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="IfElseToOption" defaultSeverity="WARNING" displayName="仿真的 Option(x)" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告模拟对 &lt;code&gt;Option.apply(x)&lt;/code&gt; 的调用。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (x == null) None else Some(x)
  if (x != null) Some(x) else None
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Option(x)
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SomeToOption" defaultSeverity="WARNING" displayName="Some 转换为 Option" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告并将 &lt;code&gt;Some(a)&lt;/code&gt; 替换为 &lt;code&gt;Option(a)&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Option&lt;/code&gt; 将额外检查 &lt;code&gt;a&lt;/code&gt; 是否为 &lt;code&gt;null&lt;/code&gt;，如果是，则结果为 &lt;code&gt;None&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Some(a)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Option(a)
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="OptionEqualsSome" defaultSeverity="WARNING" displayName="Some(x) 等同于 contains(x)" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告简化 &lt;code&gt;Option&lt;/code&gt; 和 &lt;code&gt;Some(x)&lt;/code&gt; 相等检查的机会。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  option == Some(x)
  Some(x) != option
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  option.contains(x)
  !option.contains(x)
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantHeadOrLastOption" defaultSeverity="WARNING" displayName="冗余的 headOption 或 lastOption" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;在 &lt;code&gt;Option&lt;/code&gt; 的实例上报告 &lt;code&gt;headOption&lt;/code&gt; 和 &lt;code&gt;lastOption&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;该快速修复会移除此类冗余调用。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Option(1).lastOption
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Option(1)
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MapGetOrElseBoolean" defaultSeverity="WARNING" displayName="Map 和 getOrElse(false) 转换为 exists" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 &lt;code&gt;map&lt;/code&gt; 和 &lt;code&gt;getOrElse(false)&lt;/code&gt;/&lt;code&gt;getOrElse(true)&lt;/code&gt; 并建议将其替换为 &lt;code&gt;exists&lt;/code&gt;/&lt;code&gt;forall&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  def p(x: Int): Boolean = ???
  Option(0).map(p).getOrElse(false)
  Option(0).map(p).getOrElse(true)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  def p(x: Int): Boolean = ???
  Option(0).exists(p)
  Option(0).forall(p)
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="GetOrElseNull" defaultSeverity="WARNING" displayName="GetOrElse(null) 转换为 orNull" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 &lt;code&gt;getOrElse(null)&lt;/code&gt; 并建议将其替换为 &lt;code&gt;orNull&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  option getOrElse null
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  option.orNull
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="IfElseToFilterdOption" defaultSeverity="WARNING" displayName="更改为 filter" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告评估为 &lt;code&gt;Option&lt;/code&gt; 的 if 语句，并建议将其替换为 &lt;code&gt;filter&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  def condition(x: Int): Boolean = ???
  val value = 3
  if (condition(value)) Some(value) else None
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  def condition(x: Int): Boolean = ???
  val value = 3
  Some(value).filter(condition)
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="资源泄漏" path="Scala"><inspection shortName="SourceNotClosed" defaultSeverity="WARNING" displayName="源代码未闭合" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告未关闭的 &lt;code&gt;scala.io.Source&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;直接在由 &lt;code&gt;fromFile&lt;/code&gt;、&lt;code&gt;fromURL&lt;/code&gt; 或 &lt;code&gt;fromURI&lt;/code&gt; 打开的 &lt;code&gt;Source&lt;/code&gt; 上使用 &lt;code&gt;.mkString&lt;/code&gt; 或 &lt;code&gt;.getLines&lt;/code&gt; 之类的函数将泄漏底层文件句柄。&lt;/p&gt;

&lt;p&gt;考虑使用 &lt;code&gt;.close()&lt;/code&gt; 和 &lt;code&gt;try&lt;/code&gt;/&lt;code&gt;finally&lt;/code&gt; 来管理资源的生命周期或使用 &lt;a href="https://scala-lang.org/files/archive/api/2.13.0/scala/util/Using$.html"&gt;Scala 2.13 的 &lt;code&gt;Using&lt;/code&gt;&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Source.fromFile("file.txt").getLines()
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="正则表达式" path=""><inspection shortName="RegExpDuplicateCharacterInClass" defaultSeverity="WARNING" displayName="字符类中存在重复字符" enabled="false" language="RegExp" pluginId="com.intellij" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告正则表达式字符类中的重复字符。
重复字符是多余的，可将其移除而不改变正则表达式的语义。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  [aabc]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  [abc]
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RegExpDuplicateAlternationBranch" defaultSeverity="WARNING" displayName="替代项中存在重复分支" enabled="false" language="RegExp" pluginId="com.intellij" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告正则表达式替换中的重复分支。
重复分支会降低匹配速度并导致表达式意图不明。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  (alpha|bravo|charlie|alpha)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  (alpha|bravo|charlie)
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2017.1 最新变化&lt;/small&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RegExpUnnecessaryNonCapturingGroup" defaultSeverity="WARNING" displayName="不必要的非捕获组" enabled="false" language="RegExp" pluginId="com.intellij" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告不必要的非捕获组（对匹配结果无影响）。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Everybody be cool, (?:this) is a robbery!
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Everybody be cool, this is a robbery!
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2021.1 最新变化&lt;/small&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RegExpAnonymousGroup" defaultSeverity="WARNING" displayName="匿名捕获组或数字反向引用" enabled="false" language="RegExp" pluginId="com.intellij" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告正则表达式中的匿名捕获组和数字反向引用。
只有正则表达式方言支持命名组和命名组引用，才支持这些用法。
命名组和命名反向引用可改进代码可读性，建议改用。
无需捕获时，使用非捕获组，即使用 &lt;code&gt;(?:xxx)&lt;/code&gt; 而不是 &lt;code&gt;(xxx)&lt;/code&gt;，可以提高匹配效率和减少需要使用的内存。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  (\d\d\d\d)\1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;更好的正则表达式模式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  (?&amp;lt;quad&gt;\d\d\d\d)\k&amp;lt;quad&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2017.2 最新变化&lt;/small&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RegExpEscapedMetaCharacter" defaultSeverity="INFORMATION" displayName="转义元字符" enabled="false" language="RegExp" pluginId="com.intellij" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告转义元字符。
某些正则表达式代码样式指定应将元字符放在字符类中，从而使正则表达式更易于理解。
此检查不会警告元字符 &lt;code&gt;[&lt;/code&gt;, &lt;code&gt;]&lt;/code&gt; 和 &lt;code&gt;^&lt;/code&gt;，因为这些字符可能需要在字符类中进行额外的转义。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  \d+\.\d+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  \d+[.]\d+
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2017.1 最新变化&lt;/small&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RegExpRedundantEscape" defaultSeverity="WARNING" displayName="冗余字符转义" enabled="false" language="RegExp" pluginId="com.intellij" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以替换为保留其含义的非转义字符的冗余字符转义序列。
许多在字符类外部必需的转义序列在字符类的方括号 &lt;code&gt;[]&lt;/code&gt; 内部冗余。
&lt;p&gt;
  尽管某些方言（JavaScript、Python 等）允许在字符类外部使用未转义的左大括号 &lt;code&gt;{&lt;/code&gt;，但这样可能会导致混乱并降低模式的可移植性，因为某些方言要求将大括号作为字符进行转义。
  因此，该检查不会报告转义的左大括号。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  \-\;[\.]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  -;[.]
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;b&gt;忽略转义的右括号 '}' 和 ']'&lt;/b&gt; 选项可以指定当 RegExp 方言允许在字符类外部使用未转义的 &lt;code&gt;\}&lt;/code&gt; 和 &lt;code&gt;\]&lt;/code&gt; 时是否报告它们。
&lt;p&gt;&lt;small&gt;2017.3 最新变化&lt;/small&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RegExpRedundantClassElement" defaultSeverity="WEAK WARNING" displayName="冗余的 '\d', '[:digit:]'，或 '\D' 类元素" enabled="false" language="RegExp" pluginId="com.intellij" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在同一个类中与 &lt;code&gt;\w&lt;/code&gt; 或 &lt;code&gt;[:word:]&lt;/code&gt;（带 &lt;code&gt;\W&lt;/code&gt; 的 &lt;code&gt;\D&lt;/code&gt;）一起使用且可移除的冗余 &lt;code&gt;\d&lt;/code&gt; 或 &lt;code&gt;[:digit:]&lt;/code&gt;。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  [\w\d]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  [\w]
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2022.2 最新变化&lt;/small&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RegExpRedundantNestedCharacterClass" defaultSeverity="WARNING" displayName="冗余嵌套字符类" enabled="false" language="RegExp" pluginId="com.intellij" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告非必要的嵌套字符类。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  [a-c[x-z]]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  [a-cx-z]
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2020.2 最新变化&lt;/small&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RegExpRepeatedSpace" defaultSeverity="WARNING" displayName="连续空格" enabled="false" language="RegExp" pluginId="com.intellij" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告正则表达式中的多个连续空格。
由于空格默认不可见，因此，很难了解需要的空格数量。
使用单个空格和计数量词来替换连续空格可以让正则表达式更清晰易懂。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  (     )
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  ( {5})
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;small&gt;2017.1 最新变化&lt;/small&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RegExpEmptyAlternationBranch" defaultSeverity="WARNING" displayName="替代项中存在空分支" enabled="false" language="RegExp" pluginId="com.intellij" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告正则表达式替换中的空分支。
空分支只能匹配空字符串，在大多数情况下，这并不是我们的目的。
此检查不会报告位于替换开头或末尾的单个空分支。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  (alpha||bravo)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  (alpha|bravo)
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2017.2 最新变化&lt;/small&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RegExpSuspiciousBackref" defaultSeverity="WARNING" displayName="可疑的反向引用" enabled="false" language="RegExp" pluginId="com.intellij" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在运行时无法解析的反向引用。
这意味着反向引用永远无法匹配任何内容。
如果组是在反向引用之后定义的，或者组是在替代项的不同分支中定义的，则反向引用将不可解析。
&lt;p&gt;&lt;b&gt;在其反向引用之后定义的组的示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  \1(abc)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;b&gt;不同分支中的组和反向引用的示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  a(b)c|(xy)\1z
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2022.1 最新变化&lt;/small&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RegExpSimplifiable" defaultSeverity="WEAK WARNING" displayName="正则表达式可以简化" enabled="false" language="RegExp" pluginId="com.intellij" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以简化的正则表达式。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  [a] xx* [ah-hz]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  a x+ [ahz]
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2022.1 最新变化&lt;/small&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RegExpOctalEscape" defaultSeverity="INFORMATION" displayName="八进制转义" enabled="false" language="RegExp" pluginId="com.intellij" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告八进制转义（容易与反向引用混淆）。
使用十六进制转义可避免混淆。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  \07
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  \x07
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2017.1 最新变化&lt;/small&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RegExpUnexpectedAnchor" defaultSeverity="WARNING" displayName="起始或结束定位点在意外位置" enabled="false" language="RegExp" pluginId="com.intellij" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告不在模式开头的 &lt;code&gt;^&lt;/code&gt; 或 &lt;code&gt;\A&lt;/code&gt; 定位标记以及不在模式末尾的 &lt;code&gt;$&lt;/code&gt;、&lt;code&gt;\Z&lt;/code&gt; 或 &lt;code&gt;\z&lt;/code&gt; 定位标记。
如果这些正则表达式定位标记位于错误的位置，则会阻止模式与任何对象匹配。
对于 &lt;code&gt;^&lt;/code&gt; 和 &lt;code&gt;$&lt;/code&gt; 定位标记，则很可能是指文字字符，并且忘记了转义。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  (Price $10)
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;small&gt;2018.1 最新变化&lt;/small&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RegExpSingleCharAlternation" defaultSeverity="WARNING" displayName="单字符替代项" enabled="false" language="RegExp" pluginId="com.intellij" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告正则表达式中的单一字符替换。
改用一个字符类更简单。
这还可能提高匹配性能。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  a|b|c|d
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  [abcd]
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;small&gt;2017.1 最新变化&lt;/small&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Oracle" path=""><inspection shortName="OraMissingBodyInspection" defaultSeverity="WARNING" displayName="缺少软件包/对象类型规范的主体" enabled="false" language="Oracle" pluginId="com.intellij.database" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告缺少主体声明的软件包和对象类型规范。
&lt;p&gt;声明例程的软件包规范和对象类型以及带有光标的软件包规范必须具有实现这些例程和光标的主体声明。 在程序代码中调用例程或光标时，缺少主体会导致运行时错误。&lt;/p&gt;
&lt;p&gt;示例（Oracle）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE OR REPLACE PACKAGE ppp IS
    FUNCTION foo(a INT) RETURN INT;
END;&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="OraOverloadInspection" defaultSeverity="WARNING" displayName="重载错误" enabled="false" language="Oracle" pluginId="com.intellij.database" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 Oracle 中子程序重载的无效情况。
&lt;p&gt;示例（Oracle）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;DECLARE
    SUBTYPE fff IS BINARY_INTEGER;
    SUBTYPE ggg IS NATURAL;
    PROCEDURE foo (a IN ggg) IS BEGIN NULL; END;
    PROCEDURE foo (a IN fff) IS BEGIN NULL; END;
BEGIN
    NULL;
END;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;您不能重载形参仅在子类型方面不同的子程序。 例如，您不能重载一个接受 BINARY INTEGER 形参而另一个接受 NATURAL 形参的过程。 有关过程重载限制的更多信息，请参阅 &lt;a href="https://docs.oracle.com/cd/B19306_01/appdev.102/b14261/subprograms.htm"&gt;docs.oracle.com 上的“重载限制”&lt;/a&gt;页面。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="OraUnmatchedForwardDeclarationInspection" defaultSeverity="ERROR" displayName="不含定义的前向声明" enabled="false" language="Oracle" pluginId="com.intellij.database" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在代码中缺少实现的过程和函数的声明。
&lt;p&gt;在 Oracle 中，您可以声明一个没有主体的过程或函数，并在稍后的某个时间编写实现。 该检查将报告未实现的此类过程或函数的名称。&lt;/p&gt;
&lt;p&gt;示例（Oracle）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;DECLARE PROCEDURE foo(a int, b varchar2);
BEGIN
    NULL;
END;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;foo&lt;/code&gt; 过程已被声明，但缺少实现。 我们可以添加实现来消除错误。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;DECLARE PROCEDURE foo(a int, b varchar2);
  PROCEDURE foo(a int, b varchar2) IS
BEGIN
    NULL;
END;
BEGIN
    NULL;
END;&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="完成" path="Java"><inspection shortName="FinalizeNotProtected" defaultSeverity="WARNING" displayName="'finalize()' 应为 protected，不应为 public" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告被声明为 &lt;code&gt;public&lt;/code&gt; 的 &lt;code&gt;Object.finalize()&lt;/code&gt; 方法的任何实现。
&lt;p&gt;
  根据 &lt;code&gt;Object.finalize()&lt;/code&gt; 的约定，只有垃圾回收器调用此方法。 将此方法设为 public 可能令人困惑，因为这意味着该方法可以从其他代码中使用。
&lt;/p&gt;
&lt;p&gt;
  可以通过快速修复将该方法设为 &lt;code&gt;protected&lt;/code&gt;，以防止它被其他类调用。
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;class&lt;/b&gt; X {
    &lt;b&gt;public void&lt;/b&gt; finalize() {
      /* ... */
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;class&lt;/b&gt; X {
    &lt;b&gt;protected void&lt;/b&gt; finalize() {
      /* ... */
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="Finalize" defaultSeverity="WARNING" displayName="'finalize()' 不应被重写" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告重写 &lt;code&gt;Object.finalize()&lt;/code&gt; 方法。
&lt;p&gt;根据 &lt;code&gt;Object.finalize()&lt;/code&gt; 文档：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;
    终结机制本身就有问题。 终结可能导致性能问题、死锁和挂起。 终结器中的错误可能导致资源泄漏；如果不再需要，那么无从取消终结；并且对不同对象的 &lt;code&gt;finalize&lt;/code&gt; 方法的调用之间没有指定顺序。 此外，关于终结时机也没有任何保证。 &lt;code&gt;finalize&lt;/code&gt; 方法只能在不确定的延迟之后才对可终结的对象调用（如果有）。
  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;配置检查：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    使用&lt;b&gt;对普通 'finalize()' 实现忽略&lt;/b&gt;选项可以忽略具有空方法体或仅包含具有计算结果为 &lt;code&gt;false&lt;/code&gt; 的条件并且是编译时常量的 &lt;code&gt;if&lt;/code&gt; 语句的方法体的 &lt;code&gt;finalize()&lt;/code&gt; 实现。 出于性能原因，在子类中使用空实现重写非普通 &lt;code&gt;finalize()&lt;/code&gt; 可能会有好处。 空的 final &lt;code&gt;finalize()&lt;/code&gt; 实现也可以用来防止子类被重写。
  &lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NoExplicitFinalizeCalls" defaultSeverity="WARNING" displayName="'finalize()' 被显式调用" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对 &lt;code&gt;Object.finalize()&lt;/code&gt; 的调用。
&lt;p&gt;显式调用 &lt;code&gt;Object.finalize()&lt;/code&gt; 可能导致对象处于不一致的状态。
  垃圾收集器在确定没有对该对象的引用时，自动对该对象调用此方法。&lt;/p&gt;
&lt;p&gt;该检查不报告 &lt;code&gt;finalize()&lt;/code&gt; 实现中对 &lt;code&gt;super.finalize()&lt;/code&gt; 的调用，因为它们是良性的。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  MyObject m = new MyObject();
  m.finalize();
  System.gc()
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="国际化" path="Java"><inspection shortName="DialogTitleCapitalization" defaultSeverity="WARNING" displayName="错误的字符串大小写" enabled="false" language="UAST" pluginId="com.intellij.java-i18n" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;&lt;body&gt;
报告方法形参中的字符串和使用 &lt;code&gt;@Nls&lt;/code&gt; 注解的返回值，并将形参大写以符合大多数平台 UI 指南中的大写规则。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void setTitle(@NlsContexts.DialogTitle String title) {}
  setTitle("This is sentence capitalization but should be title"); 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  setTitle("This Is Sentence Capitalization but Should Be Title"); 
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="UnnecessaryUnicodeEscape" defaultSeverity="WARNING" displayName="不必要的 Unicode 转义序列" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告不必要的 unicode 转义序列。 例如，当文件编码可以在不转义的情况下处理字符时。
此检查不报告 Unicode 控制字符（换行符和制表符除外）。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;String s = "\u0062";&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="HardCodedStringLiteral" defaultSeverity="WARNING" displayName="硬编码字符串" enabled="false" language="UAST" pluginId="com.intellij.java-i18n" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告硬编码 &lt;code&gt;String&lt;/code&gt; 文字的任何实例。
&lt;p&gt;硬编码的 &lt;code&gt;String&lt;/code&gt; 文字在国际化环境中可能是错误的。 此检查不会报告空字符串和仅包含空格的字符串。 可以使用快速修复将字符串文字转换为 &lt;code&gt;java.util.ResourceBundle.getString()&lt;/code&gt; 方法调用。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;使用检查的选项可进一步专门化此检查是否应报告以下位置的字符串：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;断言语句，如 &lt;code&gt;assert str.equals("message")&lt;/code&gt; 中&lt;/li&gt;
  &lt;li&gt;异常构造函数调用，如 &lt;code&gt;new Exception("message")&lt;/code&gt; 中&lt;/li&gt;
  &lt;li&gt;JUnit 断言调用，如 &lt;code&gt;assertEquals(str, "message")&lt;/code&gt; 中&lt;/li&gt;
  &lt;li&gt;返回 String 的方法的唯一实参，如 &lt;code&gt;getStringByKey("key")&lt;/code&gt; 中&lt;/li&gt;
  &lt;li&gt;具有合法和现有类名值的文字，如 &lt;code&gt;Class.forName("java.lang.Object")&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;具有合法和现有属性键值的文字 &lt;code&gt;bundle.getString("authentication.failed")&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CallToSuspiciousStringMethod" defaultSeverity="WARNING" displayName="调用可疑的 'String' 方法" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对以下各项的调用：
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;equals()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;equalsIgnoreCase()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;compareTo()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;compareToIgnoreCase()&lt;/code&gt; 和&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;trim()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
  （发生在 &lt;code&gt;String&lt;/code&gt; 对象上）。
  国际化字符串的比较可能应改用 &lt;code&gt;java.text.Collator&lt;/code&gt;。
  &lt;code&gt;String.trim()&lt;/code&gt; 只会移除 0x00 和 0x20 之间的控制字符。
  Java 11 中引入的 &lt;code&gt;String.strip()&lt;/code&gt; 方法对 Unicode 的感知更好，可以作为替代。
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TimeToString" defaultSeverity="WARNING" displayName="调用 'Time.toString()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;java.sql.Time&lt;/code&gt; 对象上的 &lt;code&gt;toString()&lt;/code&gt; 调用。 在国际化环境中，此类调用通常是不正确的。
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SimpleDateFormatWithoutLocale" defaultSeverity="WARNING" displayName="无区域设置的 'SimpleDateFormat'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告未指定 &lt;code&gt;java.util.Locale&lt;/code&gt; 的 &lt;code&gt;java.util.SimpleDateFormat&lt;/code&gt; 或 &lt;code&gt;java.time.format.DateTimeFormatter&lt;/code&gt; 的实例化。
这些调用将使用平台默认区域设置，具体取决于操作系统设置。
当代码在不同的平台上运行或操作系统设置被更改时，这可能会导致意外行为。
&lt;p&gt;&lt;code&gt;示例：&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  new SimpleDateFormat("yyyy");
  DateTimeFormatter.ofPattern("d/M/y");
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StringTokenizer" defaultSeverity="WARNING" displayName="使用 'StringTokenizer'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;StringTokenizer&lt;/code&gt; 类的用法。 在国际化环境中，过度使用 &lt;code&gt;StringTokenizer&lt;/code&gt; 是不正确的。
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StringConcatenation" defaultSeverity="WARNING" displayName="字符串串联" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;String&lt;/code&gt; 串联。 在国际化环境中，串联可能不正确，可以替换为 &lt;code&gt;java.text.MessageFormat&lt;/code&gt; 或类似的类的用法。
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DateToString" defaultSeverity="WARNING" displayName="调用 'Date.toString()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;java.util.Date&lt;/code&gt; 对象上的 &lt;code&gt;toString()&lt;/code&gt; 调用。 在国际化环境中，此类调用通常是不正确的。
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ImplicitDefaultCharsetUsage" defaultSeverity="WARNING" displayName="隐式平台默认字符集" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告隐式使用平台默认字符集的方法和构造函数调用。 此类调用可能会在使用不同默认字符集的系统上产生不同的结果，并可能导致意外行为。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void foo(byte[] bytes) {
  String s = new String(bytes);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果相应的重载方法可用，则可以采用指定显式 UTF-8 字符集的快速修复。
  在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void foo(byte[] bytes) {
  String s = new String(bytes, StandardCharsets.UTF_8);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AbsoluteAlignmentInUserInterface" defaultSeverity="WARNING" displayName="AWT/Swing 代码中的绝对对齐" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 AWT 和 Swing 中的绝对对齐常量的用法。 国际化应用程序使用相对对齐，因为它遵循区域设置组件的方向设置。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  JPanel panel = new JPanel(new BorderLayout(2, 2));
  JLabel label = new JLabel("Hello World");
  panel.add(label, BorderLayout.NORTH);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  JPanel panel = new JPanel(new BorderLayout(2, 2));
  JLabel label = new JLabel("Hello World");
  panel.add(label, BorderLayout.PAGE_START);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StringToUpperWithoutLocale" defaultSeverity="WARNING" displayName="调用无区域设置的 'String.toUpperCase()' 或 'toLowerCase()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告未指定 &lt;code&gt;java.util.Locale&lt;/code&gt; 的 &lt;code&gt;String&lt;/code&gt; 对象上的 &lt;code&gt;toUpperCase()&lt;/code&gt; 或 &lt;code&gt;toLowerCase()&lt;/code&gt; 调用。 这些情况下使用默认的系统区域设置，可能会在国际化环境中导致问题。
&lt;p&gt;
  例如，代码 &lt;code&gt;"i".toUpperCase().equals("I")&lt;/code&gt; 在土耳其语和阿塞拜疆语区域设置中返回 &lt;code&gt;false&lt;/code&gt;，其中带点和无点的 'i' 是单独的字母。 在土耳其语区域设置中运行时，对包含 'i' 的英文字符串调用 &lt;code&gt;toUpperCase()&lt;/code&gt; 将返回不正确的结果。 或者，在处理应被视为与区域设置无关的字符串（如 HTML 标记）时，可能会导致错误。
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CharacterComparison" defaultSeverity="WARNING" displayName="字符比较" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;char&lt;/code&gt; 值的顺序比较。 在国际化环境中，此类比较很少是正确的。
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MagicCharacter" defaultSeverity="WARNING" displayName="魔幻字符" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在没有常量声明的情况下使用的字符文字。 这些字符可能导致代码可读性差。 此外，如果只在代码中的一处更改某个字符，而不是在代码中的每一处都更改该字符，可能会出现错误。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;char c = 'c';&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConvertToBasicLatin" defaultSeverity="INFORMATION" displayName="非基本拉丁字符" enabled="false" language="JAVA" pluginId="com.intellij.java-i18n" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告文字中的非基本拉丁字符，并建议将它们替换为 unicode 实体。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  // © 2021
  char c = '©';
  String s = "Áî";
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  // &amp;amp;copy; 2021
  char c = '\u00a9';
  String s = "\u00c1\u00ee";
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NumericToString" defaultSeverity="WARNING" displayName="调用 'Number.toString()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告扩展 &lt;code&gt;Number&lt;/code&gt; 的类的对象上的 &lt;code&gt;toString()&lt;/code&gt; 调用。
此类调用在国际化环境中通常是不正确的，应该使用一些特定于区域设置的格式。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void print(Double d) {
    System.out.println(d.toString());
  }
&lt;/code&gt;&lt;/pre&gt;
修正此问题的一种可能方式是：
&lt;pre&gt;&lt;code&gt;
  void print(Double d) {
    System.out.printf("%f%n", d);
  }
&lt;/code&gt;&lt;/pre&gt;
这将使用默认区域设置来格式化数字，该默认区域设置在 JVM 启动期间进行设置，并且基于主机环境。
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DuplicateStringLiteralInspection" defaultSeverity="WARNING" displayName="复制字符串文字" enabled="false" language="JAVA" pluginId="com.intellij.java-i18n" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告整个项目中在不更改的情况下复制的字符串文字。
提供了两个快速修复。 一个是为重复的字符串引入一个常量并在整个项目中使用它，另一个是显示特定字符串文字的所有重复项的位置。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class C1 { String CONST1 = "duplicate string"; }
  class C2 { String CONST2 = "duplicate string"; }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;配置检查：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;使用&lt;b&gt;最小字符串长度&lt;/b&gt;字段设置检测重复项所需的最小字符串长度。&lt;/li&gt;
  &lt;li&gt;使用&lt;b&gt;忽略@PropertyKey 表达式&lt;/b&gt;选项可忽略作为实参传递给使用 &lt;code&gt; org.jetbrains.annotations.PropertyKey &lt;/code&gt; 注解的方法的字符串。&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Less" path=""><inspection shortName="LessUnresolvedVariable" defaultSeverity="WARNING" displayName="未解析的变量" enabled="false" language="LESS" pluginId="org.jetbrains.plugins.less" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对未解析的 &lt;a href="http://lesscss.org/features/#variables-feature"&gt; Less 变量&lt;/a&gt;的引用。
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
* {
  margin: @unknown-var;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LessResolvedByNameOnly" defaultSeverity="WEAK WARNING" displayName="缺少导入" enabled="false" language="LESS" pluginId="org.jetbrains.plugins.less" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对在另一个文件中已声明但未在当前文件中显式&lt;a href="http://lesscss.org/features/#import-atrules-feature"&gt;导入&lt;/a&gt;的变量或 mixin 的引用。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
* {
  margin: @var-in-other-file;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LessUnresolvedMixin" defaultSeverity="WARNING" displayName="未解析的 mixin" enabled="false" language="LESS" pluginId="org.jetbrains.plugins.less" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对未解析的 &lt;a href="http://lesscss.org/features/#mixins-feature"&gt; Less mixin&lt;/a&gt; 的引用。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
* {
  .unknown-mixin();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="JVM 语言" path=""><inspection shortName="SerializableHasSerialVersionUIDField" defaultSeverity="WARNING" displayName="不带 'serialVersionUID' 的可序列化类" enabled="false" language="UAST" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告实现 &lt;code&gt;Serializable&lt;/code&gt; 且不声明 &lt;code&gt;serialVersionUID&lt;/code&gt; 字段的类。
&lt;p&gt;
  如果没有 &lt;code&gt;serialVersionUID&lt;/code&gt; 字段，对该类做出的任何更改都将导致以前序列化的版本不可读。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Main implements Serializable {
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Main implements Serializable {
      private static final long serialVersionUID = -1446398935944895849L;
  }
&lt;/code&gt;&lt;/pre&gt;
当使用 JDK 14 或更高版本的语言级别时，该快速修复还将添加 &lt;code&gt;java.io.Serial&lt;/code&gt; 注解。
&lt;!-- tooltip end --&gt;
&lt;p&gt;使用以下选项配置检查：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    列出此检查不应报告其继承者的类。
    这适用于从超类继承 &lt;code&gt;Serializable&lt;/code&gt; 但不用于序列化的类。
  &lt;/li&gt;
  &lt;li&gt;
    是否忽略 &lt;code&gt;Serializable&lt;/code&gt; 匿名类。
  &lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="Dependency" defaultSeverity="ERROR" displayName="非法的软件包依赖项" enabled="false" language="UAST" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
根据指定依赖关系规则报告范围之间的非法依赖关系。 依赖关系规则可用于禁止从一个范围到另一个范围的用法。
&lt;!-- tooltip end --&gt;
&lt;p&gt;使用下面的&lt;b&gt;配置依赖关系规则&lt;/b&gt;按钮可以自定义验证规则。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="MustAlreadyBeRemovedApi" defaultSeverity="ERROR" displayName="API 必须已移除" enabled="false" language="UAST" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告使用应从当前版本的声明库中移除的 &lt;code&gt;@ApiStatus.ScheduledForRemoval&lt;/code&gt;
标记的声明。
&lt;!-- tooltip end --&gt;
&lt;p&gt;它会将计划移除的指定版本与可在下面设置的版本进行比较。&lt;/p&gt;
&lt;p&gt;
  以点分隔字符串指定版本，可选择加上
  &lt;code&gt;alpha&lt;/code&gt;、&lt;code&gt;beta&lt;/code&gt;、&lt;code&gt;snapshot&lt;/code&gt; 或 &lt;code&gt;eap&lt;/code&gt; 后缀。
&lt;/p&gt;
&lt;p&gt;有效版本示例：&lt;code&gt;1.0&lt;/code&gt;、&lt;code&gt;2.3.1&lt;/code&gt;、&lt;code&gt;2018.1&lt;/code&gt;、&lt;code&gt;7.5-snapshot&lt;/code&gt;、&lt;code&gt;3.0-eap&lt;/code&gt;。
&lt;/p&gt;
&lt;p&gt;
  版本比较非常直观，例如：&lt;code&gt;1.0 &amp;lt; 2.0&lt;/code&gt;、&lt;code&gt;1.0-eap &amp;lt; 1.0&lt;/code&gt;、&lt;code&gt;2.3-snapshot &amp;lt; 2.3&lt;/code&gt; 等。
  有关详细比较逻辑，请参阅 &lt;a
  href="https://github.com/JetBrains/intellij-community/blob/master/platform/util-rt/src/com/intellij/util/text/VersionComparatorUtil.java"&gt;VersionComparatorUtil&lt;/a&gt; 的实现。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ThreadRun" defaultSeverity="WARNING" displayName="调用 'Thread.run()'" enabled="false" language="UAST" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告对 &lt;code&gt;java.lang.Thread&lt;/code&gt; 或其任何子类进行的 &lt;code&gt;run()&lt;/code&gt; 调用。&lt;/p&gt;
&lt;p&gt;
  虽然偶尔是有意为之，但这通常表明有错误，因为 &lt;code&gt;run()&lt;/code&gt; 不会启动新线程。
  要在单独的线程中执行代码，应使用 &lt;code&gt;start()&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="BlockingMethodInNonBlockingContext" defaultSeverity="WARNING" displayName="可能在非阻塞上下文中使用阻塞调用" enabled="false" language="UAST" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告不应阻塞线程的代码段中的线程阻塞方法调用。

&lt;p&gt;&lt;b&gt;示例（项目 Reactor）：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
Flux.just("1").flatMap(f -&amp;gt; {
    Flux&amp;lt;String&amp;gt; just = loadUsersFromDatabase();
    just.toIterable(); // 错误：在非阻塞范围内调用阻塞运算符
    return just;
  }
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;考虑使用&lt;a href="https://projectreactor.io/docs/core/release/reference/#faq.wrap-blocking"&gt;适当的计划程序&lt;/a&gt;（例如 &lt;code&gt;Schedulers.boundedElastic()&lt;/code&gt;）运行阻塞代码，或者尝试寻找替代的非阻塞 API。&lt;/p&gt;

&lt;br/&gt;

&lt;p&gt;&lt;b&gt;示例（Kotlin 协同程序）：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
suspend fun exampleFun() {
    Thread.sleep(100); // 错误：在挂起函数中调用阻塞方法
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;考虑&lt;a href="https://kotlinlang.org/docs/coroutine-context-and-dispatchers.html"&gt;使用特殊调度程序&lt;/a&gt;（例如 &lt;code&gt;Dispatchers.IO&lt;/code&gt;）运行阻塞代码，或尝试寻找替代的非阻塞 API。&lt;/p&gt;

&lt;!-- tooltip end --&gt;
&lt;p&gt;配置检查：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;在&lt;b&gt;阻塞注解&lt;/b&gt;列表中，指定标记线程阻塞方法的注解。&lt;/li&gt;
  &lt;li&gt;在&lt;b&gt;无阻塞注解&lt;/b&gt;列表中，指定标记非阻塞方法的注解。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;指定的注解可用作&lt;a href="https://www.jetbrains.com/help/idea/external-annotations.html"&gt;外部注解&lt;/a&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="Since15" defaultSeverity="ERROR" displayName="使用在配置的语言级别下不可用的 API" enabled="false" language="UAST" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在所配置的语言级别不可用的 API 的用法。
此检查有 3 种作用：
&lt;ul&gt;
  &lt;li&gt;当语言级别低于 Java 7 时，高亮显示泛化类的用法。&lt;/li&gt;
  &lt;li&gt;当默认方法未被重写且语言级别低于 Java 8 时高亮显示。&lt;/li&gt;
  &lt;li&gt;当语言级别低于在文档中使用 &lt;code&gt;@since&lt;/code&gt; 标记标记的级别时，高亮显示 API 的用法。&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用&lt;b&gt;禁止使用 API&lt;/b&gt; 选项，禁止在项目或自定义语言级别使用 API。
&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SourceToSinkFlow" defaultSeverity="WARNING" displayName="不安全字符串被传递至安全方法" enabled="false" language="UAST" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;&lt;body&gt;
报告将非安全字符串传递给带有使用注解 &lt;code&gt;org.checkerframework.checker.tainting.qual.Untainted&lt;/code&gt; 标记的形参的方法的情况。
&lt;p&gt;
  安全字符串为：
&lt;ul&gt;
  &lt;li&gt;标记为 &lt;code&gt;@Untainted&lt;/code&gt; 的方法调用&lt;/li&gt;
  &lt;li&gt;未调用非安全方法的局部变量或方法形参&lt;/li&gt;
  &lt;li&gt;标记为 &lt;code&gt;@Untainted&lt;/code&gt; 且没有分配非安全方法调用的字段、局部变量或形参&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
示例：
&lt;pre&gt;
&lt;code&gt;
  void doSmth(boolean b) {
    String s = safe();
    String s1 = "other";
    if (b) s1 = s;
    sink(s);
  }
  
  String sink(@Untainted String s) {}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;
此处没有将非安全字符串赋值给 &lt;code&gt;s&lt;/code&gt;，因此没有产生警告。 另一方面：
&lt;pre&gt;
&lt;code&gt;
  void doSmth(boolean b) {
    String s = safe();
    String s1 = "other";
    s1 = foo();
    if (b) s = s1;
    sink(s);        // 此处为警告
  }
  
  String foo();

  String sink(@Untainted String s) {}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;
这里有一条警告，因为 &lt;code&gt;s1&lt;/code&gt; 在 &lt;code&gt;foo&lt;/code&gt; 调用结果赋值后具有未知状态。
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2021.2 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="NonExtendableApiUsage" defaultSeverity="WARNING" displayName="不应扩展类、接口或方法" enabled="false" language="UAST" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告扩展、实现或重写使用 &lt;code&gt;@ApiStatus.NonExtendable&lt;/code&gt; 标记的 API 元素的类、接口和方法。
&lt;p&gt;
  &lt;code&gt;@ApiStatus.NonExtendable&lt;/code&gt; 注解表示&lt;strong&gt;不得扩展、实现或重写&lt;/strong&gt;类、接口或方法。
  将此类接口和类转换为内部库实现很常见，因此，如果客户端提供不同的实现，将获得 &lt;code&gt;ClassCastException&lt;/code&gt;。
  将新的 abstract 方法添加到这种类和接口将破坏与客户端实现的兼容性。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="UnstableTypeUsedInSignature" defaultSeverity="WARNING" displayName="签名中使用了不稳定的类型" enabled="false" language="UAST" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在签名中引用不稳定 API 类型，但没有使用相同的不稳定注解进行标记的类、方法和字段的声明。
&lt;p&gt;
  此检查可以确保公共 API 的签名不会公开任何&lt;i&gt;不稳定&lt;/i&gt;（内部、实验性）类型。
  例如，如果方法返回&lt;i&gt;实验性&lt;/i&gt;类，则会将该方法视为&lt;i&gt;实验性&lt;/i&gt;方法，
因为对类型的不兼容变更（删除或移到另一个软件包）会导致不兼容的方法签名变更。
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;使用下面的列表可以指定标记不稳定 API 的注解。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnstableApiUsage" defaultSeverity="WARNING" displayName="不稳定的 API 用法" enabled="false" language="UAST" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告使用一个注解标记为不稳定的 API 的用法。 将来的版本中可能更改或移除此类 API，从而破坏使用这些 API 的代码。
&lt;!-- tooltip end --&gt;
&lt;p&gt;用于标记不稳定 API 的注解显示在以下列表中。&lt;/p&gt;
&lt;p&gt;默认情况下，如果不稳定 API 的声明位于同一项目源中，该检查会忽略这些 API 的用法。 在此类情况下，更改 API 时可以更新用法。
  但是，如果项目很大，则可能不太方便，因此，您可以关闭&lt;b&gt;忽略此项目中声明的 API&lt;/b&gt; 选项，从而报告在项目源和库中均已声明的不稳定 API。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UastIncorrectHttpHeaderInspection" defaultSeverity="WARNING" displayName="未知 HTTP 标头" enabled="false" language="UAST" pluginId="com.intellij.microservices.jvm" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;
  报告与任何&lt;a href="https://www.iana.org/assignments/message-headers/message-headers.xml"&gt;公共已知标头&lt;/a&gt;不匹配的未知 HTTP 标头。 该快速修复会建议将标头添加到自定义标头列表中，以避免将来触发此检查。
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;在 HTTP 客户端组中列出了具有相同名称的自定义 HTTP 标题以进行检查。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UastIncorrectMimeTypeInspection" defaultSeverity="ERROR" displayName="不正确的 MIME 类型声明" enabled="false" language="UAST" pluginId="com.intellij.microservices.jvm" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 HTTP 服务器和客户端不正确的 MIME 类型（例如，在 &lt;code&gt;Content-Type&lt;/code&gt; 字符串中）。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="IllegalDependencyOnInternalPackage" defaultSeverity="ERROR" displayName="对内部软件包的非法依赖" enabled="false" language="UAST" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告软件包上不包含 &lt;code&gt;module-info.java&lt;/code&gt; 且未从命名模块中导出的模块中的引用。 
&lt;p&gt;当项目中的某些模块已经迁移到 Java 模块，而其他模块仍然处于非模块化状态时，可能会出现此类配置。
与 JDK 类似，此类非模块化代码不得访问命名模块中未显式导出的代码。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MissingDeprecatedAnnotationOnScheduledForRemovalApi" defaultSeverity="ERROR" displayName="已计划移除的 API 上缺少 '@Deprecated' 注解" enabled="false" language="UAST" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告使用 &lt;code&gt;@ApiStatus.ScheduledForRemoval&lt;/code&gt;（没有 &lt;code&gt;@Deprecated&lt;/code&gt;）标记的声明。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;
  @ApiStatus.ScheduledForRemoval(inVersion = "2017.3")
  public void myLegacyMethod() { }
&lt;/pre&gt;
&lt;p&gt;应用快速修复后，结果如下所示：&lt;/p&gt;
&lt;pre&gt;
  @Deprecated
  @ApiStatus.ScheduledForRemoval(inVersion = "2017.3")
  public void myLegacyMethod() { }
&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="OverrideOnly" defaultSeverity="WARNING" displayName="方法只能重写" enabled="false" language="UAST" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对使用 &lt;code&gt;@ApiStatus.OverrideOnly&lt;/code&gt; 标记的 API 方法的调用。
&lt;p&gt;
  &lt;code&gt;@ApiStatus.OverrideOnly&lt;/code&gt; 注解表示该方法是 SPI（服务提供程序接口）的一部分。
  声明库的客户端应实现或重写此类方法，而不是直接调用。
  使用此注解标记类或接口与使用它标记每个方法相同。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="YAML" path=""><inspection shortName="YAMLSchemaDeprecation" defaultSeverity="WEAK WARNING" displayName="弃用的 YAML 键" enabled="false" language="yaml" pluginId="org.jetbrains.plugins.yaml" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 YAML 文件中已弃用的键。
&lt;p&gt;仅当存在与相应 YAML 文件关联的 JSON 架构时，才会检查是否弃用。&lt;/p&gt;
&lt;p&gt;请注意，JSON 架构规范中尚未定义弃用机制，并且此检查使用非标准的 &lt;code&gt;deprecationMessage&lt;/code&gt; 扩展。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;方案弃用示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  {
    "properties": {
      "SomeDeprecatedProperty": {
        "deprecationMessage": "Baz",
        "description": "Foo bar"
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;b&gt;以下是带有相应警告的示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  SomeDeprecatedProperty: some value
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="YAMLRecursiveAlias" defaultSeverity="ERROR" displayName="递归别名" enabled="false" language="yaml" pluginId="org.jetbrains.plugins.yaml" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 YAML 别名中的递归。
&lt;p&gt;别名不能递归并在相应定位标记引用的数据中使用。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  some_key: &amp;some_anchor
    sub_key1: value1
    sub_key2: *some_anchor
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="YAMLUnusedAnchor" defaultSeverity="WARNING" displayName="未使用的定位标记" enabled="false" language="yaml" pluginId="org.jetbrains.plugins.yaml" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告未使用的定位标记。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  some_key: &amp;some_anchor
    key1: value1
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="YAMLUnresolvedAlias" defaultSeverity="ERROR" displayName="未解析的别名" enabled="false" language="yaml" pluginId="org.jetbrains.plugins.yaml" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 YAML 文件中的未解析别名。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  some_key: *unknown_alias
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="YAMLSchemaValidation" defaultSeverity="WARNING" displayName="由 JSON 架构验证" enabled="false" language="yaml" pluginId="org.jetbrains.plugins.yaml" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
如果指定了架构，则报告 YAML 文件和 JSON 架构之间的不一致。
&lt;p&gt;&lt;b&gt;方案示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  {
    "properties": {
      "SomeNumberProperty": {
        "type": "number"
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;b&gt;以下是带有相应警告的示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  SomeNumberProperty: hello world
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="YAMLDuplicatedKeys" defaultSeverity="ERROR" displayName="重复的 YAML 键" enabled="false" language="yaml" pluginId="org.jetbrains.plugins.yaml" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 YAML 文件中的重复键。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  same_key: some value
  same_key: another value
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Bean 验证" path=""><inspection shortName="BvConfigDomInspection" defaultSeverity="ERROR" displayName="Bean Validation &lt;validation-config&gt; 文件中不正确的元素" enabled="false" language="XML" pluginId="com.intellij.beanValidation" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 Bean 验证 &lt;code&gt;&amp;lt;validation-config&amp;gt;&lt;/code&gt; 文件中的不正确元素：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;对不可实例化类的引用&lt;/li&gt;
  &lt;li&gt;对不扩展所需类的类的引用&lt;/li&gt;
  &lt;li&gt;对范围不适当的类的引用&lt;/li&gt;
  &lt;li&gt;空标记和特性值&lt;/li&gt;
  &lt;li&gt;与所需模式不匹配的标记和特性值（例如，Java 标识符）&lt;/li&gt;
  &lt;li&gt;不包含必需子标记或特性的标记&lt;/li&gt;
  &lt;li&gt;定义具有重复名称的对象的标记&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
&amp;lt;validation-config&amp;gt;
  &amp;lt;default-provider&amp;gt;&lt;strong&gt;foo.UnknownProvider&lt;/strong&gt;&amp;lt;/default-provider&amp;gt;  &amp;lt;!-- 无法解析 'UnknownProvider' 类或软件包 --&amp;gt;
  &amp;lt;message-interpolator&amp;gt;my.Interpolator&amp;lt;/message-interpolator&amp;gt;
  &amp;lt;constraint-mapping&amp;gt;META-INF/ConstraintMappings.xml&amp;lt;/constraint-mapping&amp;gt;
  &amp;lt;constraint-mapping&amp;gt;META-INF/&lt;strong&gt;unknown.xml&lt;/strong&gt;&amp;lt;/constraint-mapping&amp;gt;
&amp;lt;/validation-config&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MinMaxValuesInspection" defaultSeverity="WARNING" displayName="Bean Validation 注解中不正确的 'min' 和 'max' 值" enabled="false" language="JAVA" pluginId="com.intellij.beanValidation" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 Bean 验证约束注解中 &lt;code&gt;max&lt;/code&gt; 和 &lt;code&gt;min&lt;/code&gt; 值的不正确值。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
public class Car {
  @NotNull
  @Size(min = 14, max = &lt;strong&gt;2&lt;/strong&gt;) // 'max' 值小于 'min' 值
  private String licensePlate;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="BvConstraintMappingsInspection" defaultSeverity="ERROR" displayName="Bean Validation &lt;constraint-mappings&gt; 文件中不正确的元素" enabled="false" language="XML" pluginId="com.intellij.beanValidation" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 Bean 验证 &lt;code&gt;&amp;lt;constraint-mappings&amp;gt;&lt;/code&gt; 文件中的不正确元素：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;对不可实例化类的引用&lt;/li&gt;
  &lt;li&gt;对不扩展所需类的类的引用&lt;/li&gt;
  &lt;li&gt;对范围不适当的类的引用&lt;/li&gt;
  &lt;li&gt;空标记和特性值&lt;/li&gt;
  &lt;li&gt;与所需模式不匹配的标记和特性值（例如，Java 标识符）&lt;/li&gt;
  &lt;li&gt;不包含必需子标记或特性的标记&lt;/li&gt;
  &lt;li&gt;定义具有重复名称的对象的标记&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
&amp;lt;constraint-mappings version="1.1"&amp;gt;
    &amp;lt;bean class="my.UserClass" ignore-annotations="false"&amp;gt;
        &amp;lt;field name="name"&amp;gt;
            &amp;lt;constraint annotation="&lt;strong&gt;java.lang.String&lt;/strong&gt;"/&amp;gt;  &amp;lt;!--'java.lang.String' 不是 Java 注解 --&amp;gt;
        &amp;lt;/field&amp;gt;

        &amp;lt;field name="name"&amp;gt;
            &amp;lt;constraint annotation="javax.validation.constraints.Size"&amp;gt;
                &amp;lt;element name="min"&amp;gt;&lt;strong&gt;non-number&lt;/strong&gt;&amp;lt;/element&amp;gt;    &amp;lt;!--应该为 '-2,147,483,648' 到 '2,147,483,647' 之间的数字 --&amp;gt;
            &amp;lt;/constraint&amp;gt;
        &amp;lt;/field&amp;gt;

        &amp;lt;getter name="&lt;strong&gt;zzz&lt;/strong&gt;"&amp;gt; 无法解析 'zzz' 符号
            &amp;lt;valid/&amp;gt;
        &amp;lt;/getter&amp;gt;

    &amp;lt;/bean&amp;gt;
&amp;lt;/constraint-mappings&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Java 9" path="Java/Java 语言级别迁移帮助"><inspection shortName="JavaRequiresAutoModule" defaultSeverity="WARNING" displayName="依赖于自动模块" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;requires&lt;/code&gt; 指令中自动模块的用法。
&lt;p&gt;自动模块不可靠，因为它可能依赖于类路径中的类型，而且当它转换为显式模块时，它的名称和导出的软件包可能会改变。&lt;/p&gt;
&lt;p&gt;对应于 &lt;code&gt;-Xlint:requires-automatic&lt;/code&gt; 和 &lt;code&gt;-Xlint:requires-transitive-automatic&lt;/code&gt; Javac 选项。
第一个选项增加了对何时使用自动模块的了解。
第二个选项则是警示模块的作者，建立自动模块的隐含可读性将使该模块的用户面临风险。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  //module-info.java
  module org.printer {
    requires transitive drivers.corp.org; // 在 'drivers.corp.org' 为自动模块时报告
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用&lt;b&gt;仅高亮显示传递依赖&lt;/b&gt;选项，可仅对传递依赖发出警告。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="Java9CollectionFactory" defaultSeverity="WEAK WARNING" displayName="不可变集合创建可被替换为集合工厂调用" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;java.util.Collections&lt;/code&gt; 不可修改的集合调用，这些调用可以转换为更新的集合工厂方法。
例如，这些可以替换为在 Java 9 中引入的 &lt;code&gt;List.of()&lt;/code&gt; 或 &lt;code&gt;Set.of()&lt;/code&gt; 或在 Java 10 中引入的 &lt;code&gt;List.copyOf()&lt;/code&gt;。

&lt;p&gt;请注意，与 &lt;code&gt;java.util.Collections&lt;/code&gt; 方法相比，Java 9 集合工厂方法：
&lt;ul&gt;
  &lt;li&gt;不接受 &lt;code&gt;null&lt;/code&gt; 值。
  &lt;li&gt;需要唯一的集合元素和映射键。
  &lt;li&gt;不要接受 &lt;code&gt;null&lt;/code&gt; 实参来查询返回集合的 &lt;code&gt;List.contains()&lt;/code&gt; 或 &lt;code&gt;Map.get()&lt;/code&gt; 等方法。
&lt;/ul&gt;
&lt;p&gt;当这些情况被违反时，会抛出异常。
  这可以在迁移后更改代码的语义。&lt;/p&gt;
&lt;p&gt;示例：
&lt;pre&gt;&lt;code&gt;
  List&amp;lt;Integer&gt; even = Collections.unmodifiableList(
    Arrays.asList(2, 4, 6, 8, 10, 2));
  List&amp;lt;Integer&gt; evenCopy = Collections.unmodifiableList(
    new ArrayList&amp;lt;&gt;(list1));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  List&amp;lt;Integer&gt; even = List.of(2, 4, 6, 8, 10, 2);
  List&amp;lt;Integer&gt; evenCopy = List.copyOf(list);
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- tooltip end --&gt;
&lt;p&gt;仅当项目或模块的语言级别为 9 或更高时，此检查才会报告。
&lt;p&gt;
使用&lt;b&gt;当内容为非常量时不发出警告&lt;/b&gt;选项可以仅在提供的实参是编译时常量的情况下报告。
这减少了行为改变的机会，因为并不总是可以静态检查原始元素是否唯一且为非 &lt;code&gt;null&lt;/code&gt;。
&lt;p&gt;
  使用&lt;b&gt;建议 'Map.ofEntries'&lt;/b&gt; 选项可建议使用 &lt;code&gt;Map.ofEntries()&lt;/code&gt; 替换超过 10 个条目的不可修改的映射。
&lt;p&gt;&lt;small&gt;2017.2 最新变化&lt;/small&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReplaceNullCheck" defaultSeverity="WARNING" displayName="Null 检查可被替换为方法调用" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可被替换为从 &lt;code&gt;Objects&lt;/code&gt; 或 &lt;code&gt;Stream&lt;/code&gt; 对 static 方法的调用的 &lt;code&gt;null&lt;/code&gt; 检查。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (message == null) {
    application.messageStorage().save(new EmptyMessage());
  } else {
    application.messageStorage().save(message);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  application.messageStorage()
    .save(Objects.requireNonNullElseGet(message, () -&gt; new EmptyMessage()));
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用&lt;b&gt;替换长度大于原始长度时不发出警告&lt;/b&gt;选项，可以忽略替换长度超过原始代码的情况。
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;2017.3 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="内存" path="Java"><inspection shortName="ZeroLengthArrayInitialization" defaultSeverity="WARNING" displayName="零长度数组分配" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告已知长度为零的数组的分配。
&lt;p&gt;
  由于 Java 中的数组长度不可修改，几乎总是可以共享零长度数组，而不是重复分配新数组。 此类共享可以在程序运行时或占用空间中提供有用的优化。
&lt;/p&gt;
&lt;p&gt;
  请注意，检查不会报告分配为 static final 字段的零长度数组，因为会假设这些数组用于实现数组共享。
&lt;/p&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AnonymousInnerClassMayBeStatic" defaultSeverity="WARNING" displayName="匿名类可能是命名为 'static' 的内部类" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以安全地替换为 &lt;code&gt;static&lt;/code&gt; 内部类的匿名类。
如果某个匿名类没有从周围方法显式引用其封闭实例或局部类，则它可能是 &lt;code&gt;static&lt;/code&gt; 内部类。
&lt;p&gt;
&lt;code&gt;static&lt;/code&gt; 内部类不保留对其封闭实例的隐式引用。
这可以防止常见的内存泄漏，并减少每个类实例使用的内存。
&lt;/p&gt;
&lt;p&gt;
  从 Java 18 开始，只有可序列化的匿名类在不使用该引用的情况下，才保留对其封闭实例的隐式引用。 因此，如果模块语言级别为 Java 18 或更高，则该检查只报告可序列化的类。
&lt;/p&gt;
&lt;p&gt;该快速修复会将匿名类提取到命名的 &lt;code&gt;static&lt;/code&gt; 内部类中。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void sample(){
    Thread thread = new Thread(new Runnable() {
      @Override
      public void run() {
      }
    });
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void sample() {
    Thread thread = new Thread(new Task());
  }

  private static class Task implements Runnable {
    @Override
    public void run() {
    }
  }
&lt;/code&gt;&lt;/pre&gt;
  &lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StringBufferField" defaultSeverity="WARNING" displayName="'StringBuilder' 字段" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;java.lang.StringBuffer&lt;/code&gt; 或 &lt;code&gt;java.lang.StringBuilder&lt;/code&gt; 类型的字段。
此类字段可以无限增长，并且通常会导致内存泄漏。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Example {
    private StringBuilder builder = new StringBuilder();

  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryEmptyArrayUsage" defaultSeverity="WARNING" displayName="不必要的零长度数组用法" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告数组元素类型的类中有常量时已知长度为零的数组分配。
由于零长度数组不可变，您可以重用相同的数组实例来节省内存。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Item {
    // 可重用的 public 零长度数组常量 
    public static final Item[] EMPTY_ARRAY = new Item[0];
  }
  class EmptyNode {
    Item[] getChildren() {
      // 不必要的零长度数组创建
      return new Item[0];
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class EmptyNode {
    Item[] getChildren() {
      return Item.EMPTY_ARRAY;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StaticCollection" defaultSeverity="WARNING" displayName="静态集合" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;Collection&lt;/code&gt; 类型的 static 字段。 虽然这不一定是问题，但静态集合通常会导致内存泄漏，因此会被某些编码标准禁止。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Example {
    static List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();

  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  配置检查：
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;使用&lt;b&gt;忽略弱静态集合或映射&lt;/b&gt;选项可以忽略 &lt;code&gt;java.util.WeakHashMap&lt;/code&gt; 类型的字段。&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReturnOfInnerClass" defaultSeverity="WARNING" displayName="返回匿名、局部或内部类的实例" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告返回匿名类、局部类或内部类实例的 &lt;code&gt;return&lt;/code&gt; 语句。
此类实例会保持对外部实例的隐式引用，这可以防止外部实例被垃圾回收。
任何返回此类实例的方法的调用方都可能通过保留返回的实例而导致内存泄漏。
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  配置检查：
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;使用&lt;b&gt;忽略非 public 方法的返回值&lt;/b&gt;选项可以忽略来自 &lt;code&gt;protected&lt;/code&gt; 或 package-private 方法的返回值。
    始终忽略来自 &lt;code&gt;private&lt;/code&gt; 方法的返回。
  &lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="InnerClassMayBeStatic" defaultSeverity="WARNING" displayName="内部类可能为 'static'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以设置为 &lt;code&gt;static&lt;/code&gt; 的内部类。
&lt;p&gt;&lt;code&gt;static&lt;/code&gt; 内部类不保留对其封闭实例的隐式引用。
  这可以防止常见的内存泄漏，减少类的每个实例使用的内存。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;public class&lt;/b&gt; Outer {
    &lt;b&gt;class&lt;/b&gt; Inner { // 非 static
      &lt;b&gt;public void&lt;/b&gt; foo() {
        bar("x");
      }

      &lt;b&gt;private void&lt;/b&gt; bar(String string) {}
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;public class&lt;/b&gt; Outer {
    &lt;b&gt;static class&lt;/b&gt; Inner {
      &lt;b&gt;public void&lt;/b&gt; foo() {
        bar("x");
      }

      &lt;b&gt;private void&lt;/b&gt; bar(String string) {}
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SystemGC" defaultSeverity="WARNING" displayName="调用 'System.gc()' 或 'Runtime.gc()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;System.gc()&lt;/code&gt; 或 &lt;code&gt;Runtime.gc()&lt;/code&gt; 调用。
虽然在测试中偶尔有用，但在生产代码中几乎从不推荐通过 &lt;code&gt;System.gc()&lt;/code&gt; 显式触发垃圾回收，这可能会导致严重的性能问题。
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="JavaFX" path=""><inspection shortName="JavaFxUnusedImports" defaultSeverity="WARNING" displayName="JavaFX 未使用的 import" enabled="false" language="XML" pluginId="org.jetbrains.plugins.javaFX" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 .fxml 文件中未使用的 import。
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JavaFxResourcePropertyValue" defaultSeverity="WARNING" displayName="属性文件中的值与特性类型不兼容" enabled="false" language="XML" pluginId="org.jetbrains.plugins.javaFX" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 .properties 文件中定义的与特性类型不匹配的特性值。
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="JavaFxEventHandler" defaultSeverity="WARNING" displayName="事件处理程序方法签名问题" enabled="false" language="XML" pluginId="org.jetbrains.plugins.javaFX" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告事件处理程序问题，包括不兼容的实参类型、模糊的事件处理程序方法和错误的返回类型。
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="JavaFxDefaultTag" defaultSeverity="WARNING" displayName="不必要的默认标记" enabled="false" language="XML" pluginId="org.jetbrains.plugins.javaFX" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 .fxml 文件中的冗余标签。 这些标记对应于 @DefaultProperty 类注解中声明的类属性，因此可以省略它们。
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JavaFxUnresolvedFxIdReference" defaultSeverity="WARNING" displayName="未解析的 fx:id 特性引用" enabled="false" language="XML" pluginId="org.jetbrains.plugins.javaFX" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告未解析 fx: id 引用。 快速修复将创建相应的字段。
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="JavaFxUnresolvedStyleClassReference" defaultSeverity="WARNING" displayName="未解析的样式类引用" enabled="false" language="XML" pluginId="org.jetbrains.plugins.javaFX" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告未解析的 CSS 样式类。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JavaFxRedundantPropertyValue" defaultSeverity="WARNING" displayName="JavaFX 冗余属性值" enabled="false" language="XML" pluginId="org.jetbrains.plugins.javaFX" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 .fxml 文件中具有默认值并因此变得冗余的属性（特性和标记）。
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JavaFxColorRgb" defaultSeverity="WARNING" displayName="颜色分量超出范围" enabled="false" language="XML" pluginId="org.jetbrains.plugins.javaFX" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告有效范围之外的 RGB 颜色分量。
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="属性文件" path="Java"><inspection shortName="UnresolvedPropertyKey" defaultSeverity="ERROR" displayName="无效属性健" enabled="false" language="JAVA" pluginId="com.intellij.java-i18n" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告传递给形参注解为 &lt;code&gt;@PropertyKey&lt;/code&gt; 的方法的无效实参。
&lt;p&gt;这些实参应为相应属性文件中的有效属性键。
此外，该检查还将验证 &lt;code&gt;@PropertyKey&lt;/code&gt; 注解的 &lt;code&gt;resourceBundle&lt;/code&gt; 实参是否为现有的资源包。&lt;/p&gt;
&lt;p&gt;
  使用该快速修复可以创建新属性或选择现有属性。
&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @PropertyKey(resourceBundle = "myBundle") String value = "invalid.key";
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="简化: 通过 find 和 map 应用" path="Scala，集合"><inspection shortName="FindAndMapToGet" defaultSeverity="WARNING" displayName="find 和 map 转换为 get" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告对 &lt;code&gt;Map&lt;/code&gt; 上的 &lt;code&gt;find&lt;/code&gt; 和 &lt;code&gt;map&lt;/code&gt; 的调用，并建议将其替换为 &lt;code&gt;get&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  val map = Map(1 -&gt; 42)
  map.find(_._1 == k).map(_._2)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  val map = Map(1 -&gt; 42)
  map.get(k)
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Kotlin Android" path=""><inspection shortName="TypeParameterFindViewById" defaultSeverity="WEAK WARNING" displayName="Cast can be converted to findViewById with type parameter" enabled="false" language="kotlin" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告带类型转换并且自 Android 8.0（API 级别 26）起可以转换为带类型形参的 &lt;code&gt;findViewById&lt;/code&gt; 的 &lt;code&gt;findViewById&lt;/code&gt; 调用。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="IllegalIdentifier" defaultSeverity="ERROR" displayName="Illegal Android Identifier" enabled="false" language="kotlin" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 Android 运行时不接受的 Android 项目标识符。
例如，带有空格的方法名称。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Test {
      var `a b c` = 3
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;要修正此问题，请更改标识符的名称以匹配 Android 运行时要求。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="国际化" path=""><inspection shortName="NonAsciiCharacters" defaultSeverity="WARNING" displayName="非 ASCII 字符" enabled="false" pluginId="com.intellij" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在异常上下文中使用非 ASCII 符号的代码元素。

&lt;p&gt;示例：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;标识符、字符串或注释中使用的非 ASCII 字符。&lt;/li&gt;
  &lt;li&gt;使用不同语言编写的标识符，例如带有使用西里尔文编写的字母 &lt;code&gt;&lt;b&gt;C&lt;/b&gt;&lt;/code&gt; 的 &lt;code&gt;my&lt;b&gt;С&lt;/b&gt;ollection&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;包含 Unicode 符号（如长划线和箭头）的注释或字符串。&lt;/li&gt;
&lt;/ul&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LossyEncoding" defaultSeverity="WARNING" displayName="有损编码" enabled="false" pluginId="com.intellij" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;

报告由于当前文档编码而无法显示的字符。
&lt;p&gt;示例：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;如果在带有 &lt;b&gt;US-ASCII&lt;/b&gt; 字符集的文档中键入国际字符，保存时会丢失某些字符。&lt;/li&gt;
  &lt;li&gt;如果加载使用 &lt;b&gt;ISO-8859-1&lt;/b&gt; 一字节字符集的 &lt;b&gt;UTF-8&lt;/b&gt; 编码文件，某些字符将无法正确显示。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;要解决此问题，可以直接在文件中指定编码来更改文件编码，例如编辑 XML 文件的 XML prolog 中的 &lt;code&gt;encoding=&lt;/code&gt; 特性，或者在&lt;b&gt;设置 | 编辑器 | 文件编码&lt;/b&gt;中更改相应选项。&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="数据流分析" path="Scala"><inspection shortName="DfaConstantConditions" defaultSeverity="WARNING" displayName="恒定条件" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告值根据数据流分析始终为常量但可能不应如此的表达式。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (&lt;strong&gt;2 &amp;lt; 3&lt;/strong&gt;) // 条件始终为 true
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="编译器问题" path="Java"><inspection shortName="PreviewFeature" defaultSeverity="WARNING" displayName="预览功能警告" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告预览功能 API 的用法，即使用 &lt;code&gt;@PreviewFeature&lt;/code&gt; 注解的 &lt;code&gt;java.*&lt;/code&gt; 或 &lt;code&gt;javax.*&lt;/code&gt; 命名空间中的模块、软件包、类、接口、方法、构造函数或枚举常量。
&lt;p&gt;
  预览特性是 Java 语言、Java 虚拟机或 Java SE API 的一个新特性，它已完全指定、完全实现，但不是永久性的。 预览特性的概念在 &lt;a href="https://openjdk.org/jeps/12"&gt;JEP 12&lt;/a&gt; 中进行了定义。
&lt;/p&gt;
&lt;p&gt;
  如果某段代码依赖于预览 API，如果更改或移除该功能，该段代码可能会在未来的 JDK 版本中停止编译。
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;仅当项目或模块的语言级别为&lt;b&gt;预览版&lt;/b&gt;时，此检查才会报告。&lt;/p&gt;
&lt;p&gt;&lt;small&gt;2021.1 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="JavacQuirks" defaultSeverity="WARNING" displayName="Javac 杂项" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告现有的 Javac 问题、性能问题和不兼容性。
例如，当需要处理许多嵌套调用时，类型推断会变慢。
&lt;p&gt;以下代码会触发警告，因为 vararg 方法调用包含 50 个以上的多态实参：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Arrays.asList(
      Arrays.asList("a1", "b1"),
      Arrays.asList("a2", "b2"),
      ...
      Arrays.asList("a100", "b100"));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;快速修复程序添加了显式类型实参，可以加快编译和 IDE 的速度。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  //noinspection RedundantTypeArguments
  Arrays.&amp;lt;List&amp;lt;String&amp;gt;&amp;gt;asList(
      Arrays.asList("a1", "b1"),
      Arrays.asList("a2", "b2"),
      ...
      Arrays.asList("a100", "b100"));
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SynchronizeOnValueBasedClass" defaultSeverity="WARNING" displayName="基于值的警告" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告尝试在基于值的类的实例上进行同步的情况，从 Java 16 开始，这些实例会生成编译时警告并引发运行时异常。
&lt;p&gt;
  例如，&lt;code&gt;java.lang.Double&lt;/code&gt; 用 &lt;code&gt;jdk.internal.ValueBased&lt;/code&gt; 注解，因此以下代码会产生编译时警告：
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
Double d = 20.0;
synchronized (d) { ... } // javac 警告
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2021.1 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UNCHECKED_WARNING" defaultSeverity="WARNING" displayName="未检查的警告" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 javac 编译器发出未检查的警告的代码。
每个未检查的警告都可能在运行时触发 &lt;code&gt;ClassCastException&lt;/code&gt;。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  List items = Arrays.asList("string", "string");
  List&amp;lt;Integer&amp;gt; numbers = Collections.unmodifiableList(items); // 未检查的赋值
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该快速修复会尝试泛化该包含文件，此举可能会揭示编辑器中以及编译期间以前仅在运行时出现的问题：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  List&amp;lt;String&amp;gt; items = Arrays.asList("string", "string");
  List&amp;lt;Integer&amp;gt; numbers = Collections.unmodifiableList(items); // 不兼容的类型
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="赋值问题" path="JavaScript and TypeScript"><inspection shortName="AssignmentToFunctionParameterJS" defaultSeverity="WARNING" displayName="赋值给函数形参" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对函数形参的赋值，包括递增和递减运算。
虽然偶尔是有意为之，但此结构可能格外令人困惑，并且通常是由错误所致。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AssignmentResultUsedJS" defaultSeverity="WARNING" displayName="使用的赋值的结果" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告赋值结果在包含其的表达式中使用的赋值表达式。 此类赋值通常表明有编码错误，例如，应是 &lt;code&gt;=&lt;/code&gt; 而不是 &lt;code&gt;==&lt;/code&gt;。
此外，它们可能会由于运算顺序而导致混淆，
因为赋值的求值可能会以意想不到的方式影响外部表达式。
&lt;p&gt;将忽略圆括号中的表达式。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReplaceAssignmentWithOperatorAssignmentJS" defaultSeverity="WARNING" displayName="赋值可被替换为运算符赋值" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;!-- Copied from community/plugins/InspectionGadgets/src/inspectionDescriptions/ReplaceAssignmentWithOperatorAssignment.html --&gt;
&lt;html&gt;
&lt;body&gt;
报告可由运算符赋值替换的赋值运算，以使代码更简洁、更清晰。
&lt;p&gt;
  示例：
&lt;pre&gt;
&lt;code&gt;  x = x + 3;&lt;/code&gt;
  &lt;code&gt;x = x / 3;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;应用快速修复后，结果如下所示：
&lt;pre&gt;
  &lt;code&gt;x += 3;&lt;/code&gt;
  &lt;code&gt;x /= 3;&lt;/code&gt;
&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SillyAssignmentJS" defaultSeverity="WARNING" displayName="变量被赋值给自己" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;x = x&lt;/code&gt; 形式的赋值。 
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NestedAssignmentJS" defaultSeverity="WARNING" displayName="嵌套赋值" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;!-- Copied from community/plugins/InspectionGadgets/src/inspectionDescriptions/NestedAssignment.html --&gt;
&lt;html&gt;
&lt;body&gt;
报告嵌套在另一个表达式中的赋值表达式，例如 &lt;code&gt;a=b=1&lt;/code&gt;。
此类表达式可能令人困惑，并违反一般设计原则，即给定结构只应发挥一种作用。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSAssignmentUsedAsCondition" defaultSeverity="WARNING" displayName="用作条件的赋值" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;!-- Copied from community/plugins/InspectionGadgets/src/inspectionDescriptions/AssignmentUsedAsCondition.html --&gt;
&lt;html&gt;
&lt;body&gt;
报告用作 &lt;code&gt;if&lt;/code&gt;、&lt;code&gt;while&lt;/code&gt;、&lt;code&gt;for&lt;/code&gt; 或 
&lt;code&gt;do&lt;/code&gt; 语句的条件的赋值。 虽然偶尔是有意为之，但此用法令人困惑，而且通常表明存在拼写错误（例如，应使用 &lt;code&gt;=&lt;/code&gt; 而不是 &lt;code&gt;==&lt;/code&gt;）。
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AssignmentToForLoopParameterJS" defaultSeverity="WARNING" displayName="赋值给 'for' 循环形参" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对声明为 &lt;code&gt; for&lt;/code&gt; 循环形参的变量的赋值。
虽然偶尔是有意为之，但此结构可能格外令人困惑，并且通常是由错误所致。
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Java 互操作问题" path="Kotlin"><inspection shortName="HasPlatformType" defaultSeverity="WEAK WARNING" displayName="函数或属性具有平台类型" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告具有平台类型的函数和属性。
&lt;p&gt;为防止意外错误，应显式声明类型。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo() = java.lang.String.valueOf(1)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;快速修复让您能够指定返回类型：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(): String = java.lang.String.valueOf(1)
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="KotlinInternalInJava" defaultSeverity="ERROR" displayName="使用来自 Java 的 Kotlin 内部声明" enabled="false" language="JAVA" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告位于不同模块中的 Java 代码中 Kotlin &lt;code&gt;internal&lt;/code&gt; 声明的用法。
&lt;p&gt;
    &lt;code&gt;internal&lt;/code&gt; 关键字旨在限制对其他模块的类、函数或属性的访问。
    由于 JVM 限制，&lt;code&gt;internal&lt;/code&gt; 类、函数和属性仍然可以从 Kotlin 外部访问，这可能会导致兼容性问题。
&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="PackageDirectoryMismatch" defaultSeverity="WEAK WARNING" displayName="软件包名称与包含的目录不匹配" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告与文件位置不匹配的 &lt;code&gt;package&lt;/code&gt; 指令。
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="PlatformExtensionReceiverOfInline" defaultSeverity="WARNING" displayName="在 Kotlin 1.2 及更低版本中包含可为 null 的接收器的 'inline fun'" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告使用灵活可 null 的扩展接收器（具有未知可 null 性的平台类型）对内联函数的潜在不安全调用。&lt;/p&gt;
&lt;p&gt;
    在 Kotlin 1.2 之前，使用灵活的可 null 扩展接收器（具有未知可 null 性的平台类型）对 &lt;code&gt;inline fun&lt;/code&gt; 的调用不包括字节码中的可 null 性检查。 自 Kotlin 1.2 起，字节码中包含可 null 性检查（请参阅 &lt;a href="https://youtrack.jetbrains.com/issue/KT-12899"&gt;KT-12899&lt;/a&gt;）。
&lt;/p&gt;
&lt;p&gt;
    建议添加要抛出异常的显式 &lt;code&gt;!!&lt;/code&gt;，或者考虑将函数的接收器类型更改为可 null（如果它能够无异常地运行）。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  inline fun String.removePrefix(prefix: String): String {
      return this.substring(prefix.length)
  }

  fun main() {
      // `System.getProperty` 返回不可表示的 `String!` 类型
      val property = System.getProperty("user.dir")
      println(property.removePrefix("/home"))
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  inline fun String.removePrefix(prefix: String): String {
      return this.substring(prefix.length)
  }

  fun main() {
      // `System.getProperty` 返回不可表示的 `String!` 类型
      val property = System.getProperty("user.dir")
      println(property!!.removePrefix("/home"))
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;仅当项目或模块的 Kotlin 语言级别低于 1.2 时，此检查才会报告。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="KotlinJvmAnnotationInJava" defaultSeverity="WARNING" displayName="Java 中的 Kotlin JVM 注解" enabled="false" language="JAVA" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 Java 代码中的无用 Kotlin JVM 注解。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  import kotlin.jvm.Volatile;

  public class Test {
      @Volatile
      public int i;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="JavaCollectionsStaticMethodOnImmutableList" defaultSeverity="WARNING" displayName="在不可变的 Kotlin 集合上调用 Java 转变器方法" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在不可变的 Kotlin 集合上对 Java 更改器方法的调用（如 &lt;code&gt;fill&lt;/code&gt;、&lt;code&gt;reverse&lt;/code&gt;、&lt;code&gt;shuffle&lt;/code&gt;、&lt;code&gt;sort&lt;/code&gt;）。
&lt;p&gt;这可能会在运行时导致 &lt;code&gt;UnsupportedOperationException&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  import java.util.Collections

  fun test() {
      val immutableList = listOf(1, 2)
      Collections.reverse(immutableList)
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;要修正此问题，请使列表可变。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="KotlinSealedInheritorsInJava" defaultSeverity="ERROR" displayName="从 Java 继承 Kotlin 密封接口/类" enabled="false" language="JAVA" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告从 Java 代码中的 Kotlin sealed 接口或类进行继承的尝试。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
// Kotlin 文件：MathExpression.kt

sealed class MathExpression

data class Const(val number: Double) : MathExpression()
data class Sum(val e1: MathExpression, val e2: MathExpression) : MathExpression()
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;
// Java 文件：NotANumber.java

public class NotANumber extends MathExpression {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FakeJvmFieldConstant" defaultSeverity="WARNING" displayName="Kotlin 非 const 属性用作 Java 常量" enabled="false" language="JAVA" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告不是 &lt;code&gt;const&lt;/code&gt; 并用作 Java 注解实参的 Kotlin 属性。
&lt;p&gt;
例如，具有 &lt;code&gt;@JvmField&lt;/code&gt; 注解的属性有一个可以在编译时评估的初始值设定项，它有一个基元类型或 &lt;code&gt;String&lt;/code&gt; 类型。
&lt;/p&gt;

&lt;p&gt;
此类属性在 Kotlin 1.1-1.2 中的字节码中具有 &lt;code&gt;ConstantValue&lt;/code&gt; 特性。
此特性允许 javac 折叠相应字段的用法并在注解中使用该字段。
在混合 Java/Kotlin 代码中单独或增量编译的情况下，这可能导致错误行为。
此行为在 Kotlin 1.3 中可能发生变化（不再有 &lt;code&gt;ConstantValue&lt;/code&gt; 特性）。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;foo.kt 文件中的 Kotlin 代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  annotation class Ann(val s: String)
  @JvmField val importantString = "important"
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Java 代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class JavaUser {
      // 这很危险
      @Ann(s = FooKt.importantString)
      public void foo() {}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;要修正此问题，请将 &lt;code&gt;@JvmField&lt;/code&gt; 注解替换为相关 Kotlin 属性上的 &lt;code&gt;const&lt;/code&gt; 修饰符或将其内联。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RedundantNotNullExtensionReceiverOfInline" defaultSeverity="INFORMATION" displayName="'inline fun' 扩展接收器在 Kotlin 1.2 及更低版本中可以显式设为可为 null" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告带有不可为 null 的扩展接收器的内联函数，这些函数不使用扩展接收器不可为 null 的事实。&lt;/p&gt;
&lt;p&gt;
    在 Kotlin 1.2 之前，使用灵活的可 null 扩展接收器（具有未知可 null 性的平台类型）对 &lt;code&gt;inline fun&lt;/code&gt; 的调用不包括字节码中的可 null 性检查。 自 Kotlin 1.2 起，字节码中包含可 null 性检查（请参阅 &lt;a href="https://youtrack.jetbrains.com/issue/KT-12899"&gt;KT-12899&lt;/a&gt;）。
&lt;/p&gt;
&lt;p&gt;
    因此，在 Kotlin 1.2 之前的版本中，不使用扩展接收器不可为 null 这一事实的函数是危险的，建议使此类函数具有可为 null 的接收器。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  inline fun String.greet() {
      println("Hello, $this!")
  }

  fun main() {
      // `System.getProperty` 返回不可表示的 `String!` 类型
      val user = System.getProperty("user.name")
      user.greet()
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  inline fun String.greet() {
      println("Hello, $this!")
  }

  fun main() {
      // `System.getProperty` 返回不可表示的 `String!` 类型
      val user = System.getProperty("user.name")
      user.greet()
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;仅当项目或模块的 Kotlin 语言级别低于 1.2 时，此检查才会报告。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="ES2015 迁移协助" path="JavaScript and TypeScript"><inspection shortName="JSStringConcatenationToES6Template" defaultSeverity="INFORMATION" displayName="已使用字符串串联而不是模板文字" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告字符串串联。 建议将其替换为&lt;a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals"&gt;模板文字&lt;/a&gt;。
&lt;p&gt;示例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; "result: " + a + "." &lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;应用快速修复后，代码如下所示：&lt;/p&gt;
 &lt;pre&gt;&lt;code&gt; `result: ${a}.` &lt;/code&gt;&lt;/pre&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ES6ConvertLetToConst" defaultSeverity="INFORMATION" displayName="已使用 'let' 而不是 'const'" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以设为 &lt;code&gt;const&lt;/code&gt; 的 &lt;code&gt;let&lt;/code&gt; 声明。&lt;br/&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ES6ConvertRequireIntoImport" defaultSeverity="INFORMATION" displayName="使用了 'require()' 而不是 'import'" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;require()&lt;/code&gt; 语句。 建议使用 &lt;code&gt;import&lt;/code&gt; 语句将其转换为 &lt;code&gt;require()&lt;/code&gt; 调用。
&lt;br/&gt;&lt;br/&gt;
启用“使用‘全部修复’操作转换内部范围中的 require()”，
在使用“全部修复”操作时转换嵌套函数和语句内部的所有 &lt;code&gt;require()&lt;/code&gt; 调用。
&lt;br/&gt;&lt;br/&gt;
请注意，将内部范围中的 &lt;code&gt;require()&lt;/code&gt; 语句转换为 &lt;code&gt;import&lt;/code&gt; 语句
可能会导致代码语义更改。
Import 语句是 static 模块依赖项，它们获得了提升，
这表明它们被移至当前模块的顶部。 &lt;code&gt;require()&lt;/code&gt; 调用动态加载模块。
它们可以有条件地执行，其范围由使用它们的表达式来定义。
&lt;br/&gt;清除“使用‘全部修复’操作转换内部范围中的 require()”复选框，以防止在使用“全部修复”操作时对这些复杂情况进行任何更改。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSFunctionExpressionToArrowFunction" defaultSeverity="INFORMATION" displayName="使用了函数表达式而不是箭头函数" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;报告&lt;a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function"&gt;函数&lt;/a&gt;表达式。
建议将其转换为&lt;a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions"&gt;箭头函数&lt;/a&gt;。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;arr.map(function(el) {return el + 1})&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;应用快速修复后，代码如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;arr.map(el =&gt; el + 1)&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ES6ConvertVarToLetConst" defaultSeverity="WEAK WARNING" displayName="已使用 'var' 而不是 'let' 或 'const'" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告使用 &lt;code&gt;var&lt;/code&gt; 而不是 &lt;code&gt;let&lt;/code&gt; 或 &lt;code&gt;const&lt;/code&gt; 的声明。&lt;br/&gt;
&lt;code&gt;let&lt;/code&gt; 和 &lt;code&gt;const&lt;/code&gt; 的作用范围都为块，行为更为严格。
&lt;br/&gt;&lt;br/&gt;
建议将所有 &lt;code&gt;var&lt;/code&gt; 声明替换为 &lt;code&gt;let&lt;/code&gt; 或 &lt;code&gt;const&lt;/code&gt; 声明，具体取决于特定值的语义。
为避免引用错误，可将声明移至函数顶部，或放在变量的第一个用法前。
&lt;br/&gt;选择'通过‘全部修复’操作保守地转换变量'选项，以防止使用“全部修复”操作时在这些复杂情况下出现任何更改。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ES6ConvertModuleExportToExport" defaultSeverity="INFORMATION" displayName="使用了 'module.exports' 而不是 'export'" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;module.export&lt;/code&gt; 语句。 建议将其替换为 &lt;code&gt;export&lt;/code&gt; 或 &lt;code&gt;export default&lt;/code&gt; 语句。
&lt;br/&gt;&lt;br/&gt;
请注意，用于将 &lt;code&gt;module.export&lt;/code&gt; 转换为 &lt;code&gt;export&lt;/code&gt; 的快速修复不适用于函数或语句内部的 &lt;code&gt;module.export&lt;/code&gt;，因为 &lt;code&gt;export&lt;/code&gt; 语句只能位于模块顶层。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ES6ConvertToForOf" defaultSeverity="INFORMATION" displayName="使用了 'for..in' 而不是 'for..of'" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对数组的 &lt;code&gt;&lt;a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in"&gt; for..in &lt;/a&gt;&lt;/code&gt; 循环的用法。 建议将其替换为 &lt;code&gt;&lt;a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of"&gt;for..of&lt;/a&gt;&lt;/code&gt; 循环。
&lt;br/&gt;&lt;code&gt;for..of&lt;/code&gt; 循环 (在 ECMAScript 6 中引入) 对 &lt;code&gt;iterable&lt;/code&gt; 对象进行迭代。
对于数组，此结构比 &lt;code&gt;for..in&lt;/code&gt; 更可取，因为它只处理数组值，不处理数组对象的属性。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ES6ConvertIndexedForToForOf" defaultSeverity="INFORMATION" displayName="已使用索引的 'for' 而不是 'for..of'" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对数组使用的 &lt;code&gt;&lt;a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for"&gt;for&lt;/a&gt;&lt;/code&gt; 索引循环。 建议将其替换为 &lt;code&gt;&lt;a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of"&gt;for..of&lt;/a&gt;&lt;/code&gt; 循环。
&lt;br/&gt;&lt;code&gt;for..of&lt;/code&gt; 循环 (在 ECMAScript 6 中引入) 对 &lt;code&gt;iterable&lt;/code&gt; 对象进行迭代。
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="声明冗余" path="Groovy"><inspection shortName="GroovyUnusedDeclaration" defaultSeverity="WARNING" displayName="未使用的声明" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告未使用的类、方法和字段。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Department {
      private Organization myOrganization;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在这里，&lt;code&gt;Department&lt;/code&gt; 显式引用 &lt;code&gt;Organization&lt;/code&gt;，但如果 &lt;code&gt;Department&lt;/code&gt; 类未使用，则此检查将报告这两个类。 

&lt;p&gt;
该检查还会报告其方法、所有方法实现/重写器未使用的形参，以及已声明但未使用的局部变量。
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;有关更多信息，请参阅 Java 中的相同检查。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="错误处理" path="Java"><inspection shortName="NestedTryStatement" defaultSeverity="WARNING" displayName="嵌套 'try' 语句" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告嵌套的 &lt;code&gt;try&lt;/code&gt; 语句。
&lt;p&gt;嵌套的 &lt;code&gt;try&lt;/code&gt; 语句可能会导致代码不清晰，并且可能会合并它们的 &lt;code&gt;catch&lt;/code&gt; 和 &lt;code&gt;finally&lt;/code&gt; 部分。
  &lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="EmptyFinallyBlock" defaultSeverity="WARNING" displayName="空 'finally' 块" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告空的 &lt;code&gt;finally&lt;/code&gt; 块。
&lt;p&gt;空的 &lt;code&gt;finally&lt;/code&gt; 块通常表明存在编码错误。 在代码重构后它们可能保留下来，可以安全移除。&lt;/p&gt;
&lt;p&gt;此检查不报告在 JSP 文件中发现的空 &lt;code&gt;finally&lt;/code&gt; 块。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  try {
    Files.readString(Paths.get("in.txt"));
  } catch (IOException e) {
    throw new RuntimeException(e);
  } finally {

  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：
&lt;pre&gt;&lt;code&gt;
  try {
    Files.readString(Paths.get("in.txt"));
  } catch (IOException e) {
    throw new RuntimeException(e);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TooBroadThrows" defaultSeverity="WARNING" displayName="过宽的 'throws' 子句" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告异常比方法实际抛出的异常更通用的 &lt;code&gt;throws&lt;/code&gt; 子句。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public void createFile() throws Exception { // 警告：'throws Exception' 范围过广，屏蔽异常 'IOException'
    File file = new File("pathToFile");
    file.createNewFile();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public void createFile() throws IOException {
    File file = new File("pathToFile");
    file.createNewFile();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;配置检查：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;使用&lt;b&gt;仅对 RuntimeException、异常、错误或 Throwable 发出警告&lt;/b&gt;选项可使此检查仅对最常见的异常发出警告。&lt;/li&gt;
  &lt;li&gt;使用&lt;b&gt;忽略在重写库方法的方法上声明的异常&lt;/b&gt;选项可忽略在重写库方法的方法中过于宽泛的 &lt;code&gt;throws&lt;/code&gt; 子句。&lt;/li&gt;
  &lt;li&gt;使用&lt;b&gt;忽略隐藏其他异常但自身被抛出的异常&lt;/b&gt;选项可忽略任何隐藏其他异常但仍可能从方法体抛出的异常，因此在技术上不会过于宽泛。&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReturnFromFinallyBlock" defaultSeverity="WARNING" displayName="'return' 位于 'finally' 块内" enabled="false" language="UAST" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;finally&lt;/code&gt; 块中的 &lt;code&gt;return&lt;/code&gt; 语句。
&lt;p&gt;虽然偶尔是有意为之，但此类 &lt;code&gt;return&lt;/code&gt; 语句可能会掩盖抛出的异常，并导致调试复杂化。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  try {
    foo();
  } finally {
    if (bar()) return;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ExceptionFromCatchWhichDoesntWrap" defaultSeverity="WARNING" displayName="'throw' 位于忽略已捕获异常的 'catch' 块内" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告从 &lt;code&gt;catch&lt;/code&gt; 块内部抛出但不“包装”所捕获异常的异常。
&lt;p&gt;当异常被抛出以响应异常时，包装初始异常可防止丢失有价值的上下文信息，如堆栈帧和行号。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  ...
  catch (IOException e) {
    closeAllConnections();
    throw new ConnectException("Connection problem."); // 警告：'catch' 块内的 'throw' 忽略捕获的异常 'e'
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;配置检查：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;使用&lt;b&gt;如果使用异常方法调用的结果，则忽略&lt;/b&gt;选项可指示检查是否应忽略实参为原始异常方法调用结果的异常，例如 &lt;code&gt;getMessage()&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;使用&lt;b&gt;如果抛出的异常无法包装异常，则忽略&lt;/b&gt;选项可忽略在没有接受 &lt;code&gt;Throwable&lt;/code&gt; 子句的构造函数的情况下抛出异常的 &lt;code&gt;throw&lt;/code&gt; 语句。&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NullThrown" defaultSeverity="WARNING" displayName="已抛出 'null'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告用作 &lt;code&gt;throw&lt;/code&gt; 语句实参的 &lt;code&gt;null&lt;/code&gt; 文字。
&lt;p&gt;此类结构会产生通常不应以编程方式抛出的 &lt;code&gt;java.lang.NullPointerException&lt;/code&gt;。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ThrowCaughtLocally" defaultSeverity="WARNING" displayName="通过包含 'try' 语句捕获 'throw'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告异常始终可以通过包含 &lt;code&gt;try&lt;/code&gt; 语句捕获的 &lt;code&gt;throw&lt;/code&gt; 语句。
&lt;p&gt;使用 &lt;code&gt;throw&lt;/code&gt; 语句作为 "goto" 来更改局部控制流会令人困惑并导致性能不佳。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  try {
    if (!Files.isDirectory(PROJECTS)) {
        throw new IllegalStateException("Directory not found."); // 警告：'throw' 被所包含的 'try' 语句捕获
    }
    ...
  } catch (Exception e) {
      LOG.error("run failed");
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;使用&lt;b&gt;忽略重新抛出的异常&lt;/b&gt;选项可忽略重新抛出的异常。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryInitCause" defaultSeverity="WARNING" displayName="对 'Throwable.initCause()' 的调用不必要" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对 &lt;code&gt;Throwable.initCause()&lt;/code&gt; 的调用，其中异常构造函数还包含 &lt;code&gt;Throwable cause&lt;/code&gt; 实参。
&lt;p&gt;在本例中，可以移除 &lt;code&gt;initCause()&lt;/code&gt; 调用，并将其实参添加到对异常构造函数的调用中。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  try {
      process();
  }
  catch (RuntimeException ex) {
    RuntimeException wrapper = new RuntimeException("Error while processing");
    wrapper.initCause(ex); // 不必要调用 'Throwable.initCause()'
    throw wrapper;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可通过快速修复将 cause 实参传递给构造函数。 在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  try {
      process();
  }
  catch (RuntimeException ex) {
    RuntimeException wrapper = new RuntimeException("Error while processing", ex);
    throw wrapper;
  }
  &lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FinallyBlockCannotCompleteNormally" defaultSeverity="WARNING" displayName="不能正常完成的 'finally' 块" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在 &lt;code&gt;finally&lt;/code&gt; 块内使用的 &lt;code&gt;return&lt;/code&gt;、&lt;code&gt;throw&lt;/code&gt;、&lt;code&gt;break&lt;/code&gt;、&lt;code&gt;continue&lt;/code&gt; 和 &lt;code&gt;yield&lt;/code&gt; 语句。
这些会导致 &lt;code&gt;finally&lt;/code&gt; 块无法正常完成，而是突然完成。
从同一 &lt;code&gt;try&lt;/code&gt;-&lt;code&gt;catch&lt;/code&gt; 语句的 &lt;code&gt;try&lt;/code&gt; 和 &lt;code&gt;catch&lt;/code&gt; 块抛出的任何异常将被禁止。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void x() {
    &lt;b&gt;try&lt;/b&gt; {
      throw new RuntimeException();
    } &lt;b&gt;finally&lt;/b&gt; {
      // 如果 bar() 返回 true，则 RuntimeException 将被禁止
      &lt;b&gt;if&lt;/b&gt; (bar()) &lt;b&gt;return&lt;/b&gt;;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ThrowsRuntimeException" defaultSeverity="WARNING" displayName="在 'throws' 子句中声明的未检查的异常" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告方法 &lt;code&gt;throws&lt;/code&gt; 子句中未检查的异常的声明（&lt;code&gt;java.lang.RuntimeException&lt;/code&gt; 或其子类之一）。
&lt;p&gt;未检查的异常的声明不是必需的，可以删除或移动到 Javadoc &lt;code&gt;@throws&lt;/code&gt; 标记。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class InvalidDataException extends RuntimeException {}

  class TextEditor {
    void readSettings() throws InvalidDataException {} // 警告：在 'throws' 子句中声明了未检查的异常 'InvalidDataException'
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="BadExceptionThrown" defaultSeverity="WARNING" displayName="已抛出禁止异常" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告抛出不适当异常的 &lt;code&gt;throw&lt;/code&gt; 语句。
例如，异常可能因为过于通用而不适当，例如 &lt;code&gt;java.lang.Exception&lt;/code&gt; 或 &lt;code&gt;java.io.IOException&lt;/code&gt;。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void setup(Mode mode) {
      if (mode == null)
          throw new RuntimeException("Problem during setup"); // 警告：抛出了禁止的异常 'RuntimeException'
      ...
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;使用&lt;b&gt;被禁止的异常&lt;/b&gt;列表可指定应报告哪些异常。&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ThrowFromFinallyBlock" defaultSeverity="WARNING" displayName="'throw' 位于 'finally' 块内" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;finally&lt;/code&gt; 块内的 &lt;code&gt;throw&lt;/code&gt; 语句。
&lt;p&gt;虽然偶尔是有意为之，但此类 &lt;code&gt;throw&lt;/code&gt; 语句可能隐藏从 &lt;code&gt;try&lt;/code&gt;-&lt;code&gt;catch&lt;/code&gt; 抛出的异常，并因此导致调试变得极其复杂。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TooBroadCatch" defaultSeverity="WARNING" displayName="过宽的 'catch' 块" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告形参比相应的 &lt;code&gt;try&lt;/code&gt; 块抛出的异常更通用的 &lt;code&gt;catch&lt;/code&gt; 块。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  try  {
    File file = new File(pathToFile);
    return file.getAbsolutePath();
  } catch (Exception ex) { // warning: 'catch' of 'Exception' is too broad, masking exceptions 'RuntimeException'
    return defaultFilePath;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  try  {
    File file = new File(pathToFile);
    return file.getAbsolutePath();
  } catch (RuntimeException ex) {
    return defaultFilePath;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;配置检查：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;使用&lt;b&gt;仅对 RuntimeException、异常、错误或 Throwable 发出警告&lt;/b&gt;选项可使此检查仅对最常见的异常发出警告。&lt;/li&gt;
  &lt;li&gt;使用&lt;b&gt;忽略隐藏其他异常但自身被抛出的异常&lt;/b&gt;选项可忽略任何隐藏其他异常但仍可能被抛出的异常，因此在技术上不会过于宽泛。&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ErrorRethrown" defaultSeverity="WARNING" displayName="'Error' 未重新抛出" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告捕获 &lt;code&gt;java.lang.Error&lt;/code&gt; 或其任何子类并且不重新抛出错误的 &lt;code&gt;try&lt;/code&gt; 语句。
&lt;p&gt;不会报告捕获 &lt;code&gt;java.lang.ThreadDeath&lt;/code&gt; 的语句。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  try {
    executeTests(request);
  }
  catch (OutOfMemoryError ex) { // 警告：错误 'ex' 未重新抛出
    return false;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NonFinalFieldOfException" defaultSeverity="WARNING" displayName="'Exception' 类的非 final 字段" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;java.lang.Exception&lt;/code&gt; 的子类中未被声明为 &lt;code&gt;final&lt;/code&gt; 的字段。
&lt;p&gt;不应修改异常对象上的数据，因为这可能会导致丢失可供以后调试和记录的错误上下文。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class EditorException extends Exception {
    private String message; // 警告：异常类的非 final 字段 'message'
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="BadExceptionDeclared" defaultSeverity="WARNING" displayName="已声明禁止异常" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在其 &lt;code&gt;throws&lt;/code&gt; 子句中声明不适当异常的方法。
例如，异常可能因为过于通用而不适当，例如 &lt;code&gt;java.lang.Exception&lt;/code&gt; 或 &lt;code&gt;java.lang.Throwable&lt;/code&gt;。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void describeModule(String module) throws Exception {} // 警告：声明了禁止的异常 'Exception'
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;配置检查：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;使用&lt;b&gt;被禁止的异常&lt;/b&gt;列表可指定应报告哪些异常。&lt;/li&gt;
  &lt;li&gt;使用&lt;b&gt;忽略在重写库方法的方法上声明的异常&lt;/b&gt;选项可忽略在重写库方法的方法上声明的异常。&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="InstanceofCatchParameter" defaultSeverity="WARNING" displayName="'catch' 形参上的 'instanceof'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告使用 &lt;code&gt;instanceof&lt;/code&gt; 表达式来测试 &lt;code&gt;catch&lt;/code&gt; 块中形参类型的情况。
&lt;p&gt;测试 &lt;code&gt;catch&lt;/code&gt; 形参的类型通常最好使用单独的 &lt;code&gt;catch&lt;/code&gt; 块，而不是使用 &lt;code&gt;instanceof&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void foo(Runnable runnable) {
    try {
        runnable.run();
    } catch (Throwable throwable) {
        if (throwable instanceof NoClassDefFoundError) { // 警告：'catch' 形参 'throwable' 上的 'instanceof'
            System.out.println("Class not found!");
        }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CheckedExceptionClass" defaultSeverity="WARNING" displayName="已检查的异常类" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告已检查的异常类（即，非 &lt;code&gt;java.lang.RuntimeException&lt;/code&gt; 子类的 &lt;code&gt;java.lang.Exception&lt;/code&gt; 的子类）。
&lt;p&gt;某些编码标准禁止已检查的用户定义的异常类。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class IllegalMoveException extends Exception {}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NewExceptionWithoutArguments" defaultSeverity="WARNING" displayName="未使用实参调用异常构造函数" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告未指定任何实参的异常实例的创建。
&lt;p&gt;当异常被构造为没有任何实参时，它不包含有关所发生问题的信息，这会使调试变得不必要地困难。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  throw new IOException(); // 警告：没有实参的异常
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="EmptyTryBlock" defaultSeverity="WARNING" displayName="空 'try' 块" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告空的 &lt;code&gt;try&lt;/code&gt; 块，包括 try-with-resources 语句。
&lt;p&gt;包含注释的 &lt;code&gt;try&lt;/code&gt; 块视为空块。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
此检查不报告在 JSP 文件中发现的空 &lt;code&gt;try&lt;/code&gt; 块。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CaughtExceptionImmediatelyRethrown" defaultSeverity="WARNING" displayName="捕获的异常被立即重新抛出" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告不对其执行任何操作，而是立即重新抛出所捕获的异常的 &lt;code&gt;catch&lt;/code&gt; 块。
此类 &lt;code&gt;catch&lt;/code&gt; 块非必要，并且没有处理错误。
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
        try {
            new FileInputStream("");
        } catch (FileNotFoundException e) {
            throw e;
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ContinueOrBreakFromFinallyBlock" defaultSeverity="WARNING" displayName="'continue' 或 'break' 位于 'finally' 块内" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;finally&lt;/code&gt; 块中的 &lt;code&gt;break&lt;/code&gt; 或 &lt;code&gt;continue&lt;/code&gt; 语句。
&lt;p&gt;虽然偶尔是有意为之，但此类语句非常令人困惑，可能会掩盖抛出的异常，并导致调试复杂化。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    while (true) {
        try {
          throwingMethod();
        } finally {
            continue;
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="BadExceptionCaught" defaultSeverity="WARNING" displayName="已捕获禁止的 'Exception'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告捕获不适当异常的 &lt;code&gt;catch&lt;/code&gt; 子句。
&lt;p&gt;一些异常（例如 &lt;code&gt;java.lang.NullPointerException&lt;/code&gt; 或 &lt;code&gt;java.lang.IllegalMonitorStateException&lt;/code&gt;）表示编程错误，因此几乎肯定不会在生产代码中被捕获。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  try {
    return component.getMousePosition(true) != null;
  } catch (NullPointerException e) { // warning: Prohibited exception 'NullPointerException' caught
    return false;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;使用&lt;b&gt;被禁止的异常&lt;/b&gt;列表可指定应报告哪些异常。&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CatchMayIgnoreException" defaultSeverity="WARNING" displayName="catch 块可能会忽略异常" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告空的或可能忽略异常的 &lt;code&gt;catch&lt;/code&gt; 块。
&lt;p&gt;虽然偶尔是有意为之，但空的 &lt;code&gt;catch&lt;/code&gt; 块可能导致调试复杂化。
此外，忽略 &lt;code&gt;catch&lt;/code&gt; 形参可能是错误的。
  最后，静态代码分析器会报告是否检测到 &lt;code&gt;catch&lt;/code&gt; 块可能无提示地忽略重要的 VM 异常，如 &lt;code&gt;NullPointerException&lt;/code&gt;。 忽略此类异常（不记录或重新抛出）可能会隐藏错误。&lt;/p&gt;

&lt;p&gt;
  该检查不会报告任何命名为 &lt;code&gt;ignore&lt;/code&gt; 或 &lt;code&gt;ignored&lt;/code&gt; 的 &lt;code&gt;catch&lt;/code&gt; 形参。
  相反，它将对真正在使用的命名为 &lt;code&gt;ignore&lt;/code&gt; 或 &lt;code&gt;ignored&lt;/code&gt; 的 &lt;code&gt;catch&lt;/code&gt; 形参发出警告。
  此外，该检查不会报告命名为 &lt;code&gt;expected&lt;/code&gt; 或 &lt;code&gt;ok&lt;/code&gt; 的测试源中的 &lt;code&gt;catch&lt;/code&gt; 形参。
&lt;/p&gt;
&lt;p&gt;
  您可以使用快速修复将异常名称更改为 &lt;code&gt;ignored&lt;/code&gt;。
  对于空的 &lt;b&gt;catch&lt;/b&gt; 块，建议使用其他快速修复来生成 &lt;b&gt;catch&lt;/b&gt; 主体。
  您可以在&lt;a href="settings://fileTemplates"&gt;设置 | 编辑器 | 文件和代码模板&lt;/a&gt;中的“代码”选项卡上修改 "Catch Statement Body" 模板。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  try {
    throwingMethod();
  } catch (IOException ex) {

  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  try {
    System.out.println(System.in.read());
  } catch (IOException ignored) {

  }
&lt;/code&gt;&lt;/pre&gt;
  &lt;!-- tooltip end --&gt;
&lt;p&gt;配置检查：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    使用&lt;b&gt;当 'catch' 块包含注释时不发出警告&lt;/b&gt;选项可以忽略包含注释的 &lt;code&gt;catch&lt;/code&gt; 块。
  &lt;/li&gt;
  &lt;li&gt;
    使用&lt;b&gt;当 'catch' 块不为空时不发出警告&lt;/b&gt;选项可以忽略其中包含语句或注释但又不使用变量本身的 &lt;code&gt;catch&lt;/code&gt; 块。
  &lt;/li&gt;
  &lt;li&gt;
    使用&lt;b&gt;当名称为 'ignore(d)' 的异常实际上未被忽略时不发出警告&lt;/b&gt;选项可以忽略使用中名称为 &lt;code&gt;ignored&lt;/code&gt; 的变量。
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;small&gt;2018.1 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UncheckedExceptionClass" defaultSeverity="WARNING" displayName="未检查的 'Exception' 类" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;java.lang.RuntimeException&lt;/code&gt; 的子类。
&lt;p&gt;某些编码标准要求检查所有用户定义的异常类。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class EnigmaException extends RuntimeException {} // 警告：未检查的异常类 'EnigmaException'
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ExtendsThrowable" defaultSeverity="WARNING" displayName="类直接扩展 'Throwable'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告直接扩展 &lt;code&gt;java.lang.Throwable&lt;/code&gt; 的类。
&lt;p&gt;直接扩展 &lt;code&gt;java.lang.Throwable&lt;/code&gt; 通常被认为是一种不好的做法。
  通常扩展 &lt;code&gt;java.lang.RuntimeException&lt;/code&gt;、&lt;code&gt;java.lang.Exception&lt;/code&gt; 或在特殊情况下扩展 &lt;code&gt;java.lang.Error&lt;/code&gt; 就足够了。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class EnigmaThrowable extends Throwable {} // 警告：'EnigmaThrowable' 类会直接扩展 'java.lang.Throwable'
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ThreadDeathRethrown" defaultSeverity="WARNING" displayName="'ThreadDeath' 未重新抛出" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告捕获 &lt;code&gt;java.lang.ThreadDeath&lt;/code&gt; 并且不重新抛出异常的 &lt;code&gt;try&lt;/code&gt; 语句。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  try {
    executeInParallel(request);
  } catch (ThreadDeath ex) { // warning: ThreadDeath 'ex' not rethrown
    return false;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="样式问题" path="Kotlin"><inspection shortName="ReplaceSubstringWithSubstringAfter" defaultSeverity="INFORMATION" displayName="'substring' 调用应被替换为 'substringAfter'" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以替换为 &lt;code&gt;s.substringAfter(x)&lt;/code&gt; 的 &lt;code&gt;s.substring(s.indexOf(x))&lt;/code&gt; 等调用。
&lt;p&gt;使用 &lt;code&gt;s.substringAfter(x)&lt;/code&gt; 可使代码更简单。&lt;/p&gt;
&lt;p&gt;该快速修复会将 &lt;code&gt;substring&lt;/code&gt; 调用替换为 &lt;code&gt;substringAfter&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(s: String) {
      s.substring(s.indexOf('x'))
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(s: String) {
      s.substringAfter('x')
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NestedLambdaShadowedImplicitParameter" defaultSeverity="WEAK WARNING" displayName="嵌套 lambda 具有隐藏的隐式形参" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告具有隐藏的隐式形参的嵌套 lambda。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
fun foo(listOfLists: List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt;) {
  listOfLists.forEach {
    it.forEach {
      println(it)
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
fun foo(listOfLists: List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt;) {
  listOfLists.forEach {
    it.forEach { it1 -&amp;gt;
      println(it1)
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ReplacePutWithAssignment" defaultSeverity="WEAK WARNING" displayName="'map.put()' 可以转换为赋值" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以替换为索引运算符 (&lt;code&gt;[]&lt;/code&gt;) 的 &lt;code&gt;map.put&lt;/code&gt; 函数调用。
&lt;p&gt;使用语法糖可使代码更简单。&lt;/p&gt;
&lt;p&gt;该快速修复会将 &lt;code&gt;put&lt;/code&gt; 调用替换为赋值。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(map: MutableMap&amp;lt;Int, String&amp;gt;) {
      map.put(42, &amp;quot;foo&amp;quot;)
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(map: MutableMap&amp;lt;Int, String&amp;gt;) {
      map[42] = &amp;quot;foo&amp;quot;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CascadeIf" defaultSeverity="WEAK WARNING" displayName="级联 if 应替换为 when" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告有三个以上分支并且可以替换为 &lt;code&gt;when&lt;/code&gt; 表达式的 &lt;code&gt;if&lt;/code&gt; 语句。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun checkIdentifier(id: String) {
      fun Char.isIdentifierStart() = this in 'A'..'z'
      fun Char.isIdentifierPart() = isIdentifierStart() || this in '0'..'9'

      if (id.isEmpty()) {
          print("Identifier is empty")
      } else if (!id.first().isIdentifierStart()) {
          print("Identifier should start with a letter")
      } else if (!id.subSequence(1, id.length).all(Char::isIdentifierPart)) {
          print("Identifier should contain only letters and numbers")
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;快速修复会将 &lt;code&gt;if&lt;/code&gt; 表达式转换为 &lt;code&gt;when&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun checkIdentifier(id: String) {
      fun Char.isIdentifierStart() = this in 'A'..'z'
      fun Char.isIdentifierPart() = isIdentifierStart() || this in '0'..'9'

      when {
          id.isEmpty() -&gt; {
              print("Identifier is empty")
          }
          !id.first().isIdentifierStart() -&gt; {
              print("Identifier should start with a letter")
          }
          !id.subSequence(1, id.length).all(Char::isIdentifierPart) -&gt; {
              print("Identifier should contain only letters and numbers")
          }
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SimplifyBooleanWithConstants" defaultSeverity="WEAK WARNING" displayName="可以简化布尔表达式" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告能够缩减为常量的布尔表达式。
&lt;p&gt;该快速修复会简化条件。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun use(arg: Boolean) {
      if (false == arg) {

      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun use(arg: Boolean) {
      if (!arg) {

      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="IfThenToElvis" defaultSeverity="WEAK WARNING" displayName="If-Then 可折叠为 '?:'" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以折叠到 elvis (&lt;code&gt;?:&lt;/code&gt;) 表达式中的 &lt;code&gt;if-then&lt;/code&gt; 表达式。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun maybeFoo(): String? = "foo"

  var foo = maybeFoo()
  val bar = if (foo == null) "hello" else foo
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该快速修复会将 &lt;code&gt;if-then&lt;/code&gt; 表达式转换为 elvis (&lt;code&gt;?:&lt;/code&gt;) 表达式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun maybeFoo(): String? = "foo"

  var foo = maybeFoo()
  val bar = foo ?: "hello"
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ReplaceCallWithBinaryOperator" defaultSeverity="WEAK WARNING" displayName="可被替换为二元运算符" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以替换为二元运算符（特别是与比较相关的运算符）的函数调用。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  fun test(): Boolean {
      return 2.compareTo(1) &gt; 0 // 可替换的 'compareTo()'
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  fun test(): Boolean {
      return 2 &gt; 1
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReplaceReadLineWithReadln" defaultSeverity="WEAK WARNING" displayName="'readLine' 可被替换为 'readln' 或 'readlnOrNull'" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对可被替换为 &lt;code&gt;readln()&lt;/code&gt; 或 &lt;code&gt;readlnOrNull()&lt;/code&gt; 的 &lt;code&gt;readLine()&lt;/code&gt; 的调用。
&lt;p&gt;
    使用相应函数可使代码更简单。
&lt;/p&gt;
&lt;p&gt;
    该快速修复会将 &lt;code&gt;readLine()!!&lt;/code&gt; 替换为 &lt;code&gt;readln()&lt;/code&gt;，并将 &lt;code&gt;readLine()&lt;/code&gt; 替换为 &lt;code&gt;readlnOrNull()&lt;/code&gt;。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    val x = readLine()!!
    val y = readLine()?.length
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    val x = readln()
    val y = readlnOrNull()?.length
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ConvertTryFinallyToUseCall" defaultSeverity="WEAK WARNING" displayName="将 try / finally 转换为 use() 调用" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;finally&lt;/code&gt; 中带有 &lt;code&gt;resource.close()&lt;/code&gt; 并可转换为 &lt;code&gt;resource.use()&lt;/code&gt; 调用的 &lt;code&gt;try-finally&lt;/code&gt; 块。
&lt;p&gt;&lt;code&gt;use()&lt;/code&gt; 更容易读取，且不易出错，因为无需显式 &lt;code&gt;close()&lt;/code&gt; 调用。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun example() {
      val reader = File("file.txt").bufferedReader()
      try {
          reader.lineSequence().forEach(::print)
      } finally {
          reader.close()
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun example() {
      File("file.txt").bufferedReader().use { reader -&gt;
          reader.lineSequence().forEach(::print)
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReplaceAssociateFunction" defaultSeverity="WEAK WARNING" displayName="'associate' 可被替换为 'associateBy' 或 'associateWith'" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对可以替换为 &lt;code&gt;associateBy()&lt;/code&gt; 或 &lt;code&gt;associateWith()&lt;/code&gt; 的 &lt;code&gt;associate()&lt;/code&gt; 和 &lt;code&gt;associateTo()&lt;/code&gt; 的调用。
&lt;p&gt;
    两个函数都接受应用于给定序列或集合（作为接收器）的元素的转换器函数。
    然后该对函数被用于构建结果 &lt;code&gt;Map&lt;/code&gt;。
&lt;/p&gt;
&lt;p&gt;
    鉴于转换器引用 &lt;code&gt;it&lt;/code&gt;，&lt;code&gt;associate[To]()&lt;/code&gt; 调用可以替换为性能更高的 &lt;code&gt;associateBy()&lt;/code&gt; 或 &lt;code&gt;associateWith()&lt;/code&gt;。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  fun getKey(i: Int) = 1L
  fun getValue(i: Int) = 1L

  fun test() {
      arrayOf(1).associate { getKey(it) to it }  // 可替换的 'associate()'
      listOf(1).associate { it to getValue(it) } // 可替换的 'associate()'
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  fun getKey(i: Int) = 1L
  fun getValue(i: Int) = 1L

  fun test() {
      arrayOf(1).associateBy { getKey(it) }
      listOf(1).associateWith { getValue(it) }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SafeCastWithReturn" defaultSeverity="WEAK WARNING" displayName="带有 'return' 的安全转换应替换为 'if' 类型检查" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告带 &lt;code&gt;return&lt;/code&gt; 且可以替换为 &lt;code&gt;if&lt;/code&gt; 类型检查的安全转换。
&lt;p&gt;使用相应函数可使代码更简单。&lt;/p&gt;
&lt;p&gt;该快速修复会将安全转换替换为 &lt;code&gt;if&lt;/code&gt; 类型检查。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(x: Any) {
      x as? String ?: return
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(x: Any) {
      if (x !is String) return
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FunctionWithLambdaExpressionBody" defaultSeverity="WEAK WARNING" displayName="具有 ''= { ... }'' 和推断返回值类型的函数" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告具有 &lt;code&gt;= { ... }&lt;/code&gt; 和推断返回类型的函数。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun sum(a: Int, b: Int) = { a + b } // 此函数的返回类型为 '() -&gt; Int'。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该快速修复会移除大括号：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun sum(a: Int, b: Int) = a + b
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConvertLambdaToReference" defaultSeverity="INFORMATION" displayName="可被替换为函数引用" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以替换为函数引用的函数文字表达式。
&lt;p&gt;将 lambda 替换为函数引用通常会使代码看起来更简洁易懂。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun Int.isEven() = this % 2 == 0

  fun example() {
      val numbers = listOf(1, 2, 4, 7, 9, 10)
      val evenNumbers = numbers.filter { it.isEven() }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun Int.isEven() = this % 2 == 0

  fun example() {
      val numbers = listOf(1, 2, 4, 7, 9, 10)
      val evenNumbers = numbers.filter(Int::isEven)
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ReplaceIsEmptyWithIfEmpty" defaultSeverity="WEAK WARNING" displayName="'if' 条件可被替换为 lambda 调用" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;if&lt;/code&gt; 语句中的 &lt;code&gt;isEmpty&lt;/code&gt;、&lt;code&gt;isBlank&lt;/code&gt;、&lt;code&gt;isNotEmpty&lt;/code&gt; 或 &lt;code&gt;isNotBlank&lt;/code&gt; 调用以赋予默认值。
&lt;p&gt;该快速修复会将 &lt;code&gt;if&lt;/code&gt; 条件替换为 &lt;code&gt;ifEmpty&lt;/code&gt; 或 &lt;code&gt;ifBlank&lt;/code&gt; 调用。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(list: List&amp;lt;Int&amp;gt;): List&amp;lt;Int&amp;gt; {
      return if (list.isEmpty()) {
          println()
          foo()
      } else {
          list
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(list: List&amp;lt;Int&amp;gt;): List&amp;lt;Int&amp;gt; {
      return list.ifEmpty {
          println()
          foo()
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;此检查仅报告项目或模块的 Kotlin 语言版本是否为 1.3 或更高版本。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnlabeledReturnInsideLambda" defaultSeverity="INFORMATION" displayName="lambda 中存在未标记的 return" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告内联 lambda 内未标记的 &lt;code&gt;return&lt;/code&gt; 表达式。
&lt;p&gt;此类表达式可能令人困惑，因为可能不清楚哪个范围属于 &lt;code&gt;return&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;更改为 return@…&lt;/b&gt; 快速修复可用于自动修正代码。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(list: List&amp;lt;Int&amp;gt;) {
      list.forEach {
          // 此返回表达式从函数测试返回
          // 可以将其更改为 return@forEach 以更改范围
          if (it == 10) return
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(list: List&amp;lt;Int&amp;gt;) {
      list.forEach {
          if (it == 10) return@test
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ImplicitThis" defaultSeverity="INFORMATION" displayName="隐式 'this'" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告隐式 &lt;b&gt;this&lt;/b&gt; 的使用情况。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
      fun s() = ""

      fun test() {
          s()
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该快速修复会显式指定 &lt;b&gt;this&lt;/b&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
      fun s() = ""

      fun test() {
          this.s()
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="MemberVisibilityCanBePrivate" defaultSeverity="WEAK WARNING" displayName="类成员可以具有 'private' 可见性" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以设为 &lt;code&gt;private&lt;/code&gt; 以遵循封装原则的声明。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
class Service(val url: String) {
    fun connect(): URLConnection = URL(url).openConnection()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;应用快速修复后（考虑到 &lt;code&gt;Service&lt;/code&gt; 类之外没有使用 &lt;code&gt;url&lt;/code&gt; 的情况）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
class Service(private val url: String) {
    fun connect(): URLConnection = URL(url).openConnection()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LoopToCallChain" defaultSeverity="INFORMATION" displayName="循环可被替换为 stdlib 运算" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可替换为 stdlib 运算的序列（如 &lt;code&gt;map&lt;/code&gt;、&lt;code&gt;filter&lt;/code&gt; 等）的 &lt;code&gt;for&lt;/code&gt; 循环。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
fun foo(list: List&amp;lt;String&amp;gt;): List&amp;lt;Int&amp;gt; {
  val result = ArrayList&amp;lt;Int&amp;gt;()
  for (s in list) {
     if (s.length &amp;gt; 0)
       result.add(s.hashCode())
     }
  return result
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
fun foo(list: List&amp;lt;String&amp;gt;): List&amp;lt;Int&amp;gt; {
  val result = list
    .filter { it.length &amp;gt; 0 }
    .map { it.hashCode() }
  return result
}&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SimplifiableCall" defaultSeverity="WEAK WARNING" displayName="可以简化库函数调用" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可替换为简化形式的库函数调用。
&lt;p&gt;使用相应函数可使代码更简单。&lt;/p&gt;
&lt;p&gt;该快速修复会在函数调用之间彼此替换。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(list: List&amp;lt;Any&amp;gt;) {
      list.filter { it is String }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(list: List&amp;lt;Any&amp;gt;) {
      list.filterIsInstance&amp;lt;String&amp;gt;()
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReplaceToWithInfixForm" defaultSeverity="WEAK WARNING" displayName="'to' 调用应被替换为中缀形式" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以替换为中缀形式的 &lt;code&gt;to&lt;/code&gt; 函数调用。
&lt;p&gt;使用中缀形式可使代码更简单。&lt;/p&gt;
&lt;p&gt;该快速修复会将 &lt;code&gt;to&lt;/code&gt; 替换为中缀形式。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(a: Int, b: Int) {
      val pair = a.to(b)
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(a: Int, b: Int) {
      val pair = a to b
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConvertToStringTemplate" defaultSeverity="WEAK WARNING" displayName="可以转换为字符串模板的字符串串联" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以转换为字符串模板的字符串串联。
&lt;p&gt;建议使用字符串模板，因为这样会使代码更容易读取。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun example() {
      val capitals = mapOf("France" to "Paris", "Spain" to "Madrid")
      for ((country, capital) in capitals) {
          print(capital + " is a capital of " + country)
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun example() {
      val capitals = mapOf("France" to "Paris", "Spain" to "Madrid")
      for ((country, capital) in capitals) {
          print("$capital is a capital of $country")
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ProtectedInFinal" defaultSeverity="WEAK WARNING" displayName="'protected' 可见性在 final 类中实际是 'private'" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在 &lt;code&gt;final&lt;/code&gt; 类内部使用的 &lt;code&gt;protected&lt;/code&gt; 可见性。
在这种情况下，&lt;code&gt;protected&lt;/code&gt; 成员只能在类本身中访问，因此它们实际上是 &lt;code&gt;private&lt;/code&gt;。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class FinalClass {
      &lt;b&gt;protected&lt;/b&gt; fun foo() {}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class FinalClass {
      &lt;b&gt;private&lt;/b&gt; fun foo() {}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RedundantRunCatching" defaultSeverity="WEAK WARNING" displayName="冗余 'runCatching' 调用" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告后面紧跟 &lt;code&gt;getOrThrow&lt;/code&gt; 的 &lt;code&gt;runCatching&lt;/code&gt; 调用。
此类调用可以仅替换为 &lt;code&gt;run&lt;/code&gt;。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo() = runCatching { doSomething() }.getOrThrow()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo() = run { doSomething() }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ReplaceGetOrSet" defaultSeverity="WEAK WARNING" displayName="显式 'get' 或 'set' 调用" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对可通过索引运算符 &lt;code&gt;[]&lt;/code&gt; 替换的 &lt;code&gt;get&lt;/code&gt; 或 &lt;code&gt;set&lt;/code&gt; 函数的显式调用。
&lt;p&gt;
    Kotlin 允许对类型的预定义运算符集进行自定义实现。
    要重载运算符，您可以使用 &lt;code&gt;operator&lt;/code&gt; 修饰符标记相应的函数：
    &lt;pre&gt;&lt;code&gt;
  operator fun get(index: Int) {}
  operator fun set(index: Int, value: Int) {}
    &lt;/code&gt;&lt;/pre&gt;

以上函数对应于索引运算符。

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  class Test {
      operator fun get(i: Int): Int = 0
  }

  fun test() {
      Test().get(0) // 可替换的 'get()'
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  class Test {
      operator fun get(i: Int): Int = 0
  }

  fun test() {
      Test()[0]
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="TrailingComma" defaultSeverity="WEAK WARNING" displayName="尾随逗号推荐" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告未遵循建议的&lt;a href="https://kotlinlang.org/docs/coding-conventions.html#trailing-commas"&gt;样式指南&lt;/a&gt;的尾随逗号。
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="VerboseNullabilityAndEmptiness" defaultSeverity="WEAK WARNING" displayName="详细的为 null 性和空性检查" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告可以简化为单个检查的 &lt;code&gt;null&lt;/code&gt; 和空检查的组合。&lt;/p&gt;
&lt;p&gt;该快速修复会将高亮显示的检查替换为组合的检查调用，例如 &lt;code&gt;isNullOrEmpty()&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(list: List&amp;lt;Int&gt;?) {
      if (list == null || list.isEmpty()) {
          println("List is empty!")
      } else {
          println(list.joinToString())
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(list: List&amp;lt;Int&gt;?) {
      if (list.isNullOrEmpty()) {
          println("List is empty!")
      } else {
          println(list.joinToString())
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReplaceSizeCheckWithIsNotEmpty" defaultSeverity="WEAK WARNING" displayName="大小检查可被替换为 'isNotEmpty()'" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告应替换为 &lt;code&gt;isNotEmpty()&lt;/code&gt; 的 &lt;code&gt;Collections/Array/String&lt;/code&gt; 的大小检查。
&lt;p&gt;使用 &lt;code&gt;isNotEmpty()&lt;/code&gt; 可使代码更简单。&lt;/p&gt;
&lt;p&gt;该快速修复会将大小检查替换为 &lt;code&gt;isNotEmpty()&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo() {
      val arrayOf = arrayOf(1, 2, 3)
      arrayOf.size &amp;gt; 0
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo() {
      val arrayOf = arrayOf(1, 2, 3)
      arrayOf.isNotEmpty()
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReplaceCollectionCountWithSize" defaultSeverity="WEAK WARNING" displayName="集合计数可以转换为大小" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对 &lt;code&gt;Collection&amp;lt;T&amp;gt;.count()&lt;/code&gt; 的调用。
&lt;p&gt;
    此函数调用可以替换为 &lt;code&gt;.size&lt;/code&gt;。
&lt;/p&gt;
&lt;p&gt;
    &lt;code&gt;.size&lt;/code&gt; 形式可以确保运算是 O(1) 并且不会分配额外的对象，而 &lt;code&gt;count()&lt;/code&gt; 可能与 &lt;code&gt;Iterable&amp;lt;T&amp;gt;.count()&lt;/code&gt; 混淆，后者是 O(n) 和分配。
    &lt;br&gt;
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  fun foo() {
      var list = listOf(1,2,3)
      list.count() // 可替换的 'count()'
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  fun foo() {
      var list = listOf(1,2,3)
      list.size
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ReplaceToStringWithStringTemplate" defaultSeverity="INFORMATION" displayName="'toString' 的调用可被替换为字符串模板" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以替换为字符串模板的 &lt;code&gt;toString&lt;/code&gt; 函数调用。
&lt;p&gt;使用字符串模板可使代码更简单。&lt;/p&gt;
&lt;p&gt;该快速修复会将 &lt;code&gt;toString&lt;/code&gt; 替换为字符串模板。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(): String {
      val x = 1
      return x.toString()
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(): String {
      val x = 1
      return &amp;quot;$x&amp;quot;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="OptionalExpectation" defaultSeverity="INFORMATION" displayName="可选预期注解没有实际注解" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告某些平台模块中没有实际注解的可选预期注解。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 通用代码
@OptionalExpectation
expect annotation class JvmName(val name: String)

@JvmName(name = "JvmFoo")
fun foo() { }

// jvm 代码
actual annotation class JvmName(val name: String)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该检查还会报告对非 JVM 平台（例如 Native）省略 &lt;code&gt;actual annotation class JvmName&lt;/code&gt; 的情况。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LiftReturnOrAssignment" defaultSeverity="WEAK WARNING" displayName="可以提取 return 或赋值" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以通过提取 &lt;code&gt;return&lt;/code&gt; 语句或赋值而转换为表达式的 &lt;code&gt;if&lt;/code&gt;、&lt;code&gt;when&lt;/code&gt; 和 &lt;code&gt;try&lt;/code&gt; 语句。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(arg: Int): String {
      when (arg) {
          0 -&gt; return "Zero"
          1 -&gt; return "One"
          else -&gt; return "Multiple"
      }
  }
&lt;/code&gt;&lt;/pre&gt;
在应用快速修复后：
&lt;pre&gt;&lt;code&gt;
  fun foo(arg: Int): String {
      return when (arg) {
          0 -&gt; "Zero"
          1 -&gt; "One"
          else -&gt; "Multiple"
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MoveLambdaOutsideParentheses" defaultSeverity="WEAK WARNING" displayName="圆括号内的 lambda 实参" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告圆括号中可以移到外部的 lambda 表达式。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
fun square(a: Int, b: (Int) -&amp;gt; Int) {
  b(a * a)
}

fun foo() {
  square(2, { it })
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
fun foo() {
  square(2){ it }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReplaceJavaStaticMethodWithKotlinAnalog" defaultSeverity="WEAK WARNING" displayName="Java 方法应替换为 Kotlin 模拟" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以替换为 Kotlin 函数的 Java 方法调用，例如 &lt;code&gt;System.out.println()&lt;/code&gt;。
&lt;p&gt;替换该代码会去除 Java 的依赖项并使 Kotlin 代码更地道。&lt;/p&gt;
&lt;p&gt;该快速修复会替换相同 Kotlin 调用上的 Java 方法调用。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  import java.util.Arrays

  fun main() {
      val a = Arrays.asList(1, 3, null)
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun main() {
      val a = listOf(1, 3, null)
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AddOperatorModifier" defaultSeverity="INFORMATION" displayName="函数应具有 'operator' 修饰符" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告与其中一个运算符约定匹配但缺少 &lt;code&gt;operator&lt;/code&gt; 关键字的函数。
&lt;p&gt;通过添加 &lt;code&gt;operator&lt;/code&gt; 修饰符，您可以允许函数使用者编写惯用的 Kotlin 代码。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Complex(val real: Double, val imaginary: Double) {
      fun plus(other: Complex) =
          Complex(real + other.real, imaginary + other.imaginary)
  }

  fun usage(a: Complex, b: Complex) {
      a.plus(b)
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该快速修复会添加 &lt;code&gt;operator&lt;/code&gt; 修饰符关键字：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Complex(val real: Double, val imaginary: Double) {
      operator fun plus(other: Complex) =
          Complex(real + other.real, imaginary + other.imaginary)
  }

  fun usage(a: Complex, b: Complex) {
      a + b
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReplaceRangeToWithUntil" defaultSeverity="WEAK WARNING" displayName="'rangeTo' 或 '..' 调用应被替换为 'until'" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对 &lt;code&gt;rangeTo&lt;/code&gt; 或 &lt;code&gt;..&lt;/code&gt; 运算符的调用，而非对 &lt;code&gt;until&lt;/code&gt; 的调用。
&lt;p&gt;使用相应函数可使代码更简单。&lt;/p&gt;
&lt;p&gt;该快速修复会将 &lt;code&gt;rangeTo&lt;/code&gt; 或 &lt;code&gt;..&lt;/code&gt; 调用替换为 &lt;code&gt;until&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(a: Int) {
      for (i in 0..a - 1) {

      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(a: Int) {
      for (i in 0 until a) {

      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ReplaceRangeStartEndInclusiveWithFirstLast" defaultSeverity="WEAK WARNING" displayName="装箱的属性应替换为未装箱的属性" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告&lt;b&gt;装箱的&lt;/b&gt; &lt;code&gt;Range.start&lt;/code&gt; 和 &lt;code&gt;Range.endInclusive&lt;/code&gt; 属性。
&lt;p&gt;这些属性可替换为&lt;b&gt;未装箱的&lt;/b&gt; &lt;code&gt;first&lt;/code&gt; 和 &lt;code&gt;last&lt;/code&gt; 属性以避免冗余调用。&lt;/p&gt;
&lt;p&gt;该快速修复会将 &lt;code&gt;start&lt;/code&gt; 和 &lt;code&gt;endInclusive&lt;/code&gt; 属性替换为相应的 &lt;code&gt;first&lt;/code&gt; 和 &lt;code&gt;last&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(range: CharRange) {
      val lastElement = range.endInclusive
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(range: CharRange) {
      val lastElement = range.last
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReplaceAssertBooleanWithAssertEquality" defaultSeverity="WEAK WARNING" displayName="断言布尔可被替换为断言等式" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对可以替换为断言相等函数的 &lt;code&gt;assertTrue()&lt;/code&gt; 和 &lt;code&gt;assertFalse()&lt;/code&gt; 的调用。
&lt;p&gt;
    &lt;code&gt;assertEquals()&lt;/code&gt;、&lt;code&gt;assertSame()&lt;/code&gt; 及其否定对应项 (-Not-) 可以提供有关失败的更多信息。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  assertTrue(a == b)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  assertEquals(a, b)
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReplaceGuardClauseWithFunctionCall" defaultSeverity="INFORMATION" displayName="临界子句可被替换为 Kotlin 的函数调用" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以替换为函数调用的临界子句。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  fun test(foo: Int?) {
      if (foo == null) throw IllegalArgumentException("foo") // 可替换的子句
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  fun test(foo: Int?) {
      checkNotNull(foo)
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="IntroduceWhenSubject" defaultSeverity="WEAK WARNING" displayName="可以通过引入实参简化的 'when'" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以通过引入主体实参进行简化的 &lt;code&gt;when&lt;/code&gt; 表达式。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(obj: Any): String {
      return when {
          obj is String -&gt; "string"
          obj is Int -&gt; "int"
          else -&gt; "unknown"
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该快速修复会引入一个主体实参：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(obj: Any): String {
      return when (obj) {
          is String -&gt; "string"
          is Int -&gt; "int"
          else -&gt; "unknown"
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="MapGetWithNotNullAssertionOperator" defaultSeverity="INFORMATION" displayName="包含非 null 断言运算符 (!!) 的 'map.get()'" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可替换为 &lt;code&gt;map.getValue()&lt;/code&gt;、&lt;code&gt;map.getOrElse()&lt;/code&gt; 等的 &lt;code&gt;map.get()!!&lt;/code&gt;。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
fun test(map: Map&amp;lt;Int, String&amp;gt;): String = map.get(0)!!
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
fun test(map: Map&amp;lt;Int, String&amp;gt;): String = map.getValue(0)
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReplaceStringFormatWithLiteral" defaultSeverity="INFORMATION" displayName="'String.format' 调用可被替换为字符串模板" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以替换为字符串模板的 &lt;code&gt;String.format&lt;/code&gt; 调用。
&lt;p&gt;使用字符串模板可使代码更简单。&lt;/p&gt;
&lt;p&gt;该快速修复会将调用替换为字符串模板。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun main() {
      val id = &amp;quot;abc&amp;quot;
      val date = &amp;quot;123&amp;quot;
      val s = String.format(&amp;quot;%s_%s_%s&amp;quot;, id, date, id)
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun main() {
      val id = &amp;quot;abc&amp;quot;
      val date = &amp;quot;123&amp;quot;
      val s = &amp;quot;${id}_${date}_$id&amp;quot;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantAsSequence" defaultSeverity="WEAK WARNING" displayName="冗余 'asSequence' 调用" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告永远不会产生积极的性能影响的冗余 &lt;code&gt;asSequence()&lt;/code&gt; 调用。&lt;/p&gt;
&lt;p&gt;
    &lt;code&gt;asSequence()&lt;/code&gt; 会加速包含多个运算的集合处理，因为它会延迟执行运算并且不会创建中间集合。
&lt;/p&gt;
&lt;p&gt;
    但是，如果在 &lt;code&gt;asSequence()&lt;/code&gt; 之后立即使用终端运算（例如 &lt;code&gt;toList()&lt;/code&gt;），则不会带来任何积极的性能效果。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(list: List&amp;lt;String&amp;gt;) {
      list.&lt;b&gt;asSequence()&lt;/b&gt;.last()
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(list: List&amp;lt;String&amp;gt;) {
      list.last()
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SortModifiers" defaultSeverity="WEAK WARNING" displayName="非规范修饰符顺序" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告未遵循&lt;a href="https://kotlinlang.org/docs/coding-conventions.html#modifiers-order"&gt;样式指南&lt;/a&gt;中所建议顺序的修饰符。
&lt;p&gt;&lt;b&gt;对修饰符排序&lt;/b&gt;快速修复可用于自动修正代码。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  private inline fun correctOrder(f: () -&gt; Unit) {} // &amp;lt;== Ok

  infix private fun Int.wrongOrder(expr: Int) {} // &amp;lt;== 顺序错误，快速修复会将修饰符修正为 "private infix"
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ReplaceManualRangeWithIndicesCalls" defaultSeverity="WEAK WARNING" displayName="范围可以转换为索引或迭代" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以替换为 &lt;code&gt;Collection.indices&lt;/code&gt; 或 &lt;code&gt;for&lt;/code&gt; 循环内集合迭代的 &lt;code&gt;until&lt;/code&gt; 和 &lt;code&gt;rangeTo&lt;/code&gt; 运算符。
&lt;p&gt;使用语法糖可使代码更简单。&lt;/p&gt;
&lt;p&gt;该快速修复会将手动范围替换为相应的构造。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun main(args: Array&amp;lt;String&amp;gt;) {
      for (index in 0..args.size - 1) {
          println(args[index])
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun main(args: Array&amp;lt;String&amp;gt;) {
      for (element in args) {
          println(element)
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConvertTwoComparisonsToRangeCheck" defaultSeverity="WEAK WARNING" displayName="两个比较应转换为范围检查" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可转换为范围检查的两个连续比较。
&lt;p&gt;通过移除测试主体重复，针对范围进行检查使代码更简单。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun checkMonth(month: Int): Boolean {
      return month &gt;= 1 &amp;&amp; month &amp;lt;= 12
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;快速修复可将基于比较的检查替换为针对范围的检查：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun checkMonth(month: Int): Boolean {
      return month in 1..12
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SimplifiableCallChain" defaultSeverity="WEAK WARNING" displayName="可以简化集合类型上的调用链" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可由单个调用替换的双调用链。
&lt;p&gt;它可以帮助您避免冗余代码执行。&lt;/p&gt;
&lt;p&gt;该快速修复会将调用链替换为单个调用。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun main() {
      listOf(1, 2, 3).filter { it &amp;gt; 1 }.count()
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun main() {
      listOf(1, 2, 3).count { it &amp;gt; 1 }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="JoinDeclarationAndAssignment" defaultSeverity="WEAK WARNING" displayName="联接声明和赋值" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以与以下赋值联接的属性声明。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  val x: String
  x = System.getProperty("")
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该快速修复会将声明与赋值联接：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  val x = System.getProperty("")
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="UseWithIndex" defaultSeverity="WEAK WARNING" displayName="手动递增的索引变量可被替换为使用 'withIndex()'" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告带有手动递增索引变量的 &lt;code&gt;for&lt;/code&gt; 循环。
&lt;p&gt;可以使用 &lt;code&gt;withIndex()&lt;/code&gt; 函数简化带有手动递增索引变量的 &lt;code&gt;for&lt;/code&gt; 循环。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;使用 withIndex() 代替手动索引递增&lt;/b&gt;快速修复可用于自动修正代码。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(list: List&amp;lt;String&amp;gt;): Int? {
      var index = 0
      for (s in list) { &amp;lt;== can be simplified
          val x = s.length * index
          index++
          if (x &gt; 0) return x
      }
      return null
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(list: List&amp;lt;String&amp;gt;): Int? {
      for ((index, s) in list.withIndex()) {
          val x = s.length * index
          if (x &gt; 0) return x
      }
      return null
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ReplaceNegatedIsEmptyWithIsNotEmpty" defaultSeverity="WEAK WARNING" displayName="可以简化否定调用" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告集合与 &lt;code&gt;String&lt;/code&gt; 的否定 &lt;code&gt;isEmpty()&lt;/code&gt; 和 &lt;code&gt;isNotEmpty()&lt;/code&gt;，或者 &lt;code&gt;String&lt;/code&gt; 的 &lt;code&gt;isBlank()&lt;/code&gt; 和 &lt;code&gt;isNotBlank()&lt;/code&gt;。
&lt;p&gt;使用相应函数可使代码更简单。&lt;/p&gt;
&lt;p&gt;该快速修复会将否定调用替换为标准库中的相应调用。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun main() {
      val list = listOf(1,2,3)
      if (!list.isEmpty()) {
          // 执行 smth
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun main() {
      val list = listOf(1,2,3)
      if (list.isNotEmpty()) {
          // 执行 smth
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConvertPairConstructorToToFunction" defaultSeverity="INFORMATION" displayName="将 Pair 构造函数转换为 'to' 函数" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可替换为 &lt;code&gt;to()&lt;/code&gt; 中缀函数调用的 &lt;code&gt;Pair&lt;/code&gt; 构造函数调用。
&lt;p&gt;
    显式构造函数调用可能会增添冗余，尤其是在多次使用时。
    将构造函数调用替换为 &lt;code&gt;to()&lt;/code&gt; 会使读取和维护代码变得更容易。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  val countries = mapOf(
      Pair("France", "Paris"),
      Pair("Spain", "Madrid"),
      Pair("Germany", "Berlin")
  )
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  val countries = mapOf(
      "France" to "Paris",
      "Spain" to "Madrid",
      "Germany" to "Berlin"
  )
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ReplaceSubstringWithSubstringBefore" defaultSeverity="INFORMATION" displayName="'substring' 调用应被替换为 'substringBefore'" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以替换为 &lt;code&gt;s.substringBefore(x)&lt;/code&gt; 的 &lt;code&gt;s.substring(0, s.indexOf(x))&lt;/code&gt; 等调用。
&lt;p&gt;使用 &lt;code&gt;substringBefore()&lt;/code&gt; 可使代码更简单。&lt;/p&gt;
&lt;p&gt;该快速修复会将 &lt;code&gt;substring&lt;/code&gt; 调用替换为 &lt;code&gt;substringBefore&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(s: String) {
      s.substring(0, s.indexOf('x'))
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(s: String) {
      s.substringBefore('x')
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantObjectTypeCheck" defaultSeverity="INFORMATION" displayName="对象的非惯用 'is' 类型检查" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告对象的非惯用 &lt;code&gt;is&lt;/code&gt; 类型检查。&lt;/p&gt;
&lt;p&gt;建议将此类检查替换为引用比较。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  object Foo

  fun foo(arg: Any) = when {
      arg &lt;b&gt;is&lt;/b&gt; Foo -&gt; ...
      arg &lt;b&gt;!is&lt;/b&gt; Foo -&gt; ...
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  object Foo

  fun foo(arg: Any) = when {
      arg &lt;b&gt;===&lt;/b&gt; Foo -&gt; ...
      arg &lt;b&gt;!==&lt;/b&gt; Foo -&gt; ...
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReplaceSubstringWithDropLast" defaultSeverity="INFORMATION" displayName="'substring' 调用应被替换为 'dropLast' 调用" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以替换为 &lt;code&gt;s.dropLast(x)&lt;/code&gt; 的 &lt;code&gt;s.substring(0, s.length - x)&lt;/code&gt; 等调用。
&lt;p&gt;使用相应函数可使代码更简单。&lt;/p&gt;
&lt;p&gt;该快速修复会将 &lt;code&gt;substring&lt;/code&gt; 调用替换为 &lt;code&gt;dropLast&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(s: String) {
      s.substring(0, s.length - 5)
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(s: String) {
      s.dropLast(5)
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MayBeConstant" defaultSeverity="WEAK WARNING" displayName="可能为 'const'" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告为了获得更好的性能和 Java 互操作性而可能声明为 &lt;code&gt;const&lt;/code&gt; 的对象中的顶级 &lt;code&gt;val&lt;/code&gt; 属性。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  object A {
      val foo = 1
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  object A {
      const val foo = 1
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SimplifyNegatedBinaryExpression" defaultSeverity="WEAK WARNING" displayName="可以简化求反布尔表达式" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以简化的否定二进制表达式。
&lt;p&gt;该快速修复会简化二进制表达式。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(n: Int) {
      !(0 == 1)
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(n: Int) {
      0 != 1
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnclearPrecedenceOfBinaryExpression" defaultSeverity="WARNING" displayName="具有不同优先级的多个运算符" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告包含不同运算符且无圆括号的二进制表达式。
&lt;p&gt;此类表达式可能由于不同的运算符&lt;a href="https://kotlinlang.org/docs/reference/grammar.html#expressions"&gt;优先级规则&lt;/a&gt;而可读性不佳。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;
  fun foo(b: Boolean?, i: Int?) {
      val x = b ?: i == null // 评估为 `(b ?: i) == null`
      val y = i ?: 0 + 1 // 评估为 `i ?: (0 + 1)`
  }
&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReplaceMapIndexedWithListGenerator" defaultSeverity="WEAK WARNING" displayName="将 'mapIndexed' 替换为 List 生成器" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以替换为 &lt;code&gt;List&lt;/code&gt; 生成器的 &lt;code&gt;mapIndexed&lt;/code&gt; 调用。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  val a = listOf(1, 2, 3).mapIndexed { i, _ -&gt;
      i + 42
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  val a = List(listOf(1, 2, 3).size) { i -&gt;
          i + 42
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SimplifyNestedEachInScopeFunction" defaultSeverity="WEAK WARNING" displayName="嵌套 forEach 的范围函数可以简化" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;also&lt;/code&gt; 或 &lt;code&gt;apply&lt;/code&gt; 等范围函数中可以简化的 &lt;code&gt;forEach&lt;/code&gt; 函数。
&lt;p&gt;&lt;b&gt;将 forEach 调用转换为 onEach&lt;/b&gt; 快速修复可用于自动修正代码。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(list: List&amp;lt;Int&amp;gt;) {
      val x = list.also { it.forEach { it + 4 } }.toString()
      val y = list.apply { forEach { println(it) } }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(list: List&amp;lt;Int&amp;gt;) {
      val x = list.onEach { it + 4 }.toString()
      val y = list.onEach { println(it) }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConvertCallChainIntoSequence" defaultSeverity="WEAK WARNING" displayName="可以将集合上的调用链转换为 'Sequence' 来改善性能" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告应转换为 &lt;b&gt;Sequence&lt;/b&gt; 的 &lt;code&gt;Collection&lt;/code&gt; 上的调用链。
&lt;p&gt;每个 &lt;code&gt;Collection&lt;/code&gt; 转换函数（例如 &lt;code&gt;map()&lt;/code&gt; 或 &lt;code&gt;filter()&lt;/code&gt;）都会在后台创建一个新的
     &lt;code&gt;Collection&lt;/code&gt;（通常是 &lt;code&gt;List&lt;/code&gt; 或 &lt;code&gt;Set&lt;/code&gt;）。
    多次后续调用以及 &lt;code&gt;Collection&lt;/code&gt; 中存在大量条目的情况下，内存流量可能会很大。
    这种情况下，最好使用 &lt;code&gt;Sequence&lt;/code&gt;。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Entity(val key: String, val value: String)

  fun getValues(lines: List&amp;lt;String&amp;gt;) = lines
      .filter { it.isNotEmpty() }
      .map { it.split(',', limit = 2) }
      .filter { it.size == 2 }
      .map { Entity(it[0], it[1]) }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;快速修复可将调用链包装到 &lt;code&gt;asSequence()&lt;/code&gt; 和 &lt;code&gt;toList()&lt;/code&gt; 中：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Entity(val key: String, val value: String)

  fun getValues(lines: List&amp;lt;String&amp;gt;) = lines
      .asSequence()
      .filter { it.isNotEmpty() }
      .map { it.split(',', limit = 2) }
      .filter { it.size == 2 }
      .map { Entity(it[0], it[1]) }
      .toList()
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReplaceSubstringWithIndexingOperation" defaultSeverity="INFORMATION" displayName="'substring' 调用应被替换为索引运算符" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以替换为 &lt;code&gt;"abc"[0]&lt;/code&gt; 的 &lt;code&gt;"abc".substring(0, 1)&lt;/code&gt; 等调用。
&lt;p&gt;按索引获取元素可使代码更简单。&lt;/p&gt;
&lt;p&gt;该快速修复会将 &lt;code&gt;substring&lt;/code&gt; 调用替换为索引运算符。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo() {
      &amp;quot;abc&amp;quot;.substring(0, 1)
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo() {
      &amp;quot;abc&amp;quot;[0]
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="IfThenToSafeAccess" defaultSeverity="WEAK WARNING" displayName="If-Then 可折叠为 '?.'" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以折叠到安全访问 (&lt;code&gt;?.&lt;/code&gt;) 表达式中的 &lt;code&gt;if-then&lt;/code&gt; 表达式。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun bar(x: String) = ""

  fun foo(a: String?) {
     if (a != null) bar(a) else null
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该快速修复会将 &lt;code&gt;if-then&lt;/code&gt; 表达式转换为安全访问 (&lt;code&gt;?.&lt;/code&gt;) 表达式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun bar(x: String) = ""

  fun foo(a: String?) {
     a?.let { bar(it) }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ReplaceArrayOfWithLiteral" defaultSeverity="WEAK WARNING" displayName="'arrayOf' 调用可被替换为数组文字 […]" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以替换为数组文字 &lt;code&gt;[...]&lt;/code&gt; 的 &lt;code&gt;arrayOf&lt;/code&gt; 调用。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  annotation class MyAnnotation(val strings: Array&amp;lt;String&amp;gt;)

  @MyAnnotation(arrayOf("alpha", "beta", "omega")) // 可替换的 'arrayOf()'
  class MyClass
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  annotation class MyAnnotation(val strings: Array&amp;lt;String&amp;gt;)

  @MyAnnotation(["alpha", "beta", "omega"])
  class MyClass
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ReplaceNotNullAssertionWithElvisReturn" defaultSeverity="WEAK WARNING" displayName="非 null 断言可被替换为 'return'" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以替换为 elvis 运算符和 return (&lt;code&gt;?: return&lt;/code&gt;) 的非 null 断言 (&lt;code&gt;!!&lt;/code&gt;) 调用。
&lt;p&gt;非 null 断言会产生非预期的 NPE (NullPointerException)。 比较好的做法是避免使用 &lt;code&gt;!!&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;该快速修复会将非 null 断言替换为 &lt;code&gt;return&lt;/code&gt; 或 &lt;code&gt;return null&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(number: Int?) {
      val x = number!!
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(number: Int?) {
      val x = number ?: return
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NullableBooleanElvis" defaultSeverity="WEAK WARNING" displayName="可以使用相等检查代替 elvis 进行可以为 null 的布尔检查" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告应该使用相等检查而不是 elvis 运算符的情况。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
fun check(a: Boolean? == null) {
    if (a ?: false) throw IllegalStateException()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
fun check(a: Boolean? == null) {
    if (a == true) throw IllegalStateException()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnusedMainParameter" defaultSeverity="WEAK WARNING" displayName="主形参不必要" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告带有单个未使用形参的 &lt;code&gt;main&lt;/code&gt; 函数。
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SuspiciousAsDynamic" defaultSeverity="WEAK WARNING" displayName="可疑的 'asDynamic' 成员调用" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告动态类型接收器上的 &lt;code&gt;asDynamic&lt;/code&gt; 函数用法。
&lt;p&gt;&lt;code&gt;asDynamic&lt;/code&gt; 函数对动态类型的表达式无影响。&lt;/p&gt;
&lt;p&gt;动态类型接收器上的 &lt;code&gt;asDynamic&lt;/code&gt; 函数会导致运行时问题，因为 &lt;code&gt;asDynamic&lt;/code&gt; 将在 JavaScript 环境中执行，而且此类函数在运行时可能并不显示。
    预期方式是在常用 Kotlin 类型上使用此函数。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;移除 "asDynamic" 调用&lt;/b&gt;快速修复可用于自动修正代码。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun wrongUsage(d: Dynamic) {
     d.asDynamic().foo() // &amp;lt;== 冗余，快速修复会将调用表达式简化为 "d.foo()"
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JavaCollectionsStaticMethod" defaultSeverity="WEAK WARNING" displayName="Java 集合 static 方法调用可被替换为 Kotlin stdlib" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以替换为 Kotlin stdlib 的 Java &lt;code&gt;Collections&lt;/code&gt; static 方法调用。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  import java.util.Collections

  fun test() {
      val mutableList = mutableListOf(1, 2)
      Collections.fill(mutableList, 3)
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该快速修复会将 Java &lt;code&gt;Collections&lt;/code&gt; static 方法调用替换为相应的 Kotlin stdlib 方法调用：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  import java.util.Collections

  fun test() {
      val mutableList = mutableListOf(1, 2)
      mutableList.fill(3)
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SimplifyAssertNotNull" defaultSeverity="INFORMATION" displayName="'assert' 调用可被替换为 '!!' 或 '?:'" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告检查已声明变量非 null 值的 &lt;code&gt;assert&lt;/code&gt; 调用。
&lt;p&gt;使用 &lt;code&gt;!!&lt;/code&gt; or &lt;code&gt;?:&lt;/code&gt; 可使代码更简单。&lt;/p&gt;
&lt;p&gt;该快速修复会将变量初始值设定项中的 &lt;code&gt;assert&lt;/code&gt; 替换为 &lt;code&gt;!!&lt;/code&gt; 或 &lt;code&gt;?:&lt;/code&gt; 运算符。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(p: Array&amp;lt;String?&amp;gt;) {
      val v = p[0]
      assert(v != null, { &amp;quot;Should be not null&amp;quot; })
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(p: Array&amp;lt;String?&amp;gt;) {
      val v = p[0] ?: error(&amp;quot;Should be not null&amp;quot;)
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ReplaceSubstringWithTake" defaultSeverity="INFORMATION" displayName="'substring' 调用应被替换为 'take' 调用" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以替换为 &lt;code&gt;s.take(x)&lt;/code&gt; 的 &lt;code&gt;s.substring(0, x)&lt;/code&gt; 等调用。
&lt;p&gt;使用 &lt;code&gt;take()&lt;/code&gt; 可使代码更简单。&lt;/p&gt;
&lt;p&gt;该快速修复会将 &lt;code&gt;substring&lt;/code&gt; 调用替换为 &lt;code&gt;take()&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(s: String) {
      s.substring(0, 10)
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(s: String) {
      s.take(10)
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReplaceWithImportAlias" defaultSeverity="INFORMATION" displayName="完全限定名称可被替换为现有的导入别名" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以替换为现有导入别名的完全限定名称。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
import foo.Foo as Bar
fun main() {
    foo.Foo()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
import foo.Foo as Bar
fun main() {
    Bar()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="AddVarianceModifier" defaultSeverity="INFORMATION" displayName="类型形参可以具有 'in' 或 'out' 差异" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以具有 &lt;code&gt;in&lt;/code&gt; 或 &lt;code&gt;out&lt;/code&gt; 差异的类型形参。
&lt;p&gt;使用 &lt;code&gt;in&lt;/code&gt; 和 &lt;code&gt;out&lt;/code&gt; 差异可以在 Kotlin 中提供更精确的类型推断以及更清晰的代码语义。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Box&amp;lt;T&amp;gt;(val obj: T)

  fun consumeString(box: Box&amp;lt;String&amp;gt;) {}
  fun consumeCharSequence(box: Box&amp;lt;CharSequence&amp;gt;) {}

  fun usage(box: Box&amp;lt;String&amp;gt;) {
      consumeString(box)
      consumeCharSequence(box) // 编译时错误
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该快速修复会添加匹配的差异修饰符：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Box&amp;lt;out T&amp;gt;(val obj: T)

  fun consumeString(box: Box&amp;lt;String&amp;gt;) {}
  fun consumeCharSequence(box: Box&amp;lt;CharSequence&amp;gt;) {}

  fun usage(box: Box&amp;lt;String&amp;gt;) ++{
      consumeString(box)
      consumeCharSequence(box) // 可以
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ScopeFunctionConversion" defaultSeverity="INFORMATION" displayName="范围函数可以转换为另一个" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可彼此转换的范围函数（&lt;code&gt;let&lt;/code&gt;、&lt;code&gt;run&lt;/code&gt;、&lt;code&gt;apply&lt;/code&gt;、&lt;code&gt;also&lt;/code&gt;）。
&lt;p&gt;使用相应函数可使代码更简单。&lt;/p&gt;
&lt;p&gt;该快速修复会在范围函数之间彼此替换。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  val x = &amp;quot;&amp;quot;.let {
      it.length
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  val x = &amp;quot;&amp;quot;.run {
      length
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ObjectLiteralToLambda" defaultSeverity="WEAK WARNING" displayName="对象文字可以转换为 lambda" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告使用单个 abstract 方法实现 Java 接口的匿名对象文字，该方法可使用 lambda 表达式转换为调用。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
class SomeService {
  val threadPool = Executors.newCachedThreadPool()
    
  fun foo() {
    threadPool.submit(object : Runnable {
      override fun run() {
        println("hello")
      }
    })
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo() {
    threadPool.submit { println("hello") }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="UseExpressionBody" defaultSeverity="INFORMATION" displayName="此处更适合表达式主体语法" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
返回可以替换为表达式主体语法的 &lt;code&gt;return&lt;/code&gt; 表达式（一行代码或 &lt;code&gt;when&lt;/code&gt;）。
&lt;p&gt;表达式主体语法建议在&lt;a href="https://kotlinlang.org/docs/coding-conventions.html#functions"&gt;样式指南&lt;/a&gt;中给出。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;转换为表达式主体&lt;/b&gt;快速修复可用于自动修正代码。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun sign(x: Int): Int {
      return when { // &amp;lt;== 可以简化
          x &amp;lt; 0 -&gt; -1
          x &gt; 0 -&gt; 1
          else -&gt; 0
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun sign(x: Int): Int = when {
      x &amp;lt; 0 -&gt; -1
      x &gt; 0 -&gt; 1
      else -&gt; 0
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ConvertSecondaryConstructorToPrimary" defaultSeverity="WARNING" displayName="转换为主构造函数" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以替换为更简洁的主构造函数的辅助构造函数。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class User {
      val name: String

      constructor(name: String) {
          this.name = name
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该快速修复会自动转换代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class User(val name: String) {
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="JavaMapForEach" defaultSeverity="WEAK WARNING" displayName="Java Map.forEach 方法调用应被替换为 Kotlin 的 forEach" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以替换为 Kotlin 的 &lt;b&gt;forEach&lt;/b&gt; 的 Java Map.&lt;code&gt;forEach&lt;/code&gt; 方法调用。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(map: HashMap&amp;lt;Int, String&gt;) {
      map.forEach { (key, value) -&gt;
          foo(key, value)
      }
  }

  fun foo(i: Int, s: String) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该快速修复会移除圆括号：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(map: HashMap&amp;lt;Int, String&gt;) {
      map.forEach { key, value -&gt;
          foo(key, value)
      }
  }

  fun foo(i: Int, s: String) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="Destructure" defaultSeverity="WEAK WARNING" displayName="使用析构声明" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以析构的声明。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  data class My(val first: String, val second: Int, val third: Boolean)

  fun foo(list: List&amp;lt;My&gt;) {
      list.forEach { my -&gt;
          println(my.second)
          println(my.third)
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该快速修复会析构声明并引入具有来自相应类的名称的新变量：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  data class My(val first: String, val second: Int, val third: Boolean)

  fun foo(list: List&amp;lt;My&gt;) {
      list.forEach { (_, second, third) -&gt;
          println(second)
          println(third)
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RemoveEmptyParenthesesFromAnnotationEntry" defaultSeverity="WEAK WARNING" displayName="移除不必要的圆括号" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告注解条目中的冗余空圆括号。
&lt;p&gt;使用“移除不必要的圆括号”快速修复可清理代码。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  annotation class MyAnnotationA
  annotation class MyAnnotationB(val x: Int)
  annotation class MyAnnotationC(val x: Int = 10) // 存在默认值

  @MyAnnotationA() // &amp;lt;== 圆括号冗余
  fun testA() {
  }

  @MyAnnotationB() // &amp;lt;== 缺少实参，圆括号为必选项
  fun testB() {
  }

  @MyAnnotationC() // &amp;lt;== 圆括号冗余
  fun testC() {
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FoldInitializerAndIfToElvis" defaultSeverity="WEAK WARNING" displayName="If-Null return/break/… 可折叠为 '?:'" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在初始化后立即检查变量是否为 null 的 &lt;code&gt;if&lt;/code&gt; 表达式，该表达式可以在初始值设定项中转换为 elvis 运算符。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(foo: Int?, bar: Int): Int {
      var i = foo
      if (i == null) {
          return bar
      }
      return i
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该快速修复会将带有初始值设定项的 &lt;code&gt;if&lt;/code&gt; 表达式转换为 elvis 表达式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(foo: Int?, bar: Int): Int {
      var i = foo ?: return bar
      return i
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ReplaceSizeZeroCheckWithIsEmpty" defaultSeverity="WEAK WARNING" displayName="零大小检查可被替换为 'isEmpty()'" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告应替换为 &lt;code&gt;isEmpty()&lt;/code&gt; 的 &lt;code&gt;Collections/Array/String&lt;/code&gt; 的 &lt;code&gt;size == 0&lt;/code&gt; 检查。
&lt;p&gt;使用 &lt;code&gt;isEmpty()&lt;/code&gt; 可使代码更简单。&lt;/p&gt;
&lt;p&gt;该快速修复会将大小检查替换为 &lt;code&gt;isEmpty()&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo() {
      val arrayOf = arrayOf(1, 2, 3)
      arrayOf.size == 0
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo() {
      val arrayOf = arrayOf(1, 2, 3)
      arrayOf.isEmpty()
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CanBeVal" defaultSeverity="WARNING" displayName="本地 'var' 从未被修改，且可以声明为 'val'" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告使用 &lt;code&gt;var&lt;/code&gt; 关键字声明但从未被修改的局部变量。
&lt;p&gt;Kotlin 鼓励使用 &lt;code&gt;val&lt;/code&gt; 关键字声明几乎不可变的变量，以确保它们的值永远不会改变。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun example() {
      var primeNumbers = listOf(1, 2, 3, 5, 7, 11, 13)
      var fibonacciNumbers = listOf(1, 1, 2, 3, 5, 8, 13)
      print("Same numbers: " + primeNumbers.intersect(fibonacciNumbers))
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;快速修复会将 &lt;code&gt;var&lt;/code&gt; 关键字替换为 &lt;code&gt;val&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun example() {
      val primeNumbers = listOf(1, 2, 3, 5, 7, 11, 13)
      val fibonacciNumbers = listOf(1, 1, 2, 3, 5, 8, 13)
      print("Same numbers: " + primeNumbers.intersect(fibonacciNumbers))
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="BooleanLiteralArgument" defaultSeverity="WEAK WARNING" displayName="不包含形参名称的布尔文字实参" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告类型为 &lt;code&gt;Boolean&lt;/code&gt; 但未指定显式形参名称的调用实参。
&lt;p&gt;
    按顺序传递多个布尔文字时，很容易忘记形参顺序，这可能会导致错误。
    显式形参名称让阅读和理解代码变得更容易。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun check(checkName: Boolean, checkAddress: Boolean, checkPhone: Boolean) {}

  fun usage() {
      check(true, false, true) //这是什么意思？
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该快速修复会添加缺少的形参名称：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun check(checkName: Boolean, checkAddress: Boolean, checkPhone: Boolean) {}

  fun usage() {
      check(checkName = true, checkAddress = false, checkPhone = true)
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="MoveVariableDeclarationIntoWhen" defaultSeverity="WEAK WARNING" displayName="变量声明可以在 'when' 中移动" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可移动到 &lt;code&gt;when&lt;/code&gt; 表达式中的变量声明。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
fun someCalc(x: Int) = x * 42

fun foo(x: Int): Int {
  val a = someCalc(x)
  return when (a) {
    1 -&amp;gt; a
    2 -&amp;gt; 2 * a
    else -&amp;gt; 24
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
fun foo(x: Int): Int {
  return when (val a = someCalc(x)) {
    1 -&amp;gt; a
    2 -&amp;gt; 2 * a
    else -&amp;gt; 24
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConvertReferenceToLambda" defaultSeverity="INFORMATION" displayName="可被替换为 lambda" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以替换为函数文字 (lambda) 的函数引用表达式。
&lt;p&gt;
    有时，传递 lambda 会更直接，并且与代码的其余部分更一致。
    此外，如果需要将简单的调用替换为更复杂的调用，该修正可能很方便。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun Int.isEven() = this % 2 == 0

  fun example() {
      val numbers = listOf(1, 2, 4, 7, 9, 10)
      val evenNumbers = numbers.filter(Int::isEven)
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun Int.isEven() = this % 2 == 0

  fun example() {
      val numbers = listOf(1, 2, 4, 7, 9, 10)
      val evenNumbers = numbers.filter { it.isEven() }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ReplaceUntilWithRangeUntil" defaultSeverity="INFORMATION" displayName="将 'until' 替换为 '..&lt;' 运算符" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告可被替换为 &lt;code&gt;..&amp;lt;&lt;/code&gt; 运算符的 &lt;code&gt;until&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;每个 &lt;code&gt;until&lt;/code&gt; 到 &lt;code&gt;..&amp;lt;&lt;/code&gt; 替换都不会以任何方式更改语义。&lt;/p&gt;
&lt;p&gt;用户体验研究表明，与 &lt;code&gt;until&lt;/code&gt; 相比，开发者在阅读包含 &lt;code&gt;..&amp;lt;&lt;/code&gt; 的代码时的错误减少了约 20-30%。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun main(args: Array&amp;lt;String&amp;gt;) {
      for (index in 0 until args.size) {
          println(index)
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun main(args: Array&amp;lt;String&amp;gt;) {
      for (index in 0..&amp;lt;args.size) {
          println(index)
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;此检查仅在项目或模块的 Kotlin 语言级别为 1.7 或更高时报告，并且提供了 &lt;code&gt;-opt-in=kotlin.ExperimentalStdlibApi&lt;/code&gt; 编译器标志。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReplaceWithOperatorAssignment" defaultSeverity="WEAK WARNING" displayName="赋值可被替换为运算符赋值" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告带简单赋值（例如 &lt;code&gt;y = y + x&lt;/code&gt;）且可以替换为运算符赋值的变量的修改。
&lt;p&gt;该快速修复会将赋值替换为赋值运算符。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo() {
      val list = mutableListOf(1, 2, 3)
      list = list + 4
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo() {
      val list = mutableListOf(1, 2, 3)
      list += 4
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantElseInIf" defaultSeverity="INFORMATION" displayName="'if' 中冗余的 'else'" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 &lt;code&gt;if&lt;/code&gt; 中具有 &lt;code&gt;return&lt;/code&gt; 的冗余 &lt;code&gt;if&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(arg: Boolean): Int {
      if (arg) return 0
      else { // 此 else 冗余，大括号中的代码正好可以向左移动
          someCode()
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(arg: Boolean): Int {
      if (arg) return 0
      someCode()
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="CopyWithoutNamedArguments" defaultSeverity="WEAK WARNING" displayName="数据类的 'copy' 方法在没有命名实参的情况下调用" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对没有命名实参的数据类的 &lt;code&gt;copy()&lt;/code&gt; 方法的调用。
&lt;p&gt;
    由于 &lt;code&gt;copy()&lt;/code&gt; 函数的所有实参都是可选的，因此可能很难理解修改了哪些属性。
    显式提供形参名称使得代码容易理解，且无需导航到 &lt;code&gt;data class&lt;/code&gt; 声明。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  data class User(val name: String, val age: Int)

  fun copyUser(user: User): User {
      return user.copy("John")
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;快速修复程序会为所有的 &lt;code&gt;copy()&lt;/code&gt; 实参提供形参名称：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  data class User(val name: String, val age: Int)

  fun copyUser(user: User): User {
      return user.copy(name = "John")
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ReplaceRangeToWithRangeUntil" defaultSeverity="WEAK WARNING" displayName="'rangeTo' 或 '..' 调用应被替换为 '..&lt;'" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对 &lt;code&gt;rangeTo&lt;/code&gt; 或 &lt;code&gt;..&lt;/code&gt; 运算符的调用，而非对 &lt;code&gt;..&lt;/code&gt; 的调用。
&lt;p&gt;使用相应函数可使代码更简单。&lt;/p&gt;
&lt;p&gt;该快速修复会将 &lt;code&gt;rangeTo&lt;/code&gt; 或 &lt;code&gt;..&lt;/code&gt; 调用替换为 &lt;code&gt;..&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(a: Int) {
      for (i in 0..a - 1) {

      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(a: Int) {
      for (i in 0..&amp;lt;a) {

      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UsePropertyAccessSyntax" defaultSeverity="WEAK WARNING" displayName="可被替换为属性访问语法的访问器调用" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以替换为 Kotlin 合成属性的 Java &lt;code&gt;get&lt;/code&gt; 和 &lt;code&gt;set&lt;/code&gt; 方法调用。
&lt;p&gt;&lt;b&gt;使用属性访问语法&lt;/b&gt;快速修复可用于自动修正代码。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  // Java:
  public class JavaClassWithGetter {
      private final String expr = "result";

      // ...

      public String getExpr() {
          return expr;
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;
  // Kotlin:
  fun test(j: JavaClassWithGetter) {
      // ...
      j.getExpr() // &amp;lt;== 快速修复会将表达式简化为 'j.expr'
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="按位运算问题" path="Java"><inspection shortName="PointlessBitwiseExpression" defaultSeverity="WARNING" displayName="无意义的按位表达式" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告无意义的按位表达式。
&lt;p&gt;
  此类表达式包括对给定类型的最大值应用 &lt;code&gt;&amp;&lt;/code&gt; 运算符，对零以及移零应用 &lt;code&gt;or&lt;/code&gt; 运算符。 出现此类表达式，可能是因为自动重构没有一直持续到完成，而且不太可能是出于原本的意图。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  // 警告：运算毫无意义，可以替换为 `flags`
  // 0xFFFF_FFFF 是一个整数的最大值，并且这两个文字都被视为
  // 32 位整数文字。
  int bits = flags &amp; 0xFFFF_FFFF;

  // 警告：运算毫无意义，可以替换为 `bits`
  // 包含 0 的 OR 运算始终输出另一个操作数。
  int or = bits | 0x0;

  // 警告：运算毫无意义，结果始终为 0
  int xor = or ^ or;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ShiftOutOfRange" defaultSeverity="WARNING" displayName="按不当常量进行移位运算" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告移位值为超出合理范围的常量的移位运算。
&lt;p&gt;报告 &lt;code&gt;0..31&lt;/code&gt; 范围以外的整数移位运算以及 &lt;code&gt;0..63&lt;/code&gt; 范围以外的长移位运算。 负值或过大值移位几乎肯定表明存在编码错误。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int shiftSize = 32;
  // 警告：移动 32 位相当于移动 0 位，所以根本没有移位。
  int mask = (1 &amp;lt;&amp;lt; shiftSize) - 1;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="IncompatibleMask" defaultSeverity="WARNING" displayName="不兼容的按位掩码运算" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告确保评估为 &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt; 的按位掩码表达式。
&lt;p&gt;
  该检查将检查 &lt;code&gt;(var &amp; constant1) == constant2&lt;/code&gt; 或 &lt;code&gt;(var | constant1) == constant2&lt;/code&gt; 形式的表达式，其中 &lt;code&gt;constant1&lt;/code&gt; 和 &lt;code&gt;constant2&lt;/code&gt; 是不兼容的位掩码常量。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  // 不兼容的掩码：由于掩码以 00 结尾，
  // 结果可能是 0x1200，但不是 0x1234
  if ((mask &amp; 0xFF00) == 0x1234) {...}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="JSP检查" path=""><inspection shortName="ELMethodSignatureInspection" defaultSeverity="WARNING" displayName="EL 方法签名检查" enabled="false" language="EL" pluginId="com.intellij.jsp" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 EL 中与 TLD 文件中的 &lt;code&gt;method-signature&lt;/code&gt; 约束不匹配的方法调用。

&lt;p&gt;&lt;b&gt;示例 Java 类：&lt;/b&gt;&lt;/p&gt;&lt;br/&gt;
&lt;pre&gt;&lt;code&gt;
public class ExampleAction {
  public void goodAction() { ... }
  public void badAction(String str) { ... }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;b&gt;示例 JSP 文件：&lt;/b&gt;&lt;/p&gt;&lt;br/&gt;
&lt;pre&gt;&lt;code&gt;
&amp;lt;jsp:useBean id="example" scope="request" type="org.example.ExampleAction"/&amp;gt;
&amp;lt;f:view&amp;gt;
  &amp;lt;h:commandButton action="#{example.goodAction}"/&amp;gt; // 优良：方法接受零实参并返回 `void`
  &amp;lt;h:commandButton action="#{example.badAction}"/&amp;gt; // 错误：方法 `void badAction(String)` 返回 `java.lang.String` 类型而不是 `void`
&amp;lt;/f:view&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ReferencesToClassesFromDefaultPackagesInJSPFile" defaultSeverity="ERROR" displayName="对 JSP 文件中默认软件包中类的引用" enabled="false" language="JAVA" pluginId="com.intellij.jsp" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 JSP 文件中对默认软件包中类的任何引用。

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &amp;lt;%!
  Integer countSomeUsefulStuff() {
    ...
    new ClassFromDefaultPackage(...); // 错误
    new com.example.GoodClass(...); // OK
  }
  %&amp;gt;
  &amp;lt;html&amp;gt;
    &amp;lt;head&amp;gt;
      &amp;lt;title&amp;gt;Hello, JSP!&amp;lt;/title&amp;gt;
    &amp;lt;/head&amp;gt;
  &amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  &lt;b&gt;注意&lt;/b&gt;：在 JSP 编译期间不会解析此类引用，因为 JSP 的编译类通常会放在非默认软件包（例如，Tomcat 的 "org.apache.jsp"，WebSphere  的 "com.ibm._jsp"）中，但在 Java 中不允许从默认软件包导入。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="JspAbsolutePathInspection" defaultSeverity="WARNING" displayName="绝对路径" enabled="false" language="XML" pluginId="com.intellij.jsp" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 JSP 文件中的绝对路径。
&lt;p&gt;如果应用程序上下文非空，它们就不会被解析，因此 JSP 中禁止绝对路径。&lt;/p&gt;
&lt;p&gt;该快速修复将向路径中添加动态前缀。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &amp;lt;%@page contentType=&amp;quot;text/html; ISO-8859-1&amp;quot; %&amp;gt;

  &amp;lt;a href=&amp;quot;/hey.jsp&amp;quot;&amp;gt;hey&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &amp;lt;%@page contentType=&amp;quot;text/html; ISO-8859-1&amp;quot; %&amp;gt;

  &amp;lt;a href=&amp;quot;${pageContext.request.contextPath}/hey.jsp&amp;quot;&amp;gt;hey&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="TaglibDomModelInspection" defaultSeverity="ERROR" displayName="标记库描述符检查" enabled="false" language="XML" pluginId="com.intellij.jsp" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 JSP TLD 文件中的问题。
&lt;p&gt;TLD 文件应符合 JSP 标记库架构。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="JspDirectiveInspection" defaultSeverity="ERROR" displayName="Jsp 指令检查" enabled="false" language="XML" pluginId="com.intellij.jsp" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告没有 URI 或 tagdir 特性的 JSP 导入指令。

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
&amp;lt;html&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;%@ taglib prefix="html"%&amp;gt; // 错误：应指定 `uri` 或 `tagdir` 特性
    ...
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SelfIncludingJspFiles" defaultSeverity="ERROR" displayName="自包含 JSP 文件" enabled="false" language="XML" pluginId="com.intellij.jsp" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 JSP 文件中引用包含 JSP 文件的任何 include 指令。&lt;br/&gt;

&lt;p&gt;&lt;b&gt;名为 main.jsp 的示例 JSP 文件：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &amp;lt;jsp:include page="./main.jsp" /&amp;gt; // 错误：尝试包含包含的文件
  ...
&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;

&lt;!-- tooltip end --&gt;
&lt;p&gt;
  &lt;b&gt;注意&lt;/b&gt;：此类自包含会导致无限递归，因此无法编译 JSP 文件。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

</inspection><inspection shortName="JspUnescapedEl" defaultSeverity="WARNING" displayName="未转义的 EL 表达式" enabled="false" language="EL" pluginId="com.intellij.jsp" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 JSP 页面中未转义的 EL 表达式。
&lt;p&gt;未转义的 EL 表达式可能导致&lt;a href="http://en.wikipedia.org/wiki/Cross-site_scripting"&gt;跨站脚本攻击 (XSS)&lt;/a&gt; 漏洞。&lt;/p&gt;
&lt;p&gt;该快速修复会使用 JSTL &lt;code&gt;&amp;lt;out&amp;gt;&lt;/code&gt; 标记包装原始 EL 表达式。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
${foo}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
&amp;lt;%@ taglib prefix=&amp;quot;c&amp;quot; uri=&amp;quot;http://java.sun.com/jsp/jstl/core&amp;quot; %&amp;gt;
&amp;lt;c:out value=&amp;quot;${foo}&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnhandledExceptionInJSP" defaultSeverity="WARNING" displayName="未处理的异常在JSP" enabled="false" pluginId="com.intellij.jsp" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告由顶级 JSP Scriptlet 抛出的异常。&lt;br/&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &amp;lt;%!
  String getFormattedDate() {
    ...
    throw new IllegalArgumentException(...); // 错误
  }
  %&amp;gt;
  &amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&amp;gt;
    &amp;lt;title&amp;gt;Hello, JSP!&amp;lt;/title&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
  &amp;lt;i&amp;gt;Today is &amp;lt;%= getFormattedDate() %&amp;gt;&amp;lt;/i&amp;gt;
  &amp;lt;/body&amp;gt;
  &amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;

&lt;!-- tooltip end --&gt;
&lt;p&gt;
  &lt;b&gt;注意&lt;/b&gt;：此类 JSP 页面会编译，因为 servlet 容器将所有 JSP 代码包装在 &lt;b&gt;try {} catch() {}&lt;/b&gt; 块中，但它们在服务器上部署时会产生运行时异常。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="FunctionELReferenceInspection" defaultSeverity="ERROR" displayName="EL 方法函数形参计数" enabled="false" language="EL" pluginId="com.intellij.jsp" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 EL 函数调用中不同数量的形参和实参。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ELDeferredExpressionsInspection" defaultSeverity="WARNING" displayName="EL 推迟表达式检查" enabled="false" language="EL" pluginId="com.intellij.jsp" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告需要延迟表达式的动态表达式或需要动态表达式的延迟表达式。

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;&lt;br/&gt;
&lt;pre&gt;&lt;code&gt;
&amp;lt;jsp:useBean id="exampleBean" scope="request" type="java.util.Date"/&amp;gt;

&amp;lt;h:outputText id="${exampleBean.day}" value="#{exampleBean.day}" /&amp;gt; // OK
&amp;lt;h:outputText id="#{exampleBean.day}" value="${exampleBean.day}" /&amp;gt; // 错误：`id` 特性需要动态表达式，`value` - 延迟 
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="JspPropertiesInspection" defaultSeverity="ERROR" displayName="Jsp 属性检查" enabled="false" language="XML" pluginId="com.intellij.jsp" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;*.properties&lt;/code&gt; 文件中的未解析属性。

&lt;p&gt;&lt;b&gt;示例 JSP 文件：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
&amp;lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&amp;gt;
&amp;lt;%@ taglib uri="/tags/fmt" prefix="fmt" %&amp;gt;

&amp;lt;fmt:message bundle="bundle.properties" key="unknown.property"/&amp;gt; // 错误：引用的文件中没有此类属性
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="JspTagBodyContent" defaultSeverity="WARNING" displayName="标记正文内容类型" enabled="false" language="XML" pluginId="com.intellij.jsp" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告不符合 TLD 主体内容规范的 JSP 标记主体内容。
&lt;p&gt;如果指定了空的主体内容，则标记的主体应为空。&lt;/p&gt;
&lt;p&gt;如果指定了无脚本主体内容，该标记的主体不应包含 JSP scriptlet。&lt;/p&gt;
&lt;p&gt;对于空内容类型，该快速修复将移除标记的主体，如果指定了无脚本内容类型，则移除 scriptlet。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
&amp;lt;s:empty&amp;gt;body not allowed here&amp;lt;/s:empty&amp;gt;
&amp;lt;s:scriptless&amp;gt;say: &amp;lt;% System.out.println(&amp;quot;hey&amp;quot;); %&amp;gt;&amp;lt;/s:scriptless&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
&amp;lt;s:empty/&amp;gt;
&amp;lt;s:scriptless&amp;gt;say: &amp;lt;/s:scriptless&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ELSpecValidationInJSP" defaultSeverity="WARNING" displayName="JSP EL 规范验证" enabled="false" language="EL" pluginId="com.intellij.jsp" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告非标准 EL 扩展可能导致的问题：特性之外的 JSF EL 表达式、非标准 EL 表达式等。

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;&lt;br/&gt;
&lt;pre&gt;&lt;code&gt;
&amp;lt;f:view&amp;gt;
  &amp;lt;h:form&amp;gt;
    &amp;lt;f:loadBundle var="example"/&amp;gt;
    &amp;lt;h:commandButton action="${example.size()}"/&amp;gt; // 警告：方法调用是非标准扩展
  &amp;lt;/h:form&amp;gt;
&amp;lt;/f:view&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="可能的错误" path="Gradle"><inspection shortName="DependencyNotationArgument" defaultSeverity="WARNING" displayName="无法识别的依赖关系表示法" enabled="false" language="Groovy" pluginId="org.jetbrains.plugins.gradle" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;                                            
&lt;p&gt;检测不正确的依赖项表示法。 &lt;/p&gt;
  Gradle 支持以下类型/格式：
  &lt;ul&gt;
  &lt;li&gt; &lt;code&gt;Dependency&lt;/code&gt; 的实例； &lt;/li&gt;
  &lt;li&gt; &lt;code&gt;String&lt;/code&gt; 或 &lt;code&gt;CharSequence&lt;/code&gt; 值，例如 &lt;code&gt;'org.gradle:gradle-core:1.0'&lt;/code&gt;； &lt;/li&gt;
  &lt;li&gt; 映射，例如 &lt;code&gt;[group: 'org.gradle', name: 'gradle-core', version: '1.0']&lt;/code&gt;； &lt;/li&gt;
  &lt;li&gt; FileCollection，例如 &lt;code&gt;files('some.jar', 'someOther.jar')&lt;/code&gt;； &lt;/li&gt;
  &lt;li&gt; 项目，例如 &lt;code&gt;project(':some:project:path')&lt;/code&gt;； &lt;/li&gt;
  &lt;li&gt; &lt;code&gt;ClassPathNotation&lt;/code&gt;，例如 &lt;code&gt;gradleApi()&lt;/code&gt;； &lt;/li&gt;
  &lt;li&gt; 依赖项表示法列表，例如 &lt;code&gt;['org.gradle:gradle-core:1.0']&lt;/code&gt;； &lt;/li&gt;
  &lt;li&gt; (Gradle 7.0+) &lt;a href="https://docs.gradle.org/current/userguide/platforms.html"&gt;版本目录访问器&lt;/a&gt;，例如 &lt;code&gt;libs.groovy.core&lt;/code&gt;。 &lt;/li&gt;
&lt;/ul&gt;
  &lt;a href="https://docs.gradle.org/current/userguide/declaring_dependencies.html#sec:dependency-types"&gt;请参阅 Gradle 文档&lt;/a&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
dependencies {
  implementation(1) // reports '1'
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="BintrayPublishingPlugin" defaultSeverity="WARNING" displayName="Bintray 发布插件可能会在 2021 年 5 月 1 日停止工作" enabled="false" language="Groovy" pluginId="org.jetbrains.plugins.gradle" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;                                            
&lt;p&gt;检测 Gradle 插件 &lt;code&gt;com.jfrog.bintray&lt;/code&gt; 的用法。
  该插件用于将构建结果发布到 Bintray。
  发布到 &lt;a href="https://www.jfrog.com/confluence/display/BT/Welcome+to+JFrog+Bintray"&gt;Bintray&lt;/a&gt; 服务已禁用。
  &lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MultipleRepositoryUrls" defaultSeverity="WARNING" displayName="多个仓库 URL" enabled="false" language="Groovy" pluginId="org.jetbrains.plugins.gradle" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告每个存储库块（Maven 或 Ivy）使用多个 URL 的情况。
问题在于只能为存储库选择一个 URL，而其他 URL 将被忽略。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JCenterRepository" defaultSeverity="WARNING" displayName="2022 年 2 月 1 日后，构建不能再解析 JCenter 中的工件" enabled="false" language="Groovy" pluginId="org.jetbrains.plugins.gradle" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
检测 JCenter 存储库的用法以解决依赖关系。
2022 年 2 月 1 日后，构建不能再解析 JCenter 中的工件。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ForeignDelegate" defaultSeverity="WEAK WARNING" displayName="可能错误地调用了 Gradle 方法" enabled="false" language="Groovy" pluginId="org.jetbrains.plugins.gradle" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;                                            
&lt;p&gt;检测可能位置错误的 Gradle 方法调用。&lt;/p&gt;
  Gradle buildscripts 包含许多嵌套闭包，使得代码结构类似于标记语言。
  由于 Groovy 的行为，可以在外部闭包中编写的方法也可以在内部闭包中使用。
  此类方法在其范围之外编写时可能没有任何意义。 &lt;br&gt;有时可能很难发现这种情况。
  此检查的目的就是发现此类方法。

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
repositories {
  // 'repositories' 的委托具有方法 'exclusiveContent'，可在此处编写
  maven {
    // 'maven' 的委托具有方法 'content'，可在此处编写
    // 但也可使用 'exclusiveContent'
    exclusiveContent {} // 报告 'exclusiveContent'
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Markdown" path=""><inspection shortName="MarkdownUnresolvedLinkLabel" defaultSeverity="WARNING" displayName="未解析的链接标签" enabled="false" language="Markdown" pluginId="org.intellij.plugins.markdown" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 Markdown 文件中的未解析链接标签。
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="MarkdownUnresolvedHeaderReference" defaultSeverity="WARNING" displayName="未解析的头引用" enabled="false" language="Markdown" pluginId="org.intellij.plugins.markdown" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 Markdown 文件中的未解析头引用。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MarkdownIncorrectTableFormatting" defaultSeverity="WEAK WARNING" displayName="表格式设置不正确" enabled="false" language="Markdown" pluginId="org.intellij.plugins.markdown" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
检查表的格式是否正确。
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="MarkdownNoTableBorders" defaultSeverity="ERROR" displayName="表没有边框" enabled="false" language="Markdown" pluginId="org.intellij.plugins.markdown" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
检查表是否有正确的边框。
出于兼容性原因，所有表行的开头和结尾都应该有边框（管道符号）。
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="MarkdownIncorrectlyNumberedListItem" defaultSeverity="WARNING" displayName="列表项编号错误" enabled="false" language="Markdown" pluginId="org.intellij.plugins.markdown" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;排序列表项应从 1 开始连续编号。&lt;/p&gt;
&lt;p&gt;这背后的动机是，大多数 Markdown 处理器会忽略有序列表的编号。 处理器将为此类列表生成 &lt;code&gt;&amp;lt;ol&amp;gt;&lt;/code&gt; 元素，该元素将从 1 开始对条目进行连续编号。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="MarkdownUnresolvedFileReference" defaultSeverity="WARNING" displayName="未解析的文件引用" enabled="false" language="Markdown" pluginId="org.intellij.plugins.markdown" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 Markdown 文件中的未解析文件引用。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MarkdownOutdatedTableOfContents" defaultSeverity="WARNING" displayName="过期的目录部分" enabled="false" language="Markdown" pluginId="org.intellij.plugins.markdown" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
检查特定目录部分是否与文档的实际结构相对应。
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="MarkdownLinkDestinationWithSpaces" defaultSeverity="WARNING" displayName="链接不应包含空格" enabled="false" language="Markdown" pluginId="org.intellij.plugins.markdown" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
为确保不同工具之间的一致性，文件链接不应包含空格。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  [Some file link](some file.md)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;快速修复会将空格替换为它们的 URL 编码等效项：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  [Some file link](some%20file.md)
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="Gradle" path="Kotlin/Migration"><inspection shortName="GradleKotlinxCoroutinesDeprecation" defaultSeverity="ERROR" displayName="与 Gradle 中的 Kotlin 1.3+ 一起使用的 kotlinx.coroutines 依赖项不兼容" enabled="false" language="Groovy" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告为了与 Kotlin 1.3+ 兼容而应更新的 Gradle 中的 &lt;code&gt;kotlinx.coroutines&lt;/code&gt; 库依赖项。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  dependencies {
      implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-core:0.0.1'
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该快速修复会将 &lt;code&gt;kotlinx.coroutines&lt;/code&gt; 库版本更改为与 Kotlin 1.3 兼容的版本：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  dependencies {
      implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-core:0.27.0-eap13'
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="初始化" path="Java"><inspection shortName="InstanceVariableInitialization" defaultSeverity="WARNING" displayName="实例字段可能无法初始化" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在对象初始化时可能未被初始化的实例变量。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    public int bar;

    static { }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;请注意，此检查会使用非常保守的数据流算法，可能会错误地将实例变量报告为未初始化。 报告为已初始化的变量将始终被初始化。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;使用&lt;b&gt;忽略基元字段&lt;/b&gt;选项可以忽略未初始化的基元字段。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="OverriddenMethodCallDuringObjectConstruction" defaultSeverity="WARNING" displayName="重写的方法在对象构造期间调用" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在对象构造期间对当前类的重写方法的任何调用。
如果对象构造在内部，则会发生这种情况：
&lt;ul&gt;
  &lt;li&gt;构造函数&lt;/li&gt;
  &lt;li&gt;非 static 实例初始值设定项&lt;/li&gt;
  &lt;li&gt;非 static 字段初始值设定项&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;clone()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;readObject()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;readObjectNoData()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此类调用可能会导致难以捉摸的错误，因为不能保证对象在方法调用发生之前被初始化。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  abstract class Parent {
    void someMethod() { }
  }

  class Child extends Parent {
    Child() {
      someMethod();
    }

    @Override
    void someMethod() { }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;此检查与以下各项共享其功能：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;b&gt;对象构造期间调用的 abstract 方法&lt;/b&gt;检查&lt;/li&gt;
  &lt;li&gt;&lt;b&gt;对象构造期间调用的可重写方法&lt;/b&gt;检查&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一次只应启用一个检查，以防止重复警告。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StaticVariableInitialization" defaultSeverity="WARNING" displayName="static 字段可能无法初始化" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在类初始化时可能未被初始化的 &lt;code&gt;static&lt;/code&gt; 变量。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    public static int bar;

    static { }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;请注意，此检查使用非常保守的数据流算法，并且可能会将 &lt;code&gt;static&lt;/code&gt; 变量错误地报告为未初始化。 报告为已初始化的变量将始终被初始化。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;使用&lt;b&gt;忽略基元字段&lt;/b&gt;选项可以忽略未初始化的基元字段。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StaticVariableUninitializedUse" defaultSeverity="WARNING" displayName="static 字段在初始化前使用" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在初始化之前读取的 &lt;code&gt;static&lt;/code&gt; 变量。
&lt;p&gt;该检查会忽略 &lt;code&gt;null&lt;/code&gt; 的相等检查。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    public static int bar;

    public static void main(String[] args) {
      System.out.println(bar);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;请注意，此检查使用非常保守的数据流算法，并且可能会将 &lt;code&gt;static&lt;/code&gt; 变量错误地报告为未初始化。 报告为已初始化的变量将始终被初始化。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;使用&lt;b&gt;忽略基元字段&lt;/b&gt;选项可以忽略未初始化的基元字段。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="OverridableMethodCallDuringObjectConstruction" defaultSeverity="WARNING" displayName="对象构造期间调用的可重写方法" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在对象构造期间对当前类的可重写方法的调用。
&lt;p&gt;如果方法位于以下位置，则会在对象构造期间调用：
&lt;ul&gt;
  &lt;li&gt;构造函数&lt;/li&gt;
  &lt;li&gt;非 static 实例初始值设定项&lt;/li&gt;
  &lt;li&gt;非 static 字段初始值设定项&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;clone()&lt;/code&gt; 方法&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;readObject()&lt;/code&gt; 方法&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;readObjectNoData()&lt;/code&gt; 方法&lt;/li&gt;
&lt;p&gt;如果方法未被声明为 &lt;code&gt;final&lt;/code&gt;、&lt;code&gt;static&lt;/code&gt; 或 &lt;code&gt;private&lt;/code&gt;，则该方法可重写。
  即使可重写，package-local 方法也被认为是安全的。 此类调用可能会导致难以捉摸的错误，因为对象初始化可能发生在方法调用之前。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Parent {
    void someMethod() { }
  }

  class Child extends Parent {
    Child() {
      someMethod();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
  &lt;p&gt;此检查与以下检查共享功能：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;对象构造期间调用的 abstract 方法&lt;/li&gt;
  &lt;li&gt;在对象构造期间调用的重写的方法&lt;/li&gt;
&lt;/ul&gt;
  &lt;p&gt;一次只能启用一个检查，以防止警告重复。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DoubleBraceInitialization" defaultSeverity="INFORMATION" displayName="双大括号初始化" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告&lt;a href="https://www.c2.com/cgi/wiki?DoubleBraceInitialization"&gt;双大括号初始化&lt;/a&gt;。
&lt;p&gt;双大括号初始化在非 static 上下文中使用时可能会导致内存泄漏，因为它创建了一个将引用周围对象的匿名类。&lt;/p&gt;
&lt;p&gt;与常规初始化相比，双大括号初始化的性能更差，因为它需要加载一个额外的类。&lt;/p&gt;
&lt;p&gt;如果 &lt;code&gt;equals()&lt;/code&gt; 方法不接受子类作为形参，还可能导致 &lt;code&gt;equals()&lt;/code&gt; 比较失败。&lt;/p&gt;
&lt;p&gt;此外，在 Java 9 以前的版本中，双大括号初始化不能与 Diamond 运算符结合使用，因为它与匿名类不兼容。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;() {{
    add(1);
    add(2);
  }};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
  list.add(1);
  list.add(2);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NonFinalStaticVariableUsedInClassInitialization" defaultSeverity="WARNING" displayName="在类初始化期间使用非 final static 字段" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在类初始化期间使用 &lt;code&gt;final&lt;/code&gt; &lt;code&gt;static&lt;/code&gt; 变量的情况。
&lt;p&gt;在此类情况下，代码语义可能会依赖于类的创建顺序。 此外，此类情况可能会导致在变量初始化之前使用变量，并且通常会导致困难和令人困惑的错误。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    public static int bar = 0;

    static {
      System.out.println(bar);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="InstanceVariableUninitializedUse" defaultSeverity="WARNING" displayName="实例字段在初始化前使用" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在初始化之前读取的实例变量。
&lt;p&gt;该检查会忽略 &lt;code&gt;null&lt;/code&gt; 的相等检查。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    int bar;

    Foo() {
      System.out.println(bar);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;请注意，此检查会使用非常保守的数据流算法，可能会错误地将实例变量报告为未初始化。 报告为已初始化的变量将始终被初始化。
&lt;!-- tooltip end --&gt;
&lt;p&gt;使用&lt;b&gt;有注解时忽略&lt;/b&gt;选项可以指定特殊注解。 该检查将忽略使用其中一种注解进行注解的字段。&lt;/p&gt;
&lt;p&gt;使用&lt;b&gt;忽略基元字段&lt;/b&gt;选项可以忽略未初始化的基元字段。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ThisEscapedInConstructor" defaultSeverity="WARNING" displayName="对象构造中转义的 'this' 引用" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对象初始化期间可能的 &lt;code&gt;this&lt;/code&gt; 转义。 当 &lt;code&gt;this&lt;/code&gt; 用作构造函数或初始值设定项中的方法实参或赋值对象时，就会发生转义。 此类转义可能会导致难以捉摸的错误，因为现在该对象在不保证得到初始化的上下文中可用。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    {
      System.out.println(this);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="NonThreadSafeLazyInitialization" defaultSeverity="WARNING" displayName="不安全的 'static' 字段延迟初始化" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告以非线程安全方式延迟初始化的 &lt;code&gt;static&lt;/code&gt; 变量。
&lt;p&gt;应该使用适当的同步构造来完成 &lt;code&gt;static&lt;/code&gt; 变量的延迟初始化，以防止不同的线程执行冲突的初始化。&lt;/p&gt;
&lt;p&gt;如果适用，建议使用引入&lt;a href="https://en.wikipedia.org/wiki/Initialization_on_demand_holder_idiom"&gt;延迟初始化容器类习惯用法&lt;/a&gt;的快速修复。
  这个习惯用法利用了 JVM 会保证类在使用之前不会被初始化的事实。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class X {
    private static List&amp;lt;String&amp;gt; list;

    public List&amp;lt;String&amp;gt; getList() {
      if (list == null) {
        list = List.of("one", "two", "tree");
      }
      return list;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class X {
    private static final class ListHolder {
      static final List&amp;lt;String&amp;gt; list = List.of("one", "two", "tree");
    }

    public List&amp;lt;String&amp;gt; getList() {
      return ListHolder.list;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AbstractMethodCallInConstructor" defaultSeverity="WARNING" displayName="对象构造期间调用的 abstract 方法" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在对象构造期间对当前类的 &lt;code&gt;abstract&lt;/code&gt; 方法的调用。
&lt;p&gt;如果方法位于以下位置，则会在对象构造期间调用：
&lt;ul&gt;
  &lt;li&gt;构造函数&lt;/li&gt;
  &lt;li&gt;非 static 实例初始值设定项&lt;/li&gt;
  &lt;li&gt;非 static 字段初始值设定项&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;clone()&lt;/code&gt; 方法&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;readObject()&lt;/code&gt; 方法&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;readObjectNoData()&lt;/code&gt; 方法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此类调用可能会导致难以捉摸的错误，因为对象初始化可能发生在方法调用之前。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  abstract class Parent {
    abstract void abstractMethod();
  }

  class Child extends Parent {
    Child() {
      abstractMethod();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;此检查与以下检查共享功能：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;在对象构造期间调用的可重写方法&lt;/li&gt;
  &lt;li&gt;在对象构造期间调用的重写的方法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一次只能启用一个检查，以防止警告重复。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Specs2" path="Scala"><inspection shortName="Specs2Matchers" defaultSeverity="WARNING" displayName="Specs2 匹配器" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告可以使用 &lt;b&gt;specs2&lt;/b&gt; 中的内置匹配器。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class TestSpec extends Specification { def is = s2"""
    This is a spec
    opt
      should contain 1                                  $e1
                                                        """
    def e1 = {

      val opt = Some(1)

      opt must equalTo (Some(1))
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class TestSpec extends Specification { def is = s2"""
    This is a spec
    opt
      should contain 1                                  $e1
                                                        """
    def e1 = {

      val opt = Some(1)

      opt must beSome(1)
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="类" path="Java/命名约定"><inspection shortName="ExceptionNameDoesntEndWithException" defaultSeverity="WARNING" displayName="异常类名不以 'Exception' 结尾" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告名称不以 &lt;code&gt;Exception&lt;/code&gt; 结束的异常类。
&lt;p&gt;&lt;b&gt;示例&lt;/b&gt;：&lt;code&gt;class NotStartedEx extends Exception {}&lt;/code&gt;
&lt;p&gt;只能在编辑器中采用快速修复来重命名这种类。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ClassNameSameAsAncestorName" defaultSeverity="WARNING" displayName="类名与上级名称相同" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告与其某个超类的名称相同，而其完全限定名称仍然不同的类。
这种类名可能令人困惑。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
  &lt;pre&gt;&lt;code&gt;
  package util;
  abstract class Iterable&amp;lt;T&amp;gt; implements java.lang.Iterable&amp;lt;T&amp;gt; {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;只能在编辑器中采用快速修复来重命名这种类。&lt;/p&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ClassNamePrefixedWithPackageName" defaultSeverity="WARNING" displayName="使用软件包名称作为前缀的类名" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告名称前缀为其软件包名称并忽略大写差异的类。
&lt;p&gt;虽然偶尔使用此类名称是合理的，但通常是由于欠佳的命名方案而使用，可能冗余并且令人生厌。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;
  &lt;pre&gt;&lt;code&gt;
  package byteCode;
  class ByteCodeAnalyzer {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;只能在编辑器中采用快速修复来重命名这种类。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NonExceptionNameEndsWithException" defaultSeverity="WARNING" displayName="非异常类名以 'Exception' 结尾" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告名称以 &lt;code&gt;Exception&lt;/code&gt; 结尾的非 &lt;code&gt;exception&lt;/code&gt; 类。
&lt;p&gt;这种类可能会违反通用的命名约定而引起混淆，并且通常表示缺少 &lt;code&gt;extends Exception&lt;/code&gt; 子句。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;
  &lt;pre&gt;&lt;code&gt;public class NotStartedException {}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;只能在编辑器中采用快速修复来重命名这种类。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NewClassNamingConvention" defaultSeverity="WARNING" displayName="类命名约定" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告名称太短、太长或不遵循指定正则表达式模式的类。
&lt;p&gt;&lt;b&gt;示例&lt;/b&gt;：如果为测试启用了检查，并且指定的最小类名称长度为 8（默认值），因以下测试类的名称长度为 6，即小于 8，因此将生成警告：&lt;code&gt;public class MyTest{}&lt;/code&gt;。
&lt;p&gt;只能在编辑器中采用快速修复来重命名这种类。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;配置检查：&lt;/p&gt;
&lt;p&gt;
  使用&lt;b&gt;选项&lt;/b&gt;部分中的列表来指定应检查哪些类。 取消选中要为之跳过检查的类对应的复选框。&lt;/p&gt;
&lt;p&gt;对于类的每种类型，请使用所提供的输入字段指定类名应有的最小长度、最大长度和正则表达式。 在长度字段中指定 &lt;b&gt;0&lt;/b&gt; 可跳过相应检查。&lt;/p&gt;
&lt;p&gt;正则表达式应以标准 &lt;code&gt;java.util.regex&lt;/code&gt; 格式指定。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Try 语句问题" path="JavaScript and TypeScript"><inspection shortName="ThrowFromFinallyBlockJS" defaultSeverity="WARNING" displayName="'throw' 位于 'finally' 块内" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;finally&lt;/code&gt; 块中的 &lt;code&gt;throw&lt;/code&gt; 语句。 此类 &lt;code&gt;throw&lt;/code&gt; 语句可能会掩盖抛出的异常，并导致调试复杂化。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnusedCatchParameterJS" defaultSeverity="WARNING" displayName="未使用的 'catch' 参数" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告未在相应的块中使用的 &lt;code&gt;catch&lt;/code&gt; 形参。  将忽略名称为 &lt;code&gt;ignore&lt;/code&gt; 或 &lt;code&gt;ignored&lt;/code&gt; 的 &lt;code&gt;catch&lt;/code&gt; 形参。
&lt;!-- tooltip end --&gt;
&lt;p&gt;
    使用下面的复选框对包含注释的
&lt;code&gt;catch&lt;/code&gt; 块禁用此检查。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="EmptyCatchBlockJS" defaultSeverity="WARNING" displayName="空 'catch' 块" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告空的 &lt;code&gt;catch&lt;/code&gt; 块。 这表明错误未加处理就被直接忽略。
&lt;br/&gt;&lt;br/&gt;
&lt;code&gt;catch&lt;/code&gt; 块中的任何注释都会禁止该检查。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="EmptyFinallyBlockJS" defaultSeverity="WARNING" displayName="空 'finally' 块" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告空的 &lt;code&gt;finally&lt;/code&gt; 块，此类块通常表明有错误。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ExceptionCaughtLocallyJS" defaultSeverity="WARNING" displayName="将异常用于本地控制流" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告异常始终可以通过包含 &lt;code&gt;try&lt;/code&gt; 语句捕获的 &lt;code&gt;throw&lt;/code&gt; 语句。 使用 &lt;code&gt;throw&lt;/code&gt; 语句作为 &lt;code&gt;goto&lt;/code&gt; 来更改局部控制流令人困惑。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ContinueOrBreakFromFinallyBlockJS" defaultSeverity="WARNING" displayName="'continue' 或 'break' 位于 'finally' 块内" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;finally&lt;/code&gt; 块中的 &lt;code&gt;break&lt;/code&gt; 或 &lt;code&gt;continue&lt;/code&gt; 语句。 此类语句非常令人困惑，可能隐藏异常，并导致调试复杂化。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReturnFromFinallyBlockJS" defaultSeverity="WARNING" displayName="'return' 位于 'finally' 块内" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;finally&lt;/code&gt; 块中的 &lt;code&gt;return&lt;/code&gt; 语句。 此类 &lt;code&gt;return&lt;/code&gt; 语句可能会掩盖抛出的异常，并导致调试复杂化。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="EmptyTryBlockJS" defaultSeverity="WARNING" displayName="空 'try' 块" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告空的 &lt;code&gt;try&lt;/code&gt; 块，此类块通常表示有错误。
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Spring MVC" path="Spring"><inspection shortName="MVCPathVariableInspection" defaultSeverity="WARNING" displayName="@PathVariable 声明和用法不匹配" enabled="false" language="UAST" pluginId="com.intellij.spring.mvc" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告在方法签名中声明但在 URL 路径中不存在或者在 URL 路径中声明但在方法签名中不存在的 &lt;code&gt;@PathVariable&lt;/code&gt; 形参。
  该快速修复会添加缺失的形参。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @RequestMapping("/path/{myVariable}/")
  public String handler(@PathVariable String name_is_not_equal_to_myVariable) {
    return "...";
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;应用快速修复后，结果如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @RequestMapping("/path/{myVariable}/")
  public String handler(@PathVariable String myVariable) {
    return "...";
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SpringMVCInitBinder" defaultSeverity="ERROR" displayName="非 void @InitBinder 方法" enabled="false" language="JAVA" pluginId="com.intellij.spring.mvc" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告使用 &lt;code&gt;@InitBinder&lt;/code&gt; 注解但未被声明为 &lt;code&gt;void&lt;/code&gt; 的 Spring MVC 控制器方法。&lt;/p&gt;
&lt;p&gt;根据&lt;a href=https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/bind/annotation/InitBinder.html&gt;规范&lt;/a&gt;，init-binder 方法应被声明为 &lt;code&gt;void&lt;/code&gt;。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SpringMVCViewInspection" defaultSeverity="WARNING" displayName="未解析的视图引用" enabled="false" language="UAST" pluginId="com.intellij.spring.mvc" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告未解析的 Spring MVC 视图参考。&lt;/p&gt;
&lt;p&gt;示例&lt;/p&gt;
&lt;pre&gt;
  @RequestMapping
  public String viewHandler() {
    return "viewName"; // 如果找不到带有 "viewName" 的视图，将高亮显示
  }
&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="打包问题" path="Java"><inspection shortName="PackageWithTooFewClasses" defaultSeverity="WARNING" displayName="软件包具有过少类" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
报告包含少于指定最小值的类的软件包。
&lt;p&gt;不报告包含子软件包的软件包。 过小的软件包可能表明设计零散。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;仅适用于&lt;b&gt;代码 | 检查代码&lt;/b&gt;或&lt;b&gt;代码 | 分析代码 | 通过名称运行检查&lt;/b&gt;，并且不会在编辑器中报告。&lt;/p&gt;
&lt;p&gt;使用&lt;b&gt;最小类数&lt;/b&gt;字段可指定软件包中允许的最小类数。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ClassOnlyUsedInOnePackage" defaultSeverity="WARNING" displayName="仅在其他软件包中使用的类" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
报告如下类：不依赖于其软件包中的任何其他类，而是依赖于其他软件包中的类，并且本身仅是此其他软件包中类的依赖项。
请考虑将这种类移到它们所依赖的软件包中。
&lt;!-- tooltip end --&gt;
&lt;p&gt;仅适用于&lt;b&gt;代码 | 检查代码&lt;/b&gt;或&lt;b&gt;代码 | 分析代码 | 通过名称运行检查&lt;/b&gt;，并且不会在编辑器中报告。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ExceptionPackage" defaultSeverity="WARNING" displayName="异常软件包" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
报告仅包含直接或间接扩展 &lt;code&gt;java.lang.Throwable&lt;/code&gt; 的类的软件包。
  &lt;p&gt;尽管异常的实现通常不依赖于其他类，但它们通常不会单独使用。
    更好的设计通常会将异常与使用它们的类放在同一个软件包中。&lt;/p&gt;
  &lt;!-- tooltip end --&gt;
&lt;p&gt;仅适用于&lt;b&gt;代码 | 检查代码&lt;/b&gt;或&lt;b&gt;代码 | 分析代码 | 通过名称运行检查&lt;/b&gt;，并且不会在编辑器中报告。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PackageInMultipleModules" defaultSeverity="WARNING" displayName="具有多个模块中的类的软件包" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
报告存在于多个模块中的非空软件包。
当软件包被包含在多个模块中时，很容易在两个模块中创建同名的类。
依赖于这些模块的模块如果尝试使用这种类，就会发生冲突。
Java Platform Module System 不允许包含在多个模块中的软件包（也称为 &lt;em&gt;拆分软件包&lt;/em&gt;）
&lt;!-- tooltip end --&gt;
&lt;p&gt;仅适用于&lt;b&gt;代码 | 检查代码&lt;/b&gt;或&lt;b&gt;代码 | 分析代码 | 通过名称运行检查&lt;/b&gt;，并且不会在编辑器中报告。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ClassUnconnectedToPackage" defaultSeverity="WARNING" displayName="独立于其软件包的类" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
报告如下类：不依赖于其软件包中的任何其他类，也不是其软件包中任何其他类的依赖项。
这种类表明临时或不连贯的打包策略，并且通常可以有利地移动。
不报告作为其软件包中唯一类的类。
  &lt;!-- tooltip end --&gt;
&lt;p&gt;仅适用于&lt;b&gt;代码 | 检查代码&lt;/b&gt;或&lt;b&gt;代码 | 分析代码 | 通过名称运行检查&lt;/b&gt;，并且不会在编辑器中报告。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PackageWithTooManyClasses" defaultSeverity="WARNING" displayName="类过多的软件包" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
报告包含过多类的软件包。
&lt;p&gt;过大的软件包可能表明设计不够明确。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;仅适用于&lt;b&gt;代码 | 检查代码&lt;/b&gt;或&lt;b&gt;代码 | 分析代码 | 通过名称运行检查&lt;/b&gt;，并且不会在编辑器中报告。&lt;/p&gt;
&lt;p&gt;使用&lt;b&gt;最大类数&lt;/b&gt;字段可指定软件包中允许的最大类数。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DisjointPackage" defaultSeverity="WARNING" displayName="具有不相交依赖关系图的软件包" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
报告类可以分成相互独立的子集的软件包。
&lt;p&gt;此类非连续软件包表示临时打包或缺乏概念上的连通性。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;仅适用于&lt;b&gt;代码 | 检查代码&lt;/b&gt;或&lt;b&gt;代码 | 分析代码 | 通过名称运行检查&lt;/b&gt;，并且不会在编辑器中报告。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="插件描述符" path="Plugin DevKit"><inspection shortName="PluginXmlCapitalization" defaultSeverity="WARNING" displayName="Plugin.xml 文本大小写" enabled="false" language="XML" pluginId="DevKit" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;plugin.xml&lt;/code&gt; 中的文本大小写问题。
&lt;p&gt;
  已检查以下元素：
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;&amp;lt;name&gt;&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;&amp;lt;action&gt;、&amp;lt;group&gt;&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;&amp;lt;separator, &amp;lt;synonym&gt;、&amp;lt;override-text&gt;&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;使用指定所需 &lt;code&gt;capitalization&lt;/code&gt; 的 &lt;code&gt;org.jetbrains.annotations.Nls&lt;/code&gt; 注解的扩展点属性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
  有关更多信息，请参阅 IntelliJ 平台 UI 准则中的&lt;a href="https://jetbrains.design/intellij/text/capitalization/"&gt;大写&lt;/a&gt;。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PluginXmlExtensionRegistration" defaultSeverity="WARNING" displayName="Plugin.xml 扩展程序注册" enabled="false" language="XML" pluginId="DevKit" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;plugin.xml&lt;/code&gt; 中的扩展注册问题。
&lt;p&gt;
  报告的问题如下：
&lt;ul&gt;
  &lt;li&gt;缺少 &lt;code&gt;language&lt;/code&gt; 声明。
    如果扩展不针对特定语言，请使用快速修复为“任何语言”创建显式声明。
  &lt;/li&gt;
  &lt;li&gt;检查：缺少特性&lt;/li&gt;
  &lt;li&gt;服务：冗余的 &lt;code&gt;serviceInterface&lt;/code&gt; 声明&lt;/li&gt;
  &lt;li&gt;没有 &lt;code&gt;externalIdPrefix&lt;/code&gt; 的 &lt;code&gt;com.intellij.stubElementTypeHolder&lt;/code&gt;，请参阅&lt;a
    href='https://plugins.jetbrains.com/docs/intellij/stub-indexes.html?from=?from=DevkitPluginXmlInspectionDescription'&gt;存根索引&lt;/a&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;2022.3 最新变化&lt;/small&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PluginXmlDynamicPlugin" defaultSeverity="WARNING" displayName="Plugin.xml 动态插件验证" enabled="false" language="XML" pluginId="DevKit" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告动态插件问题。
&lt;p&gt;
  无需重新启动 IDE 即可安装、更新和卸载动态插件（2020.1 和更高版本中支持）。
&lt;/p&gt;
&lt;p&gt;
  有关其他参考，请参阅&lt;a href="https://plugins.jetbrains.com/docs/intellij/dynamic-plugins.html?from=PluginXmlDynamicPlugin"&gt;动态插件&lt;/a&gt;。
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;2020.1 最新变化&lt;/small&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PluginXmlValidity" defaultSeverity="ERROR" displayName="Plugin.xml 有效性" enabled="false" language="XML" pluginId="DevKit" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;plugin.xml&lt;/code&gt; 中的问题。
&lt;p&gt;
  无效配置可能在运行时导致问题。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PluginXmlI18n" defaultSeverity="WARNING" displayName="Plugin.xml i18n 验证" enabled="false" language="XML" pluginId="DevKit" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;plugin.xml&lt;/code&gt; 中的硬编码文本。
&lt;p&gt;
  使用在资源包中定义的文本可在 IDE 中支持多种语言。
&lt;/p&gt;
&lt;p&gt;
  已检查以下元素：
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;&amp;lt;action&gt;、&amp;lt;group&gt;&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;&amp;lt;separator, &amp;lt;override-text&gt;&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;具有 &lt;code&gt;bundle/key&lt;/code&gt; 替代项的已知扩展点&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Vue" path=""><inspection shortName="VueMissingComponentImportInspection" defaultSeverity="WARNING" displayName="缺少组件导入" enabled="false" language="Vue" pluginId="org.jetbrains.plugins.vue" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告需要在 Vue 模板中导入的 Vue 组件。 它提供了一个快速修复来添加缺失的导入。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="VueDuplicateTag" defaultSeverity="WARNING" displayName="重复的模板/脚本标记" enabled="false" language="Vue" pluginId="org.jetbrains.plugins.vue" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 Vue 文件中 &lt;code&gt;template&lt;/code&gt; 或 &lt;code&gt;script&lt;/code&gt; 标记的多次用法。
  &lt;p&gt;&lt;a href="https://vue-loader.vuejs.org/spec.html"&gt;Vue 组件规范&lt;/a&gt;指示每个 &lt;code&gt;*.vue&lt;/code&gt; 文件一次最多只能包含一个 &lt;code&gt;template&lt;/code&gt; 或 &lt;code&gt;script&lt;/code&gt; 块。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="VueDeprecatedSymbol" defaultSeverity="WARNING" displayName="弃用的符号" enabled="false" language="Vue" pluginId="org.jetbrains.plugins.vue" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告已弃用的 Vue 符号。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="VueDataFunction" defaultSeverity="WARNING" displayName="数据函数" enabled="false" language="Vue" pluginId="org.jetbrains.plugins.vue" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告并非函数的 Vue 组件 &lt;a href="https://vuejs.org/v2/api/#data"&gt;data&lt;/a&gt; 属性。 建议用函数包装对象文字。
&lt;p&gt;在定义组件时，&lt;code&gt;data&lt;/code&gt; 必须声明为返回初始数据对象的函数，因为将使用相同的定义创建多个实例。 如果 &lt;code&gt;data&lt;/code&gt; 仍然使用普通对象，那么该对象将通过引用来在创建的所有实例中共享！ 有了 &lt;code&gt;data&lt;/code&gt; 函数，每次创建新实例时，都可以直接调用它以返回初始数据的新副本。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="VueUnrecognizedSlot" defaultSeverity="WEAK WARNING" displayName="无法识别的插槽" enabled="false" language="Vue" pluginId="org.jetbrains.plugins.vue" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告无法识别的 Vue 插槽。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="VueUnrecognizedDirective" defaultSeverity="WARNING" displayName="无法识别的指令" enabled="false" language="Vue" pluginId="org.jetbrains.plugins.vue" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告无法识别的 Vue 指令。
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="控制流问题" path="Java"><inspection shortName="PointlessBooleanExpression" defaultSeverity="WARNING" displayName="无意义的布尔表达式" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告不必要的或过于复杂的布尔表达式。
&lt;p&gt;此类表达式包括： &lt;code&gt;&amp;&amp;&lt;/code&gt; 和 &lt;code&gt;true&lt;/code&gt; 的组合、
&lt;code&gt;||&lt;/code&gt; 和 &lt;code&gt;false&lt;/code&gt; 的组合、布尔文字的相等比较或布尔文字求反。 此类表达可以简化。&lt;/p&gt;
&lt;p&gt;示例：
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;boolean&lt;/b&gt; a = !(x &amp;&amp; &lt;b&gt;false&lt;/b&gt;);
  &lt;b&gt;boolean&lt;/b&gt; b = &lt;b&gt;false&lt;/b&gt; || x;
  &lt;b&gt;boolean&lt;/b&gt; c = x != &lt;b&gt;true&lt;/b&gt;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;boolean&lt;/b&gt; a = &lt;b&gt;true&lt;/b&gt;;
  &lt;b&gt;boolean&lt;/b&gt; b = x;
  &lt;b&gt;boolean&lt;/b&gt; c = !x;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;p&gt;配置检查：&lt;/p&gt;
使用 &lt;b&gt;在确定无意义表达式时忽略命名常量&lt;/b&gt; 选项可在确定表达式是否无意义时忽略命名常量。
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FallthruInSwitchStatement" defaultSeverity="WARNING" displayName="'switch' 语句中的直落" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;switch&lt;/code&gt; 语句中的直落。
&lt;p&gt;当 &lt;code&gt;case&lt;/code&gt; 标签后面的一系列可执行语句不能保证在下一个 &lt;code&gt;case&lt;/code&gt; 标签前转移控制权时，就会发生直落。 例如，如果分支缺少 &lt;code&gt;break&lt;/code&gt; 语句，就可能发生这种情况。
在这种情况下，即便 &lt;code&gt;switch&lt;/code&gt; 表达式不等于被直落标签的值，控制权也会直落到 &lt;code&gt;switch&lt;/code&gt; 标签后面的语句。 虽然偶尔是有意为之，但此结构令人困惑，并且通常是由拼写错误所致。&lt;/p&gt;
&lt;p&gt;
此检查将忽略任何使用与正则表达式模式 &lt;code&gt;(?i)falls?\s*thro?u&lt;/code&gt; 相匹配的文本注释的直落。
&lt;/p&gt;
&lt;p&gt;可以通过修正向可能直落到下一个分支的分支添加 &lt;code&gt;break&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    switch(x) {
      case (4):
          if (condition) {
              System.out.println("3");
              // 此处无 break
          } else {
              break;
          }
      case (6):
          System.out.println("4");
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    switch(x) {
        case (4):
            if (condition) {
                System.out.println("3");
            } else {
                break;
            }
            break;
        case (6):
            System.out.println("4");
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NegatedConditionalExpression" defaultSeverity="WARNING" displayName="否定条件表达式" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告使用前缀表达式否定的条件表达式，因为此类结构可能令人困惑。
&lt;p&gt;可以通过修正将外部否定同时传播到两个分支。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  !(i == 1 ? a : b)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  i == 1 ? !a : !b
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="InfiniteLoopStatement" defaultSeverity="WARNING" displayName="无限循环语句" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告只能通过抛出异常退出的 &lt;code&gt;for&lt;/code&gt;、&lt;code&gt;while&lt;/code&gt; 或 &lt;code&gt;do&lt;/code&gt; 语句。 虽然此类语句可能是正确的，但它们经常由编码错误导致。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  for (;;) {
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
使用 &lt;b&gt;放置在 Thread.run 中时忽略&lt;/b&gt; 选项忽略 &lt;code&gt;Thread.run&lt;/code&gt; 中的无限循环语句。
它可能对守护线程有用。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  new Thread(() -&amp;gt; {
    while (true) {
    }
  }).start();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NestedConditionalExpression" defaultSeverity="WARNING" displayName="嵌套条件表达式" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告嵌套的条件表达式，因为它们可能导致代码格外令人困惑。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int y = a == 10 ? b == 20 ? 10 : a : b;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SimplifiableBooleanExpression" defaultSeverity="WARNING" displayName="可简化的布尔表达式" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以简化的布尔表达式。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void f(boolean foo, boolean bar) {
    boolean b = !(foo ^ bar);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void f(boolean foo, boolean bar) {
    boolean b = foo == bar;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void f(boolean foo, boolean bar) {
    boolean b = (foo &amp;&amp; bar) || !foo;
  }
  &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void f(boolean foo, boolean bar) {
    boolean b = !foo || bar;
  }
  &lt;/code&gt;&lt;/pre&gt;

&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SwitchStatementDensity" defaultSeverity="WARNING" displayName="'switch' 语句的分支密度过低" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 switch 标签与可执行语句的比率太低的 &lt;code&gt;switch&lt;/code&gt; 语句或表达式。
&lt;p&gt;此类 &lt;code&gt;switch&lt;/code&gt; 语句可能令人困惑，或许应对其进行重构。&lt;/p&gt;

&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    switch (i) { // 1 个 case，5 个可执行语句 -&gt; 20% 的密度
        case 1:
            System.out.println("1");
            System.out.println("2");
            System.out.println("3");
            System.out.println("4");
            System.out.println("5");
            break;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;p&gt;使用&lt;b&gt;分支的最小密度&lt;/b&gt;字段可以指定 switch 标签与可执行语句的允许比率。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SwitchStatementsWithoutDefault" defaultSeverity="INFORMATION" displayName="不带 'default' 分支的 'switch' 语句" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告不包含 &lt;code&gt;default&lt;/code&gt; 标签的 &lt;code&gt;switch&lt;/code&gt; 语句。
&lt;p&gt;添加 &lt;code&gt;default&lt;/code&gt; 标签可确保涵盖所有可能的场景，从而更容易对程序的当前状态作出假设。&lt;/p&gt;
&lt;p&gt;
&lt;!-- tooltip end --&gt;
  请注意，默认情况下，如果用于枚举或 &lt;code&gt;sealed&lt;/code&gt; 类的情况都被覆盖，则检查不会报告 &lt;code&gt;switch&lt;/code&gt; 语句。
  如果您想改变这种行为，请使用&lt;b&gt;忽略详尽的 switch 语句&lt;/b&gt;选项。
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConditionalCanBePushedInsideExpression" defaultSeverity="INFORMATION" displayName="可以将条件推送到分支表达式内部" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告满足以下条件表达式：带有 &lt;code&gt;then&lt;/code&gt; 和 &lt;c&gt;else&lt;/c&gt; 分支，且足够相似，以便表达式可以移入内部。 此操作会缩短代码。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  double g(int a, int b) {
    return a == b ? Math.cos(0) : Math.cos(1);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  double g(int a, int b) {
    return Math.cos(a == b ? 0 : 1);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2017.2 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PointlessNullCheck" defaultSeverity="WARNING" displayName="方法调用前出现不必要的 'null' 检查" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告后接传递 &lt;code&gt;null&lt;/code&gt; 时必定返回 &lt;code&gt;false&lt;/code&gt; 的方法调用的 &lt;code&gt;null&lt;/code&gt; 检查（例如，&lt;code&gt;Class.isInstance&lt;/code&gt;）。
&lt;p&gt;在这种情况下，方法调用总是返回 &lt;code&gt;false&lt;/code&gt;，此类检查似乎有些多余。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (x != null &amp;&amp; myClass.isInstance(x)) { ... }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (myClass.isInstance(x)) { ... }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ExpressionMayBeFactorized" defaultSeverity="INFORMATION" displayName="表达式可以因式分解" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;!-- Copyright 2000-2021 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file. --&gt;
&lt;html&gt;
&lt;body&gt;
报告可以分解（即重组以提取公因数）的表达式。
这减少了冗余，可以提高代码的可读性。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  a &amp;amp;&amp;amp; b || a &amp;amp;&amp;amp; c
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  a &amp;amp;&amp;amp; (b || c)
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2021.3 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="PointlessIndexOfComparison" defaultSeverity="WARNING" displayName="无意义的 'indexOf()' 比较" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告与 &lt;code&gt;.indexOf()&lt;/code&gt; 表达式的不必要比较。 此类表达式的一个示例是将 &lt;code&gt;.indexOf()&lt;/code&gt; 的结果与小于 -1 的数字进行比较。
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AssertionCanBeIf" defaultSeverity="INFORMATION" displayName="断言可被替换为 'if' 语句" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;assert&lt;/code&gt; 语句并建议将它们替换为抛出 &lt;code&gt;java.lang.AssertionError&lt;/code&gt; 的 &lt;code&gt;if&lt;/code&gt; 语句。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  assert param != null;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (param == null) throw new AssertionError();
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="IfStatementWithIdenticalBranches" defaultSeverity="WEAK WARNING" displayName="'if' 语句的分支相同" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以从分支中提取通用部分的 &lt;code&gt;if&lt;/code&gt; 语句。
&lt;p&gt;这些通用部分独立于条件并使 &lt;code&gt;if&lt;/code&gt; 语句更难理解。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (x &amp;gt; 12) {
    doSomethingBefore();
    doSomethingDifferent1();
    doSomethingAfter();
  } else {
    doSomethingBefore();
    doSomethingDifferent2();
    doSomethingAfter();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  doSomethingBefore();
  if (x &amp;gt; 12) {
    doSomethingDifferent1();
  } else {
    doSomethingDifferent2();
  }
  doSomethingAfter();
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;这是 2018.1 更新的功能&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="NegatedIfElse" defaultSeverity="WARNING" displayName="具有否定条件的 'if' 语句" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告包含 &lt;code&gt;else&lt;/code&gt; 分支并且条件被否定的 &lt;code&gt;if&lt;/code&gt; 语句。
&lt;p&gt;翻转 &lt;code&gt;if&lt;/code&gt; 和 &lt;code&gt;else&lt;/code&gt; 分支的顺序通常会增加此类语句的清晰度。&lt;/p&gt;
&lt;p&gt;可以通过修正反转当前 &lt;code&gt;if&lt;/code&gt; 语句。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    void m(Object o1, Object o2) {
        if (o1 != o2) {
            System.out.println(1);
        }
        else {
            System.out.println(2);
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    void m(Object o1, Object o2) {
        if (o1 == o2) {
            System.out.println(2);
        } else {
            System.out.println(1);
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;使用&lt;b&gt;忽略 '!= null' 比较&lt;/b&gt;选项可以忽略 &lt;code&gt;!= null&lt;/code&gt; 形式的比较。&lt;/p&gt;
&lt;p&gt;使用&lt;b&gt;忽略 '!= 0' 比较&lt;/b&gt;选项可以忽略 &lt;code&gt;!= 0&lt;/code&gt; 形式的比较。&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SwitchExpressionCanBePushedDown" defaultSeverity="INFORMATION" displayName="可以从 'switch' 中提取通用子表达式" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告每个分支都有通用子表达式，因此 switch 可以移动到内部的 &lt;code&gt;switch&lt;/code&gt; 表达式和语句。
此操作会缩短代码。 在许多情况下，将得到的 switch 表达式提取到单独的变量或方法是合理的。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  switch (value) {
    case 0 -&gt; System.out.println("zero");
    case 1 -&gt; System.out.println("one");
    case 2, 3, 4 -&gt; System.out.println("few");
    default -&gt; System.out.println("many");
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  System.out.println(switch (value) {
    case 0 -&gt; "zero";
    case 1 -&gt; "one";
    case 2, 3, 4 -&gt; "few";
    default -&gt; "many";
  });
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  此检查仅适用于采用箭头语法的增强的 switch。
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;2022.3 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConfusingElse" defaultSeverity="INFORMATION" displayName="冗余的 'else'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
在 &lt;code&gt;if&lt;/code&gt;&amp;mdash;&lt;code&gt;else&lt;/code&gt; 语句和语句链中报告冗余的 &lt;code&gt;else&lt;/code&gt; 关键字。
&lt;p&gt;
当所有之前的分支以 &lt;code&gt;return&lt;/code&gt;、&lt;code&gt;throw&lt;/code&gt;、&lt;code&gt;break&lt;/code&gt; 或 &lt;code&gt;continue&lt;/code&gt; 语句结尾时，&lt;code&gt;else&lt;/code&gt; 关键字冗余。 在这种情况下，来自 &lt;code&gt;else&lt;/code&gt; 分支的语句可以放在 &lt;code&gt;if&lt;/code&gt; 语句之后，并且 &lt;code&gt;else&lt;/code&gt; 关键字可以删除。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (name == null) {
      throw new IllegalArgumentException();
  } else {
      System.out.println(name);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (name == null) {
      throw new IllegalArgumentException();
  }
  System.out.println(name);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;禁用&lt;b&gt;当 'if' 语句之后没有其他语句时报告&lt;/b&gt;选项，以忽略 &lt;code&gt;if&lt;/code&gt;&amp;mdash;&lt;code&gt;else&lt;/code&gt; 语句是代码块中最后一条语句的情况。&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SwitchStatement" defaultSeverity="WARNING" displayName="'switch' 语句" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;switch&lt;/code&gt; 语句。
&lt;p&gt;&lt;code&gt;switch&lt;/code&gt; 语句通常（但并非总是）表明面向对象的设计欠佳。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  switch (i) {
    // 代码
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ForLoopReplaceableByWhile" defaultSeverity="WARNING" displayName="'for' 循环可被替换为 'while' 循环" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告不包含初始化和更新组件的 &lt;code&gt;for&lt;/code&gt; 循环，并建议将它们转换为 &lt;code&gt;while&lt;/code&gt; 循环。 这使代码更易于阅读。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  for(; exitCondition(); ) {
    process();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  while(exitCondition()) {
    process();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;快速修复也可用于其他 &lt;code&gt;for&lt;/code&gt; 循环，因此您可以用 &lt;code&gt;while&lt;/code&gt; 循环替换任何 &lt;code&gt;for&lt;/code&gt; 循环。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;如果您想忽略具有不重要或不存在条件的 &lt;code&gt;for&lt;/code&gt; 循环，使用 &lt;b&gt;忽略无条件的 'infinite' for 循环&lt;/b&gt; 选项。
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LoopStatementsThatDontLoop" defaultSeverity="WARNING" displayName="不循环的循环语句" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告其语句体最多执行一次的 &lt;code&gt;for&lt;/code&gt;、&lt;code&gt;while&lt;/code&gt; 和 &lt;code&gt;do&lt;/code&gt; 语句的任何实例。 通常，这表明存在错误。
&lt;!-- tooltip end --&gt;
&lt;p&gt;
使用&lt;b&gt;忽略增强型 for 循环&lt;/b&gt;选项可忽略 foreach 循环。
它们有时用于以紧凑的方式仅对可迭代对象的第一个条目执行操作。
&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;for&lt;/b&gt; (String s : stringIterable) {
    doSomethingOnFirstString(s);
    &lt;b&gt;break&lt;/b&gt;;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DuplicateCondition" defaultSeverity="WARNING" displayName="条件重复" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 和 &lt;code&gt;||&lt;/code&gt; 表达式以及 &lt;code&gt;if&lt;/code&gt; 语句分支中的重复条件。
这些重复的条件有时是有意为之，但通常是因为疏忽大意所致。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean result = digit1 != digit2 || digit1 != digit2;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  要忽略可能产生副作用的条件，请使用&lt;b&gt;忽略有副作用的条件&lt;/b&gt; 选项。
禁用此选项可能会导致误报，例如，当同一方法在后续调用中返回不同的值时。
&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (iterator.next() != null || iterator.next() != null) {
    System.out.println("Got it");
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由于 &lt;code&gt;iterator.next()&lt;/code&gt; 可能存在副作用（在示例中），只有在禁用 &lt;b&gt;忽略有副作用的条件&lt;/b&gt; 选项时才会触发警告。&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ContinueStatement" defaultSeverity="WARNING" displayName="'continue' 语句" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;continue&lt;/code&gt; 语句。
&lt;p&gt;&lt;code&gt;continue&lt;/code&gt; 语句导致重构复杂化，可能令人困惑。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void foo(List&amp;lt;String&amp;gt; strs) {
    for (String str : strs) {
      if (str.contains("skip")) continue;
      handleStr(str);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SwitchStatementWithTooManyBranches" defaultSeverity="WARNING" displayName="最大 'switch' 分支" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;case&lt;/code&gt; 标签太多的 &lt;code&gt;switch&lt;/code&gt; 语句或表达式。
&lt;p&gt;如此之长的 switch 语句可能令人困惑，或许应进行重构。
  有时这并非问题（例如一个域非常复杂，并且有包含大量常量的枚举）。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    switch (x) {
        case 1 -&gt; {}
        case 2 -&gt; {}
        case 3 -&gt; {}
        case 4 -&gt; {}
        case 5 -&gt; {}
        case 6 -&gt; {}
        case 7 -&gt; {}
        case 8 -&gt; {}
        case 9 -&gt; {}
        case 10 -&gt; {}
        case 11,12,13 -&gt; {}
        default -&gt; {}
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;使用&lt;b&gt;最大分支数&lt;/b&gt;字段可以指定 &lt;code&gt;case&lt;/code&gt; 标签的预期最大数量。
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LoopConditionNotUpdatedInsideLoop" defaultSeverity="WARNING" displayName="循环变量未在循环内更新" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在循环条件中使用且未在循环内更新的任何变量和形参。
&lt;p&gt;此类变量和形参通常被错误使用，因为如果执行它们可能会导致无限循环。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void loopDoesNotLoop(boolean b) {
    while (b) {
      System.out.println();
      break;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;配置检查：&lt;/p&gt;
&lt;p&gt;
  如果条件可以间接更新（例如，通过调用的方法或从另一个线程并发更新），请使用 &lt;b&gt;忽略可能的非本地变更&lt;/b&gt; 选项来禁用此检查。
&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="EnumSwitchStatementWhichMissesCases" defaultSeverity="INFORMATION" displayName="缺少 case 的枚举 'switch' 语句" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告为不详尽的枚举类型执行的 &lt;code&gt;switch&lt;/code&gt; 语句。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;enum&lt;/b&gt; AlphaBetaGamma {
    A, B, C;

    &lt;b&gt;void&lt;/b&gt; x(AlphaBetaGamma e) {
      &lt;b&gt;switch&lt;/b&gt; (e) {

      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;enum&lt;/b&gt; AlphaBetaGamma {
    A, B, C;

    &lt;b&gt;void&lt;/b&gt; x(AlphaBetaGamma e) {
      &lt;b&gt;switch&lt;/b&gt; (e) {
        &lt;b&gt;case&lt;/b&gt; A -&gt; {}
        &lt;b&gt;case&lt;/b&gt; B -&gt; {}
        &lt;b&gt;case&lt;/b&gt; C -&gt; {}
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
使用 &lt;b&gt;忽略具有默认分支的 switch 语句&lt;/b&gt; 选项忽略具有 &lt;code&gt;default&lt;/code&gt; 分支的 &lt;code&gt;switch&lt;/code&gt; 语句。
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LoopWithImplicitTerminationCondition" defaultSeverity="WARNING" displayName="具有隐式终止条件的循环" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告任何以 &lt;code&gt;true&lt;/code&gt; 常量作为其唯一条件的 &lt;code&gt;while&lt;/code&gt;、&lt;code&gt;do-while&lt;/code&gt; 和 &lt;code&gt;for&lt;/code&gt; 循环。 同时，此类循环仍然能够被可以跳出循环的包含 &lt;code&gt;if&lt;/code&gt; 语句终止。
&lt;p&gt;此类 &lt;code&gt;if&lt;/code&gt; 语句必须是 &lt;code&gt;while&lt;/code&gt; 或 &lt;code&gt;for&lt;/code&gt; 循环中的第一个或唯一语句，也必须是 &lt;code&gt;do-while&lt;/code&gt; 循环中的最后一个或唯一语句。&lt;/p&gt;

&lt;p&gt;移除 &lt;code&gt;if&lt;/code&gt; 语句并将其条件设为显式循环条件可简化循环。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="BreakStatement" defaultSeverity="WARNING" displayName="'break' 语句" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在 &lt;code&gt;switch&lt;/code&gt; 语句分支结尾以外的位置使用的 &lt;code&gt;break&lt;/code&gt; 语句。
&lt;p&gt;&lt;code&gt;break&lt;/code&gt; 语句导致重构复杂化，可能令人困惑。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
void foo(List&amp;lt;String&amp;gt; strs) {
  for (String str : strs) {
    if (str.contains("stop")) break;
    handleStr(str);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DefaultNotLastCaseInSwitch" defaultSeverity="WARNING" displayName="'default' 不是 'switch' 中的最后一个 case" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告其中的 &lt;code&gt;default&lt;/code&gt; 分支位于另一个 case 前面的 &lt;code&gt;switch&lt;/code&gt; 语句或表达式。
此类构造会造成不必要的困惑。
如果可能，可以通过快速修复将 &lt;code&gt;default&lt;/code&gt; 分支移到最后位置。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  switch (n) {
      default:
          System.out.println();
          break;
      case 1:
          break;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  switch (n) {
    case 1:
        break;
    default:
        System.out.println();
        break;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConditionalBreakInInfiniteLoop" defaultSeverity="WARNING" displayName="循环内条件中断" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在循环开始或结束处的条件中断，并建议改为添加循环条件来缩短代码。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;while&lt;/b&gt; (true) {
    &lt;b&gt;if&lt;/b&gt; (i  == 23) &lt;b&gt;break&lt;/b&gt;;
    i++;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;while&lt;/b&gt; (i != 23) {
    i++;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NegatedEqualityExpression" defaultSeverity="WARNING" displayName="否定相等表达式" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告被前缀表达式否定的等式表达式。
&lt;p&gt;可以使用 &lt;code&gt;!=&lt;/code&gt; 运算符简化此类表达式。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  !(i == 1)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  i != 1
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ContinueStatementWithLabel" defaultSeverity="WARNING" displayName="带标签的 'continue' 语句" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告包含标签的 &lt;code&gt;continue&lt;/code&gt; 语句。
&lt;p&gt;&lt;code&gt;continue&lt;/code&gt; 标签语句导致重构复杂化，可能令人困惑。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void handle(List&amp;lt;String&amp;gt; strs) {
    outer:
    for (String s: strs) {
      for (char ch : s.toCharArray()) {
        if ('s' == ch) continue outer;
        handleChar(ch);
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NestedSwitchStatement" defaultSeverity="WARNING" displayName="嵌套 'switch' 语句" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告嵌套的 &lt;code&gt;switch&lt;/code&gt; 语句或表达式。
&lt;p&gt;嵌套的 &lt;code&gt;switch&lt;/code&gt; 语句可能导致代码格外令人困惑。 这些语句可以提取到一个单独的方法中。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int res = switch (i) {
            case 0 -&gt; 0;
            default -&gt; switch (i) {
                case 100 -&gt; 0;
                default -&gt; i;
            };
        };
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="IdempotentLoopBody" defaultSeverity="WARNING" displayName="幂等循环体" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告除了第一次迭代中产生的副作用外，在第二次和后续迭代中不产生其他副作用的循环，这可能表示编程错误。
&lt;p&gt;此类循环可能只迭代零次、一次或无限次。
如果不存在无限循环的情况，则可以将其替换为 &lt;code&gt; if &lt;/code&gt; 语句。
  否则，程序可能会卡住。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    public void foo(String baseName, String names) {
        int suffix = 1;
        String name = baseName;
        while (names.contains(name)) {
            // 错误：suffix 未更新，导致循环体幂等
            name = baseName + suffix;
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2018.1 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConditionalExpressionWithIdenticalBranches" defaultSeverity="WARNING" displayName="具有相同分支的条件表达式" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告包含相同 &lt;code&gt;then&lt;/code&gt; 和 &lt;code&gt;else&lt;/code&gt; 分支的条件表达式。
&lt;p&gt;此类表达式几乎肯定表明有错误。 该检查提供了一种折叠条件表达式的修正。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int y = x == 10 ? 4 : 4;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int y = 4;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LabeledStatement" defaultSeverity="WARNING" displayName="标记语句" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可能导致重构和方法控制流复杂化的语句。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  label:
  while (true) {
      // 代码
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="BreakStatementWithLabel" defaultSeverity="WARNING" displayName="带标签的 'break' 语句" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告包含标签的 &lt;code&gt;break&lt;/code&gt; 语句。
&lt;p&gt;&lt;code&gt;break&lt;/code&gt; 标签语句导致重构复杂化，可能令人困惑。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void handle(List&amp;lt;String&amp;gt; strs) {
    outer:
    for (String s: strs) {
      for (char ch : s.toCharArray()) {
        if ('s' == ch) break outer;
        handleChar(ch);
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="BooleanExpressionMayBeConditional" defaultSeverity="INFORMATION" displayName="布尔表达式可被替换为条件表达式" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告任何能够以比使用条件表达式更紧凑、更清晰的方式来表述的 &lt;code&gt;boolean&lt;/code&gt; 表达式。
&lt;p&gt;使用该快速修复可以将 &lt;code&gt;boolean&lt;/code&gt; 表达式替换为条件表达式。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  a &amp;amp;&amp;amp; b || !a &amp;amp;&amp;amp; c;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  a ? b : c;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SwitchStatementWithTooFewBranches" defaultSeverity="WARNING" displayName="最小 'switch' 分支" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告带有太少 &lt;code&gt;case&lt;/code&gt; 标签的 &lt;code&gt;switch&lt;/code&gt; 语句和表达式，并建议将它们重写为 &lt;code&gt;if&lt;/code&gt; 和 &lt;code&gt;else if&lt;/code&gt; 语句。
&lt;p&gt;示例 (minimum branches == 3)：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  switch (expression) {
    case "foo" -&amp;gt; foo();
    case "bar" -&amp;gt; bar();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if ("foo".equals(expression)) {
    foo();
  } else if ("bar".equals(expression)) {
    bar();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不报告详尽的 switch 表达式 (Java 14+) 或不带 'default' 分支的模式 switch 语句（Java 17 预览版）。
  这是因为当 &lt;code&gt;switch&lt;/code&gt; 被转换为 &lt;code&gt;if&lt;/code&gt; 后，编译时详尽性检查将丢失（可能是不希望发生的结果）。
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;配置检查：&lt;/p&gt;
&lt;p&gt;使用&lt;b&gt;最小分支数&lt;/b&gt; 字段指定 &lt;code&gt;case&lt;/code&gt; 标签的最小预期数量。&lt;/p&gt;
&lt;p&gt;使用&lt;b&gt;不报告模式 switch 语句&lt;/b&gt;选项可避免报告具有模式分支的 switch 语句和表达式。 例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String result = switch(obj) {
    case String str -&gt; str.trim();
    default -&gt; "none";
  };
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;即使只有一个模式分支，也应该保留 switch，而不是使用 &lt;code&gt;instanceof&lt;/code&gt; 语句。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DoubleNegation" defaultSeverity="WARNING" displayName="双重否定" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以简化的双重否定。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (!!functionCall()) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (functionCall()) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (!(a != b)) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (a == b) {}
&lt;/code&gt;&lt;/pre&gt;
  &lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TrivialIf" defaultSeverity="WARNING" displayName="冗余的 'if' 语句" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以简化为单个赋值、&lt;code&gt;return&lt;/code&gt; 或 &lt;code&gt;assert&lt;/code&gt; 语句的 &lt;code&gt;if&lt;/code&gt; 语句。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (foo()) {
    return true;
  } else {
    return false;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  return foo();
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;配置检查：&lt;/p&gt;
&lt;p&gt;如果要隐藏链式 &lt;code&gt;if&lt;/code&gt; 语句的警告，请使用&lt;b&gt;忽略链式 'if' 语句&lt;/b&gt;选项。&lt;/p&gt;
&lt;p&gt;例如，在以下代码中，警告将被隐藏，但快速修复仍然可用：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (condition1) return true;
  if (condition2) return false;
  return true;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;请注意，如果条件有副作用，将 &lt;code&gt;if (isTrue()) assert false;&lt;/code&gt; 替换为 &lt;code&gt;assert isTrue();&lt;/code&gt; 可能会改变禁用 assert 时的程序语义。
  如果要隐藏 &lt;code&gt;if&lt;/code&gt; 语句在其主体中仅包含 &lt;code&gt;assert&lt;/code&gt; 语句的警告，请使用&lt;b&gt;忽略带有普通 'assert' 的 'if' 语句&lt;/b&gt;选项。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConstantConditionalExpression" defaultSeverity="WARNING" displayName="常量条件表达式" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告条件为 &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt; 常量的条件表达式。
这些表达式有时是自动重构的结果，并且可以被简化。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  return true ? "Yes" : "No";
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  return "Yes";
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConditionalExpression" defaultSeverity="INFORMATION" displayName="条件表达式" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告三元条件运算符的用法并建议将它们转换为 &lt;code&gt;if&lt;/code&gt;/&lt;code&gt;else&lt;/code&gt; 语句。
&lt;p&gt;一些代码标准禁止使用条件运算符。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Object result = (condition) ? foo() : bar();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Object result;
  if (condition) {
    comp = foo();
  }
  else {
    comp = bar();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;配置检查：&lt;/p&gt;
&lt;p&gt;使用 &lt;b&gt;对简单赋值和返回值忽略&lt;/b&gt; 选项忽略简单的赋值和返回并允许以下结构：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String s = (foo == null) ? "" : foo.toString();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  在不可能用 if 语句自动替换的上下文中（例如，当条件表达式用作 &lt;code&gt;super()&lt;/code&gt; 构造函数调用），使用 &lt;b&gt;忽略无法使用 if 语句的位置&lt;/b&gt; 选项来忽略条件表达式。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="OverlyComplexBooleanExpression" defaultSeverity="WARNING" displayName="过度复杂的布尔表达式" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告包含太多项的布尔表达式。 此类表达方式可能令人困惑，并且容易出错。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  cond(x1) &amp;amp;&amp;amp; cond(x2) ^ cond(x3) &amp;amp;&amp;amp; cond(x4);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;配置检查：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;使用&lt;b&gt;最大项数&lt;/b&gt;字段可以指定布尔表达式中允许的最大项数。&lt;/li&gt;
  &lt;li&gt;使用&lt;b&gt;忽略纯合取和析取&lt;/b&gt;选项可以忽略重复使用单一布尔运算符的布尔表达式。&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NegatedConditional" defaultSeverity="WARNING" displayName="具有否定条件的条件表达式" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告条件被否定的条件表达式。
&lt;p&gt;翻转条件表达式分支的顺序通常会增加此类语句的清晰度。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用&lt;b&gt;忽略 '!= null' 比较&lt;/b&gt;和&lt;b&gt;忽略 '!= 0' 比较&lt;/b&gt;选项可以忽略 &lt;code&gt;obj != null&lt;/code&gt; 或 &lt;code&gt;num != 0&lt;/code&gt; 形式的比较。
  由于 &lt;code&gt;obj != null&lt;/code&gt; 实际上意味着 "obj exists"，整个表达式的含义不涉及任何否定，所以易于理解。
&lt;p&gt;
  同样的推理也适用于 &lt;code&gt;num !=0&lt;/code&gt; 表达式，在使用位掩码时更是如此。
&lt;p&gt;
  这些形式还有另外的好处，即先提及有趣的情况。
  在大多数情况下，&lt;code&gt;== null&lt;/code&gt; 分支的值为 &lt;code&gt;null&lt;/code&gt; 本身，如以下示例所示：

&lt;pre&gt;&lt;code&gt;
    static String getName(Person p) {
        return p != null ? p.getName() : null;
    }

    static String getExecutableString(int fileMode) {
        return (fileMode &amp; 0b001001001) != 0 ? "executable" : "non-executable";
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ForLoopWithMissingComponent" defaultSeverity="WARNING" displayName="缺少组件的 'for' 循环" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告缺少初始化、条件或 update 子句的 &lt;code&gt;for&lt;/code&gt; 循环。 某些编码样式禁止此类循环。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  for (int i = 0;;i++) {
    //主体
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
使用&lt;b&gt;忽略集合迭代&lt;/b&gt;选项可以忽略使用迭代器的循环。
这是在 &lt;code&gt;for&lt;/code&gt; 循环没有 update 子句的集合中迭代的标准方式。
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="IfCanBeAssertion" defaultSeverity="INFORMATION" displayName="语句可被替换为 'assert' 或 'Objects.requireNonNull'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告仅从 &lt;code&gt;then&lt;/code&gt; 分支抛出 &lt;code&gt;java.lang.Throwable&lt;/code&gt; 而没有 &lt;code&gt;else&lt;/code&gt; 分支的 &lt;code&gt;if&lt;/code&gt; 语句。 此类语句可以转换为更紧凑的 &lt;code&gt;assert&lt;/code&gt; 语句。
&lt;p&gt;
检查还报告 Guava 的 &lt;code&gt;Preconditions.checkNotNull()&lt;/code&gt;。
  它们可以替换为不需要库 &lt;code&gt;Objects.requireNonNull()&lt;/code&gt; 调用。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;if&lt;/b&gt; (x == 2) &lt;b&gt;throw new&lt;/b&gt; RuntimeException("fail");
  &lt;b&gt;if&lt;/b&gt; (y == null) &lt;b&gt;throw new&lt;/b&gt; AssertionError();
  Preconditions.checkNotNull(z, "z");
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;assert&lt;/b&gt; x != 2 : "fail";
  Objects.requireNonNull(y);
  Objects.requireNonNull(z, "z");
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;默认情况下，此检查在编辑器中提供快速修复，而没有高亮显示代码。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="IfStatementWithTooManyBranches" defaultSeverity="WARNING" displayName="'if' 语句的分支过多" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告分支太多的 &lt;code&gt;if&lt;/code&gt; 语句。
&lt;p&gt;此类语句可能令人困惑，并且通常表明设计抽象级别不足。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用&lt;b&gt;最大分支数&lt;/b&gt;字段指定 &lt;code&gt;if&lt;/code&gt; 语句可以具备的最大分支数。
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SimplifiableConditionalExpression" defaultSeverity="WARNING" displayName="可简化的条件表达式" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告并建议简化条件表达式。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;condition ? true : foo &amp;rarr; condition || foo&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;condition ? false : foo &amp;rarr; !condition &amp;&amp; foo&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;condition ? foo : !foo &amp;rarr; condition == foo&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;condition ? true : false &amp;rarr; condition&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;a == b ? b : a &amp;rarr; a&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;result != null ? result : null &amp;rarr; result&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SwitchStatementWithConfusingDeclaration" defaultSeverity="WARNING" displayName="在不同 'switch' 分支中使用并声明的局部变量" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在 &lt;code&gt;switch&lt;/code&gt; 语句的一个分支中声明并在另一个分支中使用的局部变量。 此类声明可能格外令人困惑。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    switch(i) {
      case 2:
          int x = 0;
          break;
      case 3:
          x = 3;
          System.out.println(x);
          break;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;


&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Sass/SCSS" path=""><inspection shortName="SassScssResolvedByNameOnly" defaultSeverity="WEAK WARNING" displayName="缺少导入" enabled="false" language="CSS" pluginId="org.jetbrains.plugins.sass" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对另一个文件（但该文件未在当前文件中显式&lt;a href="https://sass-lang.com/documentation/at-rules/import"&gt;导入&lt;/a&gt;）中声明的变量、mixin 或函数的引用。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
* {
  margin: $var-in-other-file;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SassScssUnresolvedMixin" defaultSeverity="WARNING" displayName="未解析的 mixin" enabled="false" language="SCSS" pluginId="org.jetbrains.plugins.sass" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告未解析的 &lt;a href="https://sass-lang.com/documentation/at-rules/mixin"&gt;Sass/SCSS mixin&lt;/a&gt; 引用。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
* {
  @include unknown-mixin;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SassScssUnresolvedPlaceholderSelector" defaultSeverity="WARNING" displayName="未解析的占位符选择器" enabled="false" language="SCSS" pluginId="org.jetbrains.plugins.sass" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告未解析的 &lt;a href="https://sass-lang.com/documentation/variables"&gt;Sass/SCSS 占位符选择器&lt;/a&gt;引用。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
* {
  @extend %unknown-placeholder-selector;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SassScssUnresolvedVariable" defaultSeverity="WARNING" displayName="未解析的变量" enabled="false" language="SCSS" pluginId="org.jetbrains.plugins.sass" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告未解析的 &lt;a href="https://sass-lang.com/documentation/variables"&gt;Sass/SCSS 变量&lt;/a&gt;引用。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
* {
  margin: $unknown-var;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="方法签名" path="Scala"><inspection shortName="AccessorLikeMethodIsEmptyParen" defaultSeverity="WARNING" displayName="类似于访问器的方法包含空形参子句" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告具有类似访问器名称且形参子句为空的方法。&lt;/p&gt;
&lt;p&gt;符合访问器 &lt;a href="https://en.wikipedia.org/wiki/JavaBean"&gt;JavaBean&lt;/a&gt; 命名协定的方法预计不会有&lt;a href="https://en.wikipedia.org/wiki/Side_effect_(computer_science)"&gt;副作用&lt;/a&gt;。
    这些方法的推荐约定是在没有形参时使用无形参方法。&lt;/p&gt;
&lt;p&gt;该约定促进了&lt;a href="https://en.wikipedia.org/wiki/Uniform_access_principle"&gt;统一访问原则&lt;/a&gt;，即客户端代码不应受到将特性实现为字段或方法的决定的影响。&lt;/p&gt;
&lt;p&gt;该快速修复会移除空形参子句。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  trait Test {
    def hasProperty(): Boolean
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  trait Test {
    def hasProperty: Boolean
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;此检查将不报告重写其他成员的方法。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TypedParameterWithoutParen" defaultSeverity="INFORMATION" displayName="函数文字中无圆括号的类型化形参" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告未被圆括号包围的函数文字形参。&lt;/p&gt;

&lt;p&gt;在 Scala 3 中，只有一个形参的函数文字不能省略形参周围的圆括号。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  call { a: Int =&gt; a }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  call { (a: Int) =&gt; a }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JavaMutatorMethodAccessedAsParameterless" defaultSeverity="WARNING" displayName="Java 转变器方法作为无形参访问" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告对具有类似转变器名称而没有实参子句的方法的调用。&lt;/p&gt;
&lt;p&gt;Scala 允许在没有实参子句的情况下调用无形参 Java 方法。
    这主要是为了允许 Scala 代码以与 Scala 访问器方法相同的方式使用无形参 Java 访问器方法。
    即，不使用任何实参子句并遵守&lt;a href="https://en.wikipedia.org/wiki/Uniform_access_principle"&gt;统一访问原则&lt;/a&gt;，也就是说客户端代码不应受到将特性实现为字段或方法的决定的影响。&lt;/p&gt;

&lt;p&gt;但是，对于具有&lt;a href="https://en.wikipedia.org/wiki/Side_effect_(computer_science)"&gt;副作用&lt;/a&gt;的方法，通常使用空实参子句。&lt;/p&gt;

&lt;p&gt;该快速修复会添加一个空实参子句。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  val stringBuilder = new java.util.ArrayList[String]
  stringBuilder.clear
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  val stringBuilder = new java.util.ArrayList[String]
  stringBuilder.clear()
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MutatorLikeMethodIsParameterless" defaultSeverity="WARNING" displayName="类似于转变器的命名方法无形参" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告具有类似转变器名称且没有形参子句的方法。&lt;/p&gt;

&lt;p&gt;对于具有&lt;a href="https://en.wikipedia.org/wiki/Side_effect_(computer_science)"&gt;副作用&lt;/a&gt;的方法，通常有一个空形参子句来表明它不仅仅是一个访问器方法。&lt;/p&gt;

&lt;p&gt;该快速修复会添加一个空形参子句。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  trait Test {
    def updateAll: Boolean
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  trait Test {
    def updateAll(): Boolean
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="OverrideAbstractMember" defaultSeverity="INFORMATION" displayName="无 override 关键字的抽象方法实现" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告重写 abstract 成员但没有 override 修饰符的函数。&lt;/p&gt;
&lt;p&gt;Scala 不要求开发者对实现 abstract 成员的方法使用 &lt;code&gt;override&lt;/code&gt;。
    尽管如此，最好用 &lt;code&gt;override&lt;/code&gt; 标记此类方法，以便在重写关系被损坏时（例如，通过后续重构）由编译器通知。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  trait Base {
    def fun(): Int
  }

  class Impl extends Base {
    def fun(): Int = 42
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  trait Base {
    def fun(): Int
  }

  class Impl extends Base {
    override def fun(): Int = 42
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JavaAccessorMethodOverriddenAsEmptyParen" defaultSeverity="WARNING" displayName="使用空实参子句重写的 Java 访问器方法" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告具有重写 Java 访问器方法的空形参子句的方法。&lt;/p&gt;

&lt;p&gt;符合访问器 &lt;a href="https://en.wikipedia.org/wiki/JavaBean"&gt;JavaBean&lt;/a&gt; 命名协定的方法预计不会有&lt;a href="https://en.wikipedia.org/wiki/Side_effect_(computer_science)"&gt;副作用&lt;/a&gt;。
    推荐的约定是，在没有形参且方法没有副作用时使用无形参方法。
    该约定促进了&lt;a href="https://en.wikipedia.org/wiki/Uniform_access_principle"&gt;统一访问原则&lt;/a&gt;，即客户端代码不应受到将特性实现为字段或方法的决定的影响。&lt;/p&gt;

&lt;p&gt;问题是 Java 没有实现统一访问原则，不允许没有形参子句的方法。
    为了填补这一空白，Scala 允许您使用没有形参子句的方法来重写带有空形参子句的方法。&lt;/p&gt;

&lt;p&gt;该快速修复会移除空形参子句。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class TestException extends Exception {
    override def getMessage(): String = ???
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class TestException extends Exception {
    override def getMessage: String = ???
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ParameterlessMemberOverriddenAsEmptyParen" defaultSeverity="WARNING" displayName="无形参 Scala 成员作为空括号重写" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告具有一个空形参子句且重写没有形参子句的方法的方法。&lt;/p&gt;

&lt;p&gt;推荐的约定是，只要没有形参并且该方法没有&lt;a href="https://en.wikipedia.org/wiki/Side_effect_(computer_science)"&gt;副作用&lt;/a&gt;，就使用没有形参子句的方法。&lt;/p&gt;

&lt;p&gt;该约定促进了&lt;a href="https://en.wikipedia.org/wiki/Uniform_access_principle"&gt;统一访问原则&lt;/a&gt;，即客户端代码不应受到将特性实现为字段或方法的决定的影响。&lt;/p&gt;

&lt;p&gt;根据&lt;a href="https://en.wikipedia.org/wiki/Liskov_substitution_principle"&gt;里氏替换原则&lt;/a&gt;，当被重写的方法没有形参子句时，重写方法也必须被声明为没有副作用的方法。&lt;/p&gt;

&lt;p&gt;该快速修复会移除空形参子句。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  trait Base { def isOk: Boolean }

  class Impl extends Base {
    override def isOk(): Boolean = ???
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  trait Base { def isOk: Boolean }

  class Impl extends Base {
    override def isOk: Boolean = ???
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ProcedureDeclaration" defaultSeverity="WARNING" displayName="方法声明中的过程语法" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;使用过程语法报告方法声明。&lt;/p&gt;
&lt;p&gt;不建议开发者对方法使用类似过程的语法。
    它将在 Scala 3 中被移除，因为它不一致并且可能导致错误。&lt;/p&gt;
&lt;p&gt;该快速修复会将声明从过程语法转换为函数语法。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  trait Test {
    def method()
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  trait Test {
    def method(): Unit
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;em&gt;提示&lt;/em&gt;：您可以使用“通过名称分析/运行检查”(Ctrl+Alt+Shift+I) 将此检查应用于整个项目。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnitMethodIsParameterless" defaultSeverity="WARNING" displayName="Unit 结果类型的方法无形参" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告结果类型为 &lt;code&gt;Unit&lt;/code&gt; 且没有形参子句的方法。&lt;/p&gt;
&lt;p&gt;结果类型为 &lt;code&gt;Unit&lt;/code&gt; 的方法仅针对它们的&lt;a href="https://en.wikipedia.org/wiki/Side_effect_(computer_science)"&gt;副作用&lt;/a&gt;执行，并且按照约定，具有副作用的方法至少有一个（空）形参子句。
    &lt;/p&gt;
&lt;p&gt;该快速修复会添加一个空形参子句。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  def test: Unit = ()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  def test(): Unit = ()
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AccessorLikeMethodIsUnit" defaultSeverity="WARNING" displayName="类似于访问器的方法包含 Unit 结果类型" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告具有类似访问器名称且结果类型为 &lt;code&gt;Unit&lt;/code&gt; 的方法。&lt;/p&gt;
&lt;p&gt;符合访问器 &lt;a href="https://en.wikipedia.org/wiki/JavaBean"&gt;JavaBean&lt;/a&gt; 命名协定的方法预计不会有&lt;a href="https://en.wikipedia.org/wiki/Side_effect_(computer_science)"&gt;副作用&lt;/a&gt;。 然而，结果类型为 &lt;code&gt;Unit&lt;/code&gt; 的方法仅针对它们的副作用而执行。&lt;/p&gt;
&lt;p&gt;这表明该方法应该导致非 &lt;code&gt;Unit&lt;/code&gt; 类型或重命名以更好地反映副作用。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  trait Test {
    def getTarget(): Unit
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;此检查将不报告重写其他成员的方法。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ProcedureDefinition" defaultSeverity="WARNING" displayName="方法定义中的过程语法" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;使用过程语法报告方法定义。&lt;/p&gt;
&lt;p&gt;不建议开发者对方法使用类似过程的语法。
  它将在 Scala 3 中被移除，因为它不一致并且可能导致错误。&lt;/p&gt;
&lt;p&gt;该快速修复会将定义从过程语法转换为函数语法。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Test {
    def method() { }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Test {
    def method(): Unit = { }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;em&gt;提示&lt;/em&gt;：您可以使用“通过名称分析/运行检查”(Ctrl+Alt+Shift+I) 将此检查应用于整个项目。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JavaMutatorMethodOverriddenAsParameterless" defaultSeverity="WARNING" displayName="Java 转变器方法作为无形参重写" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告没有形参子句并使用类似转变器的名称重写 Java 方法的方法。&lt;/p&gt;
&lt;p&gt;Scala 允许重写没有形参子句的无形参 Java 方法。
    这主要是为了允许 Scala 代码以与 Scala 访问器方法相同的方式重写 Java 访问器方法。
    即，不使用任何形参子句并遵守&lt;a href="https://en.wikipedia.org/wiki/Uniform_access_principle"&gt;统一访问原则&lt;/a&gt;，也就是说客户端代码不应受到将特性实现为字段或方法的决定的影响。&lt;/p&gt;

&lt;p&gt;但是，对于具有&lt;a href="https://en.wikipedia.org/wiki/Side_effect_(computer_science)"&gt;副作用&lt;/a&gt;的方法，通常有一个空形参子句。
    这将符合&lt;a href="https://en.wikipedia.org/wiki/Liskov_substitution_principle"&gt;里氏替换原则&lt;/a&gt;，即当被重写的方法有副作用时，重写方法也必须被声明为具有副作用的方法。&lt;/p&gt;

&lt;p&gt;该快速修复会添加一个空形参子句。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  import java.util

  class Test extends util.ArrayList[String] {
    override def clear: Unit = ???
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  import java.util

  class Test extends util.ArrayList[String] {
    override def clear(): Unit = ???
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JavaAccessorEmptyParenCall" defaultSeverity="WARNING" displayName="使用空实参子句调用的 Java 访问器方法" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告对带有空实参子句的 Java 访问器方法的调用。&lt;/p&gt;

&lt;p&gt;符合访问器 &lt;a href="https://en.wikipedia.org/wiki/JavaBean"&gt;JavaBean&lt;/a&gt; 命名协定的方法预计不会有&lt;a href="https://en.wikipedia.org/wiki/Side_effect_(computer_science)"&gt;副作用&lt;/a&gt;。
    推荐的约定是，在没有形参且方法没有副作用时使用无形参方法。
    该约定促进了&lt;a href="https://en.wikipedia.org/wiki/Uniform_access_principle"&gt;统一访问原则&lt;/a&gt;，即客户端代码不应受到将特性实现为字段或方法的决定的影响。&lt;/p&gt;

&lt;p&gt;问题是 Java 没有实现统一访问原则。
    为了填补这一空白，Scala 允许您为不带实参的 Java 方法调用省略空圆括号。&lt;/p&gt;

&lt;p&gt;该快速修复会移除空实参子句。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  "test".getClass()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  "test".getClass
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ApparentResultTypeRefinement" defaultSeverity="WARNING" displayName="表观结果类型细化；是否缺少赋值?" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告结果类型和函数体之间缺少 &lt;code&gt;=&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;当用作函数的结果类型时，不能细化类型。
    但是，当结果类型和函数体之间缺少 &lt;code&gt;=&lt;/code&gt; 时，它可能看起来很精致。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  def test(): T {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  def test(): T = {}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="EmptyParenMethodOverriddenAsParameterless" defaultSeverity="WARNING" displayName="空括号 Scala 方法作为无形参重写" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告没有形参子句且重写带有空形参子句的方法的方法。&lt;/p&gt;

&lt;p&gt;如果一个方法有&lt;a href="https://en.wikipedia.org/wiki/Side_effect_(computer_science)"&gt;副作用&lt;/a&gt;，则在方法中使用圆括号是一个常见的约定。
    根据&lt;a href="https://en.wikipedia.org/wiki/Liskov_substitution_principle"&gt;里氏替换原则&lt;/a&gt;，当被重写的方法有形参子句时，表明有副作用，重写方法也必须被声明为有副作用的方法。&lt;/p&gt;

&lt;p&gt;该快速修复会添加一个空形参子句。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Base {
    def x() = 1
  }
  class Impl extends Base {
    override def x = 2
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Base {
    def x() = 1
  }
  class Impl extends Base {
    override def x() = 2
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="EmptyParenMethodAccessedAsParameterless" defaultSeverity="WARNING" displayName="空括号方法作为无形参访问" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告没有实参子句且引用带有空形参子句的方法的方法。&lt;/p&gt;

&lt;p&gt;如果一个方法有&lt;a href="https://en.wikipedia.org/wiki/Side_effect_(computer_science)"&gt;副作用&lt;/a&gt;，则在方法中使用圆括号是一个常见的约定。
    虽然可以在方法调用中省略实参子句（以适应 Java 的&lt;a href="https://en.wikipedia.org/wiki/Uniform_access_principle"&gt;统一访问原则&lt;/a&gt;），但建议用户在调用的方法表示多个属性时添加一个空实参子句。&lt;/p&gt;

&lt;p&gt;该快速修复会添加一个空实参子句。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  def test(): Int = ???

  test
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  def test(): Int = ???

  test()
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="函数指标" path="JavaScript and TypeScript"><inspection shortName="FunctionWithMultipleReturnPointsJS" defaultSeverity="WARNING" displayName="函数具有多个返回点" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告具有多个返回点的函数。
此类函数难以理解和维护。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ThreeNegationsPerFunctionJS" defaultSeverity="WARNING" displayName="函数包含三个以上的否定" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告具有三项或更多项否定运算（&lt;code&gt;!&lt;/code&gt; 或 &lt;code&gt;!=&lt;/code&gt;）的函数。
此类函数可能造成不必要的混淆。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CyclomaticComplexityJS" defaultSeverity="WARNING" displayName="函数过于复杂" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告函数中分支点太多的函数（循环复杂度太高）。 此类函数可能令人困惑，也难以测试。
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用下面提供的字段可指定函数的最大可接受循环复杂度。

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NestingDepthJS" defaultSeverity="WARNING" displayName="函数过度嵌套" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告其函数体中包含的语句在其他语句中嵌套过深的函数。
此类函数可能令人困惑，并且表明可能有必要重构。
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用下面提供的字段指定函数中可接受的最大嵌套深度。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StatementsPerFunctionJS" defaultSeverity="WARNING" displayName="函数过长" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告过长的函数。
函数长度通过函数中非空语句的数量来计算。
太长的函数容易出错，而且难以测试。
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用下面的字段可指定函数中的可接受最大语句数量。

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FunctionWithMultipleLoopsJS" defaultSeverity="WARNING" displayName="函数具有多个循环" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告具有多个循环语句的函数。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ParametersPerFunctionJS" defaultSeverity="WARNING" displayName="函数的参数过多" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告形参过多的函数。
此类函数通常表明设计有问题。
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用下面的字段可指定函数的最大可接受形参数量。

&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Android Lint: Correctness" path=""><inspection shortName="AndroidLintWatchFaceForAndroidX" defaultSeverity="WARNING" displayName="AndroidX watch faces must use action WATCH_FACE_EDITOR" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;AndroidX watch faces must use action &lt;code&gt;WATCH_FACE_EDITOR&lt;/code&gt;&lt;br&gt;&lt;br&gt;If the package depends on &lt;code&gt;androidx.wear:wear-watchface&lt;/code&gt;, and an AndroidX watch face declares the &lt;code&gt;wearableConfigurationAction&lt;/code&gt; metadata, its value should be &lt;code&gt;androidx.wear.watchface.editor.action.WATCH_FACE_EDITOR&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: WatchFaceForAndroidX&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/training/wearables/watch-faces/configuration"&gt;https://developer.android.com/training/wearables/watch-faces/configuration&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintAppLinksAutoVerify" defaultSeverity="ERROR" displayName="App Links Auto Verification Failure" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;App Links Auto Verification Failure&lt;br&gt;&lt;br&gt;Ensures that app links are correctly set and associated with website.&lt;br&gt;&lt;br&gt;Issue id: AppLinksAutoVerify&lt;br&gt;&lt;br&gt;&lt;a href="https://g.co/appindexing/applinks"&gt;https://g.co/appindexing/applinks&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUsesMinSdkAttributes" defaultSeverity="WARNING" displayName="Minimum SDK and target SDK attributes not defined" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Minimum SDK and target SDK attributes not defined&lt;br&gt;&lt;br&gt;The manifest should contain a &lt;code&gt;&amp;lt;uses-sdk&gt;&lt;/code&gt; element which defines the minimum API Level required for the application to run, as well as the target version (the highest API level you have tested the version for).&lt;br&gt;&lt;br&gt;Issue id: UsesMinSdkAttributes&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/topics/manifest/uses-sdk-element.html"&gt;https://developer.android.com/guide/topics/manifest/uses-sdk-element.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintWebViewApiAvailability" defaultSeverity="WARNING" displayName="WebView API Availability" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;WebView API Availability&lt;br&gt;&lt;br&gt;The &lt;code&gt;androidx.webkit&lt;/code&gt; library is a static library you can add to your Android application allowing you to use new APIs on older platform versions, targeting more devices.&lt;br&gt;&lt;br&gt;Issue id: WebViewApiAvailability&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/reference/androidx/webkit/package-summary"&gt;https://developer.android.com/reference/androidx/webkit/package-summary&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintDuplicateIds" defaultSeverity="ERROR" displayName="Duplicate ids within a single layout" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Duplicate ids within a single layout&lt;br&gt;&lt;br&gt;Within a layout, id's should be unique since otherwise &lt;code&gt;findViewById()&lt;/code&gt; can return an unexpected view.&lt;br&gt;&lt;br&gt;Issue id: DuplicateIds&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUnusedQuantity" defaultSeverity="WARNING" displayName="Unused quantity translations" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Unused quantity translations&lt;br&gt;&lt;br&gt;Android defines a number of different quantity strings, such as &lt;code&gt;zero&lt;/code&gt;, &lt;code&gt;one&lt;/code&gt;, &lt;code&gt;few&lt;/code&gt; and &lt;code&gt;many&lt;/code&gt;. However, many languages do not distinguish grammatically between all these different quantities.&lt;br/&gt;
&lt;br/&gt;
This lint check looks at the quantity strings defined for each translation and flags any quantity strings that are unused (because the language does not make that quantity distinction, and Android will therefore not look it up).&lt;br/&gt;
&lt;br/&gt;
For example, in Chinese, only the &lt;code&gt;other&lt;/code&gt; quantity is used, so even if you provide translations for &lt;code&gt;zero&lt;/code&gt; and &lt;code&gt;one&lt;/code&gt;, these strings will &lt;b&gt;not&lt;/b&gt; be returned when &lt;code&gt;getQuantityString()&lt;/code&gt; is called, even with &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: UnusedQuantity&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/topics/resources/string-resource.html#Plurals"&gt;https://developer.android.com/guide/topics/resources/string-resource.html#Plurals&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintResAuto" defaultSeverity="ERROR" displayName="Hardcoded Package in Namespace" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Hardcoded Package in Namespace&lt;br&gt;&lt;br&gt;In Gradle projects, the actual package used in the final APK can vary; for example,you can add a &lt;code&gt;.debug&lt;/code&gt; package suffix in one version and not the other. Therefore, you should &lt;b&gt;not&lt;/b&gt; hardcode the application package in the resource; instead, use the special namespace &lt;code&gt;http://schemas.android.com/apk/res-auto&lt;/code&gt; which will cause the tools to figure out the right namespace for the resource regardless of the actual package used during the build.&lt;br&gt;&lt;br&gt;Issue id: ResAuto&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintValidFragment" defaultSeverity="ERROR" displayName="Fragment not instantiatable" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Fragment not instantiatable&lt;br&gt;&lt;br&gt;From the Fragment documentation:&lt;br/&gt;
&lt;b&gt;Every&lt;/b&gt; fragment must have an empty constructor, so it can be instantiated when restoring its activity's state. It is strongly recommended that subclasses do not have other constructors with parameters, since these constructors will not be called when the fragment is re-instantiated; instead, arguments can be supplied by the caller with &lt;code&gt;setArguments(Bundle)&lt;/code&gt; and later retrieved by the Fragment with &lt;code&gt;getArguments()&lt;/code&gt;.&lt;br/&gt;
&lt;br/&gt;
Note that this is no longer true when you are using &lt;code&gt;androidx.fragment.app.Fragment&lt;/code&gt;; with the &lt;code&gt;FragmentFactory&lt;/code&gt; you can supply any arguments you want (as of version androidx version 1.1).&lt;br&gt;&lt;br&gt;Issue id: ValidFragment&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/reference/android/app/Fragment.html#Fragment()"&gt;https://developer.android.com/reference/android/app/Fragment.html#Fragment()&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintAccidentalOctal" defaultSeverity="ERROR" displayName="Accidental Octal" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Accidental Octal&lt;br&gt;&lt;br&gt;In Groovy, an integer literal that starts with a leading 0 will be interpreted as an octal number. That is usually (always?) an accident and can lead to subtle bugs, for example when used in the &lt;code&gt;versionCode&lt;/code&gt; of an app.&lt;br&gt;&lt;br&gt;Issue id: AccidentalOctal&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintStringEscaping" defaultSeverity="ERROR" displayName="Invalid string escapes" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Invalid string escapes&lt;br&gt;&lt;br&gt;Apostrophes (') must always be escaped (with a \\), unless they appear in a string which is itself escaped in double quotes (").&lt;br&gt;&lt;br&gt;Issue id: StringEscaping&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintGestureBackNavigation" defaultSeverity="WARNING" displayName="Usage of KeyEvent.KEYCODE_BACK" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Usage of KeyEvent.KEYCODE_BACK&lt;br&gt;&lt;br&gt;Starting in Android 13 (API 33+), the handling of back events is moving to an ahead-of-time callback model. Use &lt;code&gt;OnBackInvokedDispatcher.registerOnBackInvokedCallback(...)&lt;/code&gt; and &lt;code&gt;onBackInvokedCallback&lt;/code&gt; or AndroidX's &lt;code&gt;OnBackPressedDispatcher&lt;/code&gt; with an implemented &lt;code&gt;onBackPressedCallback&lt;/code&gt; to handle back gestures and key presses.&lt;br&gt;&lt;br&gt;Issue id: GestureBackNavigation&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/about/versions/13/features/predictive-back-gesture"&gt;https://developer.android.com/about/versions/13/features/predictive-back-gesture&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintAppCompatMethod" defaultSeverity="WARNING" displayName="Using Wrong AppCompat Method" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using Wrong AppCompat Method&lt;br&gt;&lt;br&gt;When using the appcompat library, there are some methods you should be calling instead of the normal ones; for example, &lt;code&gt;getSupportActionBar()&lt;/code&gt; instead of &lt;code&gt;getActionBar()&lt;/code&gt;. This lint check looks for calls to the wrong method.&lt;br&gt;&lt;br&gt;Issue id: AppCompatMethod&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/topic/libraries/support-library/"&gt;https://developer.android.com/topic/libraries/support-library/&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintSupportAnnotationUsage" defaultSeverity="ERROR" displayName="Incorrect support annotation usage" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Incorrect support annotation usage&lt;br&gt;&lt;br&gt;This lint check makes sure that the support annotations (such as &lt;code&gt;@IntDef&lt;/code&gt; and &lt;code&gt;@ColorInt&lt;/code&gt;) are used correctly. For example, it's an error to specify an &lt;code&gt;@IntRange&lt;/code&gt; where the &lt;code&gt;from&lt;/code&gt; value is higher than the &lt;code&gt;to&lt;/code&gt; value.&lt;br&gt;&lt;br&gt;Issue id: SupportAnnotationUsage&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintNotificationPermission" defaultSeverity="ERROR" displayName="Notifications Without Permission" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Notifications Without Permission&lt;br&gt;&lt;br&gt;When targeting Android 13 and higher, posting permissions requires holding the runtime permission &lt;code&gt;android.permission.POST_NOTIFICATIONS&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: NotificationPermission&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMissingId" defaultSeverity="WARNING" displayName="Fragments should specify an id or tag" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Fragments should specify an &lt;code&gt;id&lt;/code&gt; or &lt;code&gt;tag&lt;/code&gt;&lt;br&gt;&lt;br&gt;If you do not specify an &lt;code&gt;android:id&lt;/code&gt; or an &lt;code&gt;android:tag&lt;/code&gt; attribute on a &lt;code&gt;&amp;lt;fragment&gt;&lt;/code&gt; element, then if the activity is restarted (for example for an orientation rotation) you may lose state. From the fragment documentation:&lt;br/&gt;
&lt;br/&gt;
"Each fragment requires a unique identifier that the system can use to restore the fragment if the activity is restarted (and which you can use to capture the fragment to perform transactions, such as remove it).&lt;br/&gt;
&lt;br/&gt;
* Supply the &lt;code&gt;android:id&lt;/code&gt; attribute with a unique ID.&lt;br/&gt;
* Supply the &lt;code&gt;android:tag&lt;/code&gt; attribute with a unique string.&lt;br/&gt;
&lt;br/&gt;
If you provide neither of the previous two, the system uses the ID of the container view.&lt;br&gt;&lt;br&gt;Issue id: MissingId&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/components/fragments.html"&gt;https://developer.android.com/guide/components/fragments.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintLibraryCustomView" defaultSeverity="ERROR" displayName="Custom views in libraries should use res-auto-namespace" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Custom views in libraries should use res-auto-namespace&lt;br&gt;&lt;br&gt;When using a custom view with custom attributes in a library project, the layout must use the special namespace &lt;a href="http://schemas.android.com/apk/res-auto"&gt;http://schemas.android.com/apk/res-auto&lt;/a&gt; instead of a URI which includes the library project's own package. This will be used to automatically adjust the namespace of the attributes when the library resources are merged into the application project.&lt;br&gt;&lt;br&gt;Issue id: LibraryCustomView&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUnknownId" defaultSeverity="ERROR" displayName="Reference to an unknown id" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Reference to an unknown id&lt;br&gt;&lt;br&gt;The &lt;code&gt;@+id/&lt;/code&gt; syntax refers to an existing id, or creates a new one if it has not already been defined elsewhere. However, this means that if you have a typo in your reference, or if the referred view no longer exists, you do not get a warning since the id will be created on demand. This check catches errors where you have renamed an id without updating all of the references to it.&lt;br&gt;&lt;br&gt;Issue id: UnknownId&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintInflateParams" defaultSeverity="WARNING" displayName="Layout Inflation without a Parent" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Layout Inflation without a Parent&lt;br&gt;&lt;br&gt;When inflating a layout, avoid passing in null as the parent view, since otherwise any layout parameters on the root of the inflated layout will be ignored.&lt;br&gt;&lt;br&gt;Issue id: InflateParams&lt;br&gt;&lt;br&gt;&lt;a href="https://www.bignerdranch.com/blog/understanding-androids-layoutinflater-inflate/"&gt;https://www.bignerdranch.com/blog/understanding-androids-layoutinflater-inflate/&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMissingPermission" defaultSeverity="ERROR" displayName="Missing Permissions" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing Permissions&lt;br&gt;&lt;br&gt;This check scans through your code and libraries and looks at the APIs being used, and checks this against the set of permissions required to access those APIs. If the code using those APIs is called at runtime, then the program will crash.&lt;br/&gt;
&lt;br/&gt;
Furthermore, for permissions that are revocable (with &lt;code&gt;targetSdkVersion&lt;/code&gt; 23), client code must also be prepared to handle the calls throwing an exception if the user rejects the request for permission at runtime.&lt;br&gt;&lt;br&gt;Issue id: MissingPermission&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintPermissionImpliesUnsupportedHardware" defaultSeverity="WARNING" displayName="Permission Implies Unsupported Hardware" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Permission Implies Unsupported Hardware&lt;br&gt;&lt;br&gt;The &lt;code&gt;&amp;lt;uses-permission&gt;&lt;/code&gt; element should not require a permission that implies an unsupported TV hardware feature. Google Play assumes that certain hardware related permissions indicate that the underlying hardware features are required by default. To fix the issue, consider declaring the corresponding &lt;code&gt;uses-feature&lt;/code&gt; element with &lt;code&gt;required="false"&lt;/code&gt; attribute.&lt;br&gt;&lt;br&gt;Issue id: PermissionImpliesUnsupportedHardware&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/topics/manifest/uses-feature-element.html#permissions"&gt;https://developer.android.com/guide/topics/manifest/uses-feature-element.html#permissions&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintInOrMmUsage" defaultSeverity="WARNING" displayName="Using mm or in dimensions" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using &lt;code&gt;mm&lt;/code&gt; or &lt;code&gt;in&lt;/code&gt; dimensions&lt;br&gt;&lt;br&gt;Avoid using &lt;code&gt;mm&lt;/code&gt; (millimeters) or &lt;code&gt;in&lt;/code&gt; (inches) as the unit for dimensions.&lt;br/&gt;
&lt;br/&gt;
While it should work in principle, unfortunately many devices do not report the correct true physical density, which means that the dimension calculations won't work correctly. You are better off using &lt;code&gt;dp&lt;/code&gt; (and for font sizes, &lt;code&gt;sp&lt;/code&gt;).&lt;br&gt;&lt;br&gt;Issue id: InOrMmUsage&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintSuspiciousIndentation" defaultSeverity="ERROR" displayName="Suspicious indentation" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Suspicious indentation&lt;br&gt;&lt;br&gt;This check looks for cases where the indentation suggests a grouping that isn't actually there in the code. A common example of this would be something like
&lt;pre&gt;
if (column &gt; width)
    line++
    column = 0
&lt;/pre&gt;
Here, the &lt;code&gt;column = 0&lt;/code&gt; line will be executed every single time, not just if the condition is true.&lt;br&gt;&lt;br&gt;Issue id: SuspiciousIndentation&lt;br&gt;&lt;br&gt;Available options:&lt;br/&gt;
&lt;br/&gt;
&lt;b&gt;always-run&lt;/b&gt; (default is false):&lt;br/&gt;
Whether this check should be included while editing.&lt;br/&gt;
&lt;br/&gt;
While you're editing, it's common to have a temporary situation where you have suspicious indentation scenarios -- e.g. you start typing an &lt;code&gt;if&lt;/code&gt; statement on the line above something you want to make conditional, and you haven't indented it yet. It can be distracting and misleading to suddenly have both statements light up as errors. Therefore, lint will avoid including this check when running on the fly in the editor, unless it looks like the file has not been recently edited. With this option, you can turn it on in all cases.&lt;br/&gt;
&lt;br/&gt;
To configure this option, use a &lt;code&gt;lint.xml&lt;/code&gt; file with an &amp;lt;option&gt; like this:&lt;br/&gt;

&lt;pre&gt;
&amp;lt;lint&gt;
    &amp;lt;issue id="SuspiciousIndentation"&gt;
        &amp;lt;option name="always-run" value="false" /&gt;
    &amp;lt;/issue&gt;
&amp;lt;/lint&gt;
&lt;/pre&gt;
&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintScrollViewCount" defaultSeverity="WARNING" displayName="ScrollView can have only one child" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;&lt;code&gt;ScrollView&lt;/code&gt; can have only one child&lt;br&gt;&lt;br&gt;A &lt;code&gt;ScrollView&lt;/code&gt; can only have one child widget. If you want more children, wrap them in a container layout.&lt;br&gt;&lt;br&gt;Issue id: ScrollViewCount&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintProguard" defaultSeverity="ERROR" displayName="Using obsolete ProGuard configuration" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using obsolete ProGuard configuration&lt;br&gt;&lt;br&gt;Using &lt;code&gt;-keepclasseswithmembernames&lt;/code&gt; in a proguard config file is not correct; it can cause some symbols to be renamed which should not be.&lt;br/&gt;
&lt;br/&gt;
Earlier versions of ADT used to create proguard.cfg files with the wrong format. Instead of &lt;code&gt;-keepclasseswithmembernames&lt;/code&gt; use &lt;code&gt;-keepclasseswithmembers&lt;/code&gt;, since the old flags also implies "allow shrinking" which means symbols only referred to from XML and not Java (such as possibly CustomViews) can get deleted.&lt;br&gt;&lt;br&gt;Issue id: Proguard&lt;br&gt;&lt;br&gt;&lt;a href="https://issuetracker.google.com/36928077"&gt;https://issuetracker.google.com/36928077&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintGradleCompatible" defaultSeverity="ERROR" displayName="Incompatible Gradle Versions" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Incompatible Gradle Versions&lt;br&gt;&lt;br&gt;There are some combinations of libraries, or tools and libraries, that are incompatible, or can lead to bugs. One such incompatibility is compiling with a version of the Android support libraries that is not the latest version (or in particular, a version lower than your &lt;code&gt;targetSdkVersion&lt;/code&gt;).&lt;br&gt;&lt;br&gt;Issue id: GradleCompatible&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintManifestResource" defaultSeverity="ERROR" displayName="Manifest Resource References" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Manifest Resource References&lt;br&gt;&lt;br&gt;Elements in the manifest can reference resources, but those resources cannot vary across configurations (except as a special case, by version, and except for a few specific package attributes such as the application title and icon).&lt;br&gt;&lt;br&gt;Issue id: ManifestResource&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintNotConstructor" defaultSeverity="WARNING" displayName="Not a Constructor" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Not a Constructor&lt;br&gt;&lt;br&gt;This check catches methods that look like they were intended to be constructors, but aren't.&lt;br&gt;&lt;br&gt;Issue id: NotConstructor&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintInvalidUsesTagAttribute" defaultSeverity="ERROR" displayName="Invalid name attribute for uses element" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Invalid &lt;code&gt;name&lt;/code&gt; attribute for &lt;code&gt;uses&lt;/code&gt; element&lt;br&gt;&lt;br&gt;The &amp;lt;uses&gt; element in &lt;code&gt;&amp;lt;automotiveApp&gt;&lt;/code&gt; should contain a valid value for the &lt;code&gt;name&lt;/code&gt; attribute. Valid values are &lt;code&gt;media&lt;/code&gt;, &lt;code&gt;notification&lt;/code&gt;, or &lt;code&gt;sms&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: InvalidUsesTagAttribute&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/training/auto/start/index.html#auto-metadata"&gt;https://developer.android.com/training/auto/start/index.html#auto-metadata&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintWrongCase" defaultSeverity="ERROR" displayName="Wrong case for view tag" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Wrong case for view tag&lt;br&gt;&lt;br&gt;Most layout tags, such as &lt;code&gt;&amp;lt;Button&gt;&lt;/code&gt;, refer to actual view classes and are therefore capitalized. However, there are exceptions such as &lt;code&gt;&amp;lt;fragment&gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;include&gt;&lt;/code&gt;. This lint check looks for incorrect capitalizations.&lt;br&gt;&lt;br&gt;Issue id: WrongCase&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/components/fragments.html"&gt;https://developer.android.com/guide/components/fragments.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintRemoteViewLayout" defaultSeverity="ERROR" displayName="Unsupported View in RemoteView" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Unsupported View in RemoteView&lt;br&gt;&lt;br&gt;In a &lt;code&gt;RemoteView&lt;/code&gt;, only some layouts and views are allowed.&lt;br&gt;&lt;br&gt;Issue id: RemoteViewLayout&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/reference/android/widget/RemoteViews"&gt;https://developer.android.com/reference/android/widget/RemoteViews&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintBrokenIterator" defaultSeverity="WARNING" displayName="Broken Iterator" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Broken Iterator&lt;br&gt;&lt;br&gt;&lt;b&gt;For LinkedHashMap:&lt;/b&gt;&lt;br/&gt;
&lt;br/&gt;
The spliterators returned by &lt;code&gt;LinkedHashMap&lt;/code&gt; in Android Nougat (API levels 24 and 25) use the wrong order (inconsistent with the iterators, which use the correct order), despite reporting &lt;code&gt;Spliterator.ORDERED&lt;/code&gt;. You may use the following code fragments to obtain a correctly ordered &lt;code&gt;Spliterator&lt;/code&gt; on API level 24 and 25:&lt;br/&gt;
&lt;br/&gt;
For a Collection view &lt;code&gt;c = lhm.entrySet()&lt;/code&gt;, &lt;code&gt;c = lhm.keySet()&lt;/code&gt; or &lt;code&gt;c = lhm.values()&lt;/code&gt;, use &lt;code&gt;java.util.Spliterators.spliterator(c, c.spliterator().characteristics())&lt;/code&gt; instead of &lt;code&gt;c.spliterator()&lt;/code&gt;.&lt;br/&gt;
&lt;br/&gt;
Instead of &lt;code&gt;c.stream()&lt;/code&gt; or &lt;code&gt;c.parallelStream()&lt;/code&gt;, use &lt;code&gt;java.util.stream.StreamSupport.stream(spliterator, false)&lt;/code&gt; to construct a (nonparallel) Stream from such a &lt;code&gt;Spliterator&lt;/code&gt;.&lt;br/&gt;
&lt;br/&gt;
&lt;b&gt;For Vector:&lt;/b&gt;&lt;br/&gt;
&lt;br/&gt;
The &lt;code&gt;listIterator()&lt;/code&gt; returned for a &lt;code&gt;Vector&lt;/code&gt; has a broken &lt;code&gt;add()&lt;/code&gt; implementation on Android N (API level 24). Consider switching to &lt;code&gt;ArrayList&lt;/code&gt; and if necessary adding synchronization.&lt;br&gt;&lt;br&gt;Issue id: BrokenIterator&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/reference/java/util/LinkedHashMap"&gt;https://developer.android.com/reference/java/util/LinkedHashMap&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintWearableBindListener" defaultSeverity="ERROR" displayName="Usage of Android Wear BIND_LISTENER is deprecated" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Usage of Android Wear BIND_LISTENER is deprecated&lt;br&gt;&lt;br&gt;BIND_LISTENER receives all Android Wear events whether the application needs them or not. This can be inefficient and cause applications to wake up unnecessarily. With Google Play Services 8.2.0 or later it is recommended to use a more efficient combination of manifest listeners and api-based live listeners filtered by action, path and/or path prefix.&lt;br&gt;&lt;br&gt;Issue id: WearableBindListener&lt;br&gt;&lt;br&gt;&lt;a href="https://android-developers.googleblog.com/2016/04/deprecation-of-bindlistener.html"&gt;https://android-developers.googleblog.com/2016/04/deprecation-of-bindlistener.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMotionLayoutInvalidSceneFileReference" defaultSeverity="ERROR" displayName="layoutDescription must specify a scene file" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;layoutDescription must specify a scene file&lt;br&gt;&lt;br&gt;A motion scene file specifies the animations used in a &lt;code&gt;MotionLayout&lt;/code&gt;. The &lt;code&gt;layoutDescription&lt;/code&gt; is required to specify a valid motion scene file.&lt;br&gt;&lt;br&gt;Issue id: MotionLayoutInvalidSceneFileReference&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintStateListReachable" defaultSeverity="WARNING" displayName="Unreachable state in a &lt;selector&gt;" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Unreachable state in a &lt;code&gt;&amp;lt;selector&gt;&lt;/code&gt;&lt;br&gt;&lt;br&gt;In a selector, only the last child in the state list should omit a state qualifier. If not, all subsequent items in the list will be ignored since the given item will match all.&lt;br&gt;&lt;br&gt;Issue id: StateListReachable&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUnsupportedTvHardware" defaultSeverity="ERROR" displayName="Unsupported TV Hardware Feature" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Unsupported TV Hardware Feature&lt;br&gt;&lt;br&gt;The &lt;code&gt;&amp;lt;uses-feature&gt;&lt;/code&gt; element should not require this unsupported TV hardware feature. Any uses-feature not explicitly marked with &lt;code&gt;required="false"&lt;/code&gt; is necessary on the device to be installed on. Ensure that any features that might prevent it from being installed on a TV device are reviewed and marked as not required in the manifest.&lt;br&gt;&lt;br&gt;Issue id: UnsupportedTvHardware&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/training/tv/start/hardware.html#unsupported-features"&gt;https://developer.android.com/training/tv/start/hardware.html#unsupported-features&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintNonResizeableActivity" defaultSeverity="WARNING" displayName="Activity is set to be non resizeable" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Activity is set to be non resizeable&lt;br&gt;&lt;br&gt;The &lt;code&gt;&amp;lt;activity&gt;&lt;/code&gt; element should be allowed to be resized to allow users to take advantage of the multi-window environments available on larger screen Android devices.&lt;br/&gt;
&lt;br/&gt;
To fix the issue, consider declaring the corresponding activity element with &lt;code&gt;resizableActivity="true"&lt;/code&gt; attribute.&lt;br&gt;&lt;br&gt;Issue id: NonResizeableActivity&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/topic/arc/window-management"&gt;https://developer.android.com/topic/arc/window-management&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintNotificationId0" defaultSeverity="ERROR" displayName="Notification Id is 0" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Notification Id is 0&lt;br&gt;&lt;br&gt;The notification id &lt;b&gt;cannot&lt;/b&gt; be 0; using 0 here can make the service not run in the foreground.&lt;br&gt;&lt;br&gt;Issue id: NotificationId0&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintNewApi" defaultSeverity="ERROR" displayName="Calling new methods on older versions" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Calling new methods on older versions&lt;br&gt;&lt;br&gt;This check scans through all the Android API calls in the application and warns about any calls that are not available on &lt;b&gt;all&lt;/b&gt; versions targeted by this application (according to its minimum SDK attribute in the manifest).&lt;br/&gt;
&lt;br/&gt;
If you really want to use this API and don't need to support older devices just set the &lt;code&gt;minSdkVersion&lt;/code&gt; in your &lt;code&gt;build.gradle&lt;/code&gt; or &lt;code&gt;AndroidManifest.xml&lt;/code&gt; files.&lt;br/&gt;
&lt;br/&gt;
If your code is &lt;b&gt;deliberately&lt;/b&gt; accessing newer APIs, and you have ensured (e.g. with conditional execution) that this code will only ever be called on a supported platform, then you can annotate your class or method with the &lt;code&gt;@TargetApi&lt;/code&gt; annotation specifying the local minimum SDK to apply, such as &lt;code&gt;@TargetApi(11)&lt;/code&gt;, such that this check considers 11 rather than your manifest file's minimum SDK as the required API level.&lt;br/&gt;
&lt;br/&gt;
If you are deliberately setting &lt;code&gt;android:&lt;/code&gt; attributes in style definitions, make sure you place this in a &lt;code&gt;values-v&lt;/code&gt;&lt;i&gt;NN&lt;/i&gt; folder in order to avoid running into runtime conflicts on certain devices where manufacturers have added custom attributes whose ids conflict with the new ones on later platforms.&lt;br/&gt;
&lt;br/&gt;
Similarly, you can use tools:targetApi="11" in an XML file to indicate that the element will only be inflated in an adequate context.&lt;br&gt;&lt;br&gt;Issue id: NewApi&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUnsupportedChromeOsHardware" defaultSeverity="ERROR" displayName="Unsupported Chrome OS Hardware Feature" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Unsupported Chrome OS Hardware Feature&lt;br&gt;&lt;br&gt;The &lt;code&gt;&amp;lt;uses-feature&gt;&lt;/code&gt; element should not require this unsupported Chrome OS hardware feature. Any uses-feature not explicitly marked with &lt;code&gt;required="false"&lt;/code&gt; is necessary on the device to be installed on. Ensure that any features that might prevent it from being installed on a Chrome OS device are reviewed and marked as not required in the manifest.&lt;br&gt;&lt;br&gt;Issue id: UnsupportedChromeOsHardware&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/topic/arc/manifest.html#incompat-entries"&gt;https://developer.android.com/topic/arc/manifest.html#incompat-entries&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintPluralsCandidate" defaultSeverity="WARNING" displayName="Potential Plurals" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Potential Plurals&lt;br&gt;&lt;br&gt;This lint check looks for potential errors in internationalization where you have translated a message which involves a quantity and it looks like other parts of the string may need grammatical changes.&lt;br/&gt;
&lt;br/&gt;
For example, rather than something like this:
&lt;pre&gt;
  &amp;lt;string name="try_again"&gt;Try again in %d seconds.&amp;lt;/string&gt;
&lt;/pre&gt;
you should be using a plural:
&lt;pre&gt;
   &amp;lt;plurals name="try_again"&gt;
        &amp;lt;item quantity="one"&gt;Try again in %d second&amp;lt;/item&gt;
        &amp;lt;item quantity="other"&gt;Try again in %d seconds&amp;lt;/item&gt;
    &amp;lt;/plurals&gt;
&lt;/pre&gt;
This will ensure that in other languages the right set of translations are provided for the different quantity classes.&lt;br/&gt;
&lt;br/&gt;
(This check depends on some heuristics, so it may not accurately determine whether a string really should be a quantity. You can use tools:ignore to filter out false positives.&lt;br&gt;&lt;br&gt;Issue id: PluralsCandidate&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/topics/resources/string-resource.html#Plurals"&gt;https://developer.android.com/guide/topics/resources/string-resource.html#Plurals&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintCommitTransaction" defaultSeverity="WARNING" displayName="Missing commit() calls" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing &lt;code&gt;commit()&lt;/code&gt; calls&lt;br&gt;&lt;br&gt;After creating a &lt;code&gt;FragmentTransaction&lt;/code&gt;, you typically need to commit it as well&lt;br&gt;&lt;br&gt;Issue id: CommitTransaction&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintIncludeLayoutParam" defaultSeverity="ERROR" displayName="Ignored layout params on include" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Ignored layout params on include&lt;br&gt;&lt;br&gt;Layout parameters specified on an &lt;code&gt;&amp;lt;include&gt;&lt;/code&gt; tag will only be used if you also override &lt;code&gt;layout_width&lt;/code&gt; and &lt;code&gt;layout_height&lt;/code&gt; on the &lt;code&gt;&amp;lt;include&gt;&lt;/code&gt; tag; otherwise they will be ignored.&lt;br&gt;&lt;br&gt;Issue id: IncludeLayoutParam&lt;br&gt;&lt;br&gt;&lt;a href="https://stackoverflow.com/questions/2631614/does-android-xml-layouts-include-tag-really-work"&gt;https://stackoverflow.com/questions/2631614/does-android-xml-layouts-include-tag-really-work&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintIllegalResourceRef" defaultSeverity="WARNING" displayName="Name and version must be integer or string, not resource" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Name and version must be integer or string, not resource&lt;br&gt;&lt;br&gt;For the &lt;code&gt;versionCode&lt;/code&gt; attribute, you have to specify an actual integer literal; you cannot use an indirection with a &lt;code&gt;@dimen/name&lt;/code&gt; resource. Similarly, the &lt;code&gt;versionName&lt;/code&gt; attribute should be an actual string, not a string resource url.&lt;br&gt;&lt;br&gt;Issue id: IllegalResourceRef&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintWearStandaloneAppFlag" defaultSeverity="WARNING" displayName="Invalid or missing Wear standalone app flag" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Invalid or missing Wear standalone app flag&lt;br&gt;&lt;br&gt;Wearable apps should specify whether they can work standalone, without a phone app. Add a valid meta-data entry for &lt;code&gt;com.google.android.wearable.standalone&lt;/code&gt; to your application element and set the value to &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;.
&lt;pre&gt;
&amp;lt;meta-data android:name="com.google.android.wearable.standalone"
           android:value="true"/&gt;`
&lt;/pre&gt;
&lt;br&gt;&lt;br&gt;Issue id: WearStandaloneAppFlag&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/training/wearables/apps/packaging.html"&gt;https://developer.android.com/training/wearables/apps/packaging.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintXmlEscapeNeeded" defaultSeverity="ERROR" displayName="Missing XML Escape" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing XML Escape&lt;br&gt;&lt;br&gt;When a string contains characters that have special usage in XML, you must escape the characters.&lt;br&gt;&lt;br&gt;Issue id: XmlEscapeNeeded&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMissingDefaultResource" defaultSeverity="ERROR" displayName="Missing Default" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing Default&lt;br&gt;&lt;br&gt;If a resource is only defined in folders with qualifiers like &lt;code&gt;-land&lt;/code&gt; or &lt;code&gt;-en&lt;/code&gt;, and there is no default declaration in the base folder (&lt;code&gt;layout&lt;/code&gt; or &lt;code&gt;values&lt;/code&gt; etc), then the app will crash if that resource is accessed on a device where the device is in a configuration missing the given qualifier.&lt;br/&gt;
&lt;br/&gt;
As a special case, drawables do not have to be specified in the base folder; if there is a match in a density folder (such as &lt;code&gt;drawable-mdpi&lt;/code&gt;) that image will be used and scaled. Note however that if you  only specify a drawable in a folder like &lt;code&gt;drawable-en-hdpi&lt;/code&gt;, the app will crash in non-English locales.&lt;br/&gt;
&lt;br/&gt;
There may be scenarios where you have a resource, such as a &lt;code&gt;-fr&lt;/code&gt; drawable, which is only referenced from some other resource with the same qualifiers (such as a &lt;code&gt;-fr&lt;/code&gt; style), which itself has safe fallbacks. However, this still makes it possible for somebody to accidentally reference the drawable and crash, so it is safer to create a default fallback in the base folder. Alternatively, you can suppress the issue by adding &lt;code&gt;tools:ignore="MissingDefaultResource"&lt;/code&gt; on the element.&lt;br/&gt;
&lt;br/&gt;
(This scenario frequently happens with string translations, where you might delete code and the corresponding resources, but forget to delete a translation. There is a dedicated issue id for that scenario, with the id &lt;code&gt;ExtraTranslation&lt;/code&gt;.)&lt;br&gt;&lt;br&gt;Issue id: MissingDefaultResource&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintWifiManagerPotentialLeak" defaultSeverity="WARNING" displayName="WifiManager Potential Leak" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;WifiManager Potential Leak&lt;br&gt;&lt;br&gt;On versions prior to Android N (24), initializing the &lt;code&gt;WifiManager&lt;/code&gt; via &lt;code&gt;Context#getSystemService&lt;/code&gt; can cause a memory leak if the context is not the application context.&lt;br/&gt;
&lt;br/&gt;
In many cases, it's not obvious from the code where the &lt;code&gt;Context&lt;/code&gt; is coming from (e.g. it might be a parameter to a method, or a field initialized from various method calls). It's possible that the context being passed in is the application context, but to be on the safe side, you should consider changing &lt;code&gt;context.getSystemService(...)&lt;/code&gt; to &lt;code&gt;context.getApplicationContext().getSystemService(...)&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: WifiManagerPotentialLeak&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintNestedScrolling" defaultSeverity="WARNING" displayName="Nested scrolling widgets" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Nested scrolling widgets&lt;br&gt;&lt;br&gt;A scrolling widget such as a &lt;code&gt;ScrollView&lt;/code&gt; should not contain any nested scrolling widgets since this has various usability issues&lt;br&gt;&lt;br&gt;Issue id: NestedScrolling&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintInlinedApi" defaultSeverity="WARNING" displayName="Using inlined constants on older versions" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using inlined constants on older versions&lt;br&gt;&lt;br&gt;This check scans through all the Android API field references in the application and flags certain constants, such as static final integers and Strings, which were introduced in later versions. These will actually be copied into the class files rather than being referenced, which means that the value is available even when running on older devices. In some cases that's fine, and in other cases it can result in a runtime crash or incorrect behavior. It depends on the context, so consider the code carefully and decide whether it's safe and can be suppressed or whether the code needs to be guarded.&lt;br/&gt;
&lt;br/&gt;
If you really want to use this API and don't need to support older devices just set the &lt;code&gt;minSdkVersion&lt;/code&gt; in your &lt;code&gt;build.gradle&lt;/code&gt; or &lt;code&gt;AndroidManifest.xml&lt;/code&gt; files.&lt;br/&gt;
&lt;br/&gt;
If your code is &lt;b&gt;deliberately&lt;/b&gt; accessing newer APIs, and you have ensured (e.g. with conditional execution) that this code will only ever be called on a supported platform, then you can annotate your class or method with the &lt;code&gt;@TargetApi&lt;/code&gt; annotation specifying the local minimum SDK to apply, such as &lt;code&gt;@TargetApi(11)&lt;/code&gt;, such that this check considers 11 rather than your manifest file's minimum SDK as the required API level.&lt;br&gt;&lt;br&gt;Issue id: InlinedApi&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintWifiManagerLeak" defaultSeverity="ERROR" displayName="WifiManager Leak" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;WifiManager Leak&lt;br&gt;&lt;br&gt;On versions prior to Android N (24), initializing the &lt;code&gt;WifiManager&lt;/code&gt; via &lt;code&gt;Context#getSystemService&lt;/code&gt; can cause a memory leak if the context is not the application context. Change &lt;code&gt;context.getSystemService(...)&lt;/code&gt; to &lt;code&gt;context.getApplicationContext().getSystemService(...)&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: WifiManagerLeak&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintIncompatibleMediaBrowserServiceCompatVersion" defaultSeverity="WARNING" displayName="Obsolete version of MediaBrowserServiceCompat" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Obsolete version of MediaBrowserServiceCompat&lt;br&gt;&lt;br&gt;&lt;code&gt;MediaBrowserServiceCompat&lt;/code&gt; from version 23.2.0 to 23.4.0 of the Support v4 Library used private APIs and will not be compatible with future versions of Android beyond Android N. Please upgrade to version 24.0.0 or higher of the Support Library.&lt;br&gt;&lt;br&gt;Issue id: IncompatibleMediaBrowserServiceCompatVersion&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintVisibleForTests" defaultSeverity="WARNING" displayName="Visible Only For Tests" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Visible Only For Tests&lt;br&gt;&lt;br&gt;With the &lt;code&gt;@VisibleForTesting&lt;/code&gt; annotation you can specify an &lt;code&gt;otherwise=&lt;/code&gt; attribute which specifies the intended visibility if the method had not been made more widely visible for the tests.&lt;br/&gt;
&lt;br/&gt;
This check looks for accesses from production code (e.g. not tests) where the access would not have been allowed with the intended production visibility.&lt;br&gt;&lt;br&gt;Issue id: VisibleForTests&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintCustomViewStyleable" defaultSeverity="WARNING" displayName="Mismatched Styleable/Custom View Name" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Mismatched Styleable/Custom View Name&lt;br&gt;&lt;br&gt;The convention for custom views is to use a &lt;code&gt;declare-styleable&lt;/code&gt; whose name matches the custom view class name. The IDE relies on this convention such that for example code completion can be offered for attributes in a custom view in layout XML resource files.&lt;br/&gt;
&lt;br/&gt;
(Similarly, layout parameter classes should use the suffix &lt;code&gt;_Layout&lt;/code&gt;.)&lt;br&gt;&lt;br&gt;Issue id: CustomViewStyleable&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintInvalidNavigation" defaultSeverity="WARNING" displayName="No start destination specified" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;No start destination specified&lt;br&gt;&lt;br&gt;All &lt;code&gt;&amp;lt;navigation&gt;&lt;/code&gt; elements must have a start destination specified, and it must be a direct child of that &lt;code&gt;&amp;lt;navigation&gt;&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: InvalidNavigation&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintGradlePath" defaultSeverity="WARNING" displayName="Gradle Path Issues" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Gradle Path Issues&lt;br&gt;&lt;br&gt;Gradle build scripts are meant to be cross platform, so file paths use Unix-style path separators (a forward slash) rather than Windows path separators (a backslash). Similarly, to keep projects portable and repeatable, avoid using absolute paths on the system; keep files within the project instead. To share code between projects, consider creating an android-library and an AAR dependency&lt;br&gt;&lt;br&gt;Issue id: GradlePath&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUnsupportedChromeOsCameraSystemFeature" defaultSeverity="WARNING" displayName="Looking for Rear Camera only feature" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Looking for Rear Camera only feature&lt;br&gt;&lt;br&gt;You should look for the &lt;code&gt;FEATURE_CAMERA_ANY&lt;/code&gt; features to include all possible cameras that may be on the device. Looking for &lt;code&gt;FEATURE_CAMERA&lt;/code&gt; only looks for a rear facing camera, which certain tablets or Chrome OS devices don't have, as well as newer device configurations and modes may place the device in a state where the rear camera is not available. To fix the issue, look for &lt;code&gt;FEATURE_CAMERA_ANY&lt;/code&gt; instead.&lt;br&gt;&lt;br&gt;Issue id: UnsupportedChromeOsCameraSystemFeature&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMissingLeanbackLauncher" defaultSeverity="ERROR" displayName="Missing Leanback Launcher Intent Filter" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing Leanback Launcher Intent Filter&lt;br&gt;&lt;br&gt;An application intended to run on TV devices must declare a launcher activity for TV in its manifest using a &lt;code&gt;android.intent.category.LEANBACK_LAUNCHER&lt;/code&gt; intent filter.&lt;br&gt;&lt;br&gt;Issue id: MissingLeanbackLauncher&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/training/tv/start/start.html#tv-activity"&gt;https://developer.android.com/training/tv/start/start.html#tv-activity&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintSwitchIntDef" defaultSeverity="WARNING" displayName="Missing @IntDef in Switch" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing @IntDef in Switch&lt;br&gt;&lt;br&gt;This check warns if a &lt;code&gt;switch&lt;/code&gt; statement does not explicitly include all the values declared by the typedef &lt;code&gt;@IntDef&lt;/code&gt; declaration.&lt;br&gt;&lt;br&gt;Issue id: SwitchIntDef&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintNotSibling" defaultSeverity="ERROR" displayName="Invalid Constraints" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Invalid Constraints&lt;br&gt;&lt;br&gt;Layout constraints in a given &lt;code&gt;ConstraintLayout&lt;/code&gt; or &lt;code&gt;RelativeLayout&lt;/code&gt; should reference other views within the same relative layout (but not itself!)&lt;br&gt;&lt;br&gt;Issue id: NotSibling&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintOpenForTesting" defaultSeverity="ERROR" displayName="Extending API only allowed from tests" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Extending API only allowed from tests&lt;br&gt;&lt;br&gt;Classes or methods annotated with &lt;code&gt;@OpenForTesting&lt;/code&gt; are only allowed to be subclassed or overridden from unit tests.&lt;br&gt;&lt;br&gt;Issue id: OpenForTesting&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintSuspicious0dp" defaultSeverity="ERROR" displayName="Suspicious 0dp dimension" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Suspicious 0dp dimension&lt;br&gt;&lt;br&gt;Using 0dp as the width in a horizontal &lt;code&gt;LinearLayout&lt;/code&gt; with weights is a useful trick to ensure that only the weights (and not the intrinsic sizes) are used when sizing the children.&lt;br/&gt;
&lt;br/&gt;
However, if you use 0dp for the opposite dimension, the view will be invisible. This can happen if you change the orientation of a layout without also flipping the &lt;code&gt;0dp&lt;/code&gt; dimension in all the children.&lt;br&gt;&lt;br&gt;Issue id: Suspicious0dp&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintInstantApps" defaultSeverity="WARNING" displayName="Instant App Issues" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Instant App Issues&lt;br&gt;&lt;br&gt;This issue flags code that will not work correctly in Instant Apps&lt;br&gt;&lt;br&gt;Issue id: InstantApps&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintWrongThread" defaultSeverity="ERROR" displayName="Wrong Thread" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Wrong Thread&lt;br&gt;&lt;br&gt;Ensures that a method which expects to be called on a specific thread, is actually called from that thread. For example, calls on methods in widgets should always be made on the UI thread.&lt;br&gt;&lt;br&gt;Issue id: WrongThread&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/components/processes-and-threads.html#Threads"&gt;https://developer.android.com/guide/components/processes-and-threads.html#Threads&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintPermissionImpliesUnsupportedChromeOsHardware" defaultSeverity="ERROR" displayName="Permission Implies Unsupported Chrome OS Hardware" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Permission Implies Unsupported Chrome OS Hardware&lt;br&gt;&lt;br&gt;The &lt;code&gt;&amp;lt;uses-permission&gt;&lt;/code&gt; element should not require a permission that implies an unsupported Chrome OS hardware feature. Google Play assumes that certain hardware related permissions indicate that the underlying hardware features are required by default. To fix the issue, consider declaring the corresponding uses-feature element with &lt;code&gt;required="false"&lt;/code&gt; attribute.&lt;br&gt;&lt;br&gt;Issue id: PermissionImpliesUnsupportedChromeOsHardware&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/topic/arc/manifest.html#implied-features"&gt;https://developer.android.com/topic/arc/manifest.html#implied-features&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintGradleDynamicVersion" defaultSeverity="WARNING" displayName="Gradle Dynamic Version" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Gradle Dynamic Version&lt;br&gt;&lt;br&gt;Using &lt;code&gt;+&lt;/code&gt; in dependencies lets you automatically pick up the latest available version rather than a specific, named version. However, this is not recommended; your builds are not repeatable; you may have tested with a slightly different version than what the build server used. (Using a dynamic version as the major version number is more problematic than using it in the minor version position.)&lt;br&gt;&lt;br&gt;Issue id: GradleDynamicVersion&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUntranslatable" defaultSeverity="WARNING" displayName="Translated Untranslatable" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Translated Untranslatable&lt;br&gt;&lt;br&gt;Strings can be marked with &lt;code&gt;translatable=false&lt;/code&gt; to indicate that they are not intended to be translated, but are present in the resource file for other purposes (for example for non-display strings that should vary by some other configuration qualifier such as screen size or API level).&lt;br/&gt;
&lt;br/&gt;
There are cases where translators accidentally translate these strings anyway, and lint will flag these occurrences with this lint check.&lt;br&gt;&lt;br&gt;Issue id: Untranslatable&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintServiceCast" defaultSeverity="ERROR" displayName="Wrong system service casts" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Wrong system service casts&lt;br&gt;&lt;br&gt;When you call &lt;code&gt;Context#getSystemService()&lt;/code&gt;, the result is typically cast to a specific interface. This lint check ensures that the cast is compatible with the expected type of the return value.&lt;br&gt;&lt;br&gt;Issue id: ServiceCast&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintInvalidVectorPath" defaultSeverity="ERROR" displayName="Invalid vector paths" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Invalid vector paths&lt;br&gt;&lt;br&gt;This check ensures that vector paths are valid. For example, it makes sure that the numbers are not using scientific notation (such as 1.0e3) which can lead to runtime crashes on older devices. As another example, it flags numbers like &lt;code&gt;.5&lt;/code&gt; which should be written as &lt;code&gt;0.5&lt;/code&gt; instead to avoid crashes on some pre-Marshmallow devices.&lt;br&gt;&lt;br&gt;Issue id: InvalidVectorPath&lt;br&gt;&lt;br&gt;&lt;a href="https://issuetracker.google.com/37008268"&gt;https://issuetracker.google.com/37008268&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintBottomAppBar" defaultSeverity="ERROR" displayName="BottomAppBar Problems" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;BottomAppBar Problems&lt;br&gt;&lt;br&gt;The &lt;code&gt;BottomAppBar&lt;/code&gt; widget must be placed within a &lt;code&gt;CoordinatorLayout&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: BottomAppBar&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintResourceType" defaultSeverity="ERROR" displayName="Wrong Resource Type" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Wrong Resource Type&lt;br&gt;&lt;br&gt;Ensures that resource id's passed to APIs are of the right type; for example, calling &lt;code&gt;Resources.getColor(R.string.name)&lt;/code&gt; is wrong.&lt;br&gt;&lt;br&gt;Issue id: ResourceType&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintDuplicateUsesFeature" defaultSeverity="WARNING" displayName="Feature declared more than once" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Feature declared more than once&lt;br&gt;&lt;br&gt;A given feature should only be declared once in the manifest.&lt;br&gt;&lt;br&gt;Issue id: DuplicateUsesFeature&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintImpliedTouchscreenHardware" defaultSeverity="ERROR" displayName="Touchscreen not optional" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Touchscreen not optional&lt;br&gt;&lt;br&gt;Apps require the &lt;code&gt;android.hardware.touchscreen&lt;/code&gt; feature by default. If you want your app to be available on TV, you must also explicitly declare that a touchscreen is not required as follows:&lt;br/&gt;
&lt;code&gt;&amp;lt;uses-feature android:name="android.hardware.touchscreen" android:required="false"/&gt;&lt;/code&gt;&lt;br&gt;&lt;br&gt;Issue id: ImpliedTouchscreenHardware&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/topics/manifest/uses-feature-element.html"&gt;https://developer.android.com/guide/topics/manifest/uses-feature-element.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintNfcTechWhitespace" defaultSeverity="ERROR" displayName="Whitespace in NFC tech lists" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Whitespace in NFC tech lists&lt;br&gt;&lt;br&gt;In a &lt;code&gt;&amp;lt;tech-list&gt;&lt;/code&gt;, there can be whitespace around the &lt;code&gt;&amp;lt;tech&gt;&lt;/code&gt; elements,but not inside them. This is because the code which reads in the tech list is currently very strict and will include the whitespace as part of the name.&lt;br/&gt;
&lt;br/&gt;
In other words, use &lt;code&gt;&amp;lt;tech&gt;name&amp;lt;/tech&gt;&lt;/code&gt;, not &lt;code&gt;&amp;lt;tech&gt; name &amp;lt;/tech&gt;&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: NfcTechWhitespace&lt;br&gt;&lt;br&gt;&lt;a href="https://issuetracker.google.com/36988969"&gt;https://issuetracker.google.com/36988969&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintEllipsizeMaxLines" defaultSeverity="ERROR" displayName="Combining Ellipsize and Maxlines" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Combining Ellipsize and Maxlines&lt;br&gt;&lt;br&gt;Combining &lt;code&gt;ellipsize&lt;/code&gt; and &lt;code&gt;maxLines=1&lt;/code&gt; can lead to crashes on some devices. Earlier versions of lint recommended replacing &lt;code&gt;singleLine=true&lt;/code&gt; with &lt;code&gt;maxLines=1&lt;/code&gt; but that should not be done when using &lt;code&gt;ellipsize&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: EllipsizeMaxLines&lt;br&gt;&lt;br&gt;&lt;a href="https://issuetracker.google.com/issues/36950033"&gt;https://issuetracker.google.com/issues/36950033&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintRequiresFeature" defaultSeverity="WARNING" displayName="Requires Feature" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Requires Feature&lt;br&gt;&lt;br&gt;Some APIs require optional features to be present. This check makes sure that calls to these APIs are surrounded by a check which enforces this.&lt;br&gt;&lt;br&gt;Issue id: RequiresFeature&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintRequiredSize" defaultSeverity="ERROR" displayName="Missing layout_width or layout_height attributes" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing &lt;code&gt;layout_width&lt;/code&gt; or &lt;code&gt;layout_height&lt;/code&gt; attributes&lt;br&gt;&lt;br&gt;All views must specify an explicit &lt;code&gt;layout_width&lt;/code&gt; and &lt;code&gt;layout_height&lt;/code&gt; attribute. There is a runtime check for this, so if you fail to specify a size, an exception is thrown at runtime.&lt;br/&gt;
&lt;br/&gt;
It's possible to specify these widths via styles as well. GridLayout, as a special case, does not require you to specify a size.&lt;br&gt;&lt;br&gt;Issue id: RequiredSize&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintDiffUtilEquals" defaultSeverity="ERROR" displayName="Suspicious DiffUtil Equality" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Suspicious DiffUtil Equality&lt;br&gt;&lt;br&gt;&lt;code&gt;areContentsTheSame&lt;/code&gt; is used by &lt;code&gt;DiffUtil&lt;/code&gt; to produce diffs. If the method is implemented incorrectly, such as using identity equals instead of equals, or calling equals on a class that has not implemented it, weird visual artifacts can occur.&lt;br&gt;&lt;br&gt;Issue id: DiffUtilEquals&lt;br&gt;&lt;br&gt;&lt;a href="https://issuetracker.google.com/116789824"&gt;https://issuetracker.google.com/116789824&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintGetLocales" defaultSeverity="ERROR" displayName="Locale crash" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Locale crash&lt;br&gt;&lt;br&gt;This check looks for usage of Lollipop-style locale folders (e.g. 3 letter language codes, or BCP 47 qualifiers) combined with an &lt;code&gt;AssetManager#getLocales()&lt;/code&gt; call. This leads to crashes&lt;br&gt;&lt;br&gt;Issue id: GetLocales&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintPxUsage" defaultSeverity="WARNING" displayName="Using 'px' dimension" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using 'px' dimension&lt;br&gt;&lt;br&gt;For performance reasons and to keep the code simpler, the Android system uses pixels as the standard unit for expressing dimension or coordinate values. That means that the dimensions of a view are always expressed in the code using pixels, but always based on the current screen density. For instance, if &lt;code&gt;myView.getWidth()&lt;/code&gt; returns 10, the view is 10 pixels wide on the current screen, but on a device with a higher density screen, the value returned might be 15. If you use pixel values in your application code to work with bitmaps that are not pre-scaled for the current screen density, you might need to scale the pixel values that you use in your code to match the un-scaled bitmap source.&lt;br&gt;&lt;br&gt;Issue id: PxUsage&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/practices/screens_support.html#screen-independence"&gt;https://developer.android.com/guide/practices/screens_support.html#screen-independence&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintSdCardPath" defaultSeverity="WARNING" displayName="Hardcoded reference to /sdcard" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Hardcoded reference to &lt;code&gt;/sdcard&lt;/code&gt;&lt;br&gt;&lt;br&gt;Your code should not reference the &lt;code&gt;/sdcard&lt;/code&gt; path directly; instead use &lt;code&gt;Environment.getExternalStorageDirectory().getPath()&lt;/code&gt;.&lt;br/&gt;
&lt;br/&gt;
Similarly, do not reference the &lt;code&gt;/data/data/&lt;/code&gt; path directly; it can vary in multi-user scenarios. Instead, use &lt;code&gt;Context.getFilesDir().getPath()&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: SdCardPath&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/training/data-storage#filesExternal"&gt;https://developer.android.com/training/data-storage#filesExternal&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMissingBackupPin" defaultSeverity="WARNING" displayName="Missing Backup Pin" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing Backup Pin&lt;br&gt;&lt;br&gt;It is highly recommended to declare a backup &lt;code&gt;&amp;lt;pin&gt;&lt;/code&gt; element. Not having a second pin defined can cause connection failures when the particular site certificate is rotated and the app has not yet been updated.&lt;br&gt;&lt;br&gt;Issue id: MissingBackupPin&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/preview/features/security-config.html"&gt;https://developer.android.com/preview/features/security-config.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintFullBackupContent" defaultSeverity="ERROR" displayName="Valid Full Backup Content File" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Valid Full Backup Content File&lt;br&gt;&lt;br&gt;Ensures that &lt;code&gt;&amp;lt;data-extraction-rules&lt;/code&gt;&gt; and &lt;code&gt;&amp;lt;full-backup-content&gt;&lt;/code&gt; files, which configure backup options, are valid.&lt;br&gt;&lt;br&gt;Issue id: FullBackupContent&lt;br&gt;&lt;br&gt;&lt;a href="https://android-developers.googleblog.com/2015/07/auto-backup-for-apps-made-simple.html"&gt;https://android-developers.googleblog.com/2015/07/auto-backup-for-apps-made-simple.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintValidActionsXml" defaultSeverity="ERROR" displayName="Invalid Action Descriptor" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Invalid Action Descriptor&lt;br&gt;&lt;br&gt;Ensures that an actions XML file is properly formed&lt;br&gt;&lt;br&gt;Issue id: ValidActionsXml&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintRange" defaultSeverity="ERROR" displayName="Outside Range" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Outside Range&lt;br&gt;&lt;br&gt;Some parameters are required to in a particular numerical range; this check makes sure that arguments passed fall within the range. For arrays, Strings and collections this refers to the size or length.&lt;br&gt;&lt;br&gt;Issue id: Range&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintKotlinNullnessAnnotation" defaultSeverity="ERROR" displayName="Kotlin nullability annotation" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Kotlin nullability annotation&lt;br&gt;&lt;br&gt;In Kotlin, nullness is part of the type system; &lt;code&gt;s: String&lt;/code&gt; is &lt;b&gt;never&lt;/b&gt; null and &lt;code&gt;s: String?&lt;/code&gt; is sometimes null, whether or not you add in additional annotations stating &lt;code&gt;@NonNull&lt;/code&gt; or &lt;code&gt;@Nullable&lt;/code&gt;. These are likely copy/paste mistakes, and are misleading.&lt;br&gt;&lt;br&gt;Issue id: KotlinNullnessAnnotation&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintLeanbackUsesWifi" defaultSeverity="WARNING" displayName="android.hardware.wifi on TV device" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using android.hardware.wifi on TV&lt;br&gt;&lt;br&gt;WiFi is not required for Android TV and many devices connect to the internet via alternative methods e.g. Ethernet.&lt;br/&gt;
&lt;br/&gt;
If your app is not focused specifically on WiFi functionality and only wishes to connect to the internet, please modify your Manifest to contain: &lt;code&gt;&amp;lt;uses-feature android:name="android.hardware.wifi" android:required="false" /&gt;&lt;/code&gt;&lt;br/&gt;
&lt;br/&gt;
Un-metered or non-roaming connections can be detected in software using &lt;code&gt;NetworkCapabilities#NET_CAPABILITY_NOT_METERED&lt;/code&gt; and &lt;code&gt;NetworkCapabilities#NET_CAPABILITY_NOT_ROAMING.&lt;/code&gt;&lt;br&gt;&lt;br&gt;Issue id: LeanbackUsesWifi&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintHighSamplingRate" defaultSeverity="WARNING" displayName="High sensor sampling rate" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;High sensor sampling rate&lt;br&gt;&lt;br&gt;Most apps don't need access to high sensor sampling rate. Double check your use case to ensure your app absolutely needs access to sensor sampling rate &gt; 200Hz. Be prepared for your app to be rejected from listing on Play Store until your use case for high sensor sampling rate has been reviewed and validated by the policy team.&lt;br&gt;&lt;br&gt;Issue id: HighSamplingRate&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintGradlePluginVersion" defaultSeverity="ERROR" displayName="Incompatible Android Gradle Plugin" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Incompatible Android Gradle Plugin&lt;br&gt;&lt;br&gt;Not all versions of the Android Gradle plugin are compatible with all versions of the SDK. If you update your tools, or if you are trying to open a project that was built with an old version of the tools, you may need to update your plugin version number.&lt;br&gt;&lt;br&gt;Issue id: GradlePluginVersion&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintInvalidId" defaultSeverity="ERROR" displayName="Invalid ID declaration" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Invalid ID declaration&lt;br&gt;&lt;br&gt;An id definition &lt;b&gt;must&lt;/b&gt; be of the form &lt;code&gt;@+id/yourname&lt;/code&gt;. The tools have not rejected strings of the form &lt;code&gt;@+foo/bar&lt;/code&gt; in the past, but that was an error, and could lead to tricky errors because of the way the id integers are assigned.&lt;br/&gt;
&lt;br/&gt;
If you really want to have different "scopes" for your id's, use prefixes instead, such as &lt;code&gt;login_button1&lt;/code&gt; and &lt;code&gt;login_button2&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: InvalidId&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintNonConstantResourceId" defaultSeverity="WARNING" displayName="Checks use of resource IDs in places requiring constants." enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Checks use of resource IDs in places requiring constants&lt;br&gt;&lt;br&gt;Avoid the usage of resource IDs where constant expressions are required.&lt;br/&gt;
&lt;br/&gt;
A future version of the Android Gradle Plugin will generate R classes with non-constant IDs in order to improve the performance of incremental compilation.&lt;br&gt;&lt;br&gt;Issue id: NonConstantResourceId&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintWrongViewCast" defaultSeverity="ERROR" displayName="Mismatched view type" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Mismatched view type&lt;br&gt;&lt;br&gt;Keeps track of the view types associated with ids and if it finds a usage of the id in the Java code it ensures that it is treated as the same type.&lt;br&gt;&lt;br&gt;Issue id: WrongViewCast&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMissingVersion" defaultSeverity="WARNING" displayName="Missing application name/version" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing application name/version&lt;br&gt;&lt;br&gt;You should define the version information for your application.&lt;br/&gt;
&lt;br/&gt;
&lt;code&gt;android:versionCode&lt;/code&gt;: An integer value that represents the version of the application code, relative to other versions.&lt;br/&gt;
&lt;br/&gt;
&lt;code&gt;android:versionName&lt;/code&gt;: A string value that represents the release version of the application code, as it should be shown to users.&lt;br&gt;&lt;br&gt;Issue id: MissingVersion&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/studio/publish/versioning#appversioning"&gt;https://developer.android.com/studio/publish/versioning#appversioning&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMissingQuantity" defaultSeverity="ERROR" displayName="Missing quantity translation" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing quantity translation&lt;br&gt;&lt;br&gt;Different languages have different rules for grammatical agreement with quantity. In English, for example, the quantity 1 is a special case. We write "1 book", but for any other quantity we'd write "n books". This distinction between singular and plural is very common, but other languages make finer distinctions.&lt;br/&gt;
&lt;br/&gt;
This lint check looks at each translation of a &lt;code&gt;&amp;lt;plural&gt;&lt;/code&gt; and makes sure that all the quantity strings considered by the given language are provided by this translation.&lt;br/&gt;
&lt;br/&gt;
For example, an English translation must provide a string for &lt;code&gt;quantity="one"&lt;/code&gt;. Similarly, a Czech translation must provide a string for &lt;code&gt;quantity="few"&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: MissingQuantity&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/topics/resources/string-resource.html#Plurals"&gt;https://developer.android.com/guide/topics/resources/string-resource.html#Plurals&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintNamespaceTypo" defaultSeverity="ERROR" displayName="Misspelled namespace declaration" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Misspelled namespace declaration&lt;br&gt;&lt;br&gt;Accidental misspellings in namespace declarations can lead to some very obscure error messages. This check looks for potential misspellings to help track these down.&lt;br&gt;&lt;br&gt;Issue id: NamespaceTypo&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUnknownIdInLayout" defaultSeverity="WARNING" displayName="Reference to an id that is not in the current layout" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Reference to an id that is not in the current layout&lt;br&gt;&lt;br&gt;The &lt;code&gt;@+id/&lt;/code&gt; syntax refers to an existing id, or creates a new one if it has not already been defined elsewhere. However, this means that if you have a typo in your reference, or if the referred view no longer exists, you do not get a warning since the id will be created on demand.&lt;br/&gt;
&lt;br/&gt;
This is sometimes intentional, for example where you are referring to a view which is provided in a different layout via an include. However, it is usually an accident where you have a typo or you have renamed a view without updating all the references to it.&lt;br&gt;&lt;br&gt;Issue id: UnknownIdInLayout&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMockLocation" defaultSeverity="ERROR" displayName="Using mock location provider in production" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using mock location provider in production&lt;br&gt;&lt;br&gt;Using a mock location provider (by requiring the permission &lt;code&gt;android.permission.ACCESS_MOCK_LOCATION&lt;/code&gt;) should &lt;b&gt;only&lt;/b&gt; be done in debug builds (or from tests). In Gradle projects, that means you should only request this permission in a test or debug source set specific manifest file.&lt;br/&gt;
&lt;br/&gt;
To fix this, create a new manifest file in the debug folder and move the &lt;code&gt;&amp;lt;uses-permission&gt;&lt;/code&gt; element there. A typical path to a debug manifest override file in a Gradle project is src/debug/AndroidManifest.xml.&lt;br&gt;&lt;br&gt;Issue id: MockLocation&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintDeprecatedSinceApi" defaultSeverity="WARNING" displayName="Using a method deprecated in earlier SDK" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using a method deprecated in earlier SDK&lt;br&gt;&lt;br&gt;Some backport methods are only necessary until a specific version of Android. These have been annotated with &lt;code&gt;@DeprecatedSinceApi&lt;/code&gt;, specifying the relevant API level and replacement suggestions. Calling these methods when the &lt;code&gt;minSdkVersion&lt;/code&gt; is already at the deprecated API level or above is unnecessary.&lt;br&gt;&lt;br&gt;Issue id: DeprecatedSinceApi&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintNotificationIconCompatibility" defaultSeverity="WARNING" displayName="Notification Icon Compatibility" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Notification Icon Compatibility&lt;br&gt;&lt;br&gt;Notification icons should define a raster image to support Android versions below 5.0 (API 21). Note that the way Lint decides whether an icon is a notification icon is based on the filename prefix &lt;code&gt;ic_stat_&lt;/code&gt;. This corresponds to the naming convention documented in &lt;a href="https://material.io/design/iconography/"&gt;https://material.io/design/iconography/&lt;/a&gt;&lt;br&gt;&lt;br&gt;Issue id: NotificationIconCompatibility&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintLogTagMismatch" defaultSeverity="ERROR" displayName="Mismatched Log Tags" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Mismatched Log Tags&lt;br&gt;&lt;br&gt;When guarding a &lt;code&gt;Log.v(tag, ...)&lt;/code&gt; call with &lt;code&gt;Log.isLoggable(tag)&lt;/code&gt;, the tag passed to both calls should be the same. Similarly, the level passed in to &lt;code&gt;Log.isLoggable&lt;/code&gt; should typically match the type of &lt;code&gt;Log&lt;/code&gt; call, e.g. if checking level &lt;code&gt;Log.DEBUG&lt;/code&gt;, the corresponding &lt;code&gt;Log&lt;/code&gt; call should be &lt;code&gt;Log.d&lt;/code&gt;, not &lt;code&gt;Log.i&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: LogTagMismatch&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintFindViewByIdCast" defaultSeverity="WARNING" displayName="Add Explicit Cast" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Add Explicit Cast&lt;br&gt;&lt;br&gt;In Android O, the &lt;code&gt;findViewById&lt;/code&gt; signature switched to using generics, which means that most of the time you can leave out explicit casts and just assign the result of the &lt;code&gt;findViewById&lt;/code&gt; call to variables of specific view classes.&lt;br/&gt;
&lt;br/&gt;
However, due to language changes between Java 7 and 8, this change may cause code to not compile without explicit casts. This lint check looks for these scenarios and suggests casts to be added now such that the code will continue to compile if the language level is updated to 1.8.&lt;br&gt;&lt;br&gt;Issue id: FindViewByIdCast&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintExtraText" defaultSeverity="WARNING" displayName="Extraneous text in resource files" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Extraneous text in resource files&lt;br&gt;&lt;br&gt;Non-value resource files should only contain elements and attributes. Any XML text content found in the file is likely accidental (and potentially dangerous if the text resembles XML and the developer believes the text to be functional).&lt;br&gt;&lt;br&gt;Issue id: ExtraText&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintSetJavaScriptEnabled" defaultSeverity="WARNING" displayName="Using setJavaScriptEnabled" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using &lt;code&gt;setJavaScriptEnabled&lt;/code&gt;&lt;br&gt;&lt;br&gt;Your code should not invoke &lt;code&gt;setJavaScriptEnabled&lt;/code&gt; if you are not sure that your app really requires JavaScript support.&lt;br&gt;&lt;br&gt;Issue id: SetJavaScriptEnabled&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/training/articles/security-tips"&gt;https://developer.android.com/training/articles/security-tips&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintReturnThis" defaultSeverity="ERROR" displayName="Method must return this" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Method must return &lt;code&gt;this&lt;/code&gt;&lt;br&gt;&lt;br&gt;Methods annotated with &lt;code&gt;@ReturnThis&lt;/code&gt; (usually in the super method that this method is overriding) should also &lt;code&gt;return this&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: ReturnThis&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintWrongCall" defaultSeverity="ERROR" displayName="Using wrong draw/layout method" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using wrong draw/layout method&lt;br&gt;&lt;br&gt;Custom views typically need to call &lt;code&gt;measure()&lt;/code&gt; on their children, not &lt;code&gt;onMeasure&lt;/code&gt;. Ditto for onDraw, onLayout, etc.&lt;br&gt;&lt;br&gt;Issue id: WrongCall&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintScopedStorage" defaultSeverity="WARNING" displayName="Affected by scoped storage" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Affected by scoped storage&lt;br&gt;&lt;br&gt;Scoped storage is enforced on Android 10+ (or Android 11+ if using &lt;code&gt;requestLegacyExternalStorage&lt;/code&gt;). In particular, &lt;code&gt;WRITE_EXTERNAL_STORAGE&lt;/code&gt; will no longer provide write access to all files; it will provide the equivalent of &lt;code&gt;READ_EXTERNAL_STORAGE&lt;/code&gt; instead.&lt;br/&gt;
&lt;br/&gt;
The &lt;code&gt;MANAGE_EXTERNAL_STORAGE&lt;/code&gt; permission can be used to manage all files, but it is rarely necessary and most apps on Google Play are not allowed to use it. Most apps should instead migrate to use scoped storage. To modify or delete files, apps should request write access from the user as described at &lt;a href="https://goo.gle/android-mediastore-createwriterequest"&gt;https://goo.gle/android-mediastore-createwriterequest&lt;/a&gt;.&lt;br/&gt;
&lt;br/&gt;
To learn more, read these resources: Play policy: &lt;a href="https://goo.gle/policy-storage-help"&gt;https://goo.gle/policy-storage-help&lt;/a&gt; Allowable use cases: &lt;a href="https://goo.gle/policy-storage-usecases"&gt;https://goo.gle/policy-storage-usecases&lt;/a&gt;&lt;br&gt;&lt;br&gt;Issue id: ScopedStorage&lt;br&gt;&lt;br&gt;&lt;a href="https://goo.gle/android-storage-usecases"&gt;https://goo.gle/android-storage-usecases&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUseAlpha2" defaultSeverity="WARNING" displayName="Using 3-letter Codes" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using 3-letter Codes&lt;br&gt;&lt;br&gt;For compatibility with earlier devices, you should only use 3-letter language and region codes when there is no corresponding 2 letter code.&lt;br&gt;&lt;br&gt;Issue id: UseAlpha2&lt;br&gt;&lt;br&gt;&lt;a href="https://tools.ietf.org/html/bcp47"&gt;https://tools.ietf.org/html/bcp47&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintResourceCycle" defaultSeverity="ERROR" displayName="Cycle in resource definitions" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Cycle in resource definitions&lt;br&gt;&lt;br&gt;There should be no cycles in resource definitions as this can lead to runtime exceptions.&lt;br&gt;&lt;br&gt;Issue id: ResourceCycle&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintReferenceType" defaultSeverity="ERROR" displayName="Incorrect reference types" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Incorrect reference types&lt;br&gt;&lt;br&gt;When you generate a resource alias, the resource you are pointing to must be of the same type as the alias&lt;br&gt;&lt;br&gt;Issue id: ReferenceType&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintDuplicateIncludedIds" defaultSeverity="WARNING" displayName="Duplicate ids across layouts combined with include tags" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Duplicate ids across layouts combined with include tags&lt;br&gt;&lt;br&gt;It's okay for two independent layouts to use the same ids. However, if layouts are combined with include tags, then the id's need to be unique within any chain of included layouts, or &lt;code&gt;Activity#findViewById()&lt;/code&gt; can return an unexpected view.&lt;br&gt;&lt;br&gt;Issue id: DuplicateIncludedIds&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintAndroidGradlePluginVersion" defaultSeverity="WARNING" displayName="Obsolete Android Gradle Plugin Version" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Obsolete Android Gradle Plugin Version&lt;br&gt;&lt;br&gt;This detector looks for usage of the Android Gradle Plugin where the version you are using is not the current stable release. Using older versions is fine, and there are cases where you deliberately want to stick with an older version. However, you may simply not be aware that a more recent version is available, and that is what this lint check helps find.&lt;br&gt;&lt;br&gt;Issue id: AndroidGradlePluginVersion&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintInconsistentArrays" defaultSeverity="WARNING" displayName="Inconsistencies in array element counts" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Inconsistencies in array element counts&lt;br&gt;&lt;br&gt;When an array is translated in a different locale, it should normally have the same number of elements as the original array. When adding or removing elements to an array, it is easy to forget to update all the locales, and this lint warning finds inconsistencies like these.&lt;br/&gt;
&lt;br/&gt;
Note however that there may be cases where you really want to declare a different number of array items in each configuration (for example where the array represents available options, and those options differ for different layout orientations and so on), so use your own judgment to decide if this is really an error.&lt;br/&gt;
&lt;br/&gt;
You can suppress this error type if it finds false errors in your project.&lt;br&gt;&lt;br&gt;Issue id: InconsistentArrays&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintProtectedPermissions" defaultSeverity="ERROR" displayName="Using system app permission" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using system app permission&lt;br&gt;&lt;br&gt;Permissions with the protection level &lt;code&gt;signature&lt;/code&gt;, &lt;code&gt;privileged&lt;/code&gt; or &lt;code&gt;signatureOrSystem&lt;/code&gt; are only granted to system apps. If an app is a regular non-system app, it will never be able to use these permissions.&lt;br&gt;&lt;br&gt;Issue id: ProtectedPermissions&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintSoonBlockedPrivateApi" defaultSeverity="ERROR" displayName="Using Soon-to-Be Blocked Private API" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using Soon-to-Be Blocked Private API&lt;br&gt;&lt;br&gt;Usage of restricted non-SDK interface will throw an exception at runtime. Accessing non-SDK methods or fields through reflection has a high likelihood to break your app between versions, and is being restricted to facilitate future app compatibility.&lt;br&gt;&lt;br&gt;Issue id: SoonBlockedPrivateApi&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/preview/restrictions-non-sdk-interfaces"&gt;https://developer.android.com/preview/restrictions-non-sdk-interfaces&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintOnClick" defaultSeverity="ERROR" displayName="onClick method does not exist" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;&lt;code&gt;onClick&lt;/code&gt; method does not exist&lt;br&gt;&lt;br&gt;The &lt;code&gt;onClick&lt;/code&gt; attribute value should be the name of a method in this View's context to invoke when the view is clicked. This name must correspond to a public method that takes exactly one parameter of type &lt;code&gt;View&lt;/code&gt;.&lt;br/&gt;
&lt;br/&gt;
Must be a string value, using '\;' to escape characters such as '\n' or '\uxxxx' for a unicode character.&lt;br&gt;&lt;br&gt;Issue id: OnClick&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintDuplicatePlatformClasses" defaultSeverity="ERROR" displayName="Duplicate Platform Classes" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Duplicate Platform Classes&lt;br&gt;&lt;br&gt;There are a number of libraries that duplicate not just functionality of the Android platform but using the exact same class names as the ones provided in Android -- for example the apache http classes. This can lead to unexpected crashes.&lt;br/&gt;
&lt;br/&gt;
To solve this, you need to either find a newer version of the library which no longer has this problem, or to repackage the library (and all of its dependencies) using something like the &lt;code&gt;jarjar&lt;/code&gt; tool, or finally, rewriting the code to use different APIs (for example, for http code, consider using &lt;code&gt;HttpUrlConnection&lt;/code&gt; or a library like &lt;code&gt;okhttp&lt;/code&gt;).&lt;br&gt;&lt;br&gt;Issue id: DuplicatePlatformClasses&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintGradleDeprecatedConfiguration" defaultSeverity="WARNING" displayName="Deprecated Gradle Configuration" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Deprecated Gradle Configuration&lt;br&gt;&lt;br&gt;Some Gradle configurations have been deprecated since Android Gradle Plugin 3.0.0 and will be removed in a future version of the Android Gradle Plugin.&lt;br&gt;&lt;br&gt;Issue id: GradleDeprecatedConfiguration&lt;br&gt;&lt;br&gt;&lt;a href="https://d.android.com/r/tools/update-dependency-configurations"&gt;https://d.android.com/r/tools/update-dependency-configurations&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintPinSetExpiry" defaultSeverity="WARNING" displayName="Validate &lt;pin-set&gt; expiration attribute" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Validate &lt;code&gt;&amp;lt;pin-set&gt;&lt;/code&gt; expiration attribute&lt;br&gt;&lt;br&gt;Ensures that the &lt;code&gt;expiration&lt;/code&gt; attribute of the &lt;code&gt;&amp;lt;pin-set&gt;&lt;/code&gt; element is valid and has not already expired or is expiring soon&lt;br&gt;&lt;br&gt;Issue id: PinSetExpiry&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/preview/features/security-config.html"&gt;https://developer.android.com/preview/features/security-config.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintSourceLockedOrientationActivity" defaultSeverity="WARNING" displayName="Incompatible setRequestedOrientation value" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Incompatible setRequestedOrientation value&lt;br&gt;&lt;br&gt;The &lt;code&gt;Activity&lt;/code&gt; should not be locked to a portrait orientation so that users can take advantage of the multi-window environments and larger landscape-first screens that Android runs on such as Chrome OS. To fix the issue, consider calling &lt;code&gt;setRequestedOrientation&lt;/code&gt; with the &lt;code&gt;ActivityInfo.SCREEN_ORIENTATION_FULL_SENSOR&lt;/code&gt; or &lt;code&gt;ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED&lt;/code&gt; options or removing the call all together.&lt;br&gt;&lt;br&gt;Issue id: SourceLockedOrientationActivity&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintStringShouldBeInt" defaultSeverity="ERROR" displayName="String should be int" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;String should be int&lt;br&gt;&lt;br&gt;The properties &lt;code&gt;compileSdkVersion&lt;/code&gt;, &lt;code&gt;minSdkVersion&lt;/code&gt; and &lt;code&gt;targetSdkVersion&lt;/code&gt; are usually numbers, but can be strings when you are using an add-on (in the case of &lt;code&gt;compileSdkVersion&lt;/code&gt;) or a preview platform (for the other two properties).&lt;br/&gt;
&lt;br/&gt;
However, you can not use a number as a string (e.g. "19" instead of 19); that will result in a platform not found error message at build/sync time.&lt;br&gt;&lt;br&gt;Issue id: StringShouldBeInt&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintCheckResult" defaultSeverity="WARNING" displayName="Ignoring results" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Ignoring results&lt;br&gt;&lt;br&gt;Some methods have no side effects, and calling them without doing something without the result is suspicious.&lt;br&gt;&lt;br&gt;Issue id: CheckResult&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintInternalInsetResource" defaultSeverity="WARNING" displayName="Using internal inset dimension resource" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using internal inset dimension resource&lt;br&gt;&lt;br&gt;The internal inset dimension resources are not a supported way to retrieve the relevant insets for your application. The insets are dynamic values that can change while your app is visible, and your app's window may not intersect with the system UI. To get the relevant value for your app and listen to updates, use &lt;code&gt;androidx.core.view.WindowInsetsCompat&lt;/code&gt; and related APIs.&lt;br&gt;&lt;br&gt;Issue id: InternalInsetResource&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMissingIntentFilterForMediaSearch" defaultSeverity="ERROR" displayName="Missing MEDIA_PLAY_FROM_SEARCH intent-filter" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing MEDIA_PLAY_FROM_SEARCH intent-filter&lt;br&gt;&lt;br&gt;To support voice searches on Android Auto, you should also register an &lt;code&gt;intent-filter&lt;/code&gt; for the action &lt;code&gt;android.media.action.MEDIA_PLAY_FROM_SEARCH&lt;/code&gt;.&lt;br/&gt;
&lt;br/&gt;
To do this, add
&lt;pre&gt;
`&amp;lt;intent-filter&gt;`
    `&amp;lt;action android:name="android.media.action.MEDIA_PLAY_FROM_SEARCH" /&gt;`
`&amp;lt;/intent-filter&gt;`
&lt;/pre&gt;
to your &lt;code&gt;&amp;lt;activity&gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;service&gt;&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: MissingIntentFilterForMediaSearch&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/training/auto/audio/index.html#support_voice"&gt;https://developer.android.com/training/auto/audio/index.html#support_voice&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintDiscouragedPrivateApi" defaultSeverity="WARNING" displayName="Using Discouraged Private API" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using Discouraged Private API&lt;br&gt;&lt;br&gt;Usage of restricted non-SDK interface may throw an exception at runtime. Accessing non-SDK methods or fields through reflection has a high likelihood to break your app between versions, and is being restricted to facilitate future app compatibility.&lt;br&gt;&lt;br&gt;Issue id: DiscouragedPrivateApi&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/preview/restrictions-non-sdk-interfaces"&gt;https://developer.android.com/preview/restrictions-non-sdk-interfaces&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintWrongRegion" defaultSeverity="WARNING" displayName="Suspicious Language/Region Combination" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Suspicious Language/Region Combination&lt;br&gt;&lt;br&gt;Android uses the letter codes ISO 639-1 for languages, and the letter codes ISO 3166-1 for the region codes. In many cases, the language code and the country where the language is spoken is the same, but it is also often not the case. For example, while 'se' refers to Sweden, where Swedish is spoken, the language code for Swedish is &lt;b&gt;not&lt;/b&gt; &lt;code&gt;se&lt;/code&gt; (which refers to the Northern Sami language), the language code is &lt;code&gt;sv&lt;/code&gt;. And similarly the region code for &lt;code&gt;sv&lt;/code&gt; is El Salvador.&lt;br/&gt;
&lt;br/&gt;
This lint check looks for suspicious language and region combinations, to help catch cases where you've accidentally used the wrong language or region code. Lint knows about the most common regions where a language is spoken, and if a folder combination is not one of these, it is flagged as suspicious.&lt;br/&gt;
&lt;br/&gt;
Note however that it may not be an error: you can theoretically have speakers of any language in any region and want to target that with your resources, so this check is aimed at tracking down likely mistakes, not to enforce a specific set of region and language combinations.&lt;br&gt;&lt;br&gt;Issue id: WrongRegion&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintOverrideAbstract" defaultSeverity="ERROR" displayName="Not overriding abstract methods on older platforms" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Not overriding abstract methods on older platforms&lt;br&gt;&lt;br&gt;To improve the usability of some APIs, some methods that used to be &lt;code&gt;abstract&lt;/code&gt; have been made concrete by adding default implementations. This means that when compiling with new versions of the SDK, your code does not have to override these methods.&lt;br/&gt;
&lt;br/&gt;
However, if your code is also targeting older versions of the platform where these methods were still &lt;code&gt;abstract&lt;/code&gt;, the code will crash. You must override all methods that used to be abstract in any versions targeted by your application's &lt;code&gt;minSdkVersion&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: OverrideAbstract&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMotionLayoutMissingId" defaultSeverity="ERROR" displayName="Views inside MotionLayout require an id" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Views inside &lt;code&gt;MotionLayout&lt;/code&gt; require an &lt;code&gt;android:id&lt;/code&gt;&lt;br&gt;&lt;br&gt;Views inside &lt;code&gt;MotionLayout&lt;/code&gt; require an &lt;code&gt;android:id&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: MotionLayoutMissingId&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintInconsistentLayout" defaultSeverity="WARNING" displayName="Inconsistent Layouts" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Inconsistent Layouts&lt;br&gt;&lt;br&gt;This check ensures that a layout resource which is defined in multiple resource folders, specifies the same set of widgets.&lt;br/&gt;
&lt;br/&gt;
This finds cases where you have accidentally forgotten to add a widget to all variations of the layout, which could result in a runtime crash for some resource configurations when a &lt;code&gt;findViewById()&lt;/code&gt; fails.&lt;br/&gt;
&lt;br/&gt;
There &lt;b&gt;are&lt;/b&gt; cases where this is intentional. For example, you may have a dedicated large tablet layout which adds some extra widgets that are not present in the phone version of the layout. As long as the code accessing the layout resource is careful to handle this properly, it is valid. In that case, you can suppress this lint check for the given extra or missing views, or the whole layout&lt;br&gt;&lt;br&gt;Issue id: InconsistentLayout&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintWearableActionDuplicate" defaultSeverity="WARNING" displayName="Duplicate watch face configuration activities found" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Duplicate watch face configuration activities found&lt;br&gt;&lt;br&gt;If and only if a watch face service defines &lt;code&gt;wearableConfigurationAction&lt;/code&gt; metadata, with the value &lt;code&gt;WATCH_FACE_EDITOR&lt;/code&gt;, there should be an activity in the same package, which has an intent filter for &lt;code&gt;WATCH_FACE_EDITOR&lt;/code&gt; (with com.google.android.wearable.watchface.category.WEARABLE_CONFIGURATION if minSdkVersion is less than 30).&lt;br&gt;&lt;br&gt;Issue id: WearableActionDuplicate&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/training/wearables/watch-faces/configuration"&gt;https://developer.android.com/training/wearables/watch-faces/configuration&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintInstantiatable" defaultSeverity="ERROR" displayName="Registered class is not instantiatable" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Registered class is not instantiatable&lt;br&gt;&lt;br&gt;Activities, services, broadcast receivers etc. registered in the manifest file (or for custom views, in a layout file) must be "instantiatable" by the system, which means that the class must be public, it must have an empty public constructor, and if it's an inner class, it must be a static inner class.&lt;br&gt;&lt;br&gt;Issue id: Instantiatable&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintDeprecated" defaultSeverity="WARNING" displayName="Using deprecated resources" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using deprecated resources&lt;br&gt;&lt;br&gt;Deprecated views, attributes and so on are deprecated because there is a better way to do something. Do it that new way. You've been warned.&lt;br&gt;&lt;br&gt;Issue id: Deprecated&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMotionSceneFileValidationError" defaultSeverity="ERROR" displayName="Validation errors in MotionScene files" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Validation errors in &lt;code&gt;MotionScene&lt;/code&gt; files&lt;br&gt;&lt;br&gt;A motion scene file specifies the animations used in a &lt;code&gt;MotionLayout&lt;/code&gt;. This check performs various serious correctness checks in a motion scene file.&lt;br&gt;&lt;br&gt;Issue id: MotionSceneFileValidationError&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintParcelCreator" defaultSeverity="ERROR" displayName="Missing Parcelable CREATOR field" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing Parcelable &lt;code&gt;CREATOR&lt;/code&gt; field&lt;br&gt;&lt;br&gt;According to the &lt;code&gt;Parcelable&lt;/code&gt; interface documentation, "Classes implementing the Parcelable interface must also have a static field called &lt;code&gt;CREATOR&lt;/code&gt;, which is an object implementing the &lt;code&gt;Parcelable.Creator&lt;/code&gt; interface."&lt;br&gt;&lt;br&gt;Issue id: ParcelCreator&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/reference/android/os/Parcelable.html"&gt;https://developer.android.com/reference/android/os/Parcelable.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMissingInflatedId" defaultSeverity="ERROR" displayName="ID not found in inflated resource" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;ID not found in inflated resource&lt;br&gt;&lt;br&gt;Checks calls to layout inflation and makes sure that the referenced ids are found in the corresponding layout (or at least one of them, if the layout has multiple configurations.)&lt;br&gt;&lt;br&gt;Issue id: MissingInflatedId&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintCanvasSize" defaultSeverity="WARNING" displayName="Wrong Canvas Size" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Wrong Canvas Size&lt;br&gt;&lt;br&gt;In a custom view's draw implementation, you should normally call &lt;code&gt;getWidth&lt;/code&gt; and &lt;code&gt;getHeight&lt;/code&gt; on the custom view itself, not on the &lt;code&gt;canvas&lt;/code&gt; instance.&lt;br/&gt;
&lt;br/&gt;
Canvas width and height are the width and height of the &lt;code&gt;Canvas&lt;/code&gt;, which is not always the same as size of the view.&lt;br/&gt;
&lt;br/&gt;
In the hardware accelerated path the width and height of the canvas typically always match that of the &lt;code&gt;View&lt;/code&gt; because every view goes to its own recorded &lt;code&gt;DisplayList&lt;/code&gt;. But in software rendering there's just one canvas that is clipped and transformed as it makes its way through the &lt;code&gt;View&lt;/code&gt; tree, and otherwise remains the same &lt;code&gt;Canvas&lt;/code&gt; object for every View's draw method.&lt;br/&gt;
&lt;br/&gt;
You should only use Canvas state to adjust how much you draw, such as a quick-reject for early work avoidance if it's going to be clipped away, but not what you draw.&lt;br&gt;&lt;br&gt;Issue id: CanvasSize&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintObjectAnimatorBinding" defaultSeverity="ERROR" displayName="Incorrect ObjectAnimator Property" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Incorrect ObjectAnimator Property&lt;br&gt;&lt;br&gt;This check cross references properties referenced by String from &lt;code&gt;ObjectAnimator&lt;/code&gt; and &lt;code&gt;PropertyValuesHolder&lt;/code&gt; method calls and ensures that the corresponding setter methods exist and have the right signatures.&lt;br&gt;&lt;br&gt;Issue id: ObjectAnimatorBinding&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMinSdkTooLow" defaultSeverity="WARNING" displayName="API Version Too Low" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;API Version Too Low&lt;br&gt;&lt;br&gt;The value of the &lt;code&gt;minSdkVersion&lt;/code&gt; property is too low and can be incremented without noticeably reducing the number of supported devices.&lt;br&gt;&lt;br&gt;Issue id: MinSdkTooLow&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintLockedOrientationActivity" defaultSeverity="WARNING" displayName="Incompatible screenOrientation manifest value" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Incompatible screenOrientation value&lt;br&gt;&lt;br&gt;The &lt;code&gt;&amp;lt;activity&gt;&lt;/code&gt; element should not be locked to any orientation so that users can take advantage of the multi-window environments and larger screens available on Android. To fix the issue, consider declaring the corresponding activity element with `screenOrientation="unspecified"&lt;code&gt;or &lt;/code&gt;"fullSensor"` attribute.&lt;br&gt;&lt;br&gt;Issue id: LockedOrientationActivity&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/topic/arc/window-management"&gt;https://developer.android.com/topic/arc/window-management&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMissingTranslation" defaultSeverity="ERROR" displayName="Incomplete translation" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Incomplete translation&lt;br&gt;&lt;br&gt;If an application has more than one locale, then all the strings declared in one language should also be translated in all other languages.&lt;br/&gt;
&lt;br/&gt;
If the string should &lt;b&gt;not&lt;/b&gt; be translated, you can add the attribute &lt;code&gt;translatable="false"&lt;/code&gt; on the &lt;code&gt;&amp;lt;string&gt;&lt;/code&gt; element, or you can define all your non-translatable strings in a resource file called &lt;code&gt;donottranslate.xml&lt;/code&gt;. Or, you can ignore the issue with a &lt;code&gt;tools:ignore="MissingTranslation"&lt;/code&gt; attribute.&lt;br/&gt;
&lt;br/&gt;
You can tell lint (and other tools) which language is the default language in your &lt;code&gt;res/values/&lt;/code&gt; folder by specifying &lt;code&gt;tools:locale="languageCode"&lt;/code&gt; for the root &lt;code&gt;&amp;lt;resources&gt;&lt;/code&gt; element in your resource file. (The &lt;code&gt;tools&lt;/code&gt; prefix refers to the namespace declaration &lt;code&gt;http://schemas.android.com/tools&lt;/code&gt;.)&lt;br&gt;&lt;br&gt;Issue id: MissingTranslation&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintTextViewEdits" defaultSeverity="WARNING" displayName="TextView should probably be an EditText instead" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;TextView should probably be an EditText instead&lt;br&gt;&lt;br&gt;Using a &lt;code&gt;&amp;lt;TextView&gt;&lt;/code&gt; to input text is generally an error, you should be using &lt;code&gt;&amp;lt;EditText&gt;&lt;/code&gt; instead.  &lt;code&gt;EditText&lt;/code&gt; is a subclass of &lt;code&gt;TextView&lt;/code&gt;, and some of the editing support is provided by &lt;code&gt;TextView&lt;/code&gt;, so it's possible to set some input-related properties on a &lt;code&gt;TextView&lt;/code&gt;. However, using a &lt;code&gt;TextView&lt;/code&gt; along with input attributes is usually a cut &amp;amp; paste error. To input text you should be using &lt;code&gt;&amp;lt;EditText&gt;&lt;/code&gt;.&lt;br/&gt;
&lt;br/&gt;
This check also checks subclasses of &lt;code&gt;TextView&lt;/code&gt;, such as &lt;code&gt;Button&lt;/code&gt; and &lt;code&gt;CheckBox&lt;/code&gt;, since these have the same issue: they should not be used with editable attributes.&lt;br&gt;&lt;br&gt;Issue id: TextViewEdits&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintRedundantLabel" defaultSeverity="WARNING" displayName="Redundant label on activity" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Redundant label on activity&lt;br&gt;&lt;br&gt;When an activity does not have a label attribute, it will use the one from the application tag. Since the application has already specified the same label, the label on this activity can be omitted.&lt;br&gt;&lt;br&gt;Issue id: RedundantLabel&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintFileEndsWithExt" defaultSeverity="WARNING" displayName="File endsWith on file extensions" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;File endsWith on file extensions&lt;br&gt;&lt;br&gt;The Kotlin extension method &lt;code&gt;File.endsWith(suffix)&lt;/code&gt; checks whole path components, not just string suffixes. This means that &lt;code&gt;File("foo.txt").endsWith(".txt")&lt;/code&gt; will return false. Instead you might have intended &lt;code&gt;file.path.endsWith&lt;/code&gt; or &lt;code&gt;file.extension.equals&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: FileEndsWithExt&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintStopShip" defaultSeverity="ERROR" displayName="Code contains STOPSHIP marker" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Code contains &lt;code&gt;STOPSHIP&lt;/code&gt; marker&lt;br&gt;&lt;br&gt;Using the comment &lt;code&gt;// STOPSHIP&lt;/code&gt; can be used to flag code that is incomplete but checked in. This comment marker can be used to indicate that the code should not be shipped until the issue is addressed, and lint will look for these. In Gradle projects, this is only checked for non-debug (release) builds.&lt;br/&gt;
&lt;br/&gt;
In Kotlin, the &lt;code&gt;TODO()&lt;/code&gt; method is also treated as a stop ship marker; you can use it to make incomplete code compile, but it will throw an exception at runtime and therefore should be fixed before shipping releases.&lt;br&gt;&lt;br&gt;Issue id: StopShip&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintGradleOverrides" defaultSeverity="WARNING" displayName="Value overridden by Gradle build script" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Value overridden by Gradle build script&lt;br&gt;&lt;br&gt;The value of (for example) &lt;code&gt;minSdkVersion&lt;/code&gt; is only used if it is not specified in the &lt;code&gt;build.gradle&lt;/code&gt; build scripts. When specified in the Gradle build scripts, the manifest value is ignored and can be misleading, so should be removed to avoid ambiguity.&lt;br&gt;&lt;br&gt;Issue id: GradleOverrides&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintInvalidAnalyticsName" defaultSeverity="ERROR" displayName="Invalid Analytics Name" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Invalid Analytics Name&lt;br&gt;&lt;br&gt;Event names and parameters must follow the naming conventions defined in the`FirebaseAnalytics#logEvent()` documentation.&lt;br&gt;&lt;br&gt;Issue id: InvalidAnalyticsName&lt;br&gt;&lt;br&gt;&lt;a href="https://firebase.google.com/docs/reference/android/com/google/firebase/analytics/FirebaseAnalytics#logEvent(java.lang.String,%20android.os.Bundle)"&gt;https://firebase.google.com/docs/reference/android/com/google/firebase/analytics/FirebaseAnalytics#logEvent(java.lang.String,%20android.os.Bundle)&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintSimpleDateFormat" defaultSeverity="WARNING" displayName="Implied locale in date format" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Implied locale in date format&lt;br&gt;&lt;br&gt;Almost all callers should use &lt;code&gt;getDateInstance()&lt;/code&gt;, &lt;code&gt;getDateTimeInstance()&lt;/code&gt;, or &lt;code&gt;getTimeInstance()&lt;/code&gt; to get a ready-made instance of SimpleDateFormat suitable for the user's locale. The main reason you'd create an instance this class directly is because you need to format/parse a specific machine-readable format, in which case you almost certainly want to explicitly ask for US to ensure that you get ASCII digits (rather than, say, Arabic digits).&lt;br/&gt;
&lt;br/&gt;
Therefore, you should either use the form of the SimpleDateFormat constructor where you pass in an explicit locale, such as Locale.US, or use one of the get instance methods, or suppress this error if really know what you are doing.&lt;br&gt;&lt;br&gt;Issue id: SimpleDateFormat&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/reference/java/text/SimpleDateFormat.html"&gt;https://developer.android.com/reference/java/text/SimpleDateFormat.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintInvalidWakeLockTag" defaultSeverity="ERROR" displayName="Invalid Wake Lock Tag" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Invalid Wake Lock Tag&lt;br&gt;&lt;br&gt;Wake Lock tags must follow the naming conventions defined in the`PowerManager` documentation.&lt;br&gt;&lt;br&gt;Issue id: InvalidWakeLockTag&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/reference/android/os/PowerManager.html"&gt;https://developer.android.com/reference/android/os/PowerManager.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintCommitPrefEdits" defaultSeverity="WARNING" displayName="Missing commit() on SharedPreference editor" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing &lt;code&gt;commit()&lt;/code&gt; on &lt;code&gt;SharedPreference&lt;/code&gt; editor&lt;br&gt;&lt;br&gt;After calling &lt;code&gt;edit()&lt;/code&gt; on a &lt;code&gt;SharedPreference&lt;/code&gt;, you must call &lt;code&gt;commit()&lt;/code&gt; or &lt;code&gt;apply()&lt;/code&gt; on the editor to save the results.&lt;br&gt;&lt;br&gt;Issue id: CommitPrefEdits&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintGridLayout" defaultSeverity="ERROR" displayName="GridLayout validation" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;GridLayout validation&lt;br&gt;&lt;br&gt;Declaring a layout_row or layout_column that falls outside the declared size of a GridLayout's &lt;code&gt;rowCount&lt;/code&gt; or &lt;code&gt;columnCount&lt;/code&gt; is usually an unintentional error.&lt;br&gt;&lt;br&gt;Issue id: GridLayout&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintInvalidImeActionId" defaultSeverity="ERROR" displayName="Invalid imeActionId declaration" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Invalid imeActionId declaration&lt;br&gt;&lt;br&gt;&lt;code&gt;android:imeActionId&lt;/code&gt; should not be a resource ID such as &lt;code&gt;@+id/resName&lt;/code&gt;. It must be an integer constant, or an integer resource reference, as defined in &lt;code&gt;EditorInfo&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: InvalidImeActionId&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/reference/android/view/inputmethod/EditorInfo.html"&gt;https://developer.android.com/reference/android/view/inputmethod/EditorInfo.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintIntentReset" defaultSeverity="WARNING" displayName="Suspicious mix of setType and setData" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Suspicious mix of &lt;code&gt;setType&lt;/code&gt; and &lt;code&gt;setData&lt;/code&gt;&lt;br&gt;&lt;br&gt;Intent provides the following APIs: &lt;code&gt;setData(Uri)&lt;/code&gt; and &lt;code&gt;setType(String)&lt;/code&gt;. Unfortunately, setting one clears the other. If you want to set both, you should call &lt;code&gt;setDataAndType(Uri, String)&lt;/code&gt; instead.&lt;br&gt;&lt;br&gt;Issue id: IntentReset&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintVectorRaster" defaultSeverity="WARNING" displayName="Vector Image Generation" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Vector Image Generation&lt;br&gt;&lt;br&gt;Vector icons require API 21 or API 24 depending on used features, but when &lt;code&gt;minSdkVersion&lt;/code&gt; is less than 21 or 24 and Android Gradle plugin 1.4 or higher is used, a vector drawable placed in the &lt;code&gt;drawable&lt;/code&gt; folder is automatically moved to &lt;code&gt;drawable-anydpi-v21&lt;/code&gt; or &lt;code&gt;drawable-anydpi-v24&lt;/code&gt; and bitmap images are generated for different screen resolutions for backwards compatibility.&lt;br/&gt;
&lt;br/&gt;
However, there are some limitations to this raster image generation, and this lint check flags elements and attributes that are not fully supported. You should manually check whether the generated output is acceptable for those older devices.&lt;br&gt;&lt;br&gt;Issue id: VectorRaster&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMangledCRLF" defaultSeverity="ERROR" displayName="Mangled file line endings" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Mangled file line endings&lt;br&gt;&lt;br&gt;On Windows, line endings are typically recorded as carriage return plus newline: \r\n.&lt;br/&gt;
&lt;br/&gt;
This detector looks for invalid line endings with repeated carriage return characters (without newlines). Previous versions of the ADT plugin could accidentally introduce these into the file, and when editing the file, the editor could produce confusing visual artifacts.&lt;br&gt;&lt;br&gt;Issue id: MangledCRLF&lt;br&gt;&lt;br&gt;&lt;a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=375421"&gt;https://bugs.eclipse.org/bugs/show_bug.cgi?id=375421&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintValidRestrictions" defaultSeverity="ERROR" displayName="Invalid Restrictions Descriptor" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Invalid Restrictions Descriptor&lt;br&gt;&lt;br&gt;Ensures that an applications restrictions XML file is properly formed&lt;br&gt;&lt;br&gt;Issue id: ValidRestrictions&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/reference/android/content/RestrictionsManager.html"&gt;https://developer.android.com/reference/android/content/RestrictionsManager.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintCustomSplashScreen" defaultSeverity="WARNING" displayName="Application-defined Launch Screen" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Application-defined Launch Screen&lt;br&gt;&lt;br&gt;Starting in Android 12 (API 31+), the application's Launch Screen is provided by the system and the application should not create its own, otherwise the user will see two splashscreens. Please check the &lt;code&gt;SplashScreen&lt;/code&gt; class to check how the Splash Screen can be controlled and customized.&lt;br&gt;&lt;br&gt;Issue id: CustomSplashScreen&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/topics/ui/splash-screen"&gt;https://developer.android.com/guide/topics/ui/splash-screen&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintWrongConstant" defaultSeverity="ERROR" displayName="Incorrect constant" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Incorrect constant&lt;br&gt;&lt;br&gt;Ensures that when parameter in a method only allows a specific set of constants, calls obey those rules.&lt;br&gt;&lt;br&gt;Issue id: WrongConstant&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMutatingSharedPrefs" defaultSeverity="WARNING" displayName="Mutating an Immutable SharedPrefs Set" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Mutating an Immutable SharedPrefs Set&lt;br&gt;&lt;br&gt;As stated in the docs for &lt;code&gt;SharedPreferences.getStringSet&lt;/code&gt;, you must not modify the set returned by &lt;code&gt;getStringSet&lt;/code&gt;:&lt;br/&gt;
&lt;br/&gt;
  "Note that you &amp;lt;em&gt;must not&amp;lt;/em&gt; modify the set instance returned    by this call.  The consistency of the stored data is not guaranteed    if you do, nor is your ability to modify the instance at all."&lt;br&gt;&lt;br&gt;Issue id: MutatingSharedPrefs&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintFontValidation" defaultSeverity="ERROR" displayName="Validation of font files" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Validation of font files&lt;br&gt;&lt;br&gt;Look for problems in various font files.&lt;br&gt;&lt;br&gt;Issue id: FontValidation&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/topics/text/downloadable-fonts.html"&gt;https://developer.android.com/guide/topics/text/downloadable-fonts.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintHalfFloat" defaultSeverity="ERROR" displayName="Incorrect Half Float" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Incorrect Half Float&lt;br&gt;&lt;br&gt;Half-precision floating point are stored in a short data type, and should be manipulated using the &lt;code&gt;android.util.Half&lt;/code&gt; class. This check flags usages where it appears that these values are used incorrectly.&lt;br&gt;&lt;br&gt;Issue id: HalfFloat&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMissingTvBanner" defaultSeverity="ERROR" displayName="TV Missing Banner" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;TV Missing Banner&lt;br&gt;&lt;br&gt;A TV application must provide a home screen banner for each localization if it includes a Leanback launcher intent filter. The banner is the app launch point that appears on the home screen in the apps and games rows.&lt;br&gt;&lt;br&gt;Issue id: MissingTvBanner&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/training/tv/start/start.html#banner"&gt;https://developer.android.com/training/tv/start/start.html#banner&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMissingSuperCall" defaultSeverity="ERROR" displayName="Missing Super Call" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing Super Call&lt;br&gt;&lt;br&gt;Some methods, such as &lt;code&gt;View#onDetachedFromWindow&lt;/code&gt;, require that you also call the super implementation as part of your method.&lt;br&gt;&lt;br&gt;Issue id: MissingSuperCall&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintGradleDependency" defaultSeverity="WARNING" displayName="Obsolete Gradle Dependency" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Obsolete Gradle Dependency&lt;br&gt;&lt;br&gt;This detector looks for usages of libraries where the version you are using is not the current stable release. Using older versions is fine, and there are cases where you deliberately want to stick with an older version. However, you may simply not be aware that a more recent version is available, and that is what this lint check helps find.&lt;br&gt;&lt;br&gt;Issue id: GradleDependency&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintJobSchedulerService" defaultSeverity="WARNING" displayName="JobScheduler problems" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;JobScheduler problems&lt;br&gt;&lt;br&gt;This check looks for various common mistakes in using the JobScheduler API: the service class must extend &lt;code&gt;JobService&lt;/code&gt;, the service must be registered in the manifest and the registration must require the permission &lt;code&gt;android.permission.BIND_JOB_SERVICE&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: JobSchedulerService&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/topic/performance/scheduling.html"&gt;https://developer.android.com/topic/performance/scheduling.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintWearableConfigurationAction" defaultSeverity="WARNING" displayName="Wear configuration action metadata must match an activity" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Wear configuration action metadata must match an activity&lt;br&gt;&lt;br&gt;Only when a watch face service defines &lt;code&gt;wearableConfigurationAction&lt;/code&gt; metadata, with the value &lt;code&gt;WATCH_FACE_EDITOR&lt;/code&gt;, there should be an activity in the same package, which has an intent filter for &lt;code&gt;WATCH_FACE_EDITOR&lt;/code&gt; (with &lt;code&gt;com.google.android.wearable.watchface.category.WEARABLE_CONFIGURATION&lt;/code&gt; if &lt;code&gt;minSdkVersion&lt;/code&gt; is less than 30).&lt;br&gt;&lt;br&gt;Issue id: WearableConfigurationAction&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/training/wearables/watch-faces/configuration"&gt;https://developer.android.com/training/wearables/watch-faces/configuration&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMissingOnPlayFromSearch" defaultSeverity="ERROR" displayName="Missing onPlayFromSearch." enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing &lt;code&gt;onPlayFromSearch&lt;/code&gt;&lt;br&gt;&lt;br&gt;To support voice searches on Android Auto, in addition to adding an &lt;code&gt;intent-filter&lt;/code&gt; for the action &lt;code&gt;onPlayFromSearch&lt;/code&gt;, you also need to override and implement &lt;code&gt;onPlayFromSearch(String query, Bundle bundle)&lt;/code&gt;&lt;br&gt;&lt;br&gt;Issue id: MissingOnPlayFromSearch&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/training/auto/audio/index.html#support_voice"&gt;https://developer.android.com/training/auto/audio/index.html#support_voice&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintDiscouragedApi" defaultSeverity="WARNING" displayName="Using discouraged APIs" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using discouraged APIs&lt;br&gt;&lt;br&gt;Discouraged APIs are allowed and are not deprecated, but they may be unfit for common use (e.g. due to slow performance or subtle behavior).&lt;br&gt;&lt;br&gt;Issue id: DiscouragedApi&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintManifestOrder" defaultSeverity="WARNING" displayName="Incorrect order of elements in manifest" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Incorrect order of elements in manifest&lt;br&gt;&lt;br&gt;The &lt;code&gt;&amp;lt;application&gt;&lt;/code&gt; tag should appear after the elements which declare which version you need, which features you need, which libraries you need, and so on. In the past there have been subtle bugs (such as themes not getting applied correctly) when the &lt;code&gt;&amp;lt;application&gt;&lt;/code&gt; tag appears before some of these other elements, so it's best to order your manifest in the logical dependency order.&lt;br&gt;&lt;br&gt;Issue id: ManifestOrder&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintTranslucentOrientation" defaultSeverity="WARNING" displayName="Mixing screenOrientation and translucency" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Mixing screenOrientation and translucency&lt;br&gt;&lt;br&gt;Specifying a fixed screen orientation with a translucent theme isn't supported on apps with &lt;code&gt;targetSdkVersion&lt;/code&gt; O or greater since there can be an another activity visible behind your activity with a conflicting request.&lt;br/&gt;
&lt;br/&gt;
For example, your activity requests landscape and the visible activity behind your translucent activity request portrait. In this case the system can only honor one of the requests and currently prefers to honor the request from non-translucent activities since there is nothing visible behind them.&lt;br/&gt;
&lt;br/&gt;
Devices running platform version O or greater will throw an exception in your app if this state is detected.&lt;br&gt;&lt;br&gt;Issue id: TranslucentOrientation&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintAppBundleLocaleChanges" defaultSeverity="WARNING" displayName="App Bundle handling of runtime locale changes" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;App Bundle handling of runtime locale changes&lt;br&gt;&lt;br&gt;When changing locales at runtime (e.g. to provide an in-app language switcher), the Android App Bundle must be configured to not split by locale or the Play Core library must be used to download additional locales at runtime.&lt;br&gt;&lt;br&gt;Issue id: AppBundleLocaleChanges&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/app-bundle/configure-base#handling_language_changes"&gt;https://developer.android.com/guide/app-bundle/configure-base#handling_language_changes&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUniqueConstants" defaultSeverity="ERROR" displayName="Overlapping Enumeration Constants" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Overlapping Enumeration Constants&lt;br&gt;&lt;br&gt;The &lt;code&gt;@IntDef&lt;/code&gt; annotation allows you to create a light-weight "enum" or type definition. However, it's possible to accidentally specify the same value for two or more of the values, which can lead to hard-to-detect bugs. This check looks for this scenario and flags any repeated constants.&lt;br/&gt;
&lt;br/&gt;
In some cases, the repeated constant is intentional (for example, renaming a constant to a more intuitive name, and leaving the old name in place for compatibility purposes).  In that case, simply suppress this check by adding a &lt;code&gt;@SuppressLint("UniqueConstants")&lt;/code&gt; annotation.&lt;br&gt;&lt;br&gt;Issue id: UniqueConstants&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintJcenterRepositoryObsolete" defaultSeverity="WARNING" displayName="JCenter Repository Obsolete" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;JCenter Maven repository is read-only&lt;br&gt;&lt;br&gt;The JCenter Maven repository is no longer accepting submissions of Maven artifacts since 31st March 2021.  Ensure that the project is configured to search in repositories with the latest versions of its dependencies.&lt;br&gt;&lt;br&gt;Issue id: JcenterRepositoryObsolete&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/r/tools/jcenter-end-of-service"&gt;https://developer.android.com/r/tools/jcenter-end-of-service&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintPrivateResource" defaultSeverity="WARNING" displayName="Using private resources" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using private resources&lt;br&gt;&lt;br&gt;Private resources should not be referenced; the may not be present everywhere, and even where they are they may disappear without notice.&lt;br/&gt;
&lt;br/&gt;
To fix this, copy the resource into your own project instead.&lt;br&gt;&lt;br&gt;Issue id: PrivateResource&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintPendingBindings" defaultSeverity="ERROR" displayName="Missing Pending Bindings" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing Pending Bindings&lt;br&gt;&lt;br&gt;When using a &lt;code&gt;ViewDataBinding&lt;/code&gt; in a &lt;code&gt;onBindViewHolder&lt;/code&gt; method, you &lt;b&gt;must&lt;/b&gt; call &lt;code&gt;executePendingBindings()&lt;/code&gt; before the method exits; otherwise the data binding runtime will update the UI in the next animation frame causing a delayed update and potential jumps if the item resizes.&lt;br&gt;&lt;br&gt;Issue id: PendingBindings&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintStringFormatMatches" defaultSeverity="ERROR" displayName="String.format string doesn't match the XML format string" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;&lt;code&gt;String.format&lt;/code&gt; string doesn't match the XML format string&lt;br&gt;&lt;br&gt;This lint check ensures the following:&lt;br/&gt;
(1) If there are multiple translations of the format string, then all translations use the same type for the same numbered arguments&lt;br/&gt;
(2) The usage of the format string in Java is consistent with the format string, meaning that the parameter types passed to String.format matches those in the format string.&lt;br&gt;&lt;br&gt;Issue id: StringFormatMatches&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintBlockedPrivateApi" defaultSeverity="ERROR" displayName="Using Blocked Private API" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using Blocked Private API&lt;br&gt;&lt;br&gt;Usage of restricted non-SDK interface is forbidden for this targetSDK. Accessing non-SDK methods or fields through reflection has a high likelihood to break your app between versions, and is being restricted to facilitate future app compatibility.&lt;br&gt;&lt;br&gt;Issue id: BlockedPrivateApi&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/preview/restrictions-non-sdk-interfaces"&gt;https://developer.android.com/preview/restrictions-non-sdk-interfaces&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintRestrictedApi" defaultSeverity="ERROR" displayName="Restricted API" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Restricted API&lt;br&gt;&lt;br&gt;This API has been flagged with a restriction that has not been met.&lt;br/&gt;
&lt;br/&gt;
Examples of API restrictions:&lt;br/&gt;
* Method can only be invoked by a subclass&lt;br/&gt;
* Method can only be accessed from within the same library (defined by the Gradle library group id)&lt;br/&gt;
* Method can only be accessed from tests.&lt;br/&gt;
&lt;br/&gt;
You can add your own API restrictions with the &lt;code&gt;@RestrictTo&lt;/code&gt; annotation.&lt;br&gt;&lt;br&gt;Issue id: RestrictedApi&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintIntentFilterUniqueDataAttributes" defaultSeverity="WARNING" displayName="Data tags should only declare unique attributes" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Data tags should only declare unique attributes&lt;br&gt;&lt;br&gt;&lt;code&gt;&amp;lt;intent-filter&gt;&lt;/code&gt; &lt;code&gt;&amp;lt;data&gt;&lt;/code&gt; tags should only declare a single unique attribute (i.e. scheme OR host, but not both). This better matches the runtime behavior of intent filters, as they combine all of the declared data attributes into a single matcher which is allowed to handle any combination across attribute types.&lt;br/&gt;
&lt;br/&gt;
For example, the following two &lt;code&gt;&amp;lt;intent-filter&gt;&lt;/code&gt; declarations are the same:
&lt;pre&gt;
&amp;lt;intent-filter&gt;
    &amp;lt;data android:scheme="http" android:host="example.com" /&gt;
    &amp;lt;data android:scheme="https" android:host="example.org" /&gt;
&amp;lt;/intent-filter&gt;
&lt;/pre&gt;

&lt;pre&gt;
&amp;lt;intent-filter&gt;
    &amp;lt;data android:scheme="http"/&gt;
    &amp;lt;data android:scheme="https"/&gt;
    &amp;lt;data android:host="example.com" /&gt;
    &amp;lt;data android:host="example.org" /&gt;
&amp;lt;/intent-filter&gt;
&lt;/pre&gt;
&lt;br/&gt;
They both handle all of the following:&lt;br/&gt;
* &lt;a href="http://example.com"&gt;http://example.com&lt;/a&gt;&lt;br/&gt;
* &lt;a href="https://example.com"&gt;https://example.com&lt;/a&gt;&lt;br/&gt;
* &lt;a href="http://example.org"&gt;http://example.org&lt;/a&gt;&lt;br/&gt;
* &lt;a href="https://example.org"&gt;https://example.org&lt;/a&gt;&lt;br/&gt;
&lt;br/&gt;
The second one better communicates the combining behavior and is clearer to an external reader that one should not rely on the scheme/host being self contained. It is not obvious in the first that &lt;a href="http://example.org"&gt;http://example.org&lt;/a&gt; is also matched, which can lead to confusion (or incorrect behavior) with a more complex set of schemes/hosts.&lt;br/&gt;
&lt;br/&gt;
Note that this does not apply to host + port, as those must be declared in the same &lt;code&gt;&amp;lt;data&gt;&lt;/code&gt; tag and are only associated with each other.&lt;br&gt;&lt;br&gt;Issue id: IntentFilterUniqueDataAttributes&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/components/intents-filters"&gt;https://developer.android.com/guide/components/intents-filters&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintRegistered" defaultSeverity="WARNING" displayName="Class is not registered in the manifest" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Class is not registered in the manifest&lt;br&gt;&lt;br&gt;Activities, services and content providers should be registered in the &lt;code&gt;AndroidManifest.xml&lt;/code&gt; file using &lt;code&gt;&amp;lt;activity&gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;service&gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;provider&gt;&lt;/code&gt; tags.&lt;br/&gt;
&lt;br/&gt;
If your activity is simply a parent class intended to be subclassed by other "real" activities, make it an abstract class.&lt;br&gt;&lt;br&gt;Issue id: Registered&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/topics/manifest/manifest-intro.html"&gt;https://developer.android.com/guide/topics/manifest/manifest-intro.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintWatchFaceEditor" defaultSeverity="WARNING" displayName="Watch face editor with incorrect launchMode" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Watch face editor must use launchMode="standard"&lt;br&gt;&lt;br&gt;Watch face editor activities must be able to launch in the Wear OS app activity task in order to work correctly. Thus only &lt;code&gt;launchMode="standard"&lt;/code&gt; is allowed. The watch face will not be shown on the watch if it does not satisfy this requirement.&lt;br&gt;&lt;br&gt;Issue id: WatchFaceEditor&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintWebViewLayout" defaultSeverity="ERROR" displayName="WebViews in wrap_content parents" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;WebViews in wrap_content parents&lt;br&gt;&lt;br&gt;The WebView implementation has certain performance optimizations which will not work correctly if the parent view is using &lt;code&gt;wrap_content&lt;/code&gt; rather than &lt;code&gt;match_parent&lt;/code&gt;. This can lead to subtle UI bugs.&lt;br&gt;&lt;br&gt;Issue id: WebViewLayout&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintBatteryLife" defaultSeverity="WARNING" displayName="Battery Life Issues" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Battery Life Issues&lt;br&gt;&lt;br&gt;This issue flags code that either&lt;br/&gt;
* negatively affects battery life, or&lt;br/&gt;
* uses APIs that have recently changed behavior to prevent background tasks from consuming memory and battery excessively.&lt;br/&gt;
&lt;br/&gt;
Generally, you should be using &lt;code&gt;WorkManager&lt;/code&gt; instead.&lt;br/&gt;
&lt;br/&gt;
For more details on how to update your code, please see &lt;a href="https://developer.android.com/topic/performance/background-optimization"&gt;https://developer.android.com/topic/performance/background-optimization&lt;/a&gt;&lt;br&gt;&lt;br&gt;Issue id: BatteryLife&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintImpliedQuantity" defaultSeverity="ERROR" displayName="Implied Quantities" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Implied Quantities&lt;br&gt;&lt;br&gt;Plural strings should generally include a &lt;code&gt;%s&lt;/code&gt; or &lt;code&gt;%d&lt;/code&gt; formatting argument. In locales like English, the &lt;code&gt;one&lt;/code&gt; quantity only applies to a single value, 1, but that's not true everywhere. For example, in Slovene, the &lt;code&gt;one&lt;/code&gt; quantity will apply to 1, 101, 201, 301, and so on. Similarly, there are locales where multiple values match the &lt;code&gt;zero&lt;/code&gt; and &lt;code&gt;two&lt;/code&gt; quantities.&lt;br/&gt;
&lt;br/&gt;
In these locales, it is usually an error to have a message which does not include a formatting argument (such as '%d'), since it will not be clear from the grammar what quantity the quantity string is describing.&lt;br&gt;&lt;br&gt;Issue id: ImpliedQuantity&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/topics/resources/string-resource.html#Plurals"&gt;https://developer.android.com/guide/topics/resources/string-resource.html#Plurals&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMissingFirebaseInstanceTokenRefresh" defaultSeverity="WARNING" displayName="Missing Firebase Messaging Callback" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing Firebase Messaging Callback&lt;br&gt;&lt;br&gt;Apps that use Firebase Cloud Messaging should implement the &lt;code&gt;FirebaseMessagingService#onNewToken()&lt;/code&gt; callback in order to observe token changes.&lt;br&gt;&lt;br&gt;Issue id: MissingFirebaseInstanceTokenRefresh&lt;br&gt;&lt;br&gt;&lt;a href="https://firebase.google.com/docs/cloud-messaging/android/client#monitor-token-generation"&gt;https://firebase.google.com/docs/cloud-messaging/android/client#monitor-token-generation&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintShiftFlags" defaultSeverity="WARNING" displayName="Dangerous Flag Constant Declaration" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Dangerous Flag Constant Declaration&lt;br&gt;&lt;br&gt;When defining multiple constants for use in flags, the recommended style is to use the form &lt;code&gt;1 &amp;lt;&amp;lt; 2&lt;/code&gt;, &lt;code&gt;1 &amp;lt;&amp;lt; 3&lt;/code&gt;, &lt;code&gt;1 &amp;lt;&amp;lt; 4&lt;/code&gt; and so on to ensure that the constants are unique and non-overlapping.&lt;br&gt;&lt;br&gt;Issue id: ShiftFlags&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintQueryPermissionsNeeded" defaultSeverity="WARNING" displayName="Using APIs affected by query permissions" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using APIs affected by query permissions&lt;br&gt;&lt;br&gt;Apps that target Android 11 cannot query or interact with other installed apps by default. If you need to query or interact with other installed apps, you may need to add a &lt;code&gt;&amp;lt;queries&gt;&lt;/code&gt; declaration in your manifest.&lt;br/&gt;
&lt;br/&gt;
As a corollary, the methods &lt;code&gt;PackageManager#getInstalledPackages&lt;/code&gt; and &lt;code&gt;PackageManager#getInstalledApplications&lt;/code&gt; will no longer return information about all installed apps. To query specific apps or types of apps, you can use methods like &lt;code&gt;PackageManager#getPackageInfo&lt;/code&gt; or &lt;code&gt;PackageManager#queryIntentActivities&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: QueryPermissionsNeeded&lt;br&gt;&lt;br&gt;&lt;a href="https://g.co/dev/packagevisibility"&gt;https://g.co/dev/packagevisibility&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUniquePermission" defaultSeverity="ERROR" displayName="Permission names are not unique" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Permission names are not unique&lt;br&gt;&lt;br&gt;The unqualified names or your permissions must be unique. The reason for this is that at build time, the &lt;code&gt;aapt&lt;/code&gt; tool will generate a class named &lt;code&gt;Manifest&lt;/code&gt; which contains a field for each of your permissions. These fields are named using your permission unqualified names (i.e. the name portion after the last dot).&lt;br/&gt;
&lt;br/&gt;
If more than one permission maps to the same field name, that field will arbitrarily name just one of them.&lt;br&gt;&lt;br&gt;Issue id: UniquePermission&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintCutPasteId" defaultSeverity="WARNING" displayName="Likely cut &amp; paste mistakes" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Likely cut &amp;amp; paste mistakes&lt;br&gt;&lt;br&gt;This lint check looks for cases where you have cut &amp;amp; pasted calls to &lt;code&gt;findViewById&lt;/code&gt; but have forgotten to update the R.id field. It's possible that your code is simply (redundantly) looking up the field repeatedly, but lint cannot distinguish that from a case where you for example want to initialize fields &lt;code&gt;prev&lt;/code&gt; and &lt;code&gt;next&lt;/code&gt; and you cut &amp;amp; pasted &lt;code&gt;findViewById(R.id.prev)&lt;/code&gt; and forgot to update the second initialization to &lt;code&gt;R.id.next&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: CutPasteId&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintRecyclerView" defaultSeverity="ERROR" displayName="RecyclerView Problems" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;RecyclerView Problems&lt;br&gt;&lt;br&gt;&lt;code&gt;RecyclerView&lt;/code&gt; will &lt;b&gt;not&lt;/b&gt; call &lt;code&gt;onBindViewHolder&lt;/code&gt; again when the position of the item changes in the data set unless the item itself is invalidated or the new position cannot be determined.&lt;br/&gt;
&lt;br/&gt;
For this reason, you should &lt;b&gt;only&lt;/b&gt; use the position parameter while acquiring the related data item inside this method, and should &lt;b&gt;not&lt;/b&gt; keep a copy of it.&lt;br/&gt;
&lt;br/&gt;
If you need the position of an item later on (e.g. in a click listener), use &lt;code&gt;getAdapterPosition()&lt;/code&gt; which will have the updated adapter position.&lt;br&gt;&lt;br&gt;Issue id: RecyclerView&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintNetworkSecurityConfig" defaultSeverity="ERROR" displayName="Valid Network Security Config File" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Valid Network Security Config File&lt;br&gt;&lt;br&gt;Ensures that a &lt;code&gt;&amp;lt;network-security-config&gt;&lt;/code&gt; file, which is pointed to by an &lt;code&gt;android:networkSecurityConfig&lt;/code&gt; attribute in the manifest file, is valid&lt;br&gt;&lt;br&gt;Issue id: NetworkSecurityConfig&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/preview/features/security-config.html"&gt;https://developer.android.com/preview/features/security-config.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMissingMediaBrowserServiceIntentFilter" defaultSeverity="ERROR" displayName="Missing MediaBrowserService intent-filter" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing MediaBrowserService intent-filter&lt;br&gt;&lt;br&gt;An Automotive Media App requires an exported service that extends &lt;code&gt;android.service.media.MediaBrowserService&lt;/code&gt; with an &lt;code&gt;intent-filter&lt;/code&gt; for the action &lt;code&gt;android.media.browse.MediaBrowserService&lt;/code&gt; to be able to browse and play media.&lt;br/&gt;
&lt;br/&gt;
To do this, add
&lt;pre&gt;
`&amp;lt;intent-filter&gt;`
    `&amp;lt;action android:name="android.media.browse.MediaBrowserService" /&gt;`
`&amp;lt;/intent-filter&gt;`
&lt;/pre&gt;
to the service that extends &lt;code&gt;android.service.media.MediaBrowserService&lt;/code&gt;&lt;br&gt;&lt;br&gt;Issue id: MissingMediaBrowserServiceIntentFilter&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/training/auto/audio/index.html#config_manifest"&gt;https://developer.android.com/training/auto/audio/index.html#config_manifest&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintVectorDrawableCompat" defaultSeverity="ERROR" displayName="Using VectorDrawableCompat" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using VectorDrawableCompat&lt;br&gt;&lt;br&gt;To use VectorDrawableCompat, you need to make two modifications to your project. First, set &lt;code&gt;android.defaultConfig.vectorDrawables.useSupportLibrary = true&lt;/code&gt; in your &lt;code&gt;build.gradle&lt;/code&gt; file, and second, use &lt;code&gt;app:srcCompat&lt;/code&gt; instead of &lt;code&gt;android:src&lt;/code&gt; to refer to vector drawables.&lt;br&gt;&lt;br&gt;Issue id: VectorDrawableCompat&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/topics/graphics/vector-drawable-resources"&gt;https://developer.android.com/guide/topics/graphics/vector-drawable-resources&lt;/a&gt;&lt;br&gt;&lt;a href="https://medium.com/androiddevelopers/using-vector-assets-in-android-apps-4318fd662eb9"&gt;https://medium.com/androiddevelopers/using-vector-assets-in-android-apps-4318fd662eb9&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintEnqueueWork" defaultSeverity="WARNING" displayName="WorkManager Enqueue" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;WorkManager Enqueue&lt;br&gt;&lt;br&gt;&lt;code&gt;WorkContinuations&lt;/code&gt; cannot be enqueued automatically.  You must call &lt;code&gt;enqueue()&lt;/code&gt; on a &lt;code&gt;WorkContinuation&lt;/code&gt; to have it and its parent continuations enqueued inside &lt;code&gt;WorkManager&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: EnqueueWork&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintHighAppVersionCode" defaultSeverity="ERROR" displayName="VersionCode too high" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;VersionCode too high&lt;br&gt;&lt;br&gt;The declared &lt;code&gt;versionCode&lt;/code&gt; is an Integer. Ensure that the version number is not close to the limit. It is recommended to monotonically increase this number each minor or major release of the app. Note that updating an app with a versionCode over &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt; is not possible.&lt;br&gt;&lt;br&gt;Issue id: HighAppVersionCode&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/studio/publish/versioning.html"&gt;https://developer.android.com/studio/publish/versioning.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintDeviceAdmin" defaultSeverity="WARNING" displayName="Malformed Device Admin" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Malformed Device Admin&lt;br&gt;&lt;br&gt;If you register a broadcast receiver which acts as a device admin, you must also register an &lt;code&gt;&amp;lt;intent-filter&gt;&lt;/code&gt; for the action &lt;code&gt;android.app.action.DEVICE_ADMIN_ENABLED&lt;/code&gt;, without any &lt;code&gt;&amp;lt;data&gt;&lt;/code&gt;, such that the device admin can be activated/deactivated.&lt;br/&gt;
&lt;br/&gt;
To do this, add
&lt;pre&gt;
`&amp;lt;intent-filter&gt;`
    `&amp;lt;action android:name="android.app.action.DEVICE_ADMIN_ENABLED" /&gt;`
`&amp;lt;/intent-filter&gt;`
&lt;/pre&gt;
to your &lt;code&gt;&amp;lt;receiver&gt;&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: DeviceAdmin&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintOldTargetApi" defaultSeverity="WARNING" displayName="Target SDK attribute is not targeting latest version" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Target SDK attribute is not targeting latest version&lt;br&gt;&lt;br&gt;When your application runs on a version of Android that is more recent than your &lt;code&gt;targetSdkVersion&lt;/code&gt; specifies that it has been tested with, various compatibility modes kick in. This ensures that your application continues to work, but it may look out of place. For example, if the &lt;code&gt;targetSdkVersion&lt;/code&gt; is less than 14, your app may get an option button in the UI.&lt;br/&gt;
&lt;br/&gt;
To fix this issue, set the &lt;code&gt;targetSdkVersion&lt;/code&gt; to the highest available value. Then test your app to make sure everything works correctly. You may want to consult the compatibility notes to see what changes apply to each version you are adding support for: &lt;a href="https://developer.android.com/reference/android/os/Build.VERSION_CODES.html"&gt;https://developer.android.com/reference/android/os/Build.VERSION_CODES.html&lt;/a&gt; as well as follow this guide:&lt;br/&gt;
&lt;a href="https://developer.android.com/distribute/best-practices/develop/target-sdk.html"&gt;https://developer.android.com/distribute/best-practices/develop/target-sdk.html&lt;/a&gt;&lt;br&gt;&lt;br&gt;Issue id: OldTargetApi&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintShowToast" defaultSeverity="WARNING" displayName="Toast created but not shown" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Toast created but not shown&lt;br&gt;&lt;br&gt;&lt;code&gt;Toast.makeText()&lt;/code&gt; creates a &lt;code&gt;Toast&lt;/code&gt; but does &lt;b&gt;not&lt;/b&gt; show it. You must call &lt;code&gt;show()&lt;/code&gt; on the resulting object to actually make the &lt;code&gt;Toast&lt;/code&gt; appear.&lt;br&gt;&lt;br&gt;Issue id: ShowToast&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintStringFormatInvalid" defaultSeverity="ERROR" displayName="Invalid format string" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Invalid format string&lt;br&gt;&lt;br&gt;If a string contains a '%' character, then the string may be a formatting string which will be passed to &lt;code&gt;String.format&lt;/code&gt; from Java code to replace each '%' occurrence with specific values.&lt;br/&gt;
&lt;br/&gt;
This lint warning checks for two related problems:&lt;br/&gt;
(1) Formatting strings that are invalid, meaning that &lt;code&gt;String.format&lt;/code&gt; will throw exceptions at runtime when attempting to use the format string.&lt;br/&gt;
(2) Strings containing '%' that are not formatting strings getting passed to a &lt;code&gt;String.format&lt;/code&gt; call. In this case the '%' will need to be escaped as '%%'.&lt;br/&gt;
&lt;br/&gt;
NOTE: Not all Strings which look like formatting strings are intended for use by &lt;code&gt;String.format&lt;/code&gt;; for example, they may contain date formats intended for &lt;code&gt;android.text.format.Time#format()&lt;/code&gt;. Lint cannot always figure out that a String is a date format, so you may get false warnings in those scenarios. See the suppress help topic for information on how to suppress errors in that case.&lt;br&gt;&lt;br&gt;Issue id: StringFormatInvalid&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintEmptySuperCall" defaultSeverity="WARNING" displayName="Calling an empty super method" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Calling an empty super method&lt;br&gt;&lt;br&gt;For methods annotated with &lt;code&gt;@EmptySuper&lt;/code&gt;, overriding methods should not also call the super implementation, either because it is empty, or perhaps it contains code not intended to be run when the method is overridden.&lt;br&gt;&lt;br&gt;Issue id: EmptySuperCall&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintAppIndexingService" defaultSeverity="WARNING" displayName="App Indexing Background Services" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;App Indexing Background Services&lt;br&gt;&lt;br&gt;Apps targeting Android 8.0 or higher can no longer rely on background services while listening for updates to the on-device index. Use a &lt;code&gt;BroadcastReceiver&lt;/code&gt; for the &lt;code&gt;UPDATE_INDEX&lt;/code&gt; intent to continue supporting indexing in your app.&lt;br&gt;&lt;br&gt;Issue id: AppIndexingService&lt;br&gt;&lt;br&gt;&lt;a href="https://firebase.google.com/docs/app-indexing/android/personal-content#add-a-broadcast-receiver-to-your-app"&gt;https://firebase.google.com/docs/app-indexing/android/personal-content#add-a-broadcast-receiver-to-your-app&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintNewerVersionAvailable" defaultSeverity="WARNING" displayName="Newer Library Versions Available" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Newer Library Versions Available&lt;br&gt;&lt;br&gt;This detector checks with a central repository to see if there are newer versions available for the dependencies used by this project. This is similar to the &lt;code&gt;GradleDependency&lt;/code&gt; check, which checks for newer versions available in the Android SDK tools and libraries, but this works with any MavenCentral dependency, and connects to the library every time, which makes it more flexible but also &lt;b&gt;much&lt;/b&gt; slower.&lt;br&gt;&lt;br&gt;Issue id: NewerVersionAvailable&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintLocalSuppress" defaultSeverity="ERROR" displayName="@SuppressLint on invalid element" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;@SuppressLint on invalid element&lt;br&gt;&lt;br&gt;The &lt;code&gt;@SuppressAnnotation&lt;/code&gt; is used to suppress Lint warnings in Java files. However, while many lint checks analyzes the Java source code, where they can find annotations on (for example) local variables, some checks are analyzing the &lt;code&gt;.class&lt;/code&gt; files. And in class files, annotations only appear on classes, fields and methods. Annotations placed on local variables disappear. If you attempt to suppress a lint error for a class-file based lint check, the suppress annotation not work. You must move the annotation out to the surrounding method.&lt;br&gt;&lt;br&gt;Issue id: LocalSuppress&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintWrongThreadInterprocedural" defaultSeverity="ERROR" displayName="Wrong Thread (Interprocedural)" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Wrong Thread (Interprocedural)&lt;br&gt;&lt;br&gt;Searches for interprocedural call paths that violate thread annotations in the program. Tracks the flow of instantiated types and lambda expressions to increase accuracy across method boundaries.&lt;br&gt;&lt;br&gt;Issue id: WrongThreadInterprocedural&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/components/processes-and-threads.html#Threads"&gt;https://developer.android.com/guide/components/processes-and-threads.html#Threads&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintSQLiteString" defaultSeverity="WARNING" displayName="Using STRING instead of TEXT" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using STRING instead of TEXT&lt;br&gt;&lt;br&gt;In SQLite, any column can store any data type; the declared type for a column is more of a hint as to what the data should be cast to when stored.&lt;br/&gt;
&lt;br/&gt;
There are many ways to store a string. &lt;code&gt;TEXT&lt;/code&gt;, &lt;code&gt;VARCHAR&lt;/code&gt;, &lt;code&gt;CHARACTER&lt;/code&gt; and &lt;code&gt;CLOB&lt;/code&gt; are string types, &lt;b&gt;but `STRING` is not&lt;/b&gt;. Columns defined as STRING are actually numeric.&lt;br/&gt;
&lt;br/&gt;
If you try to store a value in a numeric column, SQLite will try to cast it to a float or an integer before storing. If it can't, it will just store it as a string.&lt;br/&gt;
&lt;br/&gt;
This can lead to some subtle bugs. For example, when SQLite encounters a string like &lt;code&gt;1234567e1234&lt;/code&gt;, it will parse it as a float, but the result will be out of range for floating point numbers, so &lt;code&gt;Inf&lt;/code&gt; will be stored! Similarly, strings that look like integers will lose leading zeroes.&lt;br/&gt;
&lt;br/&gt;
To fix this, you can change your schema to use a &lt;code&gt;TEXT&lt;/code&gt; type instead.&lt;br&gt;&lt;br&gt;Issue id: SQLiteString&lt;br&gt;&lt;br&gt;&lt;a href="https://www.sqlite.org/datatype3.html"&gt;https://www.sqlite.org/datatype3.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintInnerclassSeparator" defaultSeverity="WARNING" displayName="Inner classes should use $ rather than ." enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Inner classes should use &lt;code&gt;$&lt;/code&gt; rather than &lt;code&gt;.&lt;/code&gt;&lt;br&gt;&lt;br&gt;When you reference an inner class in a manifest file, you must use '$' instead of '.' as the separator character, i.e. Outer$Inner instead of Outer.Inner.&lt;br/&gt;
&lt;br/&gt;
(If you get this warning for a class which is not actually an inner class, it's because you are using uppercase characters in your package name, which is not conventional.)&lt;br&gt;&lt;br&gt;Issue id: InnerclassSeparator&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintSuspiciousImport" defaultSeverity="WARNING" displayName="'import android.R' statement" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;'&lt;code&gt;import android.R&lt;/code&gt;' statement&lt;br&gt;&lt;br&gt;Importing &lt;code&gt;android.R&lt;/code&gt; is usually not intentional; it sometimes happens when you use an IDE and ask it to automatically add imports at a time when your project's R class it not present.&lt;br/&gt;
&lt;br/&gt;
Once the import is there you might get a lot of "confusing" error messages because of course the fields available on &lt;code&gt;android.R&lt;/code&gt; are not the ones you'd expect from just looking at your own &lt;code&gt;R&lt;/code&gt; class.&lt;br&gt;&lt;br&gt;Issue id: SuspiciousImport&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintNotInterpolated" defaultSeverity="ERROR" displayName="Incorrect Interpolation" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Incorrect Interpolation&lt;br&gt;&lt;br&gt;To insert the value of a variable, you can use &lt;code&gt;${variable}&lt;/code&gt; inside a string literal, but &lt;b&gt;only&lt;/b&gt; if you are using double quotes!&lt;br&gt;&lt;br&gt;Issue id: NotInterpolated&lt;br&gt;&lt;br&gt;&lt;a href="https://www.groovy-lang.org/syntax.html#_string_interpolation"&gt;https://www.groovy-lang.org/syntax.html#_string_interpolation&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintImplicitSamInstance" defaultSeverity="WARNING" displayName="Implicit SAM Instances" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Implicit SAM Instances&lt;br&gt;&lt;br&gt;Kotlin's support for SAM (single accessor method) interfaces lets you pass a lambda to the interface. This will create a new instance on the fly even though there is no explicit constructor call. If you pass one of these lambdas or method references into a method which (for example) stores or compares the object identity, unexpected results may happen.&lt;br&gt;&lt;br&gt;Issue id: ImplicitSamInstance&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintAppCompatCustomView" defaultSeverity="ERROR" displayName="Appcompat Custom Widgets" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Appcompat Custom Widgets&lt;br&gt;&lt;br&gt;In order to support features such as tinting, the appcompat library will automatically load special appcompat replacements for the builtin widgets. However, this does not work for your own custom views.&lt;br/&gt;
&lt;br/&gt;
Instead of extending the &lt;code&gt;android.widget&lt;/code&gt; classes directly, you should instead extend one of the delegate classes in &lt;code&gt;androidx.appcompat.widget.AppCompatTextView&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: AppCompatCustomView&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintCoarseFineLocation" defaultSeverity="ERROR" displayName="android.permission.ACCESS_COARSE_LOCATION is also required" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Cannot use &lt;code&gt;ACCESS_FINE_LOCATION&lt;/code&gt; without &lt;code&gt;ACCESS_COARSE_LOCATION&lt;/code&gt;&lt;br&gt;&lt;br&gt;If your app requires access to FINE location, on Android 12 and higher you must now request both FINE and COARSE. Users will have the option to grant only COARSE location. Ensure your app can work with just COARSE location.&lt;br&gt;&lt;br&gt;Issue id: CoarseFineLocation&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMissingPrefix" defaultSeverity="ERROR" displayName="Missing Android XML namespace" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing Android XML namespace&lt;br&gt;&lt;br&gt;Most Android views have attributes in the Android namespace. When referencing these attributes you &lt;b&gt;must&lt;/b&gt; include the namespace prefix, or your attribute will be interpreted by &lt;code&gt;aapt&lt;/code&gt; as just a custom attribute.&lt;br/&gt;
&lt;br/&gt;
Similarly, in manifest files, nearly all attributes should be in the &lt;code&gt;android:&lt;/code&gt; namespace.&lt;br&gt;&lt;br&gt;Issue id: MissingPrefix&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMissingClass" defaultSeverity="ERROR" displayName="Missing registered class" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing registered class&lt;br&gt;&lt;br&gt;If a class is referenced in the manifest or in a layout file, it must also exist in the project (or in one of the libraries included by the project. This check helps uncover typos in registration names, or attempts to rename or move classes without updating the XML references properly.&lt;br&gt;&lt;br&gt;Issue id: MissingClass&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/topics/manifest/manifest-intro.html"&gt;https://developer.android.com/guide/topics/manifest/manifest-intro.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintViewBindingType" defaultSeverity="ERROR" displayName="tools:viewBindingType issues" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;&lt;code&gt;tools:viewBindingType&lt;/code&gt; issues&lt;br&gt;&lt;br&gt;All issues related to using the View Binding &lt;code&gt;tools:viewBindingType&lt;/code&gt; attribute.&lt;br&gt;&lt;br&gt;Issue id: ViewBindingType&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintAdapterViewChildren" defaultSeverity="WARNING" displayName="AdapterView cannot have children in XML" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;&lt;code&gt;AdapterView&lt;/code&gt; cannot have children in XML&lt;br&gt;&lt;br&gt;An &lt;code&gt;AdapterView&lt;/code&gt; such as a `ListView`s must be configured with data from Java code, such as a &lt;code&gt;ListAdapter&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: AdapterViewChildren&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/reference/android/widget/AdapterView.html"&gt;https://developer.android.com/reference/android/widget/AdapterView.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintSpUsage" defaultSeverity="WARNING" displayName="Using dp instead of sp for text sizes" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using &lt;code&gt;dp&lt;/code&gt; instead of &lt;code&gt;sp&lt;/code&gt; for text sizes&lt;br&gt;&lt;br&gt;When setting text sizes, you should normally use &lt;code&gt;sp&lt;/code&gt;, or "scale-independent pixels". This is like the &lt;code&gt;dp&lt;/code&gt; unit, but it is also scaled by the user's font size preference. It is recommend you use this unit when specifying font sizes, so they will be adjusted for both the screen density and the user's preference.&lt;br/&gt;
&lt;br/&gt;
There &lt;b&gt;are&lt;/b&gt; cases where you might need to use &lt;code&gt;dp&lt;/code&gt;; typically this happens when the text is in a container with a specific dp-size. This will prevent the text from spilling outside the container. Note however that this means that the user's font size settings are not respected, so consider adjusting the layout itself to be more flexible.&lt;br&gt;&lt;br&gt;Issue id: SpUsage&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/training/multiscreen/screendensities.html"&gt;https://developer.android.com/training/multiscreen/screendensities.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintDataBindingWithoutKapt" defaultSeverity="WARNING" displayName="Data Binding without Annotation Processing" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Data Binding without Annotation Processing&lt;br&gt;&lt;br&gt;Apps that use Kotlin and data binding should also apply the kotlin-kapt plugin.&lt;br&gt;&lt;br&gt;Issue id: DataBindingWithoutKapt&lt;br&gt;&lt;br&gt;&lt;a href="https://kotlinlang.org/docs/reference/kapt.html"&gt;https://kotlinlang.org/docs/reference/kapt.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintLongLogTag" defaultSeverity="ERROR" displayName="Too Long Log Tags" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Too Long Log Tags&lt;br&gt;&lt;br&gt;Log tags are only allowed to be at most 23 tag characters long.&lt;br&gt;&lt;br&gt;Issue id: LongLogTag&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintSlices" defaultSeverity="WARNING" displayName="Slices" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Slices&lt;br&gt;&lt;br&gt;This check analyzes usages of the Slices API and offers suggestions based on best practices.&lt;br&gt;&lt;br&gt;Issue id: Slices&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintParcelClassLoader" defaultSeverity="WARNING" displayName="Default Parcel Class Loader" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Default Parcel Class Loader&lt;br&gt;&lt;br&gt;The documentation for &lt;code&gt;Parcel#readParcelable(ClassLoader)&lt;/code&gt; (and its variations) says that you can pass in &lt;code&gt;null&lt;/code&gt; to pick up the default class loader. However, that ClassLoader is a system class loader and is not able to find classes in your own application.&lt;br/&gt;
&lt;br/&gt;
If you are writing your own classes into the &lt;code&gt;Parcel&lt;/code&gt; (not just SDK classes like &lt;code&gt;String&lt;/code&gt; and so on), then you should supply a &lt;code&gt;ClassLoader&lt;/code&gt; for your application instead; a simple way to obtain one is to just call &lt;code&gt;getClass().getClassLoader()&lt;/code&gt; from your own class.&lt;br&gt;&lt;br&gt;Issue id: ParcelClassLoader&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/reference/android/os/Parcel.html"&gt;https://developer.android.com/reference/android/os/Parcel.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintWrongFolder" defaultSeverity="ERROR" displayName="Resource file in the wrong res folder" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Resource file in the wrong &lt;code&gt;res&lt;/code&gt; folder&lt;br&gt;&lt;br&gt;Resource files are sometimes placed in the wrong folder, and it can lead to subtle bugs that are hard to understand. This check looks for problems in this area, such as attempting to place a layout "alias" file in a &lt;code&gt;layout/&lt;/code&gt; folder rather than the &lt;code&gt;values/&lt;/code&gt; folder where it belongs.&lt;br&gt;&lt;br&gt;Issue id: WrongFolder&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintAnnotateVersionCheck" defaultSeverity="WARNING" displayName="Annotate SDK_INT checks" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Annotate SDK_INT checks&lt;br&gt;&lt;br&gt;Methods which perform &lt;code&gt;SDK_INT&lt;/code&gt; version checks (or field constants which reflect the result of a version check) in libraries should be annotated with &lt;code&gt;@ChecksSdkIntAtLeast&lt;/code&gt;. This makes it possible for lint to correctly check calls into the library later to correctly understand that problematic code which is wrapped within a call into this library is safe after all.&lt;br&gt;&lt;br&gt;Issue id: AnnotateVersionCheck&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUnusedTranslation" defaultSeverity="WARNING" displayName="Unused Translation" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Unused Translation&lt;br&gt;&lt;br&gt;If an application defines a translation for a language which is not included in the app's &lt;code&gt;localeConfig&lt;/code&gt; file (when declared in the manifest), that language will be "unused"; it will not be presented to the user. Usually this means you have forgotten to include it in the locale config file.&lt;br&gt;&lt;br&gt;Issue id: UnusedTranslation&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/about/versions/13/features/app-languages"&gt;https://developer.android.com/about/versions/13/features/app-languages&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintProguardSplit" defaultSeverity="WARNING" displayName="Proguard.cfg file contains generic Android rules" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Proguard.cfg file contains generic Android rules&lt;br&gt;&lt;br&gt;Earlier versions of the Android tools bundled a single &lt;code&gt;proguard.cfg&lt;/code&gt; file containing a ProGuard configuration file suitable for Android shrinking and obfuscation. However, that version was copied into new projects, which means that it does not continue to get updated as we improve the default ProGuard rules for Android.&lt;br/&gt;
&lt;br/&gt;
In the new version of the tools, we have split the ProGuard configuration into two halves:&lt;br/&gt;
* A simple configuration file containing only project-specific flags, in your project&lt;br/&gt;
* A generic configuration file containing the recommended set of ProGuard options for Android projects. This generic file lives in the SDK install directory which means that it gets updated along with the tools.&lt;br/&gt;
&lt;br/&gt;
In order for this to work, the proguard.config property in the &lt;code&gt;project.properties&lt;/code&gt; file now refers to a path, so you can reference both the generic file as well as your own (and any additional files too).&lt;br/&gt;
&lt;br/&gt;
To migrate your project to the new setup, create a new &lt;code&gt;proguard-project.txt&lt;/code&gt; file in your project containing any project specific ProGuard flags as well as any customizations you have made, then update your project.properties file to contain:&lt;br/&gt;
&lt;code&gt;proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt&lt;/code&gt;&lt;br&gt;&lt;br&gt;Issue id: ProguardSplit&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintStringFormatCount" defaultSeverity="WARNING" displayName="Formatting argument types incomplete or inconsistent" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Formatting argument types incomplete or inconsistent&lt;br&gt;&lt;br&gt;When a formatted string takes arguments, it usually needs to reference the same arguments in all translations (or all arguments if there are no translations.&lt;br/&gt;
&lt;br/&gt;
There are cases where this is not the case, so this issue is a warning rather than an error by default. However, this usually happens when a language is not translated or updated correctly.&lt;br&gt;&lt;br&gt;Issue id: StringFormatCount&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUnusedAttribute" defaultSeverity="WARNING" displayName="Attribute unused on older versions" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Attribute unused on older versions&lt;br&gt;&lt;br&gt;This check finds attributes set in XML files that were introduced in a version newer than the oldest version targeted by your application (with the &lt;code&gt;minSdkVersion&lt;/code&gt; attribute).&lt;br/&gt;
&lt;br/&gt;
This is not an error; the application will simply ignore the attribute. However, if the attribute is important to the appearance or functionality of your application, you should consider finding an alternative way to achieve the same result with only available attributes, and then you can optionally create a copy of the layout in a layout-vNN folder which will be used on API NN or higher where you can take advantage of the newer attribute.&lt;br/&gt;
&lt;br/&gt;
Note: This check does not only apply to attributes. For example, some tags can be unused too, such as the new &lt;code&gt;&amp;lt;tag&gt;&lt;/code&gt; element in layouts introduced in API 21.&lt;br&gt;&lt;br&gt;Issue id: UnusedAttribute&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintResourceAsColor" defaultSeverity="ERROR" displayName="Should pass resolved color instead of resource id" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Should pass resolved color instead of resource id&lt;br&gt;&lt;br&gt;Methods that take a color in the form of an integer should be passed an RGB triple, not the actual color resource id. You must call &lt;code&gt;getResources().getColor(resource)&lt;/code&gt; to resolve the actual color value first.&lt;br/&gt;
&lt;br/&gt;
Similarly, methods that take a dimension integer should be passed an actual dimension (call &lt;code&gt;getResources().getDimension(resource)&lt;/code&gt;&lt;br&gt;&lt;br&gt;Issue id: ResourceAsColor&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintInvalidResourceFolder" defaultSeverity="ERROR" displayName="Invalid Resource Folder" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Invalid Resource Folder&lt;br&gt;&lt;br&gt;This lint check looks for a folder name that is not a valid resource folder name; these will be ignored and not packaged by the Android Gradle build plugin.&lt;br/&gt;
&lt;br/&gt;
Note that the order of resources is very important; for example, you can't specify a language before a network code.&lt;br/&gt;
&lt;br/&gt;
Similarly, note that to use 3 letter region codes, you have to use a special BCP 47 syntax: the prefix b+ followed by the BCP 47 language tag but with &lt;code&gt;+&lt;/code&gt; as the individual separators instead of &lt;code&gt;-&lt;/code&gt;. Therefore, for the BCP 47 language tag &lt;code&gt;nl-ABW&lt;/code&gt; you have to use &lt;code&gt;b+nl+ABW&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: InvalidResourceFolder&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/topics/resources/providing-resources.html"&gt;https://developer.android.com/guide/topics/resources/providing-resources.html&lt;/a&gt;&lt;br&gt;&lt;a href="https://tools.ietf.org/html/bcp47"&gt;https://tools.ietf.org/html/bcp47&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintGradleGetter" defaultSeverity="ERROR" displayName="Gradle Implicit Getter Call" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Gradle Implicit Getter Call&lt;br&gt;&lt;br&gt;Gradle will let you replace specific constants in your build scripts with method calls, so you can for example dynamically compute a version string based on your current version control revision number, rather than hardcoding a number.&lt;br/&gt;
&lt;br/&gt;
When computing a version name, it's tempting to for example call the method to do that &lt;code&gt;getVersionName&lt;/code&gt;. However, when you put that method call inside the &lt;code&gt;defaultConfig&lt;/code&gt; block, you will actually be calling the Groovy getter for the &lt;code&gt;versionName&lt;/code&gt; property instead. Therefore, you need to name your method something which does not conflict with the existing implicit getters. Consider using &lt;code&gt;compute&lt;/code&gt; as a prefix instead of &lt;code&gt;get&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: GradleGetter&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintPrivateApi" defaultSeverity="WARNING" displayName="Using Private APIs" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using Private APIs&lt;br&gt;&lt;br&gt;Using reflection to access hidden/private Android APIs is not safe; it will often not work on devices from other vendors, and it may suddenly stop working (if the API is removed) or crash spectacularly (if the API behavior changes, since there are no guarantees for compatibility).&lt;br&gt;&lt;br&gt;Issue id: PrivateApi&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/preview/restrictions-non-sdk-interfaces"&gt;https://developer.android.com/preview/restrictions-non-sdk-interfaces&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintExtraTranslation" defaultSeverity="ERROR" displayName="Extra translation" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Extra translation&lt;br&gt;&lt;br&gt;If a string appears in a specific language translation file, but there is no corresponding string in the default locale, then this string is probably unused. (It's technically possible that your application is only intended to run in a specific locale, but it's still a good idea to provide a fallback.)&lt;br/&gt;
&lt;br/&gt;
Note that these strings can lead to crashes if the string is looked up on any locale not providing a translation, so it's important to clean them up.&lt;br&gt;&lt;br&gt;Issue id: ExtraTranslation&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintGradleIdeError" defaultSeverity="ERROR" displayName="Gradle IDE Support Issues" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Gradle IDE Support Issues&lt;br&gt;&lt;br&gt;Gradle is highly flexible, and there are things you can do in Gradle files which can make it hard or impossible for IDEs to properly handle the project. This lint check looks for constructs that potentially break IDE support.&lt;br&gt;&lt;br&gt;Issue id: GradleIdeError&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintLocaleFolder" defaultSeverity="WARNING" displayName="Wrong locale name" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Wrong locale name&lt;br&gt;&lt;br&gt;From the &lt;code&gt;java.util.Locale&lt;/code&gt; documentation:&lt;br/&gt;
"Note that Java uses several deprecated two-letter codes. The Hebrew ("he") language code is rewritten as "iw", Indonesian ("id") as "in", and Yiddish ("yi") as "ji". This rewriting happens even if you construct your own Locale object, not just for instances returned by the various lookup methods.&lt;br/&gt;
&lt;br/&gt;
Because of this, if you add your localized resources in for example &lt;code&gt;values-he&lt;/code&gt; they will not be used, since the system will look for &lt;code&gt;values-iw&lt;/code&gt; instead.&lt;br/&gt;
&lt;br/&gt;
To work around this, place your resources in a &lt;code&gt;values&lt;/code&gt; folder using the deprecated language code instead.&lt;br&gt;&lt;br&gt;Issue id: LocaleFolder&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/reference/java/util/Locale.html"&gt;https://developer.android.com/reference/java/util/Locale.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintDuplicateActivity" defaultSeverity="ERROR" displayName="Activity registered more than once" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Activity registered more than once&lt;br&gt;&lt;br&gt;An activity should only be registered once in the manifest. If it is accidentally registered more than once, then subtle errors can occur, since attribute declarations from the two elements are not merged, so you may accidentally remove previous declarations.&lt;br&gt;&lt;br&gt;Issue id: DuplicateActivity&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintGradleDeprecated" defaultSeverity="WARNING" displayName="Deprecated Gradle Construct" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Deprecated Gradle Construct&lt;br&gt;&lt;br&gt;This detector looks for deprecated Gradle constructs which currently work but will likely stop working in a future update.&lt;br&gt;&lt;br&gt;Issue id: GradleDeprecated&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintInvalidWearFeatureAttribute" defaultSeverity="ERROR" displayName="Invalid attribute for Wear uses-feature" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Invalid attribute for Wear uses-feature&lt;br&gt;&lt;br&gt;For the &lt;code&gt;android.hardware.type.watch&lt;/code&gt; uses-feature, android:required="false" is disallowed. A single APK for Wear and non-Wear devices is not supported.&lt;br&gt;&lt;br&gt;Issue id: InvalidWearFeatureAttribute&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/training/wearables/apps/packaging.html"&gt;https://developer.android.com/training/wearables/apps/packaging.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMissingConstraints" defaultSeverity="ERROR" displayName="Missing Constraints in ConstraintLayout" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing Constraints in ConstraintLayout&lt;br&gt;&lt;br&gt;The layout editor allows you to place widgets anywhere on the canvas, and it records the current position with designtime attributes (such as &lt;code&gt;layout_editor_absoluteX&lt;/code&gt;). These attributes are &lt;b&gt;not&lt;/b&gt; applied at runtime, so if you push your layout on a device, the widgets may appear in a different location than shown in the editor. To fix this, make sure a widget has both horizontal and vertical constraints by dragging from the edge connections.&lt;br&gt;&lt;br&gt;Issue id: MissingConstraints&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMergeMarker" defaultSeverity="ERROR" displayName="Code contains merge marker" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Code contains merge marker&lt;br&gt;&lt;br&gt;Many version control systems leave unmerged files with markers such as &amp;lt;&amp;lt;&amp;lt; in the source code. This check looks for these markers, which are sometimes accidentally left in, particularly in resource files where they don't break compilation.&lt;br&gt;&lt;br&gt;Issue id: MergeMarker&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintTypos" defaultSeverity="WARNING" displayName="Spelling error" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Spelling error&lt;br&gt;&lt;br&gt;This check looks through the string definitions, and if it finds any words that look like likely misspellings, they are flagged.&lt;br&gt;&lt;br&gt;Issue id: Typos&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintDuplicateDefinition" defaultSeverity="ERROR" displayName="Duplicate definitions of resources" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Duplicate definitions of resources&lt;br&gt;&lt;br&gt;You can define a resource multiple times in different resource folders; that's how string translations are done, for example. However, defining the same resource more than once in the same resource folder is likely an error, for example attempting to add a new resource without realizing that the name is already used, and so on.&lt;br&gt;&lt;br&gt;Issue id: DuplicateDefinition&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintApplySharedPref" defaultSeverity="WARNING" displayName="Use apply() on SharedPreferences" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Use &lt;code&gt;apply()&lt;/code&gt; on &lt;code&gt;SharedPreferences&lt;/code&gt;&lt;br&gt;&lt;br&gt;Consider using &lt;code&gt;apply()&lt;/code&gt; instead of &lt;code&gt;commit&lt;/code&gt; on shared preferences. Whereas &lt;code&gt;commit&lt;/code&gt; blocks and writes its data to persistent storage immediately, &lt;code&gt;apply&lt;/code&gt; will handle it in the background.&lt;br&gt;&lt;br&gt;Issue id: ApplySharedPref&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintDefaultLocale" defaultSeverity="WARNING" displayName="Implied default locale in case conversion" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Implied default locale in case conversion&lt;br&gt;&lt;br&gt;Calling &lt;code&gt;String#toLowerCase()&lt;/code&gt; or &lt;code&gt;#toUpperCase()&lt;/code&gt; &lt;b&gt;without specifying an explicit locale&lt;/b&gt; is a common source of bugs. The reason for that is that those methods will use the current locale on the user's device, and even though the code appears to work correctly when you are developing the app, it will fail in some locales. For example, in the Turkish locale, the uppercase replacement for &lt;code&gt;i&lt;/code&gt; is &lt;b&gt;not&lt;/b&gt; &lt;code&gt;I&lt;/code&gt;.&lt;br/&gt;
&lt;br/&gt;
If you want the methods to just perform ASCII replacement, for example to convert an enum name, call &lt;code&gt;String#toUpperCase(Locale.US)&lt;/code&gt; instead. If you really want to use the current locale, call &lt;code&gt;String#toUpperCase(Locale.getDefault())&lt;/code&gt; instead.&lt;br&gt;&lt;br&gt;Issue id: DefaultLocale&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/reference/java/util/Locale.html#default_locale"&gt;https://developer.android.com/reference/java/util/Locale.html#default_locale&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMissingLeanbackSupport" defaultSeverity="ERROR" displayName="Missing Leanback Support" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing Leanback Support&lt;br&gt;&lt;br&gt;The manifest should declare the use of the Leanback user interface required by Android TV.&lt;br/&gt;
&lt;br/&gt;
To fix this, add
&lt;pre&gt;
`&amp;lt;uses-feature android:name="android.software.leanback"
               android:required="false" /&gt;`
&lt;/pre&gt;
to your manifest.&lt;br&gt;&lt;br&gt;Issue id: MissingLeanbackSupport&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/training/tv/start/start.html#leanback-req"&gt;https://developer.android.com/training/tv/start/start.html#leanback-req&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintResourceName" defaultSeverity="ERROR" displayName="Resource with Wrong Prefix" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Resource with Wrong Prefix&lt;br&gt;&lt;br&gt;In Gradle projects you can specify a resource prefix that all resources in the project must conform to. This makes it easier to ensure that you don't accidentally combine resources from different libraries, since they all end up in the same shared app namespace.&lt;br&gt;&lt;br&gt;Issue id: ResourceName&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintExifInterface" defaultSeverity="WARNING" displayName="Using android.media.ExifInterface" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using &lt;code&gt;android.media.ExifInterface&lt;/code&gt;&lt;br&gt;&lt;br&gt;The &lt;code&gt;android.media.ExifInterface&lt;/code&gt; implementation has some known security bugs in older versions of Android. There is a new implementation available of this library in the support library, which is preferable.&lt;br&gt;&lt;br&gt;Issue id: ExifInterface&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintOverride" defaultSeverity="ERROR" displayName="Method conflicts with new inherited method" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Method conflicts with new inherited method&lt;br&gt;&lt;br&gt;Suppose you are building against Android API 8, and you've subclassed Activity. In your subclass you add a new method called &lt;code&gt;isDestroyed&lt;/code&gt;(). At some later point, a method of the same name and signature is added to Android. Your method will now override the Android method, and possibly break its contract. Your method is not calling &lt;code&gt;super.isDestroyed()&lt;/code&gt;, since your compilation target doesn't know about the method.&lt;br/&gt;
&lt;br/&gt;
The above scenario is what this lint detector looks for. The above example is real, since &lt;code&gt;isDestroyed()&lt;/code&gt; was added in API 17, but it will be true for &lt;b&gt;any&lt;/b&gt; method you have added to a subclass of an Android class where your build target is lower than the version the method was introduced in.&lt;br/&gt;
&lt;br/&gt;
To fix this, either rename your method, or if you are really trying to augment the builtin method if available, switch to a higher build target where you can deliberately add &lt;code&gt;@Override&lt;/code&gt; on your overriding method, and call &lt;code&gt;super&lt;/code&gt; if appropriate etc.&lt;br&gt;&lt;br&gt;Issue id: Override&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUnlocalizedSms" defaultSeverity="WARNING" displayName="SMS phone number missing country code" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;SMS phone number missing country code&lt;br&gt;&lt;br&gt;SMS destination numbers must start with a country code or the application code must ensure that the SMS is only sent when the user is in the same country as the receiver.&lt;br&gt;&lt;br&gt;Issue id: UnlocalizedSms&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintAppCompatResource" defaultSeverity="ERROR" displayName="Menu namespace" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Menu namespace&lt;br&gt;&lt;br&gt;When using the appcompat library, menu resources should refer to the &lt;code&gt;showAsAction&lt;/code&gt; (or &lt;code&gt;actionViewClass&lt;/code&gt;, or &lt;code&gt;actionProviderClass&lt;/code&gt;) in the &lt;code&gt;app:&lt;/code&gt; namespace, not the &lt;code&gt;android:&lt;/code&gt; namespace.&lt;br/&gt;
&lt;br/&gt;
Similarly, when &lt;b&gt;not&lt;/b&gt; using the appcompat library, you should be using the &lt;code&gt;android:showAsAction&lt;/code&gt; (or &lt;code&gt;actionViewClass&lt;/code&gt;, or &lt;code&gt;actionProviderClass&lt;/code&gt;) attribute.&lt;br&gt;&lt;br&gt;Issue id: AppCompatResource&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintAaptCrash" defaultSeverity="ERROR" displayName="Potential AAPT crash" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Potential AAPT crash&lt;br&gt;&lt;br&gt;Defining a style which sets &lt;code&gt;android:id&lt;/code&gt; to a dynamically generated id can cause many versions of &lt;code&gt;aapt&lt;/code&gt;, the resource packaging tool, to crash. To work around this, declare the id explicitly with &lt;code&gt;&amp;lt;item type="id" name="..." /&gt;&lt;/code&gt; instead.&lt;br&gt;&lt;br&gt;Issue id: AaptCrash&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMultipleUsesSdk" defaultSeverity="ERROR" displayName="Multiple &lt;uses-sdk&gt; elements in the manifest" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Multiple &lt;code&gt;&amp;lt;uses-sdk&gt;&lt;/code&gt; elements in the manifest&lt;br&gt;&lt;br&gt;The &lt;code&gt;&amp;lt;uses-sdk&gt;&lt;/code&gt; element should appear just once; the tools will &lt;b&gt;not&lt;/b&gt; merge the contents of all the elements so if you split up the attributes across multiple elements, only one of them will take effect. To fix this, just merge all the attributes from the various elements into a single &amp;lt;uses-sdk&gt; element.&lt;br&gt;&lt;br&gt;Issue id: MultipleUsesSdk&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/topics/manifest/uses-sdk-element.html"&gt;https://developer.android.com/guide/topics/manifest/uses-sdk-element.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintOrientation" defaultSeverity="ERROR" displayName="Missing explicit orientation" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing explicit orientation&lt;br&gt;&lt;br&gt;The default orientation of a &lt;code&gt;LinearLayout&lt;/code&gt; is horizontal. It's pretty easy to believe that the layout is vertical, add multiple children to it, and wonder why only the first child is visible (when the subsequent children are off screen to the right). This lint rule helps pinpoint this issue by warning whenever a &lt;code&gt;LinearLayout&lt;/code&gt; is used with an implicit orientation and multiple children.&lt;br/&gt;
&lt;br/&gt;
It also checks for empty LinearLayouts without an &lt;code&gt;orientation&lt;/code&gt; attribute that also defines an &lt;code&gt;id&lt;/code&gt; attribute. This catches the scenarios where children will be added to the &lt;code&gt;LinearLayout&lt;/code&gt; dynamically. &lt;br&gt;&lt;br&gt;Issue id: Orientation&lt;/body&gt;&lt;/html&gt;</inspection></group><group name="Selenium" path=""><inspection shortName="CssShorthandPropertyUsage" defaultSeverity="ERROR" displayName="不受支持的 CSS 速记属性" enabled="false" language="UAST" pluginId="com.intellij.aqua.selenium" pluginVersion="223.8617.27" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 Selenium API 中的 CSS 速记属性（例如，&lt;code&gt;border&lt;/code&gt;、&lt;code&gt;font&lt;/code&gt;、&lt;code&gt;padding&lt;/code&gt; 等）。
  Selenium WebDriver 不支持 CSS 速记属性。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  webElement.getCssValue("&lt;b&gt;font&lt;/b&gt;"); // 错误：Selenium WebDriver 不支持 CSS 速记属性
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SeleniumPageObjectUrlMismatch" defaultSeverity="WEAK WARNING" displayName="Selenium 页面对象 URL 不匹配" enabled="false" pluginId="com.intellij.aqua.selenium" pluginVersion="223.8617.27" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告页面对象 URL 链接与页面对象编辑器浏览器视图中的 URL 不匹配。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SelenideEmptyMatchText" defaultSeverity="ERROR" displayName="Selenide 文本或 matchText 条件中使用了空字符串" enabled="false" language="UAST" pluginId="com.intellij.aqua.selenium" pluginVersion="223.8617.27" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告传递给 Selenide 的 &lt;code&gt;text()&lt;/code&gt; 和 &lt;code&gt;matchText()&lt;/code&gt; 条件的空字符串：&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  $("#code").shouldHave(text("")) // 错误：text() 的实参不能为空字符串。
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="常规" path=""><inspection shortName="InjectedReferences" defaultSeverity="ERROR" displayName="已注入的引用" enabled="false" pluginId="org.intellij.intelliLang" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告&lt;a href="https://www.jetbrains.com/help/idea/using-language-injections.html"&gt;语言注入&lt;/a&gt;所注入的未解析引用。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;
    @Language("file-reference")
    String fileName = "/home/user/nonexistent.file"; // 文件不存在时高亮显示
&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="InconsistentLineSeparators" defaultSeverity="WARNING" displayName="行分隔符不一致" enabled="false" pluginId="com.intellij" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告包含的行分隔符与项目设置中指定的行分隔符不同的文件。
&lt;p&gt;例如，如果在&lt;a href="settings://preferences.sourceCode?Line%20separator"&gt;设置 | 编辑器 | 代码样式 | 行分隔符&lt;/a&gt;中将行分隔符设置为 &lt;code&gt;\n&lt;/code&gt;，而您正在编辑的文件使用 &lt;code&gt;\r\n&lt;/code&gt; 作为行分隔符，就会触发该检查。&lt;/p&gt;

&lt;p&gt;该检查还会警告留意文件中的混合行分隔符。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="KotlinAnnotator" defaultSeverity="ERROR" displayName="Kotlin 注解器" enabled="false" pluginId="org.intellij.qodana" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
允许查看 Kotlin 注解器报告的问题：编译问题、IDE 未解析的引用等。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantSuppression" defaultSeverity="WARNING" displayName="冗余禁止" enabled="false" pluginId="com.intellij" pluginVersion="223.8836.41" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
报告由于它们所影响的检查在此上下文中不再适用而可以安全移除的下列元素：
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;@SuppressWarning&lt;/code&gt; 注解或&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;// noinspection&lt;/code&gt; 行注释，或&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;/** noinspection */&lt;/code&gt; JavaDoc 注释&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
&lt;b&gt;&lt;font color="#000080"&gt;public class&lt;/font&gt;&lt;/b&gt; C {
 // 符号已经为 private，
 // 但周围仍有注解
  @SuppressWarnings({"WeakerAccess"})
 &lt;b&gt;&lt;font color="#000080"&gt;private boolean&lt;/font&gt;&lt;/b&gt; CONST = &lt;b&gt;&lt;font color="#000080"&gt;true&lt;/font&gt;&lt;/b&gt;;
 &lt;b&gt;&lt;font color="#000080"&gt;void&lt;/font&gt;&lt;/b&gt; f() {
    CONST = &lt;b&gt;&lt;font color="#000080"&gt;false&lt;/font&gt;&lt;/b&gt;;
  }
}
&lt;/code&gt;&lt;/pre&gt;


&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="LongLine" defaultSeverity="WARNING" displayName="行长度超出代码样式的允许范围" enabled="false" pluginId="com.intellij" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告比在&lt;a href="settings://preferences.sourceCode?Hard%20wrap%20at"&gt;设置 | 编辑器 | 代码样式 | 常规&lt;/a&gt;中指定的&lt;b&gt;强制换行位置&lt;/b&gt;参数长的行。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="QodanaServiceMessage" defaultSeverity="ERROR" displayName="Qodana 服务消息" enabled="false" pluginId="org.intellij.qodana" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 Qodana 服务消息，例如由于报告的大量问题而暂停特定检查。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DuplicatedCode" defaultSeverity="WEAK WARNING" displayName="重复的代码段" enabled="false" pluginId="com.intellij" pluginVersion="223.8836.41" isGlobalTool="false">报告所选范围内的重复代码块: 相同文件、相同模块、依赖模块或整个项目。&lt;!-- tooltip end --&gt; 检查功能快速修复，可以帮助您设置检测到的重复项的大小，导航至重复的代码段，然后在工具窗口中进行比较。检查会在可行时提供快速修复以从重复代码提取方法。

检查选项允许您选择已报告重复片段的范围，并为重复语言结构设置初始大小。

您还可以配置要在 &lt;a href="settings://duplicates.index"&gt; 设置 | 编辑器 | 重复项&lt;/a&gt; 中匿名化的结构。</inspection><inspection shortName="EmptyDirectory" defaultSeverity="WARNING" displayName="空目录" enabled="false" pluginId="com.intellij" pluginVersion="223.8836.41" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
报告空目录。
&lt;!-- tooltip end --&gt;
&lt;p&gt;仅适用于&lt;b&gt;代码 | 检查代码&lt;/b&gt;或&lt;b&gt;代码 | 分析代码 | 通过名称运行检查&lt;/b&gt;，并且不会在编辑器中报告。&lt;/p&gt;
&lt;p&gt;使用&lt;b&gt;仅报告位于源文件夹下的空目录&lt;/b&gt;选项可以仅报告源根下的目录。&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TodoComment" defaultSeverity="WARNING" displayName="TODO 注释" enabled="false" pluginId="com.intellij" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告代码中的 &lt;b&gt;TODO&lt;/b&gt; 注释。
&lt;p&gt;您可以在&lt;a href="settings://preferences.toDoOptions"&gt;设置 | 编辑器 | TODO&lt;/a&gt; 中配置 &lt;b&gt;TODO&lt;/b&gt; 注释的格式。
&lt;!-- tooltip end --&gt;
&lt;p&gt;启用&lt;b&gt;仅对没有任何详细信息的 TODO 注释发出警告&lt;/b&gt;选项，以仅对不提供有关应完成任务的任何描述的空 TODO 注释发出警告。 禁用可报告所有 TODO 注释。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ProblematicWhitespace" defaultSeverity="WARNING" displayName="有问题的空格" enabled="false" pluginId="com.intellij" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告以下问题：
&lt;ul&gt;
  &lt;li&gt;当代码样式配置为只使用空格时使用制表符进行缩进。&lt;/li&gt;
  &lt;li&gt;当代码样式配置为只使用制表符时使用空格进行缩进。&lt;/li&gt;
  &lt;li&gt;当代码样式配置为使用智能制表符时，使用空格进行缩进，以及使用制表符进行对齐。&lt;/li&gt;
&lt;/ul&gt;

&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReassignedToPlainText" defaultSeverity="WARNING" displayName="重新分配为纯文本" enabled="false" pluginId="com.intellij" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告被显式重新分配为纯文本文件类型的文件。
这种关联是不必要的，因为平台会根据内容自动检测文本文件。

&lt;p&gt;您可以通过在&lt;b&gt;设置 | 编辑器 | 文件类型 | 文本&lt;/b&gt;中移除文件类型关联来关闭此警告。&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="Annotator" defaultSeverity="ERROR" displayName="注解器" enabled="false" pluginId="com.intellij" pluginVersion="223.8836.41" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
报告语言注解器在批处理代码检查运行结果中发现的问题。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="IncorrectFormatting" defaultSeverity="WEAK WARNING" displayName="格式设置不正确" enabled="false" pluginId="com.intellij" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;
  报告代码不遵循项目代码样式设置时出现的格式问题。
&lt;/p&gt;
&lt;p&gt;
  此检查与需要第三方格式化程序进行代码格式设置的语言（例如启用了 CLangFormat 的 Go 或 C 语言）不兼容。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SyntaxError" defaultSeverity="ERROR" displayName="语法错误" enabled="false" pluginId="com.intellij" pluginVersion="223.8836.41" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
报告批处理代码检查运行结果中发现的语法错误。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JavaAnnotator" defaultSeverity="ERROR" displayName="Java 注解器" enabled="false" pluginId="org.intellij.qodana" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
允许查看 Java 注解器报告的问题：编译问题、IDEA 引用未解析等。
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="JPA" path=""><inspection shortName="JpaConfigDomFacetInspection" defaultSeverity="WARNING" displayName="Persistence.xml 未添加到 facet 中" enabled="false" language="XML" pluginId="com.intellij.javaee.jpa" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告缺失的 persistence.xml 配置文件并建议将文件添加到持久性 facet。
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="JpaEntityListenerWarningsInspection" defaultSeverity="WARNING" displayName="实体侦听器警告" enabled="false" language="UAST" pluginId="com.intellij.javaee.jpa" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告没有任何实体侦听器方法的实体侦听器类。

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;&lt;br/&gt;
&lt;pre&gt;&lt;code&gt;
  @Entity
  @EntityListeners(value = JavaEntityListener.class)
  public class JavaEntity { ... }

  class JavaEntityListener { // 错误：找不到特定于实体侦听器的方法

  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="JpaEntityListenerInspection" defaultSeverity="ERROR" displayName="实体侦听器问题" enabled="false" language="UAST" pluginId="com.intellij.javaee.jpa" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告以下 JPA 规范错误：&lt;br/&gt;
&lt;ul&gt;
  &lt;li&gt;没有 public 无实参构造函数的实体侦听器类&lt;/li&gt;
  &lt;li&gt;具有不正确签名的实体侦听器方法&lt;/li&gt;
&lt;/ul&gt;&lt;br/&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Entity
  @EntityListeners(value = JavaEntityListener.class)
  class JavaEntity { ... }

  class JavaEntityListener {

    @PostLoad
    void postLoad(String parameter) { ... } // 错误：方法 'postLoad' 应在此处采用 'Object' 类型的形参
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="JpaModelReferenceInspection" defaultSeverity="ERROR" displayName="查询中存在未解析的引用" enabled="false" language="UAST" pluginId="com.intellij.javaee.jpa" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告以下 JPA 注解和 API 方法中的未解析符号：
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;AttributeOverride&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;AssociationOverride&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;MapsId&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;MapKey&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Criteria API 方法&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;&lt;br/&gt;
&lt;pre&gt;&lt;code&gt;
  @Entity
  @AssociationOverrides({
    @AssociationOverride(name = "missingAttribute", joinColumns = { ... }), // 错误：未解析的特性
    @AssociationOverride(name = "existingAttribute", joinColumns = { ... })
  })
  public class JavaEntity {
    @OneToOne
    AnotherEntity existingAttribute;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="JpaMissingIdInspection" defaultSeverity="ERROR" displayName="持久实体缺少主键" enabled="false" language="UAST" pluginId="com.intellij.javaee.jpa" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告缺失的标识属性持久性对象。&lt;br/&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;&lt;br/&gt;
&lt;pre&gt;&lt;code&gt;
  @Entity
  public class JavaEntity { // 错误：实体类应该有一个 @Id 注解的属性
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="JpaAttributeMemberSignatureInspection" defaultSeverity="ERROR" displayName="持久特性签名检查" enabled="false" language="UAST" pluginId="com.intellij.javaee.jpa" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告以下 JPA 规范错误：
&lt;ul&gt;
  &lt;li&gt;为一个方法或字段配置了多个特性&lt;/li&gt;
  &lt;li&gt;Embeddable 对象中使用了非法特性 (JPA 1.0)&lt;/li&gt;
  &lt;li&gt;持久特性元数据不在字段或属性 getter 上指定&lt;/li&gt;
  &lt;li&gt;没有基于属性访问的 setter 或 getter&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Entity
  @Table(name = "TABLE")
  public class JavaEntity {

    private Integer id; // 错误：getter 和 setter 都应该存在

    public Integer getId() { ... }



    private String data;

    public String getData() { ... }

    @Basic // 错误：持久注解应该放在字段或 getter 方法上
    public void setData(String data) { ... }
  }
&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="JpaDataSourceORMDomInspection" defaultSeverity="ERROR" displayName="XML 中存在未解析的数据库引用" enabled="false" language="XML" pluginId="com.intellij.javaee.jpa" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告无法在配置的数据源中解析的 Persistence ORM XML 描述符并建议刷新数据源或分配不同的数据源。

&lt;p&gt;&lt;b&gt;示例数据库表：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  CREATE TABLE DATA_TABLE (
    ID INTEGER,
    DATA VARCHAR(100)
  );
&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;

&lt;p&gt;&lt;b&gt;示例 JSP 文件：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &amp;lt;?xml version="1.0" encoding="UTF-8"?&amp;gt;
  &amp;lt;entity-mappings xmlns="http://java.sun.com/xml/ns/persistence/orm" version="1.0"&amp;gt;
    &amp;lt;entity name="JavaEntity" class="JavaEntity"&amp;gt;
        &amp;lt;table name="UNKNOWN_TABLE"/&amp;gt; // 错误：未解析的表
        &amp;lt;attributes&amp;gt;
          &amp;lt;id name="id"&amp;gt;
            &amp;lt;column name="ID" nullable="false"/&amp;gt;
          &amp;lt;/id&amp;gt;
          &amp;lt;basic name="UNKNOWN_COLUMN"&amp;gt; // 错误：未解析的列
            &amp;lt;column name="UNKNOWN_COLUMN" length="12"/&amp;gt;
          &amp;lt;/basic&amp;gt;
        &amp;lt;/attributes&amp;gt;
    &amp;lt;/entity&amp;gt;
  &amp;lt;/entity-mappings&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  &lt;b&gt;注意&lt;/b&gt;：数据源可以通过 `分配数据源` 操作进行配置
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="JpaDataSourceORMInspection" defaultSeverity="ERROR" displayName="注解中存在未解析的数据库引用" enabled="false" language="UAST" pluginId="com.intellij.javaee.jpa" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
如果无法在配置的数据源中解析，则报告以下 Persistence ORM 注解中的引用：&lt;br/&gt;
&lt;ul&gt;
  &lt;li&gt; Table&lt;/li&gt;
  &lt;li&gt; Column&lt;/li&gt;
  &lt;li&gt; [Any]To[Any]&lt;/li&gt;
  &lt;li&gt; JoinColumn / JoinTable&lt;/li&gt;
  &lt;li&gt; NamedQuery / NativeQuery&lt;/li&gt;
  &lt;li&gt; Embeddable&lt;/li&gt;
&lt;/ul&gt;&lt;br/&gt;

建议刷新数据源或分配不同的数据源。&lt;br/&gt;

&lt;p&gt;&lt;b&gt;示例数据库表：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  CREATE TABLE DATA_TABLE (
    ID INTEGER,
    DATA VARCHAR(100)
);
&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;

&lt;p&gt;&lt;b&gt;示例 JPA 实体类：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Entity
  @Table(name = "UNKNOWN_TABLE") // 未解决的引用
  public class JavaEntity {
    @Column(name = "ID") // 无法解析未定义的表中的列
    Integer id;
  }
&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;

&lt;!-- tooltip end --&gt;
&lt;p&gt;
  &lt;b&gt;注意&lt;/b&gt;：数据源可以通过 `分配数据源` 操作或实体类的相应间距图标进行配置
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="JpaObjectClassSignatureInspection" defaultSeverity="ERROR" displayName="持久对象类签名检查" enabled="false" language="UAST" pluginId="com.intellij.javaee.jpa" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
在以下情况下报告错误定义的持久对象类：

&lt;ul&gt;
  &lt;li&gt;类不是顶级类&lt;/li&gt;
  &lt;li&gt;类为 final&lt;/li&gt;
  &lt;li&gt;类被多次注解&lt;/li&gt;
  &lt;li&gt;类被定义为持久实体和实体侦听器&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;&lt;br/&gt;
&lt;pre&gt;&lt;code&gt;
  @Entity
  @EntityListeners(value = JavaEntity.class) // 错误：@Entity 和 @EntityListener 注解都指向同一个类
  public final class JavaEntity { // 错误：持久实体不应为 final
    ...
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="JpaAttributeTypeInspection" defaultSeverity="ERROR" displayName="持久特性类型检查" enabled="false" language="UAST" pluginId="com.intellij.javaee.jpa" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 JPA 特性的属性类型不匹配。

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;&lt;br/&gt;
&lt;pre&gt;&lt;code&gt;
  @Entity
  public class JavaEntity {

    @OneToOne
    Map&lt;Integer, AnotherEntity&gt; incorrectRelationship; // 错误：'One To One' 特性类型应该是 Entity，而不是 Map

    @ManyToMany
    Map&lt;Integer, AnotherEntity&gt; correctRelationship;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="JpaEntityGraphsInspection" defaultSeverity="ERROR" displayName="未解析的实体图名称" enabled="false" language="UAST" pluginId="com.intellij.javaee.jpa" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 EntityGraph 相关注解中的以下未解析特性：&lt;br/&gt;
&lt;ul&gt;
  &lt;li&gt; &lt;code&gt;@NamedAttributeNode&lt;/code&gt; 中的值&lt;/li&gt;
  &lt;li&gt; &lt;code&gt;@NamedAttributeNode&lt;/code&gt; 中的命名子图&lt;/li&gt;
  &lt;li&gt; &lt;code&gt;@NamedEntityGraph&lt;/code&gt; 中的名称&lt;/li&gt;
&lt;/ul&gt;&lt;br/&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;&lt;br/&gt;
&lt;pre&gt;&lt;code&gt;
  @Entity
  @NamedEntityGraph(name = "entity-graph", ...)
  public class JavaEntity {
    public void foo() {
      Persistence.createEntityManagerFactory("")
        .createEntityManager()
        .getEntityGraph("unknown-entity-graph"); // 未解析的引用
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="JpaQlInspection" defaultSeverity="ERROR" displayName="查询语言检查" enabled="false" language="JPAQL" pluginId="com.intellij.javaee.jpa" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 Persistence QL 查询中的以下错误：
&lt;ul&gt;
  &lt;li&gt;不匹配的表达式类型&lt;/li&gt;
  &lt;li&gt;形参不正确&lt;/li&gt;
  &lt;li&gt;空或常量条件&lt;/li&gt;
  &lt;li&gt;未解析的符号&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;b&gt;示例查询：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
SELECT OBJECT(e) FROM JavaEntity e WHERE TRUE // 警告：常量条件

SELECT OBJECT(e) FROM JavaEntity e WHERE e.id BETWEEN 0 AND '2' // 错误：应为数值，但得到字符串

SELECT e from JavaEntity e where e.id=?1 and e.name=?3 // 错误：只有 2 个实际查询形参
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="JpaORMDomInspection" defaultSeverity="ERROR" displayName="Orm.xml 问题" enabled="false" language="XML" pluginId="com.intellij.javaee.jpa" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对 `orm.xml` 配置文件中任何数据库对象的未解析引用：
&lt;ul&gt;
  &lt;li&gt;表&lt;/li&gt;
  &lt;li&gt;列&lt;/li&gt;
  &lt;li&gt;架构&lt;/li&gt;
  &lt;li&gt;目录&lt;/li&gt;
  &lt;li&gt;序列&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;b&gt;示例数据库表：&lt;/b&gt;&lt;/p&gt;&lt;br/&gt;
&lt;pre&gt;&lt;code&gt;
CREATE TABLE DATA_TABLE (
  ID INTEGER,
  DATA VARCHAR(100)
);
&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;

&lt;p&gt;&lt;b&gt;示例 orm.xml 文件：&lt;/b&gt;&lt;/p&gt;&lt;br/&gt;
&lt;pre&gt;&lt;code&gt;
&amp;lt;entity-mappings xmlns="http://java.sun.com/xml/ns/persistence/orm" version="1.0"&amp;gt;
    &amp;lt;package&amp;gt;example&amp;lt;/package&amp;gt;
    &amp;lt;entity name="JavaEntity" class="JavaEntity"&amp;gt;
        &amp;lt;table name="DATA_TABLE"/&amp;gt;
        &amp;lt;attributes&amp;gt;
          &amp;lt;id name="id"&amp;gt;
            &amp;lt;column name="UNKNOWN_ID" nullable="false" length="20"/&amp;gt; // 错误：未解析的列名
          &amp;lt;/id&amp;gt;
          &amp;lt;basic name="data"&amp;gt;
            &amp;lt;column name="DATA" length="12"/&amp;gt; // OK
          &amp;lt;/basic&amp;gt;
        &amp;lt;/attributes&amp;gt;
    &amp;lt;/entity&amp;gt;
&amp;lt;/entity-mappings&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="JpaQueryApiInspection" defaultSeverity="ERROR" displayName="未解析的查询和查询形参" enabled="false" language="UAST" pluginId="com.intellij.javaee.jpa" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告命名和原生查询以及相关 API 方法中的未解析符号：
&lt;ul&gt;
  &lt;li&gt;未知命名查询&lt;/li&gt;
  &lt;li&gt;未知查询形参&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Entity
  @NamedQuery(name = "SelectByConditionQuery", query = "...")
  public class JavaEntity { ... }

  class Main {
    public static void executeQuery() {
      Persistence.createEntityManagerFactory("")
        .createEntityManager()
        .createNamedQuery("SelectAllQuery") // 错误：未知查询名称
        ...
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="JpaDomInspection" defaultSeverity="ERROR" displayName="persistence.xml 问题" enabled="false" language="XML" pluginId="com.intellij.javaee.jpa" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;

报告 XML 配置文件中的以下问题：
&lt;ul&gt;
  &lt;li&gt;对不可实例化类的引用&lt;/li&gt;
  &lt;li&gt;对不扩展所需类的类的引用&lt;/li&gt;
  &lt;li&gt;对范围不适当的类的引用&lt;/li&gt;
  &lt;li&gt;与所需模式不匹配的标记和特性值（例如，Java 标识符）&lt;/li&gt;
  &lt;li&gt;不包含必需子标记或特性的标记&lt;/li&gt;
  &lt;li&gt;定义具有重复名称的对象的标记&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;&lt;br/&gt;
&lt;pre&gt;&lt;code&gt;
&amp;lt;persistence&amp;gt;
    &amp;lt;persistence-unit name="example-persistence-unit"&amp;gt;
        &amp;lt;provider&amp;gt;org.example.SomeRandomClass&amp;lt;/provider&amp;gt; // 错误：提供程序类应实现 PersistenceProvider 接口
    &amp;lt;/persistence-unit&amp;gt;
&amp;lt;/persistence&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="FreeMarker" path=""><inspection shortName="FtlWellformednessInspection" defaultSeverity="ERROR" displayName="指令格式不正确" enabled="false" language="FTL" pluginId="com.intellij.freemarker" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告格式错误的 FreeMarker 指令（例如，错误的嵌套、缺少结束标记等）。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FtlReferencesInspection" defaultSeverity="WARNING" displayName="未解析的引用" enabled="false" language="FTL" pluginId="com.intellij.freemarker" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告未解析的 FreeMarker 引用。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FtlDeprecatedBuiltInsInspection" defaultSeverity="WARNING" displayName="内置已弃用" enabled="false" language="FTL" pluginId="com.intellij.freemarker" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告已弃用的内置对象（例如，&lt;code&gt;default&lt;/code&gt;、&lt;code&gt;exists&lt;/code&gt;、&lt;code&gt;if_exists&lt;/code&gt;、&lt;code&gt;web_safe&lt;/code&gt;）。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FtlFileReferencesInspection" defaultSeverity="ERROR" displayName="未解析的文件引用" enabled="false" language="FTL" pluginId="com.intellij.freemarker" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 &lt;code&gt;#include&lt;/code&gt; 和 &lt;code&gt;#import&lt;/code&gt; 指令中的未解析 FreeMarker 文件引用。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FtlImportCallInspection" defaultSeverity="ERROR" displayName="未解析的外部调用" enabled="false" language="FTL" pluginId="com.intellij.freemarker" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告位于其他文件中的未解析 &lt;code&gt;#macro&lt;/code&gt; 和 &lt;code&gt;#function&lt;/code&gt; 指令。&lt;/p&gt;
&lt;p&gt;该快速修复会建议对所需文件使用 &lt;code&gt;#import&lt;/code&gt; 或 &lt;code&gt;#include&lt;/code&gt;。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FtlTypesInspection" defaultSeverity="WARNING" displayName="不正确的表达式类型" enabled="false" language="FTL" pluginId="com.intellij.freemarker" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告不正确的 FreeMarker 表达式类型。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FtlCallsInspection" defaultSeverity="ERROR" displayName="无效的调用指令" enabled="false" language="FTL" pluginId="com.intellij.freemarker" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告与宏声明不匹配的 FreeMarker 调用（例如，缺少形参、错误类型等）。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="可能引起混淆的代码结构" path="Groovy"><inspection shortName="GroovyOverlyComplexBooleanExpression" defaultSeverity="WARNING" displayName="过于复杂的布尔表达式" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告包含太多项的布尔表达式。
&lt;p&gt;
  此类表达方式可能令人困惑，并且容易出错。
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
 使用&lt;b&gt;最大项数&lt;/b&gt;字段可以指定布尔表达式中允许的最大项数。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyEmptyStatementBody" defaultSeverity="WARNING" displayName="带空体的语句" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告语句体为空的 &lt;code&gt;if&lt;/code&gt;、&lt;code&gt;while&lt;/code&gt;、&lt;code&gt;do&lt;/code&gt; 或 &lt;code&gt;for&lt;/code&gt; 语句。 虽然偶尔是有意为之，但此结构令人困惑，并且通常是由拼写错误所致。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
if (condition) {}
while(true){}
&lt;/code&gt;
&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GrReassignedInClosureLocalVar" defaultSeverity="WARNING" displayName="在闭包类或匿名类中重新分配局部变量" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在闭包或匿名类中分配给不同类型的表达式的局部变量。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int sum = 0
  [1, 2, 3].each { sum += 'as' }
  println(sum)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因此，&lt;code&gt;integer&lt;/code&gt; 变量 &lt;b&gt;sum&lt;/b&gt; 会被重新赋值给 &lt;code&gt;String&lt;/code&gt; 表达式。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyNegatedIf" defaultSeverity="WARNING" displayName="否定 if 条件表达式" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告包含 &lt;code&gt;else&lt;/code&gt; 分支且条件被否定的 &lt;code&gt;if&lt;/code&gt; 语句。
翻转 &lt;code&gt;if&lt;/code&gt; 和 &lt;code&gt;else&lt;/code&gt; 分支的顺序通常会改进此类语句的清晰度。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
if (!condition) {
  return "1"
} else {
  return "2"
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="UnnecessaryQualifiedReference" defaultSeverity="WARNING" displayName="不必要的限定参考" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告可以替换为 import 的完全限定引用。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  def swingBuilder = new groovy.swing.SwingBuilder()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  import groovy.swing.SwingBuilder
 
  def swingBuilder = new SwingBuilder()
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyNestedConditional" defaultSeverity="WARNING" displayName="嵌套条件表达式" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告嵌套在其他条件表达式中的三元条件表达式。
此类嵌套条件可能非常令人困惑。 出于此检查的目的，"Elvis" 表达式将算作条件表达式。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
return (condition ? "result" : null) ?: "fail"
&lt;/code&gt;
&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="GroovyPointlessArithmetic" defaultSeverity="WARNING" displayName="无意义的算术表达式" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告无意义的算术表达式。
&lt;p&gt;
  此类表达式包括加 0 或减 0、乘以 0 或 1、除以 1 以及 0 移位。 此类表达式可能是未完全完成的自动重构所致，在任何情况下都不太可能是开发人员有意为之。
&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  a + 0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  a
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ClashingGetters" defaultSeverity="WARNING" displayName="冲突的 getter" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可通过同一属性名称访问的布尔方法。
&lt;p&gt;访问此类属性可能产生意外的结果。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class X {
      boolean isFoo() { true }
      boolean getFoo() { false }
  }

  // 将调用 getFoo()
  new X().foo
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyImplicitNullArgumentCall" defaultSeverity="WEAK WARNING" displayName="隐式 null 实参" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对只有一个形参的方法的无实参调用。
这等效于使用 &lt;code&gt;null&lt;/code&gt; 进行调用，但这种行为通常令人困惑并且是无意为之。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
def foo(String s){}
foo() // 此调用实际上为 'foo(null)' 调用
&lt;/code&gt;
&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyOctalInteger" defaultSeverity="WARNING" displayName="八进制整数" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告八进制整数文字。
&lt;p&gt;
  某些编码标准禁止使用八进制文字，因为它们可能容易与十进制文字混淆。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="NewInstanceOfSingleton" defaultSeverity="WARNING" displayName="使用 @groovy.lang.Singleton 注解的类的新实例" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告使用 &lt;code&gt;@groovy.lang.Singleton&lt;/code&gt; 注解的类的新实例创建。
  此类构造可能导致运行时异常&lt;b&gt;无法实例化单例&lt;/b&gt;。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Singleton
  class Foo{
  }
  
  Foo foo = &lt;b&gt;new Foo()&lt;/b&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Singleton
  class Foo{
  }
  
  Foo foo = &lt;b&gt;Foo.instance&lt;/b&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GrDeprecatedAPIUsage" defaultSeverity="WARNING" displayName="弃用的 API 用法" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对已弃用类、字段和方法的引用。
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyResultOfIncrementOrDecrementUsed" defaultSeverity="WARNING" displayName="使用增量或减量的结果" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告嵌套在其他表达式中的增量或减量表达式。
&lt;p&gt;
  此类表达式可能令人困惑，并违反一般设计原则，即给定结构只应发挥一种作用。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyOverlyComplexArithmeticExpression" defaultSeverity="WARNING" displayName="过于复杂的算术表达式" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告包含太多项的算术表达式。
&lt;p&gt;
  此类表达方式可能令人困惑，并且容易出错。
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
 使用&lt;b&gt;最大项数&lt;/b&gt;字段可指定算数表达式中允许的最大项数。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyNegatedConditional" defaultSeverity="WARNING" displayName="否定条件表达式" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告条件被否定的条件表达式。
翻转条件表达式分支的顺序通常会增加此类语句的清晰度。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
~condition ? "1" : "2"
&lt;/code&gt;
&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GrPackage" defaultSeverity="WARNING" displayName="软件包不匹配" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告包含与预期软件包不相符的声明软件包的文件。 此外，如果类不是直接位于源根目录中，则报告不包含 &lt;code&gt;package&lt;/code&gt; 语句的文件。
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyGStringKey" defaultSeverity="WARNING" displayName="GString 映射键" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告将 &lt;code&gt;groovy.lang.GString&lt;/code&gt; 对象用作映射键的语句。
通常，&lt;code&gt;GString&lt;/code&gt; 对象是可变的，可能不应用作键。
此外，使用具有相同值的 &lt;code&gt;java.lang.String&lt;/code&gt; 对象无法访问 &lt;code&gt;GString&lt;/code&gt; 条目。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
def map = [:]
def key = 'foo'
map &amp;lt&amp;lt ["${key}": 'bar']
assert map[key] == null // 令人困惑的比较 'true' 结果
&lt;/code&gt;
&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2017.1 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="GroovyNestedSwitch" defaultSeverity="WARNING" displayName="嵌套 switch 语句" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告嵌套在其他 &lt;code&gt;switch&lt;/code&gt; 语句中的 &lt;code&gt;switch&lt;/code&gt; 语句。
此类嵌套 switch 语句令人困惑，并且可能导致意外行为。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
switch (outer) {
  case 1:
    switch (inner) {
      case 1:
        print "inner 1"
        break
      default:
        print "inner default"
    }
    break
  default:
    print "default"
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="GroovyPointlessBoolean" defaultSeverity="WARNING" displayName="无意义的布尔表达式" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告无意义或复杂的无意义布尔表达式。
&lt;p&gt;
  此类表达式包括与 true 的合取、与 false 的析取、与布尔文字的相等比较或布尔文字求反。 此类表达式可能是未完全完成的自动重构所致，在任何情况下都不太可能是开发人员有意为之。
&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (someBool &amp;&amp; true) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (someBool) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ClashingTraitMethods" defaultSeverity="WARNING" displayName="冲突的特征方法" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告实现两个或多个特征（包含具有相同签名的方法）的类。
&lt;p&gt;调用此类方法可能产生意外的结果。&lt;/p&gt;
&lt;p&gt;该快速修复会添加显式重写方法。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  trait T1 {
      def foo() {}
  }

  trait T2 {
      def foo() {}
  }

  class X implements T1, T2 {}

  // 将调用 T2.foo()
  new X().foo()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class X implements T1, T2 {
      @Override
      Object foo() {
          return T2.super.foo()
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyDoubleNegation" defaultSeverity="WARNING" displayName="双重求反" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以简化的双重否定。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
if (!!functionCall()) {} // 双重否定
if (!(a != b)) {} // 双重否定
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
if (functionCall()) {}
if (a == b) {}
&lt;/code&gt;
&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Cucumber" path=""><inspection shortName="GherkinBrokenTableInspection" defaultSeverity="ERROR" displayName="Gherkin 表损坏" enabled="false" language="Gherkin" pluginId="gherkin" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
如果至少有一行的单元格数与表格标题中的单元格数不同，则报告表格。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CucumberTableInspection" defaultSeverity="WARNING" displayName="Cucumber 表中未使用或缺少的列" enabled="false" language="Gherkin" pluginId="gherkin" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 Cucumber .feature 文件中 &lt;code&gt;Examples&lt;/code&gt; 部分中的表格，其中包含未使用或缺失的列。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="GherkinScenarioToScenarioOutline" defaultSeverity="ERROR" displayName="带有 Examples 部分的 Scenario" enabled="false" language="Gherkin" pluginId="gherkin" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告包含 &lt;code&gt;Examples&lt;/code&gt; 部分的 Gherkin 方案。
&lt;p&gt;使用快速修复可以将 &lt;code&gt;Scenario&lt;/code&gt; 转换为 &lt;code&gt;Scenario Outline&lt;/code&gt;。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CucumberExamplesColon" defaultSeverity="ERROR" displayName="示例关键字后面缺少 ':'" enabled="false" language="Gherkin" pluginId="gherkin" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
如果 &lt;code&gt;Examples&lt;/code&gt; 关键字后没有 ':'，则报告 Cucumber .feature 文件中的 &lt;code&gt;Examples&lt;/code&gt; 部分。
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="CucumberMissedExamples" defaultSeverity="ERROR" displayName="缺少 Examples 部分" enabled="false" language="Gherkin" pluginId="gherkin" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
    报告没有 &lt;code&gt;Examples&lt;/code&gt; 部分的 Cucumber .feature 文件中的 Scenario Outline。
    &lt;p&gt;使用快速修复可以自动创建带有预填充表格标题的 &lt;code&gt;Examples&lt;/code&gt; 部分。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="GherkinMisplacedBackground" defaultSeverity="ERROR" displayName="Background 部分的位置不对" enabled="false" language="Gherkin" pluginId="gherkin" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告位置不正确的 &lt;code&gt;Background&lt;/code&gt; 部分。 &lt;code&gt;Background&lt;/code&gt; 部分必须位于 &lt;code&gt;Scenario&lt;/code&gt; 部分之前。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CucumberJavaStepDefClassIsPublic" defaultSeverity="WARNING" displayName="步骤定义类不为 public" enabled="false" language="JAVA" pluginId="cucumber-java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告非 public 步骤定义类。 Cucumber-JVM 仅使用来自 public 类的步骤定义。
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="CucumberUndefinedStep" defaultSeverity="WARNING" displayName="未定义的步骤" enabled="false" language="Gherkin" pluginId="gherkin" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告没有匹配步骤定义的 Cucumber（或其他一些 Gherkin）.feature 文件中的步骤。
&lt;p&gt;使用快速修复可以自动创建新的步骤定义。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CucumberJavaStepDefClassInDefaultPackage" defaultSeverity="WARNING" displayName="步骤定义类在默认软件包中" enabled="false" language="JAVA" pluginId="cucumber-java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告位于默认软件包中的步骤定义类。 Cucumber-JVM 仅在命名软件包中使用步骤定义类。
&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="Kotlin" path=""><inspection shortName="DeprecatedMavenDependency" defaultSeverity="WARNING" displayName="在 Maven 中使用了弃用的库" enabled="false" language="XML" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告已弃用的 Maven 依赖项。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &amp;lt;dependencies&gt;
    &amp;lt;dependency&gt;
        &amp;lt;groupId&gt;org.jetbrains.kotlin&amp;lt;/groupId&gt;
        &amp;lt;artifactId&gt;kotlin-stdlib-jre7&amp;lt;/artifactId&gt;
        &amp;lt;version&gt;${kotlin.version}&amp;lt;/version&gt;
    &amp;lt;/dependency&gt;
  &amp;lt;/dependencies&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该快速修复会将已弃用的依赖项更改为维护的依赖项：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
   &amp;lt;dependencies&gt;
    &amp;lt;dependency&gt;
        &amp;lt;groupId&gt;org.jetbrains.kotlin&amp;lt;/groupId&gt;
        &amp;lt;artifactId&gt;kotlin-stdlib-jdk7&amp;lt;/artifactId&gt;
        &amp;lt;version&gt;${kotlin.version}&amp;lt;/version&gt;
    &amp;lt;/dependency&gt;
  &amp;lt;/dependencies&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="KotlinTestJUnit" defaultSeverity="WARNING" displayName="kotlin-test-junit 可以使用" enabled="false" language="XML" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;kotlin-test&lt;/code&gt; 和 &lt;code&gt;junit&lt;/code&gt; 依赖项（无 &lt;code&gt;kotlin-test-junit&lt;/code&gt;）的用法。
&lt;p&gt;建议使用 &lt;code&gt;kotlin-test-junit&lt;/code&gt; 依赖项来处理 Kotlin 和 JUnit。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="KotlinMavenPluginPhase" defaultSeverity="WARNING" displayName="Kotlin Maven 插件配置错误" enabled="false" language="XML" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">报告 kotlin-maven-plugin 配置问题</inspection><inspection shortName="DifferentStdlibGradleVersion" defaultSeverity="WARNING" displayName="Kotlin 库和 Gradle 插件版本不同" enabled="false" language="Groovy" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告不同的 Kotlin stdlib 和编译器版本。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  dependencies {
    classpath "org.jetbrains.kotlin:kotlin-stdlib:0.0.1"
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;要修正此问题，请更改 kotlin stdlib 版本以匹配 kotlin 编译器版本。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DifferentKotlinMavenVersion" defaultSeverity="WARNING" displayName="Maven 和 IDE 插件版本不同" enabled="false" language="XML" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告当前的 IDE 插件无法正确支持 Maven 插件版本。
&lt;p&gt;这种不一致可能导致 IDE 和编译器出现不同的错误报告行为。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="KotlinInvalidBundleOrProperty" defaultSeverity="ERROR" displayName="无效属性健" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 Kotlin 文件中未解析的 &lt;code&gt;.properties&lt;/code&gt; 文件密钥和资源包引用。
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="DifferentKotlinGradleVersion" defaultSeverity="WARNING" displayName="Kotlin Gradle 和 IDE 插件版本不同" enabled="false" language="Groovy" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告当前的 IDE 插件无法正确支持 Gradle 插件版本。
&lt;p&gt;这可能会导致 IDE 和 Gradle 构建在错误报告或代码行为方面的不一致。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  dependencies {
    classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:0.0.1"
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;要修正此问题，请更改 kotlin gradle 插件版本以匹配捆绑到 IDE 插件中的 kotlin 版本。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DifferentMavenStdlibVersion" defaultSeverity="WARNING" displayName="库和 Maven 插件版本不同" enabled="false" language="XML" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告不同的 Kotlin stdlib 和编译器版本。
&lt;p&gt;使用不同版本的 Kotlin 编译器和标准库会导致不可预测的运行时问题，应避免此情况。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DeprecatedGradleDependency" defaultSeverity="WARNING" displayName="在 Gradle 中使用了弃用的库" enabled="false" language="Groovy" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 Gradle 构建脚本中已弃用的依赖项。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  dependencies {
      compile "org.jetbrains.kotlin:kotlin-stdlib-jre7:1.2.0"
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  dependencies {
      compile "org.jetbrains.kotlin:kotlin-stdlib-jdk7:1.2.0"
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Java 7" path="Java/Java 语言级别迁移帮助"><inspection shortName="Convert2Diamond" defaultSeverity="WARNING" displayName="显式类型可被替换为 '&lt;&gt;'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告其类型实参可被替换为菱形类型 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 的所有 &lt;code&gt;new&lt;/code&gt; 表达式。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;String&amp;gt;(); // 报告数组列表类型实参
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;仅当项目或模块的语言级别为 7 或更高时，此检查才会报告。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="EqualsReplaceableByObjectsCall" defaultSeverity="WEAK WARNING" displayName="'equals()' 表达式可被替换为 'Objects.equals()' 表达式" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以替换为对 &lt;code&gt;java.util.Objects#equals&lt;/code&gt; 的调用的表达式。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void f(Object a, Object b) {
    boolean result = a != null &amp;&amp; a.equals(b);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void f(Object a, Object b) {
    boolean result = Objects.equals(a, b);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  将 &lt;code&gt;a != null &amp;&amp; a.equals(b)&lt;/code&gt; 之类的表达式替换为 &lt;code&gt;Objects.equals(a, b)&lt;/code&gt; 会略微改变语义。 使用&lt;b&gt;高亮显示与 'a != null &amp;&amp; a.equals(b)' 类似的表达式&lt;/b&gt;选项，可启用或禁用此行为。
&lt;/p&gt;
&lt;p&gt;仅当项目或模块的语言级别为 7 或更高时，此检查才会报告。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SafeVarargsDetector" defaultSeverity="WARNING" displayName="形参化 vararg 类型可能导致堆污染" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告所有包含可变 arity 且可以注解为 &lt;code&gt;@SafeVarargs&lt;/code&gt; 的方法。
&lt;code&gt;@SafeVarargs&lt;/code&gt; 注解禁止有关在调用点创建形参化数组的未检查的警告。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Foo&amp;lt;T&amp;gt; {
    private List&amp;lt;T&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();

    public final void safeVarargs(T... elements) {
      Collections.addAll(list, elements);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Foo&amp;lt;T&amp;gt; {
    private List&amp;lt;T&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();

    @SafeVarargs
    public final void safeVarargs(T... elements) {
      Collections.addAll(list, elements);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  Java 1.6 或更早版本的 JVM 不支持此注解。
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TryWithIdenticalCatches" defaultSeverity="WARNING" displayName="'try' 语句中的相同 'catch' 分支" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告单个 &lt;code&gt;try&lt;/code&gt; 语句中相同的 &lt;code&gt;catch&lt;/code&gt; 部分。
&lt;p&gt;将这些部分折叠成一个 &lt;i&gt;multi-catch&lt;/i&gt; 块可以减少代码重复，并防止出现一个 &lt;code&gt;catch&lt;/code&gt; 部分更新而另一个部分未更新的情况。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    try {
        doSmth();
    }
    catch (IOException e) {
        LOG.error(e);
    }
    catch (URISyntaxException e) {
        LOG.error(e);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可通过快速修复使代码更加紧凑：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    try {
        doSmth();
    }
    catch (IOException | URISyntaxException e) {
        LOG.error(e);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;仅当项目或模块的语言级别为 7 或更高时，此检查才会报告。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TryFinallyCanBeTryWithResources" defaultSeverity="WARNING" displayName="'try finally' 可被替换为 'try' with resources" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可能使用 Java 7 Automatic Resource Management（这样不容易出错）的 &lt;code&gt;try&lt;/code&gt;-&lt;code&gt;finally&lt;/code&gt; 语句。
&lt;p&gt;可以通过快速修复将 &lt;code&gt;try&lt;/code&gt;-&lt;code&gt;finally&lt;/code&gt; 语句转换为 &lt;code&gt;try&lt;/code&gt;-with-resources 语句。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  PrintStream printStream = new PrintStream(fileName);
  try {
    printStream.print(true);
  } finally {
    printStream.close();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过快速修复将原因传递给构造函数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  try (PrintStream printStream = new PrintStream(fileName)) {
    printStream.print(true);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;仅当项目或模块的语言级别为 7 或更高时，此检查才会报告。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Security" path=""><inspection shortName="VulnerableCodeUsages" defaultSeverity="WARNING" displayName="Vulnerable API usage" enabled="false" language="UAST" pluginId="org.jetbrains.security.package-checker" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告导入依赖项的脆弱的 API 的用法。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;由 &lt;a href="https://checkmarx.com/"&gt;Checkmarx&lt;/a&gt; (c) 提供的脆弱性数据。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="VulnerableLibrariesLocal" defaultSeverity="WARNING" displayName="Vulnerable declared dependency" enabled="false" pluginId="org.jetbrains.security.package-checker" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告在项目中声明的 Gradle、Maven、NPM 和 PyPI 依赖项中的漏洞。
  Gradle 和 Maven 依赖项的完整列表显示在项目工具窗口的外部库下。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;由 &lt;a href="https://checkmarx.com/"&gt;Checkmarx&lt;/a&gt; (c) 提供的脆弱性数据。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="VulnerableLibrariesGlobal" defaultSeverity="WARNING" displayName="Vulnerable imported dependency" enabled="false" pluginId="org.jetbrains.security.package-checker" pluginVersion="223.8836.41" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告导入到项目中的 Gradle 和 Maven 依赖项中的漏洞。
  Gradle 和 Maven 依赖项的完整列表显示在项目工具窗口的外部库下。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;由 &lt;a href="https://checkmarx.com/"&gt;Checkmarx&lt;/a&gt; (c) 提供的脆弱性数据。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="可访问性" path="HTML"><inspection shortName="HtmlRequiredTitleAttribute" defaultSeverity="INFORMATION" displayName="缺少所需的 'title' 特性" enabled="false" language="XML" pluginId="HtmlTools" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告缺少的标题特性 &lt;code&gt;frame&lt;/code&gt;、&lt;code&gt;iframe&lt;/code&gt;、&lt;code&gt;dl&lt;/code&gt; 和 &lt;code&gt;a&lt;/code&gt; 标记。 建议添加标题特性。 基于 WCAG 2.0：&lt;a href="https://www.w3.org/TR/WCAG20-TECHS/H33.html"&gt;H33&lt;/a&gt;、&lt;a href="https://www.w3.org/TR/WCAG20-TECHS/H40.html"&gt;H40&lt;/a&gt; 和 &lt;a href="https://www.w3.org/TR/WCAG20-TECHS/H64.html"&gt;H64&lt;/a&gt;。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="HtmlFormInputWithoutLabel" defaultSeverity="WARNING" displayName="表单输入没有相关的label" enabled="false" language="XML" pluginId="HtmlTools" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告没有关联标签的表单元素 (&lt;code&gt;input&lt;/code&gt;、&lt;code&gt;textarea&lt;/code&gt; 或 &lt;code&gt;select&lt;/code&gt;)。 建议创建新标签。 基于 WCAG 2.0：&lt;a href="https://www.w3.org/TR/WCAG20-TECHS/H44.html"&gt;H44&lt;/a&gt;。&lt;br&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="HtmlRequiredAltAttribute" defaultSeverity="WARNING" displayName="缺少所需的 'alt' 特性" enabled="false" language="XML" pluginId="HtmlTools" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;img&lt;/code&gt; 或 &lt;code&gt;applet&lt;/code&gt; 标记或图像映射的 &lt;code&gt;area&lt;/code&gt; 元素中缺少的 &lt;code&gt;alt&lt;/code&gt; 特性。 建议添加含标签内容替代文本的必要特性。 基于 WCAG 2.0：&lt;a href="https://www.w3.org/TR/WCAG20-TECHS/H24.html"&gt;H24&lt;/a&gt;、&lt;a href="https://www.w3.org/TR/WCAG20-TECHS/H35.html"&gt;H35&lt;/a&gt;、&lt;a href="https://www.w3.org/TR/WCAG20-TECHS/H36.html"&gt;H36&lt;/a&gt;、&lt;a href="https://www.w3.org/TR/WCAG20-TECHS/H37.html"&gt;H37&lt;/a&gt;。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="HtmlRequiredLangAttribute" defaultSeverity="WARNING" displayName="缺少所需的 'lang' 特性" enabled="false" language="XML" pluginId="HtmlTools" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;html&lt;/code&gt; 标记中缺少的 &lt;code&gt;lang&lt;/code&gt;（或 &lt;code&gt;xml:lang&lt;/code&gt;）特性。 建议添加一项必备特性来声明文档的默认语言。 基于 WCAG 2.0：&lt;a href="https://www.w3.org/TR/WCAG20-TECHS/H57.html"&gt;H57&lt;/a&gt;。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="HtmlRequiredSummaryAttribute" defaultSeverity="INFORMATION" displayName="缺少所需的 'summary' 特性" enabled="false" language="XML" pluginId="HtmlTools" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;table&lt;/code&gt; 标记中缺少的 &lt;code&gt;summary&lt;/code&gt; 特性。 建议添加 &lt;code&gt;summary&lt;/code&gt; 特性。 基于 WCAG 2.0：&lt;a href="https://www.w3.org/TR/WCAG20-TECHS/H73.html"&gt;H73&lt;/a&gt;。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="HtmlRequiredTitleElement" defaultSeverity="WARNING" displayName="缺少所需的 'title' 元素" enabled="false" language="XML" pluginId="HtmlTools" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;head&lt;/code&gt; 部分中缺少的 &lt;code&gt;title&lt;/code&gt; 元素。 建议添加 &lt;code&gt;title&lt;/code&gt; 元素。 标题应能说明文档。 基于 WCAG 2.0：&lt;a href="https://www.w3.org/TR/WCAG20-TECHS/H25.html"&gt;H25&lt;/a&gt;。
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="其他问题" path="Kotlin"><inspection shortName="PublicApiImplicitType" defaultSeverity="WEAK WARNING" displayName="具有隐式返回值类型的公共 API 声明" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;
    报告具有隐式返回类型的 &lt;code&gt;public&lt;/code&gt; 和 &lt;code&gt;protected&lt;/code&gt; 函数和属性。
    出于 API 稳定性的原因，建议显式指定此种类型。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun publicFunctionWhichAbusesTypeInference() =
      otherFunctionWithNotObviousReturnType() ?: yetAnotherFunctionWithNotObviousReturnType()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun publicFunctionWhichAbusesTypeInference(): &lt;b&gt;Api&lt;/b&gt; =
      otherFunctionWithNotObviousReturnType() ?: yetAnotherFunctionWithNotObviousReturnType()
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RedundantEmptyInitializerBlock" defaultSeverity="WEAK WARNING" displayName="冗余空白初始值设定项块" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告冗余的空初始值设定项块。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
      init {
          // 空 init 块
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="KDocMissingDocumentation" defaultSeverity="WARNING" displayName="public 声明缺少 KDoc 注释" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告没有 KDoc 注释的 public 声明。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class A
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该快速修复会在声明上方生成注释块：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  /**
   *
   */
  class A
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MigrateDiagnosticSuppression" defaultSeverity="WARNING" displayName="应替换诊断名称" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告带有旧诊断名称的禁止，例如 &lt;code&gt;@Suppress("HEADER_WITHOUT_IMPLEMENTATION")&lt;/code&gt;。
&lt;p&gt;
    来自 Kotlin 1.2 及更早版本的一些诊断现在已经过时，从而使这样的禁止变得冗余。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
@Suppress("HEADER_DECLARATION_WITH_BODY")
expect fun connection() {
  // ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
@Suppress("EXPECTED_DECLARATION_WITH_BODY")
expect fun connection() {
  // ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReplaceWithStringBuilderAppendRange" defaultSeverity="WARNING" displayName="JVM 上的 'StringBuilder.append(CharArray, offset, len)' 调用" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 JVM 平台上应替换为 &lt;code&gt;StringBuilder.appendRange(CharArray, startIndex, endIndex)&lt;/code&gt; 函数调用的 &lt;code&gt;StringBuilder.append(CharArray, offset, len)&lt;/code&gt; 函数调用。
&lt;p&gt;&lt;code&gt;append&lt;/code&gt; 函数在 JVM、JS 和 Native 平台上的行为不同，因此推荐使用 &lt;code&gt;appendRange&lt;/code&gt; 函数。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun f(charArray: CharArray, offset: Int, len: Int): String {
      return buildString {
          append(charArray, offset, len)
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun f(charArray: CharArray, offset: Int, len: Int): String {
      return buildString {
          appendRange(charArray, offset, offset + len)
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="FloatingPointLiteralPrecision" defaultSeverity="WEAK WARNING" displayName="浮点文字超出可用精度" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告无法使用 &lt;a href="https://en.wikipedia.org/wiki/IEEE_754"&gt;IEEE 754&lt;/a&gt; 以所需精度表示的浮点文字 &lt;code&gt;Float&lt;/code&gt; 和 &lt;code&gt;Double&lt;/code&gt; 类型。

&lt;p&gt;
    例如，&lt;code&gt;1.9999999999999999999&lt;/code&gt; 的有效数字太多，因此其作为 &lt;code&gt;Double&lt;/code&gt; 的表示将舍入为 &lt;code&gt;2.0&lt;/code&gt;。
    指定多余的数字可能具有误导性，因为它掩盖了改用舍入值进行计算的事实。
&lt;/p&gt;

&lt;p&gt;
    该快速修复会将文字替换为与常量的实际表示相匹配的舍入值。
&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  val x: Float = 3.14159265359f
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  val x: Float = 3.1415927f
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ReplaceWithEnumMap" defaultSeverity="WARNING" displayName="'HashMap' 可被替换为 'EnumMap'" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以替换为 &lt;code&gt;EnumMap&lt;/code&gt; 构造函数调用的 &lt;code&gt;hashMapOf&lt;/code&gt; 函数或 &lt;code&gt;HashMap&lt;/code&gt; 构造函数调用。
&lt;p&gt;使用 &lt;code&gt;EnumMap&lt;/code&gt; 构造函数可使代码更简单。&lt;/p&gt;
&lt;p&gt;该快速修复会将函数调用替换为 &lt;code&gt;EnumMap&lt;/code&gt; 构造函数调用。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  enum class E {
      A, B
  }

  fun getMap(): Map&amp;lt;E, String&amp;gt; = hashMapOf()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  enum class E {
      A, B
  }

  fun getMap(): Map&amp;lt;E, String&amp;gt; = EnumMap(E::class.java)
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConvertArgumentToSet" defaultSeverity="WEAK WARNING" displayName="实参可以转换为 'Set' 以提高性能" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
检测可以通过将实参转换为 &lt;code&gt;Set&lt;/code&gt; 而加快速度的函数调用。

&lt;p&gt;
    当实参为集合时，'minus' 或 'intersect' 等运算更高效。
    将 &lt;code&gt;Iterable&amp;lt;T&amp;gt;&lt;/code&gt; 或 &lt;code&gt;Array&amp;lt;T&amp;gt;&lt;/code&gt; 显式转换为 &lt;code&gt;Set&amp;lt;T&amp;gt;&lt;/code&gt; 通常可以提高代码效率。
&lt;/p&gt;

&lt;p&gt;
    该快速修复会向函数调用添加显式转换。
&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun &amp;lt;T&amp;gt; f(a: Iterable&amp;lt;T&amp;gt;, b: Iterable&amp;lt;T&amp;gt;): Int =
      a.intersect(b).size
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun &amp;lt;T&amp;gt; f(a: Iterable&amp;lt;T&amp;gt;, b: Iterable&amp;lt;T&amp;gt;): Int =
      a.intersect(b.toSet()).size
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DeprecatedCallableAddReplaceWith" defaultSeverity="WEAK WARNING" displayName="不包含 'replaceWith' 实参的 @Deprecated 注解" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在其 &lt;code&gt;kotlin.deprecated&lt;/code&gt; 注解中没有 &lt;code&gt;kotlin.ReplaceWith&lt;/code&gt; 实参的已弃用函数和属性，IDE 会建议根据它们的主体进行添加。
&lt;p&gt;
    Kotlin 提供 &lt;code&gt;ReplaceWith&lt;/code&gt; 实参来自动替换已弃用的声明。
    建议使用实参来修正代码中的弃用问题。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Deprecated("Use refined() instead.")
  fun deprecated() = refined()

  fun refined() = 42
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该快速修复会添加 &lt;code&gt;ReplaceWith()&lt;/code&gt; 实参：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Deprecated("Use refined() instead.", ReplaceWith("refined()"))
  fun deprecated() = refined()

  fun refined() = 42
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="冗余定义" path="Java/Lombok"><inspection shortName="RedundantSlf4jDefinition" defaultSeverity="WARNING" displayName="@Slf4j" enabled="false" language="JAVA" pluginId="Lombook Plugin" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告明确定义的 &lt;em&gt;Slf4j&lt;/em&gt; 记录器。 可以改用 &lt;code&gt;@Slf4j&lt;/code&gt; 注解。
&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="TypeScript" path="JavaScript and TypeScript"><inspection shortName="TypeScriptValidateJSTypes" defaultSeverity="WEAK WARNING" displayName="'any' 类型的类型不匹配" enabled="false" language="TypeScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
如果上下文符号可以隐式解析为 &lt;code&gt;any&lt;/code&gt; 类型，则报告包含形参、返回值、赋值表达式或类型不正确的函数调用。
&lt;pre&gt;
declare var test: any;
test.hasOwnProperty(true); //报告 'true'
&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TypeScriptFieldCanBeMadeReadonly" defaultSeverity="WEAK WARNING" displayName="可以为只读字段" enabled="false" language="TypeScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可设为 readonly 的 private 字段（例如，如果该字段仅在构造函数中赋值）。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TypeScriptMissingAugmentationImport" defaultSeverity="INFORMATION" displayName="缺少增强导入" enabled="false" language="TypeScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告没有显式 import 的
&lt;a href="https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation"&gt;增强模块&lt;/a&gt;的用法。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TypeScriptUMDGlobal" defaultSeverity="WEAK WARNING" displayName="已引用的 UMD 全局变量" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
如果当前文件是模块（EcmaScript 或 CommonJS），则报告 UMD 全局变量的用法。
如果没有隐式包含此库，那么在没有显式 import 的情况下引用 UMD 变量可能会导致运行时错误。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TypeScriptUnresolvedVariable" defaultSeverity="WEAK WARNING" displayName="未解析的 TypeScript 变量" enabled="false" language="TypeScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对变量或字段的未解析引用。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TypeScriptLibrary" defaultSeverity="ERROR" displayName="缺少全局库" enabled="false" language="TypeScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告符号必须具备但未在 &lt;code&gt;tsconfig.json&lt;/code&gt; 中的 &lt;code&gt;lib&lt;/code&gt; 编译器选项下列出的 TypeScript 库文件。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TypeScriptExplicitMemberType" defaultSeverity="INFORMATION" displayName="显式类型" enabled="false" language="TypeScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告与显式类型的当前代码样式不匹配的类型注解。
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  从上下文推断出的类型与类型注解完全匹配时，不需要类型声明，例如：
&lt;/p&gt;
&lt;p&gt;
  &lt;code&gt;
    var pi: number = 3.14
  &lt;/code&gt;
&lt;/p&gt;
&lt;p&gt;在某些情况下，最好始终采用显式类型 - 这可以防止意外更改类型，并使代码更明确。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TypeScriptConfig" defaultSeverity="WARNING" displayName="不一致的 Tsconfig.json 属性" enabled="false" language="JSON" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 tsconfig.json 文件中的 &lt;code&gt;paths&lt;/code&gt; 、&lt;code&gt;checkJs&lt;/code&gt; 或 &lt;code&gt;extends&lt;/code&gt; 属性不一致的情况。
&lt;br&gt;
&lt;code&gt;checkJs&lt;/code&gt; 属性必须具备 &lt;code&gt;allowJs&lt;/code&gt;。
&lt;br&gt;
&lt;code&gt;extends&lt;/code&gt; 属性应为有效的文件引用。

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TypeScriptValidateGenericTypes" defaultSeverity="ERROR" displayName="不正确的泛型实参" enabled="false" language="TypeScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告函数、接口或类声明中的无效类型实参。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TypeScriptAbstractClassConstructorCanBeMadeProtected" defaultSeverity="WEAK WARNING" displayName="抽象类构造函数可以设为 protected" enabled="false" language="TypeScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 abstract 类的 public 构造函数，并建议将其设置为 protected（因为将其设置为 public 是无用的）。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TypeScriptRedundantGenericType" defaultSeverity="WEAK WARNING" displayName="冗余类型实参" enabled="false" language="TypeScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告其值等于默认值并且可以移除的类型实参。
&lt;p&gt;
示例：
&lt;pre&gt;
type Foo&amp;#60;T=number&gt; = T;
let z: Foo&amp;#60;number&gt;;
&lt;/pre&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TypeScriptDuplicateUnionOrIntersectionType" defaultSeverity="WARNING" displayName="联合或相交类型组件重复" enabled="false" language="TypeScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告合集或交集中的重复类型。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TypeScriptSmartCast" defaultSeverity="WARNING" displayName="范围缩小的类型" enabled="false" language="TypeScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告通过类型防护缩小变量类型范围时的变量用法。
请注意，严重性级别不影响此检查。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSEqualityComparisonWithCoercion.TS" defaultSeverity="WARNING" displayName="相等运算符可能导致类型强制" enabled="false" language="TypeScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可能导致意外类型强制的相等运算符的用法。
建议将 &lt;code&gt;==&lt;/code&gt; 或 &lt;code&gt;!=&lt;/code&gt; 相等运算符替换为类型安全的 &lt;code&gt;===&lt;/code&gt; 或 &lt;code&gt;!==&lt;/code&gt; 运算符。

&lt;p&gt;根据所选的选项，将报告下面的一种情况：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;code&gt;==&lt;/code&gt; 和 &lt;code&gt;!=&lt;/code&gt; 运算符的所有用法。
  &lt;/li&gt;
  &lt;li&gt;
    除了与 null 比较之外的所有用法。 某些代码样式允许使用 &lt;code&gt;x == null&lt;/code&gt; 替代
    &lt;code&gt;x === null || x === undefined&lt;/code&gt;。
  &lt;/li&gt;
  &lt;li&gt;
    仅可疑的表达式，例如：&lt;code&gt;==&lt;/code&gt; 或 &lt;code&gt;!=&lt;/code&gt; 与
     &lt;code&gt;0&lt;/code&gt;、&lt;code&gt;''&lt;/code&gt;、
    &lt;code&gt;null&lt;/code&gt;、&lt;code&gt;true&lt;/code&gt;、
    &lt;code&gt;false&lt;/code&gt; 或 &lt;code&gt;undefined&lt;/code&gt; 比较。
  &lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TypeScriptValidateTypes" defaultSeverity="ERROR" displayName="类型不匹配" enabled="false" language="TypeScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告类型不正确的形参、返回值或赋值表达式。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TypeScriptCheckImport" defaultSeverity="ERROR" displayName="未解析的已导入名称" enabled="false" language="TypeScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 TypeScript 代码的 &lt;code&gt;import&lt;/code&gt; 声明中未解析的名称或绑定。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TypeScriptMissingConfigOption" defaultSeverity="WARNING" displayName="缺少 tsconfig.json 选项 " enabled="false" language="TypeScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;tsconfig.json&lt;/code&gt; 中需要显式选项的用法。
例如，要在 &lt;code&gt;.tsx&lt;/code&gt; 文件中使用 JSX，&lt;code&gt;tsconfig.json&lt;/code&gt; 必须包含 &lt;code&gt;"jsx"&lt;/code&gt; 属性。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TypeScriptUnresolvedFunction" defaultSeverity="WEAK WARNING" displayName="未解析的 TypeScript 函数" enabled="false" language="TypeScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告未解析的函数调用。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TypeScriptSuspiciousConstructorParameterAssignment" defaultSeverity="WARNING" displayName="已分配构造函数字段形参" enabled="false" language="TypeScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
在类字段声明为构造函数形参，然后为此形参赋值时，报告 TypeScript 代码中的常见错误。&lt;br/&gt;
在这种情况下，&lt;i&gt;不会&lt;/i&gt;赋值给相应的字段，而只是修改局部形参值。
&lt;pre&gt;
class Foo {
  constructor(private p: number) {
    p = 1; //必须为 this.p = 1;
  }
}
&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TypeScriptJSXUnresolvedComponent" defaultSeverity="WEAK WARNING" displayName="未解析的 JSX 组件" enabled="false" language="TypeScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对 JSX 组件的未解析引用。
如果引用的组件在此项目或其依赖项中定义，则建议添加 import 语句，或使用指定名称创建新组件。
&lt;p&gt;新组件的模板可以在“编辑器 | 文件和代码模板”中修改。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Java EE" path=""><inspection shortName="JavaeeApplicationDomInspection" defaultSeverity="ERROR" displayName="Java EE 应用程序描述符正确性" enabled="false" language="XML" pluginId="com.intellij.javaee" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 `application.xml` 配置文件中的以下问题：
&lt;ul&gt;
  &lt;li&gt;对不可实例化类的引用&lt;/li&gt;
  &lt;li&gt;对不扩展所需类的类的引用&lt;/li&gt;
  &lt;li&gt;对范围不适当的类的引用&lt;/li&gt;
  &lt;li&gt;与所需模式不匹配的标记和特性值（例如，Java 标识符）&lt;/li&gt;
  &lt;li&gt;不包含必需子标记或特性的标记&lt;/li&gt;
  &lt;li&gt;定义具有重复名称的对象的标记&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;&lt;br/&gt;
&lt;pre&gt;&lt;code&gt;
&amp;lt;application&amp;gt;
    &amp;lt;module id="ExampleWebModule"&amp;gt;
      &amp;lt;web&amp;gt; // 错误：应定义 “web-uri” 子标记
        &amp;lt;context-root&amp;gt;ExampleWebApp&amp;lt;/context-root&amp;gt;
      &amp;lt;/web&amp;gt;
    &amp;lt;/module&amp;gt;
&amp;lt;/application&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MimeType" defaultSeverity="ERROR" displayName="MIME 类型" enabled="false" language="XML" pluginId="com.intellij.javaee.web" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;

允许您控制 MIME 类型名称的有效性。

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="WebWarnings" defaultSeverity="WARNING" displayName="Web.xml 警告" enabled="false" language="XML" pluginId="com.intellij.javaee.web" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告描述符中用于将 Web 模块部署到服务器的重复 welcome-file。

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;&lt;br/&gt;
&lt;pre&gt;&lt;code&gt;
  &amp;lt;?xml version="1.0" encoding="UTF-8"?&amp;gt;
  &amp;lt;!DOCTYPE web-app PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN" "http://java.sun.com/dtd/web-app_2_3.dtd"&amp;gt;
  &amp;lt;web-app&amp;gt;
    &amp;lt;welcome-file-list&amp;gt;
      &amp;lt;welcome-file&amp;gt;
        Welcome1.jsp
      &amp;lt;/welcome-file&amp;gt;
      &amp;lt;welcome-file&amp;gt;
        /Welcome1.jsp // 错误：重复的 welcome-file
      &amp;lt;/welcome-file&amp;gt;
      &amp;lt;welcome-file&amp;gt;
        Welcome3.jsp
      &amp;lt;/welcome-file&amp;gt;
    &amp;lt;/welcome-file-list&amp;gt;
  &amp;lt;/web-app&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ServletWithoutMappingInspection" defaultSeverity="ERROR" displayName="Servlet 映射" enabled="false" language="XML" pluginId="com.intellij.javaee.web" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告没有关联映射的 servlet。

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &amp;lt;web-app&amp;gt;
    &amp;lt;servlet&amp;gt;
      &amp;lt;servlet-name&amp;gt;foo&amp;lt;/servlet-name&amp;gt; // 错误：servlet 应该有一个映射
      &amp;lt;servlet-class&amp;gt;javax.servlet.Servlet&amp;lt;/servlet-class&amp;gt;
    &amp;lt;/servlet&amp;gt;
  
    &amp;lt;filter&amp;gt;
      &amp;lt;filter-name&amp;gt;bar&amp;lt;/filter-name&amp;gt; // 错误：筛选器应该有一个映射
      &amp;lt;filter-class&amp;gt;java.lang.String&amp;lt;/filter-class&amp;gt;
    &amp;lt;/filter&amp;gt;
  &amp;lt;/web-app&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SecurityRoles" defaultSeverity="ERROR" displayName="安全角色名称的正确性" enabled="false" language="XML" pluginId="com.intellij.javaee" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告无效的安全角色名称。

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &amp;lt;web-app&amp;gt;
    &amp;lt;security-role&amp;gt;
      &amp;lt;role-name&amp;gt;custom#role&amp;lt;/role-name&amp;gt; // 错误：名称无效
    &amp;lt;/security-role&amp;gt;
    &amp;lt;security-role&amp;gt;
      &amp;lt;role-name&amp;gt;customRole&amp;lt;/role-name&amp;gt; // 好名称
    &amp;lt;/security-role&amp;gt;
  &amp;lt;/web-app&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="WebProperties" defaultSeverity="ERROR" displayName="Web.xml 错误" enabled="false" language="XML" pluginId="com.intellij.javaee.web" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告用于将 Web 模块部署到服务器的描述符中的以下问题：
&lt;ul&gt;
  &lt;li&gt;对不可实例化类的引用&lt;/li&gt;
  &lt;li&gt;对不扩展所需类的类的引用&lt;/li&gt;
  &lt;li&gt;对范围不适当的类的引用&lt;/li&gt;
  &lt;li&gt;空标记和特性值&lt;/li&gt;
  &lt;li&gt;与所需模式不匹配的标记和特性值（例如，Java 标识符）&lt;/li&gt;
  &lt;li&gt;不包含必需子标记或特性的标记&lt;/li&gt;
  &lt;li&gt;定义具有重复名称的对象的标记&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;&lt;br/&gt;
&lt;pre&gt;&lt;code&gt;
&amp;lt;web-app&amp;gt;
  &amp;lt;filter-mapping&amp;gt;
    &amp;lt;filter-name&amp;gt;CustomFilter&amp;lt;/filter-name&amp;gt; // 错误：应定义 servlet-name 或 url-pattern 子标记
  &amp;lt;/filter-mapping&amp;gt;
  &amp;lt;servlet-mapping&amp;gt;
    &amp;lt;servlet-name&amp;gt;CustomServletName&amp;lt;/servlet-name&amp;gt;
    &amp;lt;url-pattern&amp;gt;/ baseUrl&amp;lt;/url-pattern&amp;gt; // 错误：URI 模式不得包含空格
  &amp;lt;/servlet-mapping&amp;gt;
&amp;lt;/web-app&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="单元测试" path="JavaScript and TypeScript"><inspection shortName="JSTestFailedLine" defaultSeverity="WARNING" displayName="在测试代码中高亮显示失败的行" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告失败的方法调用或测试中的断言。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="KarmaConfigFile" defaultSeverity="WARNING" displayName="无效的 Karma 配置文件" enabled="false" language="JavaScript" pluginId="Karma" pluginVersion="223.8836.41" isGlobalTool="false">&lt;!--
  ~ Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
  --&gt;

&lt;html&gt;
&lt;body&gt;
  报告 Karma 配置文件 (例如 &lt;code&gt;karma.conf.js&lt;/code&gt;) 的文件路径 ('basePath'、'files') 中的潜在错误。
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="线程问题" path="Java"><inspection shortName="WaitNotInLoop" defaultSeverity="WARNING" displayName="未在循环中调用的 'wait()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告不是在循环中进行的 &lt;code&gt;wait()&lt;/code&gt; 调用。
&lt;p&gt;
  &lt;code&gt;wait()&lt;/code&gt; 通常用于挂起线程，直到某个条件变为 true 为止。
  线程可能出于不同的原因而被唤醒，因此在 &lt;code&gt;wait()&lt;/code&gt; 调用返回后应检查条件。
  使用循环很容易做到这一点。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class BoundedCounter {
    private int count;
    synchronized void inc() throws InterruptedException {
      if (count &gt;= 10) wait();
      ++count;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;优良的代码应类似于：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class BoundedCounter {
    private int count;
    synchronized void inc() throws InterruptedException {
      while (count &gt;= 10) wait();
      ++count;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AwaitWithoutCorrespondingSignal" defaultSeverity="WARNING" displayName="没有相应 'signal()' 的 'await()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对无法为之找到相应 &lt;code&gt;Condition.signal()&lt;/code&gt; 或 &lt;code&gt;Condition.signalAll()&lt;/code&gt; 调用的 &lt;code&gt;Condition.await()&lt;/code&gt; 的调用。
&lt;p&gt;
  在没有相应 &lt;code&gt;Condition.signal()&lt;/code&gt; 的线程中调用 &lt;code&gt;Condition.await()&lt;/code&gt; 可能导致该线程被禁用，直到它被中断或发生“可疑唤醒”为止。
&lt;/p&gt;
&lt;p&gt;此检查仅报告以当前类的目标字段为目标的调用。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Queue {
    private final Condition isEmpty = ...;

    void add(Object elem) {
      // ...
      // isEmpty.signal();
      // ...
    }

    void remove(Object elem) throws InterruptedException {
      // ...
      isEmpty.await(); // 'await()' 不包含相应的 'signal()'/'signalAll()' 调用
      // ...
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SynchronizeOnNonFinalField" defaultSeverity="WARNING" displayName="在非 final 字段上同步" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告由非 &lt;code&gt;final&lt;/code&gt; 字段引用组成的 &lt;code&gt;synchronized&lt;/code&gt; 语句锁定表达式。
此类语句不太可能包含有用的语义，因为不同的线程即便在对同一对象上操作时也可能获取不同的锁定。
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  private Object o;
  public void foo() {
    synchronized (o) // 在非 final 字段上同步
    { }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NotifyWithoutCorrespondingWait" defaultSeverity="WARNING" displayName="没有相应 'wait()' 的 'notify()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对无法为之找到相应 &lt;code&gt;Object.wait()&lt;/code&gt; 调用的 &lt;code&gt;Object.notify()&lt;/code&gt; 或 &lt;code&gt;Object.notifyAll()&lt;/code&gt; 的调用。
&lt;p&gt;此检查仅报告以当前类的目标字段为目标的调用。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  synchronized (synList) {
    synList.notify(); //从未调用 synList.wait()
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MethodMayBeSynchronized" defaultSeverity="WARNING" displayName="只有一个 'synchronized' 块的方法可被替换为 'synchronized' 方法" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告其主体只包含一条 &lt;code&gt;synchronized&lt;/code&gt; 语句的方法。
对于实例方法，此 &lt;code&gt;synchronized&lt;/code&gt; 语句的锁定表达式必须等于 &lt;code&gt;this&lt;/code&gt;；对于 static 方法，必须等于 &lt;code&gt;[ClassName].class&lt;/code&gt;。
&lt;p&gt;
  为改善此类方法的可读性，可以移除 &lt;code&gt;synchronized&lt;/code&gt; 包装器，并将方法标记为 &lt;code&gt;synchronized&lt;/code&gt;。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public int generateInt(int x) {
    synchronized (this) {
      return 1;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public synchronized int generateInt(int x) {
    return 1;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SynchronizationOnLocalVariableOrMethodParameter" defaultSeverity="WARNING" displayName="在局部变量或方法形参上同步" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告局部变量或形参的同步。 
&lt;p&gt;
  使用此类同步时，很难保证正确的运算。
  可以改进此类代码，例如，通过使用 synchronized 包装器类控制访问或通过在字段上进行同步。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void bar() {
    final Object lock = new Object();
    synchronized (lock) { }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="WaitWithoutCorrespondingNotify" defaultSeverity="WARNING" displayName="没有相应 'notify()' 的 'wait()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对无法为之找到相应 &lt;code&gt;Object.notify()&lt;/code&gt; 或 &lt;code&gt;Object.notifyAll()&lt;/code&gt; 调用的 &lt;code&gt;Object.wait()&lt;/code&gt; 的调用。
&lt;p&gt;此检查仅报告包含引用当前类字段的限定符的调用。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Foo {
    public Object foo = new Object();

    void bar() throws InterruptedException {
      this.foo.wait();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConditionSignal" defaultSeverity="WARNING" displayName="调用 'signal()' 而不是 'signalAll()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对 &lt;code&gt;java.util.concurrent.locks.Condition.signal()&lt;/code&gt; 的调用。 虽然偶尔有用，但在几乎所有情况下，&lt;code&gt;signalAll()&lt;/code&gt; 都是更好、更安全的选择。
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ThreadStartInConstruction" defaultSeverity="WARNING" displayName="对象构造期间调用 'Thread.start()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对象构造过程中在 &lt;code&gt;java.lang.Thread&lt;/code&gt; 或其任何子类上对 &lt;code&gt;start()&lt;/code&gt; 的调用。
&lt;p&gt;
  虽然此类结构偶尔有用，但由于继承问题，应避免使用。
  在对象构造期间启动线程的类的子类在线程启动前不会完成自身的任何初始化逻辑。
&lt;/p&gt;
&lt;p&gt;如果启动线程的类被声明为 &lt;code&gt;final&lt;/code&gt;，此检查不会报告。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class MyThread extends Thread {
    MyThread() {
      start();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CallToNativeMethodWhileLocked" defaultSeverity="WARNING" displayName="锁定时调用 'native' 方法" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;synchronized&lt;/code&gt; 块或方法中的调用 &lt;code&gt;native&lt;/code&gt; 方法。
&lt;p&gt;
  如果可能，最好将对 &lt;code&gt;native&lt;/code&gt; 方法的调用排除在同步上下文之外，因为此类调用会导致开销巨大的上下文切换，并且可能导致性能问题。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  native void nativeMethod();

  void example(){
    synchronized (lock){
      nativeMethod();//警告
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="WaitCalledOnCondition" defaultSeverity="WARNING" displayName="在 'java.util.concurrent.locks.Condition' 对象上调用了 'wait()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在 &lt;code&gt;java.util.concurrent.locks.Condition&lt;/code&gt; 对象上进行的 &lt;code&gt;wait()&lt;/code&gt; 调用。 这可能是编程错误，本应使用 &lt;code&gt;await()&lt;/code&gt; 方法的某种变体。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void acquire(Condition released) throws InterruptedException {
    while (acquired) {
      released.wait();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;优良的代码应类似于：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void acquire(Condition released) throws InterruptedException {
    while (acquired) {
      released.await();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FieldAccessedSynchronizedAndUnsynchronized" defaultSeverity="WARNING" displayName="同时在 'synchronized' 和未同步上下文中访问字段" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在 &lt;code&gt;synchronized&lt;/code&gt; 和非 &lt;code&gt;synchronized&lt;/code&gt; 上下文中访问的非 final 字段。
&lt;code&gt;volatile&lt;/code&gt; 字段以及构造函数和初始值设定项中的访问将被此检查忽略。
&lt;p&gt;
  此类“部分同步的”访问通常是编码疏忽所致，可能导致意外的不一致数据结构。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Program {
    Console console; // 警告：在同步和非同步上下文中都访问字段 'console'

    public synchronized void execute() {
      console.print("running");
    }

    public void check() {
      console.check();
    }
  }
&lt;/code&gt;
&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用该选项可以指定简单的 getter 和 setter 是否也算作访问。
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SharedThreadLocalRandom" defaultSeverity="WARNING" displayName="'ThreadLocalRandom' 实例可能是共享的" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可能在线程之间共享的 &lt;code&gt;java.util.concurrent.ThreadLocalRandom&lt;/code&gt; 实例。
&lt;p&gt;
  &lt;code&gt;ThreadLocalRandom&lt;/code&gt; 不应在线程之间共享，因为不具备线程安全。
  该检查可以报告分配给用作方法实参的字段，或分配给局部变量并在匿名类或嵌套类中使用的实例，因为它们可能在线程之间共享。
&lt;/p&gt;
&lt;p&gt;
  &lt;code&gt;ThreadLocalRandom&lt;/code&gt; 的用法通常应类似于&lt;code&gt;ThreadLocalRandom.current().nextInt(...)&lt;/code&gt;（或 &lt;code&gt;nextDouble(...)&lt;/code&gt; 等）。
  当所有用法都采取这种形式时，&lt;code&gt;ThreadLocalRandom&lt;/code&gt; 实例就不会被多个线程误用。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    class Main {
      void printRandomNumbersAsync() {
        ThreadLocalRandom random = ThreadLocalRandom.current();
        CompletableFuture.supplyAsync(() -&amp;gt; generateNumbers(random))
          .thenAccept(numbers -&amp;gt; System.out.println(Arrays.toString(numbers)));
      }

      private int[] generateNumbers(Random random) {
        return random.ints(1000, 0, 100).toArray();
      }
    }
  &lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用这些选项可以列出能够作为实参传递给 &lt;code&gt;ThreadLocalRandom&lt;/code&gt; 实例的方法。
  可以将正则表达式用于方法名称。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SleepWhileHoldingLock" defaultSeverity="WARNING" displayName="同步时调用 'Thread.sleep()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对发生在 &lt;code&gt;synchronized&lt;/code&gt; 块或方法中的&lt;code&gt;java.lang.Thread.sleep()&lt;/code&gt; 方法的调用。
&lt;p&gt;
  &lt;code&gt;synchronized&lt;/code&gt; 块中的 &lt;code&gt;sleep()&lt;/code&gt; 可能导致性能下降，可扩展性变差，甚至可能导致死锁。 不妨改用 &lt;code&gt;wait()&lt;/code&gt;，因为它将释放持有的锁定。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  synchronized (lock) {
    Thread.sleep(100);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="WaitWhileHoldingTwoLocks" defaultSeverity="WARNING" displayName="保持两个锁时 'wait()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在当前线程持有两个锁定时可能发生的对 &lt;code&gt;wait()&lt;/code&gt; 方法的调用。
&lt;p&gt;
  调用 &lt;code&gt;wait()&lt;/code&gt; 只会释放目标上的一个锁定，因此持有两个锁定时的等待很容易导致死锁。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  synchronized (lockA) {
    synchronized (lockB) {
      lockB.wait(); //警告
      //线程 A 卡在这里，持有 lockA
    }
  }

  synchronized (lockA) { //线程 B 无法进入此块和释放线程 A
    lockB.notify();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SynchronizedOnLiteralObject" defaultSeverity="WARNING" displayName="在使用文字初始化的对象上同步" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在用文字初始化的对象上锁定的 &lt;code&gt;synchronized&lt;/code&gt; 块。
&lt;p&gt;
  字符串文字是暂存的，&lt;code&gt;Character&lt;/code&gt;、&lt;code&gt;Boolean&lt;/code&gt; 和 &lt;code&gt;Number&lt;/code&gt; 文字可以从缓存中分配。
  正因为如此，可能系统的其他某些部分（使用通过相同文字初始化的对象）实际上会包含对完全相同的对象的引用。 如果锁定对象被认为是 private 对象，这可能会产生意外的死锁情况。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Main {
    final String mutex = "Mutex";
    void method() {
      synchronized (mutex) {
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用&lt;strong&gt;警告所有可能的文字&lt;/strong&gt;选项可以报告 &lt;code&gt;String&lt;/code&gt;、&lt;code&gt;Character&lt;/code&gt;、&lt;code&gt;Boolean&lt;/code&gt; 和 &lt;code&gt;Number&lt;/code&gt; 对象的任何同步。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StaticInitializerReferencesSubClass" defaultSeverity="WARNING" displayName="static 初始值设定项引用子类" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在 static 初始值设定项或 static 字段中引用其子类的类。
&lt;p&gt;此类引用可能在多线程环境（即一个线程试图加载超类，另一个线程同时试图加载子类）中引起 JVM 级死锁。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Parent {
    static final Child field = new Child();
  }
  class Child extends Parent { }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ExtendsThread" defaultSeverity="WARNING" displayName="类直接扩展 'Thread'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告直接扩展 &lt;code&gt;java.lang.Thread&lt;/code&gt; 的类。
通常建议使用组合而不是继承来创建更便于日后修改的可重用代码。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class MainThread extends Thread {
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="VolatileArrayField" defaultSeverity="WARNING" displayName="volatile 数组字段" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告被声明为 &lt;code&gt;volatile&lt;/code&gt; 的数组字段。 此类声明可能令人困惑，因为访问数组本身遵循 &lt;code&gt;volatile&lt;/code&gt; 字段的规则，但访问数组的内容时并非如此。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Data {
    private volatile int[] idx = new int[0];
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  如果需要对数组内容进行此类可变访问，不妨改用 &lt;code&gt;java.util.concurrent.atomic&lt;/code&gt; 类：
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Data {
    private final AtomicIntegerArray idx = new AtomicIntegerArray(new int[0]);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AccessToStaticFieldLockedOnInstance" defaultSeverity="WARNING" displayName="访问实例数据上锁定的 'static' 字段" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对在 &lt;code&gt;this&lt;/code&gt; 或 &lt;code&gt;this&lt;/code&gt; 的实例字段上锁定的非常量 static 字段的访问。
&lt;p&gt;
  在实例数据上锁定 static 字段并不能防止其他实例修改该字段，因此可能会导致意外的竞争条件。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  static String test;
  public void foo() {
      synchronized (this) {
          System.out.println(test); // 警告
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  通过快速修复可以忽略特定类型的 static 字段。
  可以在检查选项中管理被忽略的类型。
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用检查选项可以指定应忽略哪些用于 static 字段的类。
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="BusyWait" defaultSeverity="WARNING" displayName="忙等待" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在循环内发生的对 &lt;code&gt;java.lang.Thread.sleep()&lt;/code&gt; 的调用。
&lt;p&gt;此类调用表示“忙等待”。 忙等待通常效率低下，并且可能导致意外死锁，因为忙等待线程不会释放锁定的资源。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class X {
     volatile int x;
     public void waitX() throws Exception {
      while (x &amp;gt; 0) {
        Thread.sleep(10);// 警告：在循环中调用 'Thread.sleep()'，可能处于忙等待
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="WhileLoopSpinsOnField" defaultSeverity="WARNING" displayName="'while' 循环在字段上自旋" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在非 &lt;code&gt;volatile&lt;/code&gt; 字段值上自旋，等待它被另一个线程更改的 &lt;code&gt;while&lt;/code&gt; 循环。
&lt;p&gt;
除了在循环内完成少量工作时可能会非常耗费 CPU 之外，此类循环很可能具有与预期不同的语义。
即便另一个线程更改了该字段的值，Java 内存模型也允许此类循环永不完成。
&lt;/p&gt;
&lt;p&gt;
此外，自 Java 9 起，建议在 &lt;code&gt;volatile&lt;/code&gt; 字段上的自旋循环中调用 &lt;code&gt;Thread.onSpinWait()&lt;/code&gt;，这可能会显著提高某些硬件上的性能。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class SpinsOnField {
    boolean ready = false;

    void run() {
      while (!ready) {
      }
      // 执行某些工作
    }

    void markAsReady() {
      ready = true;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class SpinsOnField {
    volatile boolean ready = false;

    void run() {
      while (!ready) {
        Thread.onSpinWait();
      }
      // 执行某些工作
    }

    void markAsReady() {
      ready = true;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
使用检查选项可仅报告空的 &lt;code&gt;while&lt;/code&gt; 循环。
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ThreadWithDefaultRunMethod" defaultSeverity="WARNING" displayName="使用默认的 'run()' 方法实例化 'Thread'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在不指定 &lt;code&gt;Runnable&lt;/code&gt; 形参或重写 &lt;code&gt;run()&lt;/code&gt; 方法的情况下实例化 &lt;code&gt;Thread&lt;/code&gt; 的代码。
&lt;p&gt;
  此类线程没有任何用。
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AccessToNonThreadSafeStaticFieldFromInstance" defaultSeverity="WARNING" displayName="非线程安全的 'static' 字段访问" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对非线程安全类型的 &lt;code&gt;static&lt;/code&gt; 字段的访问。
&lt;p&gt;
  从实例方法或非同步块访问 &lt;code&gt;static&lt;/code&gt; 字段时，多个线程都可以访问该字段。
  这可能导致未指明的副作用，例如异常和不正确的结果。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Sample {
    private static final SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd");
    String method() {
      return df.format("");
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  您可以指定哪些类型应被视为非线程安全。
  仅报告具有这些确切类型或使用这些确切类型进行初始化的字段，因为可能存在这些类型的线程安全子类。
&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NotifyCalledOnCondition" defaultSeverity="WARNING" displayName="在 'java.util.concurrent.locks.Condition' 对象上调用了 'notify()' 或 'notifyAll()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在 &lt;code&gt;java.util.concurrent.locks.Condition&lt;/code&gt; 对象上对 &lt;code&gt;notify()&lt;/code&gt; 或 &lt;code&gt;notifyAll()&lt;/code&gt; 的调用。
&lt;p&gt;
  这可能是编程错误，本应使用 &lt;code&gt;signal()&lt;/code&gt; 或 &lt;code&gt;signalAll()&lt;/code&gt; 方法的某些变体，否则可能出现 &lt;code&gt;IllegalMonitorStateException&lt;/code&gt;。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class C {
    final Lock l = new ReentrantLock();
    final Condition c = l.newCondition();

    void release() {
      l.lock();
      try {
        c.notifyAll(); // 此处可能本应使用 'signalAll()'
      } finally {
        l.unlock();
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ThreadLocalNotStaticFinal" defaultSeverity="WARNING" displayName="'ThreadLocal' 字段未被声明为 'static final'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告未被声明为 &lt;code&gt;static final&lt;/code&gt; 的 &lt;code&gt;java.lang.ThreadLocal&lt;/code&gt; 类型的字段。
&lt;p&gt;
  在最常见的情况下，&lt;code&gt;java.lang.ThreadLocal&lt;/code&gt; 实例会将状态与线程关联。
  非 static、非 final &lt;code&gt;java.lang.ThreadLocal&lt;/code&gt; 字段会将状态与实例线程组合关联。
  这通常是不必要的，而且通常是可能导致内存泄漏和行为不正确的错误。
&lt;/p&gt;
&lt;p&gt;
  建议通过快速修复将该字段设为 &lt;code&gt;static final&lt;/code&gt;。
&lt;p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  private ThreadLocal tl = ThreadLocal.withInitial(() -&gt; Boolean.TRUE);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NakedNotify" defaultSeverity="WARNING" displayName="没有相应状态更改的 'notify()' 或 'notifyAll()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告调用的未发生任何可检测到的状态变更的 &lt;code&gt;Object.notify()&lt;/code&gt; 或 &lt;code&gt;Object.notifyAll()&lt;/code&gt;。
&lt;p&gt;
  &lt;code&gt;Object.notify()&lt;/code&gt; 和 &lt;code&gt;Object.notifyAll()&lt;/code&gt; 通常用于通知其他线程发生了状态变更。 该状态变更应发生在包含 &lt;code&gt;Object.notify()&lt;/code&gt; 或
&lt;code&gt;Object.notifyAll()&lt;/code&gt; 调用的同步上下文中，并且发生在调用之前。 尽管没有此类状态变更未必就不正确，但肯定值得检查。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  synchronized (this) {
    notify();
  }
  // 无状态变更
  synchronized (this) {
    notify(); // 告知可能冗余
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NestedSynchronizedStatement" defaultSeverity="WARNING" displayName="嵌套 'synchronized' 语句" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告嵌套的 &lt;code&gt;synchronized&lt;/code&gt; 语句。
建议尽量避免嵌套同步，因为在某些情况下，嵌套同步可能会导致死锁。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  synchronized (lockA){
    //线程 1 在等待 lockB
    synchronized (lockB){ //警告
    }
  }
  ...
  synchronized (lockB) {
    //线程 2 在等待 lockA
    synchronized (lockA) { //警告
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnconditionalWait" defaultSeverity="WARNING" displayName="无条件的 'wait()' 调用" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在同步上下文中无条件调用的 &lt;code&gt;wait()&lt;/code&gt;。
&lt;p&gt;
  &lt;code&gt;wait()&lt;/code&gt; 通常用于在某个条件为 true 前阻塞线程。 如果是无条件调用 &lt;code&gt;wait()&lt;/code&gt;，它通常表示在获取锁定之前检查了条件。 在这种情况下可能会发生数据竞争，条件在得到检查和获取锁定之间变为 true。
&lt;/p&gt;
&lt;p&gt;
  虽然此检查发现的结构未必不正确，但肯定值得检查。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Bar {
      void foo() throws InterruptedException {
          synchronized (this) {
              wait(); // 警告
          }
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SynchronizationOnStaticField" defaultSeverity="WARNING" displayName="在 'static' 字段上同步" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;static&lt;/code&gt; 字段的同步。 虽然并非完全不正确，但 &lt;code&gt;static&lt;/code&gt; 字段上的同步可能会因争用而导致性能不佳。
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SignalWithoutCorrespondingAwait" defaultSeverity="WARNING" displayName="没有相应 'await()' 的 'signal()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对无法为之找到相应 &lt;code&gt;Condition.await()&lt;/code&gt; 调用的 &lt;code&gt;Condition.signal()&lt;/code&gt; 或 &lt;code&gt;Condition.signalAll()&lt;/code&gt; 的调用。
&lt;p&gt;此检查仅报告以当前类的目标字段为目标的调用。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Queue {
    private final Condition isEmpty = ...;

    void add(Object elem) {
      // ...
      isEmpty.signal(); // 警告：在没有相应 'await()' 的情况下调用 'signal()'
      // ...
    }

    void remove(Object elem) throws InterruptedException {
      // ...
      //      isEmpty.await();
      // ...
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AwaitNotInLoop" defaultSeverity="WARNING" displayName="未在循环中调用的 'await()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告没有在循环中调用的 &lt;code&gt;java.util.concurrent.locks.Condition.await()&lt;/code&gt;。
&lt;p&gt;
  &lt;code&gt;await()&lt;/code&gt; 和相关方法通常用于挂起线程，直到某个条件变为 true 为止。
  线程可能出于不同原因而被唤醒，因此应在 &lt;code&gt;await()&lt;/code&gt; 调用返回后检查条件。
  使用循环很容易做到这一点。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void acquire(Condition released) throws InterruptedException {
    released.await();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;优良的代码应类似于：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void acquire(Condition released) throws InterruptedException {
    while (acquired) {
      released.await();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="EmptySynchronizedStatement" defaultSeverity="WARNING" displayName="空 'synchronized' 语句" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告语句体为空的 &lt;code&gt;synchronized&lt;/code&gt; 语句。
&lt;p&gt;
  空的 &lt;code&gt;synchronized&lt;/code&gt; 语句有时用于等待其他线程释放特定资源。 但是，不能保证空的 &lt;code&gt;synchronized&lt;/code&gt; 语句完成后不会再次获取同一资源。
  为了正确同步，应当在 &lt;code&gt;synchronized&lt;/code&gt; 块中使用此资源。
&lt;/p&gt;
&lt;p&gt;
  此外，在移除冗余代码后，重构后可能会出现空的 &lt;code&gt;synchronized&lt;/code&gt; 块。 在本例中，&lt;code&gt;synchronized&lt;/code&gt; 块本身是冗余的，也应移除。
&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  synchronized(lock) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  建议通过快速修复移除空的 synchronized 语句。
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  JSP 文件中禁用了此检查。
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="WaitNotifyNotInSynchronizedContext" defaultSeverity="WARNING" displayName="'wait()' 或 'notify()' 不在同步的上下文中" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告不是在相应的 synchronized 语句或 synchronized 方法进行中的 &lt;code&gt;wait()&lt;/code&gt;、&lt;code&gt;notify()&lt;/code&gt; 和 &lt;code&gt;notifyAll()&lt;/code&gt; 调用。
&lt;p&gt;
  在没有持有锁定的对象上调用这些方法会导 &lt;code&gt;IllegalMonitorStateException&lt;/code&gt;。
  此类结构不一定错误，因为在调用该包含方法前可能已获取必要的锁定，但即便如此，还是要仔细查看。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Sync {
    private final Object lock = new Object();

    void test() throws InterruptedException {
      synchronized (this) {
        lock.wait(); // 'lock.wait()' 未在 'lock' 上同步
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SafeLock" defaultSeverity="WARNING" displayName="已获取但未安全解锁的锁" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告没有在 &lt;code&gt;try&lt;/code&gt; 块前面获取，或者没有在相应的 &lt;code&gt;finally&lt;/code&gt; 块中解锁的 &lt;code&gt;java.util.concurrent.locks.Lock&lt;/code&gt; 资源。 如果在资源关闭之前抛出异常，此类资源可能会被无意泄漏。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  lock.lock(); // 由于缺少 'finally' 块，因此会报告
  try {
    doSmthWithLock();
  } catch (IOException e) {
    throw new UncheckedIOException(e);
  }
  lock.unlock();
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="WaitOrAwaitWithoutTimeout" defaultSeverity="WARNING" displayName="无超时的 'wait()' 或 'await()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对未指定超时的 &lt;code&gt;Object.wait()&lt;/code&gt; 或 &lt;code&gt;Condition.await()&lt;/code&gt; 的调用。
&lt;p&gt;
  在高可用性程序中，此类调用可能很危险，因为如果从未调用 &lt;code&gt;notify()&lt;/code&gt;/&lt;code&gt;notifyAll()&lt;/code&gt; 或 &lt;code&gt;signal()&lt;/code&gt;/&lt;code&gt;signalAll()&lt;/code&gt;，那么一个组件中的故障可能会导致等待的组件发生阻塞。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void foo(Object bar) throws InterruptedException {
    bar.wait();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NonSynchronizedMethodOverridesSynchronizedMethod" defaultSeverity="WARNING" displayName="未同步方法重写 'synchronized' 方法" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告重写 &lt;code&gt;synchronized&lt;/code&gt; 方法的非 &lt;code&gt;synchronized&lt;/code&gt; 方法。
&lt;p&gt;
  如果超类方法被声明为 &lt;code&gt;synchronized&lt;/code&gt;，重写的方法将不会自动同步。 这可能导致使用子类时出现意外的竞争条件。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Super {
    synchronized void process() {}
  }
  class Sub extends Super {
    // 非 synchronized 方法 'process()' 重写 synchronized 方法
    void process() {}
  }  
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DoubleCheckedLocking" defaultSeverity="WARNING" displayName="双重检查锁定" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告&lt;a href="https://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html"&gt;双重检查锁定&lt;/a&gt;。
&lt;p&gt;
  双重检查锁定会尝试以线程安全的方式按需初始化字段，同时避免同步的开销。
  遗憾的是，在未被声明为 &lt;code&gt;volatile&lt;/code&gt; 的字段上使用时，它不具备线程安全。
  在使用 Java 1.4 或更早的版本时，双重检查锁定即便对 &lt;code&gt;volatile&lt;/code&gt; 字段也不起作用。
  阅读上面的链接文章，了解该问题的详细说明。
&lt;/p&gt;
&lt;p&gt;不正确的双重检查锁定示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    private Helper helper = null;
    public Helper getHelper() {
      if (helper == null)
        synchronized(this) {
          if (helper == null) helper = new Helper();
        }
        return helper;
      }
    }
    // 其他函数和成员…
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PublicFieldAccessedInSynchronizedContext" defaultSeverity="WARNING" displayName="在 'synchronized' 上下文中访问d了非 private 字段" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在同步上下文中访问的非 &lt;code&gt;final&lt;/code&gt;、非 &lt;code&gt;private&lt;/code&gt; 字段。
&lt;p&gt;
  不能保证始终以同步方式访问非 &lt;code&gt;private&lt;/code&gt; 字段，此类“部分同步的”访问可能意外导致不一致的数据结构。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Bar {
    public String field1;
  }
  public Bar myBar;

  synchronized public void sample() {
   myBar.field1 = "bar";
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SystemRunFinalizersOnExit" defaultSeverity="WARNING" displayName="调用 'System.runFinalizersOnExit()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对 &lt;code&gt;System.runFinalizersOnExit()&lt;/code&gt; 的调用。
&lt;p&gt;
  此调用是 Java 语言中最危险的调用之一。 它本质上为非线程安全，可能导致数据损坏、死锁，并可能影响远离调用点的程序部分。
  在 JDK 11 中已被弃用并移除，强烈建议不要使用。
&lt;/p&gt;
&lt;p&gt;仅当项目或模块的语言级别为 10 或更低时，此检查才会报告。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ThreadStopSuspendResume" defaultSeverity="WARNING" displayName="调用 'Thread.stop()'、'suspend()' 或 'resume()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对 &lt;code&gt;Thread.stop()&lt;/code&gt;、&lt;code&gt;Thread.suspend()&lt;/code&gt; 和 &lt;code&gt;Thread.resume()&lt;/code&gt; 的调用。
&lt;p&gt;
  这些调用本质上容易导致数据损坏和死锁，强烈建议不要使用。
  最好使用合作取消代替 &lt;code&gt;stop&lt;/code&gt;，使用中断代替直接调用 &lt;code&gt;suspend&lt;/code&gt; 和 &lt;code&gt;resume&lt;/code&gt;。
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SynchronizedMethod" defaultSeverity="WARNING" displayName="'synchronized' 方法" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告方法上的 &lt;code&gt;synchronized&lt;/code&gt; 修饰符。
&lt;p&gt;
  对方法使用 &lt;code&gt;synchronized&lt;/code&gt; 修饰符可能并非好主意，原因有几点：
&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;
    在锁定的情况下应尽可能少地执行工作。 因此，通常最好使用 &lt;code&gt;synchronized&lt;/code&gt; 块，只保留共享状态的代码。
  &lt;/li&gt;
  &lt;li&gt;
    同步成为方法接口的一部分。 这导致难以转换到不同的锁定机制。
  &lt;/li&gt;
  &lt;li&gt;
    跟踪锁定特定对象的内容变得更加困难。
  &lt;/li&gt;
  &lt;li&gt;
    在继承方法的类时，无论是有意还是无意进行的 DoS（拒绝服务）攻击都变得可行。
  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;
  替代做法是考虑在 &lt;code&gt;private final&lt;/code&gt; 锁定对象上同步，可以完全控制对该对象的访问。
&lt;/p&gt;
&lt;p&gt;可以通过快速修复使用 &lt;code&gt;synchronized(this)&lt;/code&gt; 包装方法体。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Main {
    public synchronized void fooBar() {
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Main {
    public void fooBar() {
      synchronized (this) {
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- tooltip end --&gt;
&lt;p&gt;您可以为此检查配置以下选项：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;包括原生方法&lt;/strong&gt; - 将原生方法纳入检查范围。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;忽略重写 synchronized 方法的方法&lt;/strong&gt; - 不报告重写 &lt;code&gt;synchronized&lt;/code&gt; 方法的方法。&lt;/li&gt;
&lt;/ol&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AtomicFieldUpdaterIssues" defaultSeverity="WARNING" displayName="'AtomicFieldUpdater' 声明不一致" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;AtomicLongFieldUpdater&lt;/code&gt;、&lt;code&gt;AtomicIntegerFieldUpdater&lt;/code&gt; 或 &lt;code&gt;AtomicReferenceFieldUpdater&lt;/code&gt; 字段（&lt;code&gt;java.util.concurrent.atomic&lt;/code&gt; 软件包）的问题。
&lt;p&gt;报告的问题与原子字段更新程序可能发生的运行时问题相同：找不到指定字段、指定字段不可访问、指定字段类型错误等。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;pre&gt;&lt;code&gt;
  class A {
    private static volatile int value = 0;
    private static final AtomicIntegerFieldUpdater updater =
    AtomicIntegerFieldUpdater.newUpdater((A.class), "value"); // 警告：字段 'value' 具有 'static' 修饰符
  }
  &lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
  &lt;li&gt;&lt;pre&gt;&lt;code&gt;
  class B {
    private static final AtomicIntegerFieldUpdater updater =
      AtomicIntegerFieldUpdater.newUpdater(B.class, "value"); // 警告：在类 'B' 中找不到名为 'Value' 的字段
  }
  &lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SynchronizeOnLock" defaultSeverity="WARNING" displayName="在 'Lock' 对象上同步" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告锁定 &lt;code&gt;java.util.concurrent.locks.Lock&lt;/code&gt; 实例的 &lt;code&gt;synchronized&lt;/code&gt; 块。
此类同步几乎肯定是无意为之，应当改用适当版本的 &lt;code&gt;.lock()&lt;/code&gt; 和 &lt;code&gt;.unlock()&lt;/code&gt;。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  final ReentrantLock lock = new ReentrantLock();

  public void foo() {
    synchronized (lock) {}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ThreadPriority" defaultSeverity="WARNING" displayName="调用 'Thread.setPriority()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对 &lt;code&gt;Thread.setPriority()&lt;/code&gt; 的调用。
修改线程的优先级本质上是不可移植的操作，因为 Java 规范中没有保证如何在调度线程中使用优先级，甚至没有保证是否使用优先级。
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ObjectNotify" defaultSeverity="WARNING" displayName="调用 'notify()' 而不是 'notifyAll()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对 &lt;code&gt;Object.notify()&lt;/code&gt; 的调用。 虽然偶尔有用，但在几乎所有情况下，&lt;code&gt;Object.notifyAll()&lt;/code&gt; 都是更好的选择，因为调用 &lt;code&gt;Object.notify()&lt;/code&gt; 可能导致死锁。
有关讨论，请参阅 Doug Lea 的 &lt;i&gt;Concurrent Programming in Java&lt;/i&gt;。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SynchronizationOnGetClass" defaultSeverity="WARNING" displayName="在 'getClass()' 上同步" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对 &lt;code&gt;getClass()&lt;/code&gt; 的调用上的同步。
&lt;p&gt;
  如果包含同步的类被子类化，子类将在不同的类对象上同步。 对 &lt;code&gt;getClass()&lt;/code&gt; 的调用通常可以替换为类的文字表达式，例如 &lt;code&gt;String.class&lt;/code&gt;。 一种更好的解决办法是在 &lt;code&gt;private static final&lt;/code&gt; 锁对象上同步，从而完全控制对该对象的访问。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; synchronized(getClass()) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="AtomicFieldUpdaterNotStaticFinal" defaultSeverity="WARNING" displayName="'AtomicFieldUpdater' 字段未被声明为 'static final'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告以下类型的字段：
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;java.util.concurrent.atomic.AtomicLongFieldUpdater&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;java.util.concurrent.atomic.AtomicIntegerFieldUpdater&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;java.util.concurrent.atomic.AtomicReferenceFieldUpdater&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
其类型为 &lt;code&gt;static final&lt;/code&gt;。
因为在一个类的所有实例中，只需要一个原子字段更新程序来更新 &lt;code&gt;volatile&lt;/code&gt; 字段，所以它几乎总是 &lt;code&gt;static&lt;/code&gt;。

&lt;p&gt;使更新程序为 &lt;code&gt;final&lt;/code&gt;，JVM 就能优化访问以提高性能。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Main {
    private volatile int id;
    private AtomicIntegerFieldUpdater&amp;lt;Main&amp;gt; idFieldUpdater = AtomicIntegerFieldUpdater.newUpdater(Main.class, "id");
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Main {
    private volatile int id;
    private static final AtomicIntegerFieldUpdater&amp;lt;Main&amp;gt; idFieldUpdater = AtomicIntegerFieldUpdater.newUpdater(Main.class, "id");
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NonAtomicOperationOnVolatileField" defaultSeverity="WARNING" displayName="'volatile' 字段上的非原子操作" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对 volatile 字段的非原子操作。
&lt;p&gt;
  非原子操作的示例之一是使用增量运算符更新字段。
  由于操作涉及读写，并且在此之间可能发生其他修改，因此可能损坏数据。
  使用 &lt;code&gt;synchronized&lt;/code&gt; 块进行环绕，或使用 &lt;code&gt;java.util.concurrent.atomic&lt;/code&gt; 软件包中的一个类，可以使该项操作成为原子操作。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  private volatile int v = 1;

  void foo() {
    v = 2 * v;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ThreadYield" defaultSeverity="WARNING" displayName="调用 'Thread.yield()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对 &lt;code&gt;Thread.yield()&lt;/code&gt; 的调用。
&lt;p&gt;
  &lt;code&gt;yield()&lt;/code&gt; 的行为是不确定的并且依赖于平台，很少适合使用此方法。
  它的使用应当与详细的分析和基准测试相结合，以确保真正达到预期效果。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public static void main(String[] args) {
    Runnable r = () -&gt; {
      for (int i = 0; i &amp;lt; 10; i++) {
        System.out.println(i);
        Thread.yield();
      }
    };
    new Thread(r).start();
    new Thread(r).start();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SynchronizeOnThis" defaultSeverity="WARNING" displayName="在 'this' 上同步" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;this&lt;/code&gt; 或 &lt;code&gt;class&lt;/code&gt; 表达式的同步。
报告的结构包括 &lt;code&gt;synchronized&lt;/code&gt; 块以及对 &lt;code&gt;wait()&lt;/code&gt;、&lt;code&gt;notify()&lt;/code&gt; 或 &lt;code&gt;notifyAll()&lt;/code&gt; 的调用。
&lt;p&gt;同步 &lt;code&gt;this&lt;/code&gt; 或 &lt;code&gt;class&lt;/code&gt; 表达式可能并非好主意，原因有几点：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;
    它使同步成为类的外部接口的一部分，导致将来很难更改为其他锁定机制，
  &lt;/li&gt;
  &lt;li&gt;
    难以跟踪究竟是谁锁定了给定对象，
  &lt;/li&gt;
  &lt;li&gt;
    使得故意为之或在子类化时很容易意外发生的拒绝服务攻击成为可能。
  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;替代做法是考虑在 &lt;code&gt;private final&lt;/code&gt; 锁定对象上同步，可以完全控制对该对象的访问。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public void print() {
    synchronized(this) { // 警告：对 'this' 的锁定操作可能会产生不可预见的副作用
      System.out.println("synchronized");
    }
  }
  &lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="命名约定" path="Groovy"><inspection shortName="GroovyLocalVariableNamingConvention" defaultSeverity="WARNING" displayName="局部变量命名约定" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告名称太短、太长或不遵循指定正则表达式模式的局部变量。
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用下面提供的字段可指定局部变量名称的预期最小长度、最大长度和正则表达式。&lt;/p&gt;
&lt;p&gt;正则表达式应以标准 &lt;code&gt;java.util.regex&lt;/code&gt; 格式指定。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyInstanceMethodNamingConvention" defaultSeverity="WARNING" displayName="实例方法命名约定" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告名称太短、太长或不遵循指定正则表达式模式的实例方法。 此检查将忽略重写库方法的实例方法。
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用下面提供的字段可指定实例方法名称的预期最小长度、最大长度和正则表达式。&lt;/p&gt;
&lt;p&gt;正则表达式应以标准 &lt;code&gt;java.util.regex&lt;/code&gt; 格式指定。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="NewGroovyClassNamingConvention" defaultSeverity="WARNING" displayName="类命名约定" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告名称太短、太长或不遵循指定正则表达式模式的类。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;对于类的每种类型，请使用所提供的输入字段指定类名应有的最小长度、最大长度和正则表达式。&lt;/p&gt;
&lt;p&gt;正则表达式应以标准 &lt;code&gt;java.util.regex&lt;/code&gt; 格式指定。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyParameterNamingConvention" defaultSeverity="WARNING" displayName="方法形参命名约定" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告名称太短、太长或不遵循指定正则表达式模式的方法形参。
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用下面提供的字段可指定方法形参名称的预期最小长度、最大长度和正则表达式。&lt;/p&gt;
&lt;p&gt;正则表达式应以标准 &lt;code&gt;java.util.regex&lt;/code&gt; 格式指定。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyStaticVariableNamingConvention" defaultSeverity="WARNING" displayName="static 变量命名约定" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告名称太短、太长或不遵循指定正则表达式模式的 &lt;code&gt;static&lt;/code&gt; 变量。
&lt;p&gt;
  此检查不会检查常量（即被声明为 &lt;code&gt;static final&lt;/code&gt; 的不可变类型的变量）。
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
 使用下面提供的字段可指定 static 变量名称的预期最小长度、最大长度和正则表达式。
&lt;p&gt;正则表达式应以标准 &lt;code&gt;java.util.regex&lt;/code&gt; 格式指定。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyInstanceVariableNamingConvention" defaultSeverity="WARNING" displayName="实例变量命名约定" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告名称太短、太长或不遵循指定正则表达式模式的实例变量。
&lt;!-- tooltip end --&gt;
&lt;p&gt;
 使用下面提供的字段可指定实例变量名称的预期最小长度、最大长度和正则表达式。&lt;/p&gt;
&lt;p&gt;正则表达式应以标准 &lt;code&gt;java.util.regex&lt;/code&gt; 格式指定。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyStaticMethodNamingConvention" defaultSeverity="WARNING" displayName="static 方法命名约定" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告名称太短、太长或不遵循指定正则表达式模式的 static 方法。
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用下面提供的字段可指定 static 方法名称的预期最小长度、最大长度和正则表达式。&lt;/p&gt;
&lt;p&gt;正则表达式应以标准 &lt;code&gt;java.util.regex&lt;/code&gt; 格式指定。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyConstantNamingConvention" defaultSeverity="WARNING" displayName="常量命名约定" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告名称与指定约定不相符的常量。
&lt;p&gt;常量是使用 &lt;code&gt;static&lt;/code&gt; 和 &lt;code&gt;final&lt;/code&gt; 修饰符声明的不可变类型的字段。&lt;/p&gt;
报告名称太短、太长或不遵循指定正则表达式模式的常量。
&lt;!-- tooltip end --&gt;
&lt;p&gt;配置检查：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;使用&lt;b&gt;模式&lt;/b&gt;字段可指定常量名称预期与其相符的 &lt;code&gt;java.util.regex.Pattern&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;使用&lt;b&gt;最小长度&lt;/b&gt;字段可指定常量名称的最小长度。&lt;/li&gt;
  &lt;li&gt;使用&lt;b&gt;最大长度&lt;/b&gt;字段可指定常量名称的最大长度。&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="日志记录" path="Kotlin"><inspection shortName="KotlinPlaceholderCountMatchesArgumentCount" defaultSeverity="WARNING" displayName="占位符数量与日志调用中的实参数量不匹配" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 SLF4J 或 Log4j 2 日志记录调用，例如 &lt;code&gt;logger.info("{}: {}", key)&lt;/code&gt;，其中记录器消息中 &lt;code&gt;{}&lt;/code&gt; 占位符的数量与日志调用的其他实参的数量不匹配。
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="KotlinLoggerInitializedWithForeignClass" defaultSeverity="WARNING" displayName="使用外类初始化记录器" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告使用类文字初始化的 &lt;code&gt;Logger&lt;/code&gt; 实例，而非使用 &lt;code&gt;Logger&lt;/code&gt; 驻留的类。
&lt;p&gt;
    当从另一个类复制粘贴时可能会发生这种情况。
    这可能导致记录意外类别下的事件以及错误筛选。
&lt;/p&gt;
&lt;p&gt;
    使用检查选项可指定此检查识别的记录器工厂类和方法。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
class AnotherService
class MyService {
    private val logger = LoggerFactory.getLogger(AnotherService::class.java)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
class MyService {
    private val logger = LoggerFactory.getLogger(MyService::class.java)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Velocity" path=""><inspection shortName="VtlReferencesInspection" defaultSeverity="WARNING" displayName="引用检查" enabled="false" language="VTL" pluginId="com.intellij.velocity" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
如果 Velocity 参考被错误解析，则报告。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="VtlFileReferencesInspection" defaultSeverity="WARNING" displayName="文件引用检查" enabled="false" language="VTL" pluginId="com.intellij.velocity" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
如果 &lt;code&gt;#include&lt;/code&gt; 和 &lt;code&gt;#parse&lt;/code&gt; 指令中的 Velocity 文件引用被错误解析，则报告。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="VtlInterpolationsInspection" defaultSeverity="ERROR" displayName="合式性检查" enabled="false" language="VTL" pluginId="com.intellij.velocity" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;#macro&lt;/code&gt; 和 &lt;code&gt;#set&lt;/code&gt; 指令中正式符号的非法用法。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="VtlTypesInspection" defaultSeverity="WARNING" displayName="类型检查" enabled="false" language="VTL" pluginId="com.intellij.velocity" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
如果二元和一元表达式具有类型不正确的操作数，则报告。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="VtlDirectiveArgsInspection" defaultSeverity="WARNING" displayName="指令实参检查" enabled="false" language="VTL" pluginId="com.intellij.velocity" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 Velocity 指令的非法值或实参类型。
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Java 语言级问题" path="Java"><inspection shortName="AnnotationClass" defaultSeverity="WARNING" displayName="注解接口" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告注解接口。
Java 1.4 和更早版本不支持此类接口。
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AssertStatement" defaultSeverity="WARNING" displayName="'assert' 语句" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;assert&lt;/code&gt; 语句。 默认情况下，在生产环境中执行期间禁用 &lt;code&gt;assert&lt;/code&gt; 语句。 可以考虑改用记录器或异常。
&lt;p&gt;Java 1.3 和更早版本的 JVM 不支持 &lt;code&gt;assert&lt;/code&gt; 语句。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ForwardCompatibility" defaultSeverity="WARNING" displayName="前向兼容性" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告未来 Java 版本中可能无法编译的 Java 代码结构。
&lt;p&gt;报告的问题如下：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;使用 &lt;code&gt;assert&lt;/code&gt;、&lt;code&gt;enum&lt;/code&gt; 或 &lt;code&gt;_&lt;/code&gt; 作为标识符&lt;/li&gt;
  &lt;li&gt;使用 &lt;code&gt;var&lt;/code&gt;、&lt;code&gt;yield&lt;/code&gt; 或 &lt;code&gt;record&lt;/code&gt; 受限标识符作为类型名称&lt;/li&gt;
  &lt;li&gt;对 &lt;code&gt;yield()&lt;/code&gt; 方法的非限定调用&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;module-info.java&lt;/code&gt; 内部的 &lt;code&gt;requires java.base&lt;/code&gt; 语句的修饰符&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  // 这个以前合法的类无法在 Java 14 中编译，
  // 因为 'yield' 变成了一个受限的标识符。
  public class yield {} 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;及时解决这些问题，可以简化向未来 Java 版本的迁移。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="EnumClass" defaultSeverity="WARNING" displayName="枚举类" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;b&gt;enum&lt;/b&gt; 类。
Java 1.4 和更早版本的 JVM 不支持此类语句。
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="VarargParameter" defaultSeverity="INFORMATION" displayName="vararg 方法" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告接受任意数量形参的方法（也称为 vararg 方法）。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  enum EnumConstants {
  A(null), B, C;

  EnumConstants(String... ss) {}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可通过快速修复将可变实参形参替换为等效的数组形参。 方法调用中的相关实参包装在数组初始值设定项表达式中。
  在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  enum EnumConstants {
  A(null), B(new String[]{}), C(new String[]{});

  EnumConstants(String[] ss) {}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  &lt;i&gt;Varargs 方法&lt;/i&gt;在 Java 5 中出现。
  此检查有助于为向后兼容早期 Java 版本而降级。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="Annotation" defaultSeverity="WARNING" displayName="注解" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告注解。
Java 1.4 和更早版本的 JVM 不支持注解。
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ForeachStatement" defaultSeverity="WARNING" displayName="增强的 'for' 语句" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告增强型 &lt;code&gt;for&lt;/code&gt; 语句。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  for (int x: Arrays.asList(1, 2, 3)) {
    System.out.println(x);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后： &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  for (Iterator&amp;lt;Integer&amp;gt; iterator = Arrays.asList(1, 2, 3).iterator(); iterator.hasNext(); ) {
    final int x = iterator.next();
    System.out.println(x);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  &lt;i&gt;增强型&lt;/i&gt; &lt;code&gt;for&lt;/code&gt; &lt;i&gt;语句&lt;/i&gt;在 Java 5 中出现。
  此检查有助于为向后兼容早期 Java 版本而降级。
&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="HTML" path=""><inspection shortName="HtmlUnknownTag" defaultSeverity="WARNING" displayName="未知标记" enabled="false" language="HTML" pluginId="com.intellij" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告未知的 HTML 标记。 建议配置不应报告的标记。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CheckValidXmlInScriptTagBody" defaultSeverity="ERROR" displayName="'script' 标记的内容格式错误" enabled="false" language="XML" pluginId="com.intellij" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告是无效 XML 的 &lt;code&gt;script&lt;/code&gt; 标记的内容。&lt;br&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &amp;lt;script type="text/javascript"&gt;
    console.log('&amp;lt;');
  &amp;lt;/script&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &amp;lt;script type="text/javascript"&gt;
    console.log('&amp;amp;lt;');
  &amp;lt;/script&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="HtmlUnknownAnchorTarget" defaultSeverity="WARNING" displayName="链接中未解析的片段" enabled="false" language="XML" pluginId="com.intellij" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;#&lt;/code&gt; 符号后面的 URL 中未解析的最后部分。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RequiredAttributes" defaultSeverity="WARNING" displayName="缺少必要的特性" enabled="false" language="XML" pluginId="com.intellij" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 XML/HTML 标记中缺少的强制特性。 建议配置不应报告的特性。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="HtmlExtraClosingTag" defaultSeverity="WARNING" displayName="冗余结束标记" enabled="false" language="HTML" pluginId="com.intellij" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告空元素的冗余结束标记，例如 &lt;code&gt;img&lt;/code&gt; 或 &lt;code&gt;br&lt;/code&gt;。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &amp;lt;html&gt;
    &amp;lt;body&gt;
      &amp;lt;br&gt;&amp;lt;/br&gt;
    &amp;lt;/body&gt;
  &amp;lt;/html&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &amp;lt;html&gt;
    &amp;lt;body&gt;
      &amp;lt;br&gt;
    &amp;lt;/body&gt;
  &amp;lt;/html&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="HtmlDeprecatedAttribute" defaultSeverity="WARNING" displayName="废弃的特性" enabled="false" language="XML" pluginId="HtmlTools" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告过时的 HTML5 特性。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CheckImageSize" defaultSeverity="WARNING" displayName="不匹配的图像大小" enabled="false" language="XML" pluginId="HtmlTools" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告与所引用图像的实际宽度和高度不同的 &lt;code&gt;img&lt;/code&gt; 标记的 &lt;code&gt;width&lt;/code&gt; 和 &lt;code&gt;height&lt;/code&gt; 特性值。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="HtmlWrongAttributeValue" defaultSeverity="WARNING" displayName="特性值错误" enabled="false" language="HtmlCompatible" pluginId="com.intellij" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告不正确的 HTML 特性值。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="HtmlUnknownBooleanAttribute" defaultSeverity="WARNING" displayName="不正确的布尔特性" enabled="false" language="HTML" pluginId="com.intellij" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告不含值的 HTML 非布尔特性。 建议配置不应报告的特性。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="HtmlNonExistentInternetResource" defaultSeverity="WARNING" displayName="未解析的 Web 链接" enabled="false" language="XML" pluginId="HtmlTools" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告未解析的 Web 链接。 通过在后台发出网络请求来发挥作用。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="HtmlMissingClosingTag" defaultSeverity="INFORMATION" displayName="缺少结束标记" enabled="false" language="HTML" pluginId="com.intellij" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告不含结束标记的 HTML 元素。
即便在可选的情况下，有些编码样式也要求 HTML 元素包含结束标记。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &amp;lt;html&gt;
    &amp;lt;body&gt;
      &amp;lt;p&gt;Behold!
    &amp;lt;/body&gt;
  &amp;lt;/html&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &amp;lt;html&gt;
    &amp;lt;body&gt;
      &amp;lt;p&gt;Behold!&amp;lt;/p&gt;
    &amp;lt;/body&gt;
  &amp;lt;/html&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="HtmlDeprecatedTag" defaultSeverity="WARNING" displayName="废弃的标记" enabled="false" language="XML" pluginId="HtmlTools" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告过时的 HTML5 标记。 建议将过时的标记替换为 CSS 或其他标记。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="HtmlPresentationalElement" defaultSeverity="INFORMATION" displayName="演示标记" enabled="false" language="XML" pluginId="HtmlTools" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 HTML 表示标记。 建议将表示标记替换为 CSS 或其他标记。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="HtmlUnknownAttribute" defaultSeverity="WARNING" displayName="未知特性" enabled="false" language="HTML" pluginId="com.intellij" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告未知的 HTML 特性。 建议配置不应报告的特性。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CheckEmptyScriptTag" defaultSeverity="WARNING" displayName="空标记" enabled="false" language="XML" pluginId="com.intellij" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在某些浏览器中无法正常运行的空标记。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &amp;lt;html&gt;
    &amp;lt;script/&gt;
  &amp;lt;/html&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &amp;lt;html&gt;
    &amp;lt;script&gt;&amp;lt;/script&gt;
  &amp;lt;/html&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="HtmlUnknownTarget" defaultSeverity="WARNING" displayName="链接中未解析的文件" enabled="false" language="XML" pluginId="com.intellij" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告链接中未解析的文件。
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Android" path=""><inspection shortName="AndroidDomInspection" defaultSeverity="ERROR" displayName="Android 资源验证" enabled="false" language="XML" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="false">&lt;html&gt;&lt;body&gt;
  验证 Android XML 文件内部的资源引用。
&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidUnknownAttribute" defaultSeverity="WARNING" displayName="未知 Android XML 特性" enabled="false" language="XML" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
此检查会高亮显示 Android 资源文件和 AndroidManifest.xml 中的未知 XML 特性
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="XmlWrongFileType" defaultSeverity="WARNING" displayName="Android XML 根标记验证" enabled="false" language="XML" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
此检查会检查 XML 资源是否存储在文档所推荐类型的资源文件夹中
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AndroidNonConstantResIdsInSwitch" defaultSeverity="ERROR" displayName="switch 语句中存在非常量资源 ID" enabled="false" language="JAVA" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="false">&lt;html&gt;&lt;body&gt;
验证在 Android 库模块的 switch 语句中使用资源 ID 的情况。&lt;br&gt;。
从 SDK Tools r14 开始，库项目中的资源 ID 为非 final，这意味着库代码不能将这些 ID 视为常量。
&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidUnresolvableTag" defaultSeverity="ERROR" displayName="不可解析的标记" enabled="false" language="XML" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="false">&lt;!--
  ~ Copyright (C) 2019 The Android Open Source Project
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  --&gt;
&lt;html&gt;
&lt;body&gt;
此检查会高亮显示 Android 资源文件中无法解析的 XML 标记引用
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AndroidMissingOnClickHandler" defaultSeverity="WARNING" displayName="相关 Activity 中缺少 onClick 处理程序" enabled="false" language="XML" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
检查在 onClick XML 特性中指定的方法是否已在相关 Activity 中声明
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AndroidElementNotAllowed" defaultSeverity="WARNING" displayName="不允许 Android XML 元素" enabled="false" language="XML" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
此检查会高亮显示 Android 资源文件和 AndroidManifest.xml 中不允许使用的 XML 标记
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Java 8" path="Java/Java 语言级别迁移帮助"><inspection shortName="SimplifyForEach" defaultSeverity="INFORMATION" displayName="可简化的 forEach() 调用" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以替换为更简洁的方法或可以从中提取中间步骤的 &lt;code&gt;forEach()&lt;/code&gt; 调用。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  List&amp;lt;String&amp;gt; findNStrings(List&amp;lt;String&amp;gt; list, int n) {
    List&amp;lt;String&amp;gt; other = new ArrayList&amp;lt;&gt;();
    list.forEach(s -&gt; {
      if(s.length() &gt; n) other.add(s);
    });
    return other;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  List&amp;lt;String&amp;gt; findNStrings(List&amp;lt;String&amp;gt; list, int n) {
    List&amp;lt;String&amp;gt; other = list.stream()
      .filter(s -&gt; s.length() &gt; n)
      .collect(Collectors.toList());
    return other;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;仅当项目或模块的语言级别为 8 或更高时，此检查才会报告。&lt;/p&gt;
&lt;p&gt;&lt;small&gt;2017.3 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FoldExpressionIntoStream" defaultSeverity="INFORMATION" displayName="表达式可以折叠到流链中" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告所具有的重复模式可以替换为 &lt;i&gt;Stream API&lt;/i&gt; 或 &lt;code&gt;String.join()&lt;/code&gt; 的表达式。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean allStartWith(String a, String b, String c, String d, String prefix) {
    return a.startsWith(prefix) &amp;&amp; b.startsWith(prefix) &amp;&amp; c.startsWith(prefix) &amp;&amp; d.startsWith(prefix);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean foo(String a, String b, String c, String d, String prefix) {
    return Stream.of(a, b, c, d).allMatch(s -&gt; s.startsWith(prefix));
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String joinAll(String a, String b, String c, String d) {
    return a + "," + b + "," + c + "," + d;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String joinAll(String a, String b, String c, String d) {
    return String.join(",", a, b, c, d);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;仅当项目或模块的语言级别为 8 或更高时，此检查才会报告。&lt;/p&gt;
&lt;p&gt;&lt;small&gt;2018.2 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ComparatorCombinators" defaultSeverity="WARNING" displayName="可以使用 'Comparator' 连结符" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告定义为可以使用 &lt;code&gt;Comparator.comparing()&lt;/code&gt; 调用表示的 lambda 表达式的 &lt;code&gt;Comparator&lt;/code&gt; 实例。
还会报告可以替换为 &lt;code&gt;Comparator.thenComparing()&lt;/code&gt; 表达式的链式比较。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  myList.sort((person1, person2) -&gt; person1.getName().compareTo(person2.getName()));

  myList2.sort((person1, person2) -&gt; {
      int res = person1.first().compareTo(person2.first());
      if(res == 0) res = person1.second().compareTo(person2.second());
      if(res == 0) res = person1.third() - person2.third();
      return res;
  });
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  myList.sort(Comparator.comparing(Person::getName));

  myList2.sort(Comparator.comparing(Person::first)
                         .thenComparing(Person::second)
                         .thenComparingInt(Person::third));
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="Guava" defaultSeverity="WARNING" displayName="Guava 的函数基元可被替换为 Java" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以迁移到标准 Java API 调用的 Guava 函数基元的用法。
&lt;p&gt;例如，该检查会报告类和接口（如 &lt;code&gt;FluentIterable&lt;/code&gt;、&lt;code&gt;Optional&lt;/code&gt;、&lt;code&gt;Function&lt;/code&gt;、&lt;code&gt;Predicate&lt;/code&gt; 或 &lt;code&gt;Supplier&lt;/code&gt;）的用法。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  ImmutableList&amp;lt;String&amp;gt; results = FluentIterable.from(List.of(1, 2, 3)).transform(Object::toString).toList();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  List&amp;lt;String&amp;gt; results = List.of(1, 2, 3).stream().map(Object::toString).collect(Collectors.toList());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
该快速修复可能会改变语义。 Guava 的一些惰性求值的可迭代对象可以转换为预求值的可迭代对象。
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;仅当项目或模块的语言级别为 8 或更高时，此检查才会报告。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="Java8MapForEach" defaultSeverity="WARNING" displayName="可以使用 Map.forEach()" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
建议将 &lt;code&gt;for(Entry&amp;lt;?,?&amp;gt; entry : map.entrySet()) {...}&lt;/code&gt; 或 
&lt;code&gt;map.entrySet().forEach(entry -&amp;gt; ...)&lt;/code&gt; 替换为 &lt;code&gt;map.forEach((key, value) -&gt; ...)&lt;/code&gt;。
&lt;p&gt;示例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void print(Map&amp;lt;String, Integer&amp;gt; map) {
    map.entrySet().forEach(entry -&gt; {
      String str = entry.getKey();
      System.out.println(str + ":" + entry.getValue());
    });
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void print(Map&amp;lt;String, Integer&amp;gt; map) {
    map.forEach((str, value) -&gt; System.out.println(str + ":" + value));
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  启用 &lt;b&gt;不要报告循环&lt;/b&gt;选项后，只会报告 &lt;code&gt;entrySet().forEach()&lt;/code&gt; 情况。
  但是，该快速修复操作也可用于 &lt;code&gt;for&lt;/code&gt; 循环。
&lt;/p&gt;
&lt;p&gt;仅当项目或模块的语言级别为 8 或更高时，此检查才会报告。&lt;/p&gt;
&lt;p&gt;&lt;small&gt;2017.1 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="Java8MapApi" defaultSeverity="WARNING" displayName="可简化的 'Map' 运算" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;java.util.Map&lt;/code&gt; 常见的使用模式，并建议将其替换为：
&lt;code&gt;getOrDefault()&lt;/code&gt;、&lt;code&gt;computeIfAbsent()&lt;/code&gt;、&lt;code&gt;putIfAbsent()&lt;/code&gt;、&lt;code&gt;merge()&lt;/code&gt; 或 &lt;code&gt;replaceAll( )&lt;/code&gt;。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  map.containsKey(key) ? map.get(key) : "default";
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  map.getOrDefault(key, "default");
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  List&amp;lt;String&amp;gt; list = map.get(key);
  if (list == null) {
    list = new ArrayList&amp;lt;&amp;gt;();
    map.put(key, list);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  map.computeIfAbsent(key, localKey -&gt; new ArrayList&amp;lt;&amp;gt;());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Integer val = map.get(key);
  if (val == null) map.put(key, 1);
  else map.put(key, val + 1);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  map.merge(key, 1, (localKey, localValue) -&gt; localValue + 1);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  for (Map.Entry&amp;lt;String, String&amp;gt; entry : map.entrySet()) {
    map.put(entry.getKey(), transform(entry.getValue()));
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  map.replaceAll((localKey, localValue) -&gt; transform(localValue));
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- tooltip end --&gt;
&lt;p&gt;请注意，如果提取到 lambda 表达式的代码修改了相同的 &lt;code&gt;Map&lt;/code&gt;，对于某些 &lt;code&gt;Map&lt;/code&gt;，替换为 &lt;code&gt;computeIfAbsent()&lt;/code&gt; 或 &lt;code&gt;merge()&lt;/code&gt; 可能无法正常使用。 在默认情况下，如果这段代码有副作用，则不会出现警告。 如有必要，启用&lt;b&gt;建议替换，即使 lambda 可能有副作用&lt;/b&gt;选项，以始终显示警告。&lt;/p&gt;
&lt;p&gt;此外，由于 &lt;code&gt;put()&lt;/code&gt; 等旧方法和 &lt;code&gt;computeIfAbsent()&lt;/code&gt; 或 &lt;code&gt;merge()&lt;/code&gt; 等新方法中对 &lt;code&gt;null&lt;/code&gt; 值的不同处理，语义可能会改变，如果将 &lt;code&gt;null&lt;/code&gt; 值存储到给定的 &lt;code&gt;Map&lt;/code&gt; 中很重要，您需要考虑这一点。 当值是静态已知为 null 时，该检查不会建议进行替换。但对于可 null 性未知的值，仍然建议进行替换。 在这些情况下，我们建议禁止警告并添加说明注释。
&lt;/p&gt;
&lt;p&gt;仅当项目或模块的语言级别为 8 或更高时，此检查才会报告。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AnonymousHasLambdaAlternative" defaultSeverity="WARNING" displayName="匿名类型有较短的 lambda 替代项" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以转换为构造函数或带有 lambda 表达式实参的工厂方法调用的匿名类。
&lt;p&gt;本次检查报告以下类别：
&lt;ul&gt;
  &lt;li&gt;扩展 &lt;code&gt;ThreadLocal&lt;/code&gt; 的匿名类，其具有 &lt;code&gt;initialValue()&lt;/code&gt; 方法（可以替换为 &lt;code&gt;ThreadLocal.withInitial&lt;/code&gt;）&lt;/li&gt;
  &lt;li&gt;扩展 &lt;code&gt;Thread&lt;/code&gt; 的匿名类，其具有 &lt;code&gt;run()&lt;/code&gt; 方法（可以替换为 &lt;code&gt;new Thread(Runnable)&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;new&lt;/b&gt; Thread() {
    @Override
    &lt;b&gt;public void&lt;/b&gt; run() {
      System.out.println("Hello from thread!");
    }
  }.start();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;new&lt;/b&gt; Thread(() -&gt; {
    System.out.println("Hello from thread!");
  }).start();
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="Convert2MethodRef" defaultSeverity="WARNING" displayName="lambda 可被替换为方法引用" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以替换为方法引用的 lambda。 方法引用比 lambda 更容易理解和阅读，尽管它们通常取决于您的喜好。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Runnable r = () -&gt; System.out.println();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Runnable r = System.out::println;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  即使 lambda 不调用任何方法，该检查也可能会建议方法引用，例如将 &lt;code&gt;obj -&gt; obj != null&lt;/code&gt; 替换为 &lt;code&gt;Objects::nonNull&lt;/code&gt;。 
  使用&lt;a href="settings://preferences.sourceCode.Java?Lambda%20Body"&gt;设置 | 编辑器 | 代码样式 | Java | 代码生成&lt;/a&gt;设置来配置特殊方法引用。
&lt;/p&gt;
&lt;p&gt;仅当项目或模块的语言级别为 8 或更高时，此检查才会报告。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="LambdaCanBeMethodCall" defaultSeverity="INFORMATION" displayName="lambda 可被替换为方法调用" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可被替换为 JDK 方法调用的 lambda 表达式。
&lt;p&gt;例如，&lt;code&gt;Function&amp;lt;T, T&amp;gt;&lt;/code&gt; 类型的表达式 &lt;code&gt;x -&amp;gt; x&lt;/code&gt; 可被替换为 &lt;code&gt;Function.identity()&lt;/code&gt; 调用。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2017.1 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CodeBlock2Expr" defaultSeverity="WARNING" displayName="语句 lambda 可被替换为表达式 lambda" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
当可以使用表达式样式的主体时，报告包含代码块主体的 lambda 表达式。
转换的结果更短更清晰。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Comparable&amp;lt;String&amp;gt; c = o -&gt; {return 0;};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Comparable&amp;lt;String&amp;gt; c = o -&gt; 0;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="Java8CollectionRemoveIf" defaultSeverity="WARNING" displayName="循环可被替换为 'Collection.removeIf()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以折叠为单个 &lt;code&gt;Collection.removeIf&lt;/code&gt; 调用的循环。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  for (Iterator&amp;lt;String&amp;gt; it = collection.iterator(); it.hasNext(); ) {
    String aValue = it.next();
    if(shouldBeRemoved(aValue)) {
      it.remove();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  collection.removeIf(aValue -&gt; shouldBeRemoved(aValue));
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  仅当项目或模块的语言级别为 8 或更高时，此检查才会报告。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="Convert2Lambda" defaultSeverity="WARNING" displayName="匿名类型可被替换为 lambda" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以替换为 lambda 表达式的匿名类。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  new Thread(new Runnable() {
    @Override
    public void run() {
      // 运行线程
    }
  });
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  new Thread(() -&gt; {
    // 运行线程
  });
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
请注意，如果将匿名类转换为无状态 lambda，则 Java 运行时可以在后续调用期间重用相同的 lambda 对象。 另一方面，当使用匿名类时，每次都会创建单独的对象。 因此，在极少数情况下，应用该快速修复可能会导致语义发生变化，例如，当匿名类实例用作 &lt;code&gt;HashMap&lt;/code&gt; 键时。
&lt;/p&gt;
&lt;p&gt;Java 1.7 和更早版本的 JVM 不支持 lambda 语法。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
使用&lt;b&gt;在接口未使用 @FunctionalInterface 注解时报告&lt;/b&gt;选项可忽略匿名类实现没有 &lt;code&gt;@FunctionalInterface&lt;/code&gt; 注解的接口的情况。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="Anonymous2MethodRef" defaultSeverity="WARNING" displayName="匿名类型可被替换为方法引用" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以替换为方法引用的匿名类。
&lt;p&gt;
  请注意，如果将匿名类转换为未绑定的方法引用，则 Java 运行时可以在后续调用期间重用相同的方法引用对象。 另一方面，使用匿名类时，每次都会创建单独的对象。 因此，在极少数情况下，应用该快速修复可能会导致语义发生变化，例如，当匿名类实例用作 &lt;code&gt;HashMap&lt;/code&gt; 键时。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    Runnable r = new Runnable() {
      @Override
      public void run() {
        System.out.println();
      }
    };
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该快速修复会将此代码更改为压缩形式：&lt;code&gt;Runnable r = System.out::println;&lt;/code&gt;。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;使用&lt;b&gt;在接口未使用 @FunctionalInterface 注解时报告&lt;/b&gt;选项可为未使用 @FunctionalInterface 注解的接口启用此检查。&lt;/p&gt;

&lt;p&gt;仅当项目或模块的语言级别为 8 或更高时，此检查才会报告。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="Java8ListSort" defaultSeverity="WARNING" displayName="'Collections.sort()' 可被替换为 'List.sort()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;Collections.sort(list,comparator)&lt;/code&gt; 的调用，可以替换为 &lt;code&gt;list.sort(comparator)&lt;/code&gt;。
&lt;p&gt;&lt;code&gt;Collections.sort&lt;/code&gt; 只是一个包装器，所以最好直接使用实例方法。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;仅当项目或模块的语言级别为 8 或更高时，此检查才会报告。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StaticPseudoFunctionalStyleMethod" defaultSeverity="WARNING" displayName="使用 static 类的伪函数表达式" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
如果 &lt;code&gt;Java Stream API&lt;/code&gt; 可用，则报告伪函数代码的用法。
&lt;p&gt;虽然 &lt;code&gt;guava Iterable API&lt;/code&gt; 提供类似于 &lt;code&gt;Java Streams API&lt;/code&gt; 的功能，但它略有不同，可能会缺少某些功能。
  特别是，&lt;code&gt;IntStream&lt;/code&gt; 等基元专门化的流变体比一般变体的性能更好。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
List&amp;lt;String&amp;gt; transformedIterable = Iterables.transform(someList, someTransformFunction);//警告：伪函数样式代码
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;List&amp;lt;String&amp;gt; transformedIterable = someList.stream().map(someTransformFunction).collect(Collectors.toList());&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  &lt;b&gt;注意&lt;/b&gt;：代码语义可能改变：例如 guava 的 &lt;code&gt;Iterable.transform&lt;/code&gt; 产生惰性求值的可迭代对象，但替换为及早求值。
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用&lt;b&gt;转换为 'Stream' API 的 static 方法调用&lt;/b&gt;选项，配置应转换为 &lt;code&gt;stream&lt;/code&gt; API 的 static 方法调用。
&lt;/p&gt;

&lt;p&gt;仅当项目或模块的语言级别为 8 或更高时，此检查才会报告。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="Convert2streamapi" defaultSeverity="INFORMATION" displayName="可以通过 Stream API 收起循环" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告使用 lambda 表达式替换为流 API 调用的循环。
&lt;p&gt;此类替换将命令式样式更改为功能式样式，代码也变得更加紧凑。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;boolean&lt;/b&gt; check(List&amp;lt;String&gt; data) {
    &lt;b&gt;for&lt;/b&gt; (String e : data) {
      String trimmed = e.trim();
      &lt;b&gt;if&lt;/b&gt; (!trimmed.startsWith("xyz")) {
        &lt;b&gt;return&lt;/b&gt; false;
      }
    }
    return true;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;boolean&lt;/b&gt; check(List&amp;lt;String&gt; data) {
    &lt;b&gt;return&lt;/b&gt; data.stream().map(String::trim).allMatch(trimmed -&gt; trimmed.startsWith("xyz"));
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;仅当项目或模块的语言级别为 8 或更高时，此检查才会报告。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="Java8ListReplaceAll" defaultSeverity="WARNING" displayName="循环可以替换为 'List.replaceAll()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以折叠为单个 &lt;code&gt;List.replaceAll()&lt;/code&gt; 调用的循环。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  for (int i = 0; i &amp;lt; strings.size(); i++) {
    String str = strings.get(i).toLowerCase();
    strings.set(i, str);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  strings.replaceAll(String::toLowerCase);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  仅当项目或模块的语言级别为 8 或更高时，此检查才会报告。
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;2022.1 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="冗余修饰符" path="Java/Lombok"><inspection shortName="RedundantModifiersValLombok" defaultSeverity="WARNING" displayName="'val' 前的不必要 final" enabled="false" language="JAVA" pluginId="Lombook Plugin" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在 &lt;code&gt;val&lt;/code&gt; 之前的不需要 &lt;code&gt;final&lt;/code&gt; 修饰符。
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RedundantModifiersUtilityClassLombok" defaultSeverity="WARNING" displayName="@UtilityClass 修饰符" enabled="false" language="JAVA" pluginId="Lombook Plugin" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告使用 &lt;code&gt;@UtilityClass&lt;/code&gt; 注解的类中不需要的修饰符。
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RedundantModifiersValueLombok" defaultSeverity="WARNING" displayName="@Value 修饰符" enabled="false" language="JAVA" pluginId="Lombook Plugin" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告使用 &lt;code&gt;@Value&lt;/code&gt; 注解的类中不需要的修饰符。
&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="Protocol Buffers" path=""><inspection shortName="PbDuplicatedImports" defaultSeverity="WARNING" displayName="Duplicated import statements" enabled="false" language="protobuf" pluginId="idea.plugin.protoeditor" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告有效对等的 import 语句。
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="属性文件" path=""><inspection shortName="InconsistentResourceBundle" defaultSeverity="ERROR" displayName="不一致的资源包" enabled="false" language="Properties" pluginId="com.intellij.java-i18n" pluginVersion="223.8836.41" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
报告资源包中包含的属性文件中的问题。
&lt;ul&gt;
  &lt;li&gt;&lt;b&gt;报告缺失的翻译&lt;/b&gt;
  &lt;/li&gt;
&lt;/ul&gt;
选项会控制搜索未翻译的属性。 &lt;br&gt;
它报告在父属性文件中包含但在继承中缺失的属性（除非它是语言方言）。 &lt;br&gt;
例如： 拥有此资源包： &lt;br&gt;

&lt;b&gt;messages.properties&lt;/b&gt; : &lt;font color="#000080"&gt;&lt;b&gt;abc=xxx&lt;/b&gt;&lt;/font&gt; &lt;br&gt;
&lt;b&gt;messages_fr.properties&lt;/b&gt;：空&lt;br&gt;

属性 &lt;font color="#000080"&gt;&lt;b&gt;abc&lt;/b&gt;&lt;/font&gt; 将报告为未翻译。
&lt;ul&gt;
  &lt;li&gt;

    &lt;b&gt;报告不一致的属性&lt;/b&gt;
  &lt;/li&gt;
&lt;/ul&gt;
选项会控制无效的资源包结构检查。 &lt;br&gt;
它报告在继承属性文件中包含但在父级（如果没有父级，则在同级）中缺失的属性。 &lt;br&gt;
例如： 拥有此资源包： &lt;br&gt;
&lt;b&gt;messages.properties&lt;/b&gt;：空 &lt;br&gt;
&lt;b&gt;messages_fr.properties&lt;/b&gt; : &lt;font color="#000080"&gt;&lt;b&gt;abc=xxx&lt;/b&gt;&lt;/font&gt; &lt;br&gt;

此处的属性 &lt;font color="#000080"&gt;&lt;b&gt;abc&lt;/b&gt;&lt;/font&gt; 翻译不适用于法语以外的任何语言，因此，将在（默认）属性文件 &lt;b&gt;messages.properties&lt;/b&gt; 中报告为缺失。

&lt;ul&gt;
  &lt;li&gt;

    &lt;b&gt;报告使用相同值重写的属性&lt;/b&gt;
  &lt;/li&gt;
&lt;/ul&gt;
选项会检查逐字复制粘贴到多个属性文件中的属性。 &lt;br&gt;
例如： 在此资源包中： &lt;br&gt;
&lt;b&gt;messages.properties&lt;/b&gt; : &lt;font color="#000080"&gt;&lt;b&gt;abc=xxx&lt;/b&gt;&lt;/font&gt; &lt;br&gt;
&lt;b&gt;messages_fr.properties&lt;/b&gt; : &lt;font color="#000080"&gt;&lt;b&gt;abc=xxx&lt;/b&gt;&lt;/font&gt; &lt;br&gt;

属性 &lt;font color="#000080"&gt;&lt;b&gt;abc&lt;/b&gt;&lt;/font&gt; 将在文件 &lt;b&gt;messages_fr.properties&lt;/b&gt; 中报告为不必要地继承。
&lt;br&gt;

&lt;ul&gt;
  &lt;li&gt;

    &lt;b&gt;报告被不同的占位符重写的属性&lt;/b&gt;
  &lt;/li&gt;
&lt;/ul&gt;
选项会检查为占位符一致性而重写的属性。 &lt;br&gt;
例如： 在此资源包中： &lt;br&gt;
&lt;b&gt;messages.properties&lt;/b&gt;： &lt;br&gt;
&lt;font color="#000080"&gt;&lt;b&gt;qwe={0}xxx{1}&lt;/b&gt;&lt;/font&gt; &lt;br&gt;
&lt;font color="#000080"&gt;&lt;b&gt;abc={0}yyy{1}&lt;/b&gt;&lt;/font&gt; &lt;br&gt;
&lt;b&gt;messages_fr.properties&lt;/b&gt;： &lt;br&gt;
&lt;font color="#000080"&gt;&lt;b&gt;qwe={0}xxx{0}xxx{1}&lt;/b&gt;&lt;/font&gt; &lt;br&gt;
&lt;font color="#000080"&gt;&lt;b&gt;abc={0}yyy&lt;/b&gt;&lt;/font&gt; &lt;br&gt;


将报告属性 &lt;font color="#000080"&gt;&lt;b&gt;abc&lt;/b&gt;&lt;/font&gt;，因为属性包含值与 &lt;b&gt;messages.properties&lt;/b&gt; 不对应的消息格式占位符。
&lt;br&gt;

&lt;ul&gt;
  &lt;li&gt;

    &lt;b&gt;报告使用不同值结尾重写的属性&lt;/b&gt;
  &lt;/li&gt;
&lt;/ul&gt;
选项会检查为了结尾一致性而被重写的属性。 &lt;br&gt;
例如： 在此资源包中： &lt;br&gt;
&lt;b&gt;messages.properties&lt;/b&gt;： &lt;br&gt;
&lt;font color="#000080"&gt;&lt;b&gt;abc=xxxzzz&lt;/b&gt;&lt;/font&gt; &lt;br&gt;
&lt;b&gt;messages_fr.properties&lt;/b&gt;： &lt;br&gt;
&lt;font color="#000080"&gt;&lt;b&gt;abc=xxx;&lt;/b&gt;&lt;/font&gt; &lt;br&gt;


属性 &lt;font color="#000080"&gt;&lt;b&gt;abc&lt;/b&gt;&lt;/font&gt; 将被报告，因为属性在值的末尾包含特殊符号（&lt;b&gt;'!'&lt;/b&gt;、&lt;b&gt;'?'&lt;/b&gt;、&lt;b&gt;'.'&lt;/b&gt;、&lt;b&gt;':'&lt;/b&gt; 或 &lt;b&gt;';'&lt;/b&gt;），但 &lt;b&gt;messages.properties&lt;/b&gt; 中的值没有。
&lt;br&gt;

&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="UnusedMessageFormatParameter" defaultSeverity="WARNING" displayName="缺少消息格式参数" enabled="false" language="Properties" pluginId="com.intellij.java-i18n" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告类似于 &lt;code&gt;java.text.MessageFormat&lt;/code&gt; 格式字符串但不使用某些 &lt;code&gt;{xx}&lt;/code&gt; 类型形参的属性值。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
#未使用形参 {0}
&lt;b&gt;error.message&lt;/b&gt;=第 &lt;b&gt;{1}&lt;/b&gt; 行有问题
  &lt;/code&gt;&lt;/pre&gt;

&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="AlphaUnsortedPropertiesFile" defaultSeverity="WEAK WARNING" displayName="属性文件或资源包未按字母顺序排序" enabled="false" language="Properties" pluginId="com.intellij.properties" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告未按字母顺序排序的资源包或 .properties 文件。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UseEllipsisInPropertyInspection" defaultSeverity="WARNING" displayName="使用三点字符而不是省略号" enabled="false" language="Properties" pluginId="com.intellij.properties" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 UTF-8 属性文件中用于代替省略号字符的三个“点”字符。
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="TrailingSpacesInProperty" defaultSeverity="WARNING" displayName="属性中有尾随空格" enabled="false" language="Properties" pluginId="com.intellij.properties" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告键或值以空格结尾的所有属性。
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="DuplicatePropertyInspection" defaultSeverity="WARNING" displayName="重复属性" enabled="false" language="Properties" pluginId="com.intellij.properties" pluginVersion="223.8836.41" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
报告具有不同值的重复属性键、重复键或重复属性值。
&lt;!-- tooltip end --&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
property1=&lt;b&gt;&lt;font color="#000080"&gt;value&lt;/font&gt;&lt;/b&gt;;
property2=&lt;b&gt;&lt;font color="#000080"&gt;value&lt;/font&gt;&lt;/b&gt;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;b&gt;选项&lt;/b&gt; 列表允许选择检查应搜索重复项的区域。&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="WrongPropertyKeyValueDelimiter" defaultSeverity="WEAK WARNING" displayName="属性键/值分隔符与代码样式设置不匹配" enabled="false" language="Properties" pluginId="com.intellij.properties" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告键或值分隔符与代码样式设置不匹配的属性。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SuspiciousLocalesLanguages" defaultSeverity="WARNING" displayName="可疑的资源包区域设置语言" enabled="false" language="Properties" pluginId="com.intellij.java-i18n" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告语言代码不受 Java 支持的区域设置。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnusedProperty" defaultSeverity="WARNING" displayName="未使用的属性" enabled="false" language="Properties" pluginId="com.intellij.properties" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告未在包含它们的 .properties 文件外部引用的属性。
&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="清单" path=""><inspection shortName="MisspelledHeader" defaultSeverity="WEAK WARNING" displayName="未知或拼写错误的标头名称" enabled="false" language="Manifest" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
  报告任何未知的和可能拼写错误的标头名称，并提供可能的变体。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MissingFinalNewline" defaultSeverity="ERROR" displayName="缺少最终新行" enabled="false" language="Manifest" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
如果清单文件未按照 JAR 文件规范的要求以最后的换行符结尾，则报告。
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="大小" path="Scala，集合"><inspection shortName="SizeToLength" defaultSeverity="WARNING" displayName="将数组和字符串中的 size 转换为 length" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 &lt;code&gt;array.size&lt;/code&gt; 和 &lt;code&gt;string.size&lt;/code&gt; 调用。&lt;/p&gt;
&lt;p&gt;虽然此类调用是合法的，但它们需要额外的隐式转换为 &lt;code&gt;SeqLike&lt;/code&gt;。
    对数组和字符串调用 &lt;code&gt;length&lt;/code&gt; 可能会提供显著优势。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Array(1, 2, 3, 4).size
  "this is a string".size
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Array(1, 2, 3, 4).length
  "this is a string".length
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="EmptyCheck" defaultSeverity="WARNING" displayName="可简化的空性检查" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告检查集合和 &lt;code&gt;Options&lt;/code&gt; 是否为空的不同方法，并建议将它们替换为 &lt;code&gt;.isEmpty&lt;/code&gt;、&lt;code&gt;.nonEmpty&lt;/code&gt; 或 &lt;code&gt;.isDefined&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  !Seq(1).isEmpty
  Seq(1).size == 0
  Seq(1).size != 0
  !(Seq(1).length &gt; 0)
  Seq(1).exists(_ =&gt; true)
  import scala.Function.const
  Seq(1).exists(const(true))
  !Option(0).isEmpty
  Option(0) == None
  Option(0) != None
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Seq(1).nonEmpty
  Seq(1).isEmpty
  Seq(1).nonEmpty
  Seq(1).isEmpty
  Seq(1).nonEmpty
  import scala.Function.const
  Seq(1).nonEmpty
  Option(0).isDefined
  Option(0).isEmpty
  Option(0).isDefined
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="XPath" path=""><inspection shortName="RedundantTypeConversion" defaultSeverity="WARNING" displayName="冗余类型转换" enabled="false" language="XPath" pluginId="XPathView" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告不必要的类型转换。
当 &lt;code&gt;string()&lt;/code&gt;、&lt;code&gt;number()&lt;/code&gt; 或
&lt;code&gt;boolean()&lt;/code&gt; 函数的实参类型已经与函数的返回类型相同时，或者如果
预期表达式类型为 &lt;code&gt;any&lt;/code&gt;，无需类型转换。 建议移除不必要的转换。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="HardwiredNamespacePrefix" defaultSeverity="WARNING" displayName="硬编码命名空间前缀" enabled="false" language="XPath" pluginId="XPathView" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;name()&lt;/code&gt; 函数与包含冒号 (&lt;code&gt;:&lt;/code&gt;) 的字符串的比较。  此类用法通常表明在比较中存在硬编码的命名空间前缀。 因此，针对为相同命名空间使用另一个前缀的 XML 运行时，代码将中断。

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &amp;lt;xsl:if test="name() = 'xlink:href'"&gt;...&amp;lt;xsl:if&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="IndexZeroUsage" defaultSeverity="WARNING" displayName="索引为 0 的 XPath 谓词" enabled="false" language="XPath" pluginId="XPathView" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;0&lt;/code&gt; 在谓词索引中或者与函数 &lt;code&gt;position()&lt;/code&gt; 的
比较中的用法。 此类用法几乎在所有情况下都是错误，因为在 XPath 中，索引从 &lt;code&gt;1&lt;/code&gt; 而&lt;em&gt;不是&lt;/em&gt; &lt;code&gt;0&lt;/code&gt; 开始。

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
  //someelement[&lt;b&gt;position() = 0&lt;/b&gt;]&lt;/code&gt; or &lt;code&gt;//something[&lt;b&gt;0&lt;/b&gt;]
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="CheckNodeTest" defaultSeverity="WARNING" displayName="未知的元素或特性名称" enabled="false" language="XPath" pluginId="XPathView" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在 XPath 表达式中使用但在关联的 XML 文件中缺少并且也没有在引用的架构中定义的元素或特性的名称。
此类名称通常是拼写错误所致，否则可能只会在运行时被发现。

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &amp;lt;xsl:template match="&lt;b&gt;h:txtarea&lt;/b&gt;" /&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;
  如果 &lt;code&gt;h&lt;/code&gt; 被绑定到 XHTML 命名空间，检查会将 &lt;code&gt;match&lt;/code&gt; 表达式的这一部分报告为未知元素名称，因为该元素的正确名称是 "textarea"。
&lt;/p&gt;


&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ImplicitTypeConversion" defaultSeverity="WARNING" displayName="隐式类型转换" enabled="false" language="XPath" pluginId="XPathView" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在预定义的 XPath 类型 &lt;code&gt;STRING&lt;/code&gt;、&lt;code&gt;NUMBER&lt;/code&gt;、&lt;code&gt;BOOLEAN&lt;/code&gt; 和 &lt;code&gt;NODESET&lt;/code&gt; 之间进行的隐式转换。 有助于编写类型表现更明确的XSLT脚本，且避免难以捉摸的错误。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &amp;lt;xsl:if test="&lt;b&gt;foo&lt;/b&gt;" /&gt;
&lt;/code&gt;&lt;/pre&gt;
不同于
&lt;pre&gt;&lt;code&gt;
  &amp;lt;xsl:if test="&lt;b&gt;string(foo)&lt;/b&gt;" /&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;
第一个测试检查元素 “ foo” 是否存在(&lt;code&gt;count(foo) &gt; 0)&lt;/code&gt;，而第二个测试仅当元素包含文本时 (&lt;code&gt;string-length(foo) &gt; 0&lt;/code&gt;)，才会为 “true”。 建议使 
类型转换更加明确。
&lt;/p&gt;

&lt;p&gt;
  使用以下选项配置检查：
&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;启用或禁用某些类型之间的隐式转换&lt;/li&gt;
&lt;li&gt;总是报告没有导致实际预期类型的显式转换，例如， 
 &lt;code&gt;&amp;lt;xsl:if test="number(foo)" /&gt;&lt;/code&gt;&lt;/li&gt; 
&lt;li&gt;忽略使用 &lt;code&gt;string()&lt;/code&gt; 函数作为编写 &lt;code&gt;string-length() &gt; 0&lt;/code&gt; 的快捷方式而造成的从 &lt;code&gt;NODESET&lt;/code&gt;
  到 &lt;code&gt;BOOLEAN&lt;/code&gt; 的转换。&lt;/li&gt;&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="命名约定" path="Kotlin"><inspection shortName="TestFunctionName" defaultSeverity="WEAK WARNING" displayName="测试函数命名约定" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告未遵循&lt;a href="https://kotlinlang.org/docs/coding-conventions.html#names-for-test-methods"&gt;建议的命名约定&lt;/a&gt;的测试函数名称。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="InconsistentCommentForJavaParameter" defaultSeverity="WARNING" displayName="Java 形参的注释不一致" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在注释块中指定的 &lt;b&gt;Java&lt;/b&gt; 方法调用的不一致形参名称。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  // Java
  public class JavaService {
      public void invoke(String command) {}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;
  // Kotlin
  fun main() {
      JavaService().invoke(/* name = */ "fix")
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该快速修复会更正注释块中的形参名称：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun main() {
      JavaService().invoke(/* command = */ "fix")
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ObjectPropertyName" defaultSeverity="WEAK WARNING" displayName="object 属性命名约定" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告不遵循命名约定的属性。
&lt;p&gt;报告了以下属性：&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;顶级属性&lt;/li&gt;
    &lt;li&gt;对象和伴生对象中的属性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;您可以在检查选项中指定所需的模式。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://kotlinlang.org/docs/coding-conventions.html#naming-rules"&gt;建议的命名约定&lt;/a&gt;：必须以大写字母开头，使用驼峰拼写法并且没有下划线。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  // 顶级属性
  val USER_NAME_FIELD = "UserName"
  // 包含对单例对象的引用的顶级属性
  val PersonComparator: Comparator&amp;lt;Person&amp;gt; = /*...*/

  class Person {
    companion object {
      // 伴生对象中的属性
      val NO_NAME = Person()
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PropertyName" defaultSeverity="WEAK WARNING" displayName="属性命名约定" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告不遵循推荐命名约定的属性名称。&lt;/p&gt;
&lt;p&gt;
    一致的命名会让阅读和理解代码变得更容易。
    根据 &lt;a href="https://kotlinlang.org/docs/coding-conventions.html#naming-rules"&gt;Kotlin 官方样式指南&lt;/a&gt;，属性名称应以小写字母开头并使用驼峰拼写法。
&lt;/p&gt;
&lt;p&gt;可以通过更改“模式”正则表达式来引入其他命名规则。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  val My_Cool_Property = ""
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该快速修复会根据 Kotlin 命名约定重命名类：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  val myCoolProperty = ""
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FunctionName" defaultSeverity="WEAK WARNING" displayName="函数命名约定" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告不遵循推荐命名约定的函数名称。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun Foo() {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;要修正此问题，请更改函数名称以匹配推荐的命名约定。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ObjectPrivatePropertyName" defaultSeverity="WEAK WARNING" displayName="对象 private 属性命名约定" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告不遵循命名约定的属性。
&lt;p&gt;报告了以下属性：&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;对象和伴生对象中的私有属性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;您可以在检查选项中指定所需的模式。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://kotlinlang.org/docs/coding-conventions.html#naming-rules"&gt;建议的命名约定&lt;/a&gt;：必须以下划线或大写字母开头，使用驼峰拼写法。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Person {
    companion object {
      // 伴生对象中的属性
      private val NO_NAME = Person()
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PackageName" defaultSeverity="WEAK WARNING" displayName="软件包命名约定" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
报告不遵循命名约定的软件包名称。
&lt;p&gt;您可以在检查选项中指定所需的模式。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://kotlinlang.org/docs/coding-conventions.html#naming-rules"&gt;建议的命名约定&lt;/a&gt;：软件包的名称始终小写，并且不应包含下划线。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;code&gt;org.example.project&lt;/code&gt;
&lt;p&gt;通常不鼓励使用多词名称，但如果您确实需要使用多个词，则可以将它们串联在一起或使用驼峰拼写法&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;code&gt;org.example.myProject&lt;/code&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LocalVariableName" defaultSeverity="WEAK WARNING" displayName="局部变量命名约定" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告不遵循命名约定的局部变量。
&lt;p&gt;您可以在检查选项中指定所需的模式。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://kotlinlang.org/docs/coding-conventions.html#function-names"&gt;建议的命名约定&lt;/a&gt;：必须以小写字母开头，使用驼峰拼写法并且没有下划线。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun fibonacciNumber(index: Int): Long = when(index) {
      0 -&gt; 0
      else -&gt; {
          // 未遵循命名约定：包含下划线符号 (`_`)
          var number_one: Long = 0
          // 未遵循命名约定：以大写字母开头
          var NUMBER_TWO: Long = 1
          // 遵循命名约定：以小写字母开头，使用驼峰拼写法并且没有下划线。
          var numberThree: Long = number_one + NUMBER_TWO

          for(currentIndex in 2..index) {
              numberThree = number_one + NUMBER_TWO
              number_one = NUMBER_TWO
              NUMBER_TWO = numberThree
          }
          numberThree
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PrivatePropertyName" defaultSeverity="WEAK WARNING" displayName="private 属性命名约定" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告不遵循推荐命名约定的 private 属性名称。&lt;/p&gt;
&lt;p&gt;
    一致的命名会让阅读和理解代码变得更容易。
    根据 &lt;a href="https://kotlinlang.org/docs/coding-conventions.html#naming-rules"&gt;Kotlin 官方样式指南&lt;/a&gt;，private 属性名称应以小写字母开头并使用驼峰拼写法。
    或者，允许使用下划线前缀，但仅限于 &lt;b&gt;private&lt;/b&gt; 属性。
&lt;/p&gt;
&lt;p&gt;可以通过更改“模式”正则表达式来引入其他命名规则。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  val _My_Cool_Property = ""
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该快速修复会根据 Kotlin 命名约定重命名类：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  val _myCoolProperty = ""
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ClassName" defaultSeverity="WEAK WARNING" displayName="类命名约定" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告不遵循推荐命名约定的类名。
&lt;p&gt;
    一致的命名会让阅读和理解代码变得更容易。
    根据 &lt;a href="https://kotlinlang.org/docs/coding-conventions.html#naming-rules"&gt;Kotlin 官方样式指南&lt;/a&gt;，类名应以大写字母开头并使用驼峰拼写法。
&lt;/p&gt;
&lt;p&gt;可以通过更改“模式”正则表达式来引入其他命名规则。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class user(val name: String)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该快速修复会根据 Kotlin 命名约定重命名类：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class User(val name: String)
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="EnumEntryName" defaultSeverity="WEAK WARNING" displayName="枚举条目命名约定" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告不遵循推荐的命名约定的枚举条目名称。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  enum class Foo {
    _Foo,
    foo
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;要修正此问题，请重命名枚举条目以匹配推荐的命名约定。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConstPropertyName" defaultSeverity="WEAK WARNING" displayName="const 属性命名约定" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="223-1.8.0-release-345-IJ8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告不遵循推荐命名约定的 &lt;code&gt;const&lt;/code&gt; 属性名称。
&lt;p&gt;
    一致的命名会让阅读和理解代码变得更容易。
    根据 &lt;a href="https://kotlinlang.org/docs/coding-conventions.html#property-names"&gt;Kotlin 官方样式指南&lt;/a&gt;，&lt;code&gt;const&lt;/code&gt; 属性应使用大写下划线分隔的名称。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  const val Planck: Double = 6.62607015E-34
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该快速修复会重命名属性：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  const val PLANCK: Double = 6.62607015E-34
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="语言注入" path=""><inspection shortName="UnknownLanguage" defaultSeverity="ERROR" displayName="未知语言 ID" enabled="false" language="JAVA" pluginId="org.intellij.intelliLang" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;@Language&lt;/code&gt; 注解中使用的语言 ID 未知的情况。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Language("HMTL") String html;
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="InjectionNotApplicable" defaultSeverity="ERROR" displayName="注入注解不适用" enabled="false" language="JAVA" pluginId="org.intellij.intelliLang" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告将 &lt;code&gt;@Language&lt;/code&gt; 注解应用于 &lt;code&gt;String&lt;/code&gt; 或 &lt;code&gt;String[]&lt;/code&gt; 以外类型的元素的情况。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Language("HTML") &lt;b&gt;int&lt;/b&gt; i;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;int&lt;/b&gt; i;
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="LanguageMismatch" defaultSeverity="WARNING" displayName="语言不匹配" enabled="false" language="JAVA" pluginId="org.intellij.intelliLang" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告引用的语言与用法上下文的预期语言不匹配的情况。

&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Language("JavaScript")
  String JS_CODE = "var x;";

  @Language("XPath")
  String XPATH_CODE = JS_CODE; // 此处为警告
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="Java 10" path="Java/Java 语言级别迁移帮助"><inspection shortName="VariableTypeCanBeExplicit" defaultSeverity="INFORMATION" displayName="变量类型可以是显式的" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以替换为显式类型的 &lt;code&gt;var&lt;/code&gt; 类型的局部变量。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  var str = "Hello";
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String str = "Hello";
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  &lt;code&gt;var&lt;/code&gt; &lt;i&gt;关键字&lt;/i&gt;在 Java 10 中出现。
  此检查有助于为向后兼容早期 Java 版本而降级。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantExplicitVariableType" defaultSeverity="INFORMATION" displayName="可以省略局部变量类型" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告冗余局部变量类型。
&lt;p&gt;这些类型可以从上下文中推断出来，因此替换为 &lt;code&gt;var&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void test(InputStream s) {
    try (InputStream in = s) {}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;应用修正后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void test(InputStream s) {
    try (var in = s) {}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Spring Core" path="Spring"><inspection shortName="SpringElStaticFieldInjectionInspection" defaultSeverity="WARNING" displayName="在 static 字段中不正确地注入 SpEL" enabled="false" language="JAVA" pluginId="com.intellij.spring" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告将 Spring Expression Language (SpEL) 注入静态字段（注入 'null' 值）的尝试。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
@Controller
public class MyController {
    &lt;strong&gt;@Value&lt;/strong&gt;("#{systemProperties['some.key']}")  //  不允许注入到 static 字段
    static String spelWithDefaultValue;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SpringHandlersSchemasHighlighting" defaultSeverity="ERROR" displayName="spring.handlers 或 spring.schemas 文件中未解析的文件或类引用" enabled="false" language="Properties" pluginId="com.intellij.spring" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 &lt;code&gt;spring.handlers&lt;/code&gt; 和 &lt;code&gt;spring.schemas&lt;/code&gt; 文件中未解析的类和文件引用。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例 &lt;code&gt;spring.handlers&lt;/code&gt; 文件：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
   a=my.company.MyHandler
   b=my.company.UnknownHandler // 报告 "无法解析类 'my.company.UnknownHandler'"
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SpringElInspection" defaultSeverity="WARNING" displayName="不正确的 Spring Expression Language (SpEl) 语法 " enabled="false" language="SpEL" pluginId="com.intellij.spring" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 Spring Expression Language (SpEL) 代码中的语法错误，例如未解析的引用和无效位置。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
@Controller
public class MyController {
    @Value("#{T(java.lang.Math).&lt;strong&gt;unknown&lt;/strong&gt;()}") // 无法解析属性或 'unknown' 方法
    public void setValue(String s) {}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Java 5" path="Java/Java 语言级别迁移帮助"><inspection shortName="ForCanBeForeach" defaultSeverity="WARNING" displayName="'for' 循环可被替换为增强的 for 循环" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告迭代集合或数组并且可以自动替换为增强型 &lt;code&gt;for&lt;/code&gt; 循环（foreach 迭代语法）的 &lt;code&gt;for&lt;/code&gt; 循环。
&lt;!--  'foreach' still used in this description so that the inspection continues to be found using this keyword --&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  for (Iterator&amp;lt;String&amp;gt; iterator = list.iterator(); iterator.hasNext(); ) {
    String item = iterator.next();
    System.out.println(item);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  for (String item : list) {
    System.out.println(item);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用&lt;b&gt;报告索引的 'java.util.List' 循环&lt;/b&gt;选项可查找涉及 &lt;code&gt;list.get(index)&lt;/code&gt; 调用的循环。
  这些循环通常可以替换为增强型 &lt;code&gt;for&lt;/code&gt; 循环，除非它们修改了进程中的基础列表，例如通过调用 &lt;code&gt;list.remove(index)&lt;/code&gt; 进行修改。
  如果是后面这种情况，增强型 &lt;code&gt;for&lt;/code&gt; 循环可能抛出 &lt;code&gt;ConcurrentModificationException&lt;/code&gt;。
  在某些情况下，&lt;code&gt;list.get(index)&lt;/code&gt; 循环的操作速度也可能更快一些。&lt;/p&gt;
&lt;p&gt;
  使用&lt;b&gt;不报告无类型集合上的迭代&lt;/b&gt;选项可忽略没有类型形参的集合。
  这将防止创建 &lt;code&gt;java.lang.Object&lt;/code&gt; 类型的增强型 &lt;code&gt;for&lt;/code&gt; 循环变量以及在使用循环变量的位置插入转换。&lt;/p&gt;
&lt;p&gt;仅当项目或模块的语言级别为 5 或更高时，此检查才会报告。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryUnboxing" defaultSeverity="WARNING" displayName="不必要的拆箱" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告取消装箱，即显式解开已环绕的基元值。
&lt;p&gt;对于 Java 5 和更高版本，拆箱不必要，并且可以安全移除。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;Integer i = Integer.valueOf(42).intValue();&lt;/code&gt; &amp;rarr; &lt;code&gt;Integer i = Integer.valueOf(42);&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;int k = Integer.valueOf(42).intValue();&lt;/code&gt; &amp;rarr; &lt;code&gt;int k = Integer.valueOf(42);&lt;/code&gt;
    &lt;p&gt;（仅在未选中&lt;b&gt;仅报告真正多余的拆箱表达式&lt;/b&gt;选项时报告）&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用&lt;b&gt;仅报告真正多余的拆箱表达式&lt;/b&gt;选项，可仅报告真正多余的拆箱，其中的拆箱值立即隐式或显式地装箱。
  在本例中，可以移除整个拆箱-装箱步骤。 该检查不报告简单的显式拆箱。&lt;/p&gt;
&lt;p&gt;仅当项目或模块的语言级别为 5 或更高时，此检查才会报告。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="IndexOfReplaceableByContains" defaultSeverity="WARNING" displayName="'String.indexOf()' 表达式可被替换为 'contains()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告与 &lt;code&gt;String.indexOf()&lt;/code&gt; 调用（可以替换为对 &lt;code&gt;String.contains()&lt;/code&gt; 方法的调用）的比较。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;boolean&lt;/b&gt; b = "abcd".indexOf('e') &gt;= 0;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;boolean&lt;/b&gt; b = "abcd".contains('e');
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;仅当项目或模块的语言级别为 5 或更高时，此检查才会报告。&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MethodCanBeVariableArityMethod" defaultSeverity="INFORMATION" displayName="方法可以有 varargs 形参" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以转换为可变 arity 方法的方法。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void process(String name, Object[] objects);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void process(String name, Object... objects);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  仅当项目或模块的语言级别为 5 或更高时，此检查才会报告。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="WhileCanBeForeach" defaultSeverity="WARNING" displayName="'while' 循环可被替换为增强的 'for' 循环" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告迭代集合并且可以替换为增强型 &lt;code&gt;for&lt;/code&gt; 循环（foreach 迭代语法）的 &lt;code&gt;while&lt;/code&gt; 循环。
&lt;!--  'foreach' still used in this description so that the inspection continues to be found using this keyword --&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Iterator it = c.iterator();
  while(it.hasNext()) {
    Object obj = it.next();
    System.out.println(obj);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以替换为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  for (Object obj : c) {
    System.out.println(obj);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;仅当项目或模块的语言级别为 5 或更高时，此检查才会报告。&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StringBufferReplaceableByStringBuilder" defaultSeverity="WARNING" displayName="'StringBuffer' 可能是 'StringBuilder'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告声明为 &lt;code&gt;StringBuffer&lt;/code&gt; 的变量，并建议将它们替换为 &lt;code&gt;StringBuilder&lt;/code&gt;。
&lt;code&gt;StringBuilder&lt;/code&gt; 是 &lt;code&gt;StringBuffer&lt;/code&gt; 的非线程安全替换。
&lt;!-- tooltip end --&gt;
&lt;p&gt;仅当项目或模块的语言级别为 5 或更高时，此检查才会报告。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryBoxing" defaultSeverity="WARNING" displayName="不必要的装箱" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告显式装箱，即将基元值包装到对象中。
&lt;p&gt;对于 Java 5 和更高版本，显式手动装箱不必要，并且可以安全移除。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;Integer i = new Integer(1);&lt;/code&gt; &amp;rarr; &lt;code&gt;Integer i = Integer.valueOf(1);&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;int i = Integer.valueOf(1);&lt;/code&gt; &amp;rarr; &lt;code&gt;int i = 1;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;!-- tooltip end --&gt;
&lt;p&gt;
使用&lt;b&gt;仅报告真正多余的装箱表达式&lt;/b&gt;选项，可仅报告真正多余的装箱，其中的装箱值立即隐式或显式地拆箱。
在本例中，可以移除整个装箱-拆箱步骤。 该检查不报告简单的显式装箱。
&lt;p&gt;仅当项目或模块的语言级别为 5 或更高时，此检查才会报告。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RawUseOfParameterizedType" defaultSeverity="WARNING" displayName="形参化类的原始使用" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告类型形参被忽略的泛型类。 这种对泛型类型的&lt;i&gt;原始&lt;/i&gt;使用在 Java 中虽然有效，但它违背了类型形参的用途，并且可能掩盖错误。 此检查反映出 &lt;code&gt;javac&lt;/code&gt; 的 &lt;code&gt;rawtypes&lt;/code&gt; 警告。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
//警告：形参化类 'List' 的原始使用
List list = new ArrayList&amp;lt;String&amp;gt;();
//创建了字符串列表，但也接受整数
list.add(1);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;
//无警告，因为在数组创建期间无法提供类型实参
IntFunction&amp;lt;List&amp;lt;?&amp;gt;[]&gt; fun = List[]::new;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;配置检查：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;使用&lt;b&gt;忽略新对象的构造&lt;/b&gt;选项，可忽略对象构造中使用的原始类型。&lt;/li&gt;
  &lt;li&gt;使用&lt;b&gt;忽略类型转换&lt;/b&gt;选项，可忽略类型转换中使用的原始类型。&lt;/li&gt;
  &lt;li&gt;使用&lt;b&gt;忽略类型形参无法编译的位置&lt;/b&gt;选项，可忽略类型形参编译失败的情况（例如创建数组或重写库方法的情况）。&lt;/li&gt;
  &lt;li&gt;使用&lt;b&gt;忽略重写方法的形参类型&lt;/b&gt;选项，可忽略重写方法的形参中使用的类型形参。&lt;/li&gt;
  &lt;li&gt;使用&lt;b&gt;在自动快速修复不可用时忽略&lt;/b&gt;选项，可忽略快速修复不可用的情况。&lt;/li&gt;
&lt;/ul&gt;
仅当项目或模块的语言级别为 5 或更高时，此检查才会报告。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="BigDecimalLegacyMethod" defaultSeverity="WARNING" displayName="调用了 'BigDecimal' 遗留方法" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对使用整数常量指定舍入模式的 &lt;code&gt;BigDecimal.divide()&lt;/code&gt; 或 &lt;code&gt;BigDecimal.setScale()&lt;/code&gt; 的调用。
自 JDK 1.5 起，可以考虑使用接受 &lt;code&gt;RoundingMode&lt;/code&gt; &lt;code&gt;enum&lt;/code&gt; 形参的方法。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;new BigDecimal("42").setScale(2, BigDecimal.ROUND_FLOOR);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;new BigDecimal("42").setScale(2, RoundingMode.FLOOR);&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CollectionsFieldAccessReplaceableByMethodCall" defaultSeverity="WARNING" displayName="对空集合字段的引用可被替换为方法调用" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;java.util.Collections&lt;/code&gt; 字段的用法：&lt;code&gt;EMPTY_LIST&lt;/code&gt;、&lt;code&gt;EMPTY_MAP&lt;/code&gt;
或 &lt;code&gt;EMPTY_SET&lt;/code&gt;。 这些字段用法可以替换为以下方法调用：&lt;code&gt;emptyList()&lt;/code&gt;、&lt;code&gt;emptyMap()&lt;/code&gt; 或 &lt;code&gt;emptySet()&lt;/code&gt;。
此类方法调用会防止编译器发出未检查的警告，因为可以推断出类型形参。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  List&amp;lt;Integer&amp;gt; emptyList = Collections.EMPTY_LIST;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  List&amp;lt;Integer&amp;gt; emptyList = Collections.emptyList();
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;仅当项目或模块的语言级别为 5 或更高时，此检查才会报告。&lt;/p&gt;
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="映射" path="Scala，集合"><inspection shortName="MapLift" defaultSeverity="WARNING" displayName="将 Lift 转换为 Get" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 &lt;code&gt;map.lift(n)&lt;/code&gt; 的用法，并建议将其替换为 &lt;code&gt;map.get(n)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  val m = Map(1 -&gt; 1)
  m.lift(1)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  val m = Map(1 -&gt; 1)
  m.get(1)
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnitInMap" defaultSeverity="WARNING" displayName="map 实参中的 Unit 返回值类型" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 &lt;code&gt;map&lt;/code&gt; 与不产生结果的表达式的搭配使用。&lt;/p&gt;
&lt;p&gt;如果可能，此检查会建议将此类 &lt;code&gt;map&lt;/code&gt; 调用替换为 &lt;code&gt;foreach&lt;/code&gt; 调用。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Seq(1, 2).map(println)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Seq(1, 2).foreach(println)
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MapGetGet" defaultSeverity="WARNING" displayName="从 Map 获取值时存在冗余的 get" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;通过键从映射中获取值时，报告对 &lt;code&gt;Map.get&lt;/code&gt;/&lt;code&gt;Option.get&lt;/code&gt; 的不必要调用&lt;/p&gt;.
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  val map = Map(1 -&gt; 42)
  map.get(k).get
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  val map = Map(1 -&gt; 42)
  map(k)
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MapGetEmptinessCheck" defaultSeverity="WARNING" displayName="对 Get 到 Contains 执行空性检查" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 &lt;code&gt;Map.get&lt;/code&gt; 结果的空性检查，并建议将其替换为对 &lt;code&gt;Map.contains&lt;/code&gt; 的调用。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  val map = Map(1 -&gt; 42)
  map.get(key).nonEmpty
  map.get(key).isEmpty
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  val map = Map(1 -&gt; 42)
  map.contains(key)
  !map.contains(key)
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MapValues" defaultSeverity="WARNING" displayName="正在手动提取值" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告从 &lt;code&gt;Map&lt;/code&gt; 中提取值的非标准方法。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  val map = Map(1 -&gt; 42)
  map.map(_._2)
  map.map(_._2).toIterator
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  val map = Map(1 -&gt; 42)
  map.values
  map.valuesIterator
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MapKeys" defaultSeverity="WARNING" displayName="正在手动提取键" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告从 &lt;code&gt;Map&lt;/code&gt; 中提取键的非标准方法。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  val map = Map(1 -&gt; 42)
  map.map(_._1)
  map.map(_._1).toSet
  map.map(_._1).toIterator
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  val map = Map(1 -&gt; 42)
  map.keys
  map.keySet
  map.keysIterator
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="GetGetOrElse" defaultSeverity="WARNING" displayName="将 Get 和 getOrElse 转换为 getOrElse" enabled="false" language="Scala" pluginId="org.intellij.scala" pluginVersion="2022.3.20" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 &lt;code&gt;map&lt;/code&gt; 上的 &lt;code&gt;get(key).getOrElse(value)&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;该快速修复改用 &lt;code&gt;getOrElse(key, value)&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  val map = Map(1 -&gt; 42)
  map.get(key).getOrElse(defValue)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：
&lt;pre&gt;&lt;code&gt;
  al map = Map(1 -&gt; 42)
  ap.getOrElse(key, defValue)
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Spring Integration" path="Spring"><inspection shortName="SpringIntegrationDeprecations21" defaultSeverity="WARNING" displayName="Spring Integration 2.1 弃用" enabled="false" language="XML" pluginId="com.intellij.spring.integration" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告当前版本的 &lt;a href="https://spring.io/projects/spring-integration"&gt;Spring Integration&lt;/a&gt; 基于 XML 的应用程序上下文中已弃用的 XML 元素。&lt;/p&gt;

&lt;p&gt;有关详细信息，请参阅 &lt;a href="https://github.com/SpringSource/spring-integration/wiki/Spring-Integration-2.0-to-2.1-Migration-Guide"&gt;迁移指南&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
&amp;lt;beans ... &amp;gt;
   &amp;lt;int:channel id="failChannel"
                dispatcher="&lt;strong&gt;failover&lt;/strong&gt;"/&amp;gt; &amp;lt;!-- 此特性已被弃用，请改用调度程序子元素 --&amp;gt;
   &amp;lt;int:poller default="true"&amp;gt;
     &amp;lt;&lt;strong&gt;int:cron-trigger&lt;/strong&gt;  expression="5"/&amp;gt;  &amp;lt;!-- 此元素在 Spring Integration 2.1 中已被移除，请改用 'cron' 特性 --&amp;gt;
     &amp;lt;&lt;strong&gt;int:interval-trigger&lt;/strong&gt; interval="3"/&amp;gt; &amp;lt;!--  此元素在 Spring Integration 2.1 中已被移除，请改用 interval-trigger 特性 --&amp;gt;
  &amp;lt;/int:poller&amp;gt;
  &amp;lt;ftp:inbound-channel-adapter session-factory="ftpSessionFactory"
                               cache-sessions="&lt;strong&gt;false&lt;/strong&gt;" &amp;lt;!--  This attribute is deprecated, use CachingSessionFactory instead --&amp;gt;
                               channel="channel"/&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnresolvedMessageChannel" defaultSeverity="WARNING" displayName="端点方法注解中不正确的 'channel' 特性" enabled="false" language="JAVA" pluginId="com.intellij.spring.integration" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告端点方法注解中不正确的通道特性：
&lt;a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/annotation/Gateway.html"&gt;@Gateway&lt;/a&gt;、
&lt;a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/annotation/ServiceActivator.html"&gt;@ServiceActivator、&lt;/a&gt;
&lt;a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/annotation/Filter.html"&gt;@Filter&lt;/a&gt; 等。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
  @Component
  public class MyComponent {}
     @Gateway(requestChannel = "requestChannel", replyChannel = "replyChannel")
     public void gateway() {...}

     @Gateway(
        requestChannel ="&lt;strong&gt;simpleBean&lt;/strong&gt;",   // Bean 必须为以下一种类型：org.springframework.integration.MessageChannel,org.springframework.messaging.MessageChannel
        replyChannel = "&lt;strong&gt;unknownChannel&lt;/strong&gt;")   // 找不到通道
     public void errors() {...}

     @Bean
     public MyBean simpleBean() {...}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;

</inspection><inspection shortName="SpringIntegrationModel" defaultSeverity="ERROR" displayName="不正确的 Spring Integration 基于 XML 的应用程序上下文" enabled="false" language="XML" pluginId="com.intellij.spring.integration" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 &lt;a href="https://spring.io/projects/spring-integration"&gt;Spring Integration&lt;/a&gt; 基于 XML 的应用程序上下文的问题：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;未解析的 Bean 引用&lt;/li&gt;
  &lt;li&gt;缺少必需的标记或特性&lt;/li&gt;
  &lt;li&gt;属性类型不正确&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;enum&lt;/code&gt; 属性不一致&lt;/li&gt;
  &lt;li&gt;引用 Bean 的类型不正确&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &amp;lt;beans ... &amp;gt;
  &amp;lt;int:channel id="channel"&amp;gt; &amp;lt;!-- 'dispatcher' 和 'queue' 不能一起使用  --&amp;gt;
    &amp;lt;int:dispatcher failover="true"/&amp;gt;
    &amp;lt;int:priority-queue capacity="4"/&amp;gt;
  &amp;lt;/int:channel&amp;gt;
  
  &amp;lt;int:channel id="another" &amp;gt;
    &amp;lt;int:queue &amp;lt;!--Exactly one of 'message-store' or 'ref' is required  --&amp;gt;
              capacity="4" message-store="myMessageStore" ref="myQueue"/&amp;gt;
  &amp;lt;/int:channel&amp;gt;
  
   &amp;lt;int:gateway id="asyncGatewayError"
                async-executor="dummyBean"/&amp;gt; &amp;lt;!--Bean 必须为 'java.util.concurrent.Executor' 类型  --&amp;gt;

   &amp;lt;int:delayer default-delay="3"
              message-store="myMessageStore"
              scheduler="scheduler"
              wait-for-tasks-to-complete-on-shutdown="false"/&amp;gt;
  &amp;lt;!--Bean 必须为 'java.util.concurrent.Executor' 类型  --&amp;gt;
  &amp;lt;int:delayer
    default-delay="INVALID_VALUE"  &amp;lt;!--Cannot convert string 'INVALID_VALUE' to target class 'java.lang.Integer' --&amp;gt;
               message-store="dummyBean" &amp;lt;!-- Bean 必须为 'org.springframework.integration.store.MessageStore' 类型--&amp;gt;
               scheduler="dummyBean" &amp;lt;!-- Bean 必须为以下一种类型：java.util.concurrent.ScheduledExecutorService,org.springframework.scheduling.TaskScheduler--&amp;gt;
               wait-for-tasks-to-complete-on-shutdown="INVALID_VALUE"/&amp;gt; &amp;lt;!-- 无法解析符号 'INVALID_VALUE' --&amp;gt;

  &amp;lt;bean id="dummyBean" class="java.lang.String"/&amp;gt;
  &amp;lt;bean id="myMessageStore" class="org.springframework.integration.store.SimpleMessageStore"/&amp;gt;
  &amp;lt;task:scheduler id="scheduler"/&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;

</inspection><inspection shortName="SpringIntegrationMethodEndpointInconsistency" defaultSeverity="WARNING" displayName="不正确的 Spring Integration 端点方法" enabled="false" language="JAVA" pluginId="com.intellij.spring.integration" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告不正确的 &lt;a href="https://spring.io/projects/spring-integration"&gt;Spring Integration&lt;/a&gt; 端点方法声明。

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
class MyEndpoints {
  @InboundChannelAdapter("channel")
  public void &lt;strong&gt;cannotBeVoid&lt;/strong&gt;() {...} // 使用 @InboundChannelAdapter 注解的方法必须具有返回类型

  @InboundChannelAdapter("channel")
  public String &lt;strong&gt;cannotHaveParams&lt;/strong&gt;(String s) {..} // 使用 @InboundChannelAdapter 注解的方法不能有实参

  @&lt;strong&gt;Filter&lt;/strong&gt;(inputChannel = "channel", // 端点只能具有一个轮询器
    outputChannel = "channel2",
    poller = {@Poller(fixedDelay = "100"), @Poller(fixedRate = "100")})
  public void testMultiplePollers() {
  }

  @Filter(inputChannel = "channel",
  outputChannel = "channel2",
  poller = @&lt;strong&gt;Poller&lt;/strong&gt;(value = "poller", maxMessagesPerPoll = "100"))
  public void testValue() {
  }

  @Filter(inputChannel = "channel",
    outputChannel = "channel2",
    poller = @&lt;strong&gt;Poller&lt;/strong&gt;(trigger = "trigger", cron = "0 */10 * * * *")) // 'trigger' 特性与其他特性互斥
  public void testTrigger() {
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="XML" path="Spring/Spring Core"><inspection shortName="SpringScopesInspection" defaultSeverity="ERROR" displayName="未知 &lt;bean&gt; 范围" enabled="false" language="XML" pluginId="com.intellij.spring" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 &lt;strong&gt;&amp;lt;bean&amp;gt;&lt;/strong&gt; 元素中 &lt;code&gt;scope&lt;/code&gt; 特性的未知值。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &amp;lt;beans&amp;gt;
    &amp;lt;bean class="beans.FooComponent" id="foo" scope="unknown"/&amp;gt;
    // 报告 "无法解析符号 'unknown'"
    &amp;lt;bean class="beans.BarComponent" id="bar" scope="prototype"/&amp;gt;
  &amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SpringInjectionValueStyleInspection" defaultSeverity="WARNING" displayName="XML 应用程序上下文中的注入值违反约定" enabled="false" language="XML" pluginId="com.intellij.spring" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告通过 &lt;code&gt;&amp;lt;value&amp;gt;&lt;/code&gt; 或 &lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt; 子元素配置的属性，并建议将其替换为相应的特性。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &amp;lt;beans&amp;gt;
    &amp;lt;bean class="MyBean" id="myBean"/&amp;gt;

    &amp;lt;bean class="MyFactory"&amp;gt;
      &amp;lt;property name="bean"&amp;gt;
        &amp;lt;ref bean="myBean"/&amp;gt; // 报告 "使用了显式 &amp;lt;ref&amp;gt; 元素"
      &amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;
  &amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;应用快速修复后：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
  &amp;lt;beans&amp;gt;
    &amp;lt;bean class="MyBean" id="myBean"/&amp;gt;
    &amp;lt;bean class="MyFactory"&amp;gt;
      &amp;lt;property name="bean" ref="myBean"/&amp;gt;
    &amp;lt;/bean&amp;gt;
  &amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SpringInactiveProfileHighlightingInspection" defaultSeverity="WARNING" displayName="停用配置文件高亮显示" enabled="false" language="XML" pluginId="com.intellij.spring" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 Spring XML 应用程序上下文中的停用配置文件。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &amp;lt;!-- 为此应用程序上下文选择有效配置文件 &lt;strong&gt;'DEV'&lt;/strong&gt; --&amp;gt;
  &amp;lt;beans profile="&lt;strong&gt;DEV&lt;/strong&gt;"&amp;gt;
    &amp;lt;bean class="MyFactory" factory-method="createBean"/&amp;gt;
  &amp;lt;/beans&amp;gt;
  &amp;lt;!--  此标记的内容高亮显示为 'unused' --&amp;gt;
  &lt;em&gt;&amp;lt;beans profile="&lt;strong&gt;TESTS&lt;/strong&gt;"&amp;gt;
    &amp;lt;bean class="MyTestFactory" factory-method="createBean"/&amp;gt;
  &amp;lt;/beans&amp;gt;&lt;/em&gt;
  &amp;lt;!--  'unused' 部分的结尾 --&amp;gt;
  &amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SpringRequiredPropertyInspection" defaultSeverity="ERROR" displayName="Spring Xml Bean 声明中缺少 @Required 属性注入" enabled="false" language="XML" pluginId="com.intellij.spring" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告未注入或自动装配的 &lt;code&gt;@Required&lt;/code&gt; setter Bean 属性。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
&amp;lt;beans&amp;gt;
  &amp;lt;bean class="beans.MyComponent" id="foo"/&amp;gt;
  // 报告 "缺少必需属性: 'port'"
&amp;lt;/beans&amp;gt;

&lt;hr/&gt;

public class MyComponent {
   @Required
   public void setPort(int port) // 报告 "未注入必需属性 'port'"
   {...}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AbstractBeanReferencesInspection" defaultSeverity="ERROR" displayName="对抽象 Bean 不正确的引用" enabled="false" language="XML" pluginId="com.intellij.spring" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告引用的抽象 Bean。&lt;/p&gt;

&lt;p&gt;抽象 Bean 只能用作模板 Bean 定义，即子定义的父项。
  尝试通过作为另一个 Bean 的 ref 属性进行引用，或者通过使用父 Bean ID 调用 &lt;code&gt;getBean()&lt;/code&gt; 来单独使用此类抽象父 Bean，将导致错误。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
  &amp;lt;bean abstract="true" id="parentBeanWithoutClass"/&amp;gt;
  &amp;lt;bean class="com.my.company.FooBean" id="childBean" parent="parentBeanWithoutClass"&amp;gt;
  &amp;lt;!--  properties --&amp;gt;
  &amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在此示例中，父 Bean 不能自己实例化，因为它不完整并且被显式声明为抽象。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

</inspection><inspection shortName="SpringBeanConstructorArgInspection" defaultSeverity="ERROR" displayName="XML Spring Bean 中不正确的构造函数注入" enabled="false" language="XML" pluginId="com.intellij.spring" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告使用基于构造函数的依赖项注入的 Spring &lt;code&gt;&amp;lt;bean&amp;gt;&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;当使用配置的 &lt;code&gt;&amp;lt;constructor-arg&amp;gt;&lt;/code&gt; 标记和定义的 &lt;code&gt;autowire&lt;/code&gt; 策略找不到 &lt;code&gt;&amp;lt;bean&amp;gt;&lt;/code&gt; 的合适构造函数或工厂方法时，将触发检查。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    public class MyComponent {
    // constructor
    public MyComponent(MyBean bean) {}
    // factory method
    public static MyComponent getInstance(String name, int port) {
    }
    &amp;lt;beans&amp;gt;
      &amp;lt;bean class="beans.MyComponent" id="foo"&amp;gt; // 报告 "在类 'MyComponent' 中找不到匹配的构造函数"
         &amp;lt;constructor-arg ref="myBean"/&amp;gt;
         &amp;lt;constructor-arg value="123"/&amp;gt;
      &amp;lt;/bean&amp;gt;

      &amp;lt;bean class="beans.MyComponent" factory-method="getInstance"&amp;gt; // 报告 "在类中找不到匹配的工厂方法"
         &amp;lt;constructor-arg value="123"/&amp;gt;
      &amp;lt;/bean&amp;gt;
    &amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SpringIncorrectResourceTypeInspection" defaultSeverity="ERROR" displayName="不正确的资源类型" enabled="false" language="XML" pluginId="com.intellij.spring" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 XML 应用程序上下文中引用的不正确文件。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &amp;lt;beans&amp;gt;
    &amp;lt;import resource="imported-app-context.xml"/&amp;gt;
    &amp;lt;import resource="banner.txt"/&amp;gt;// 报告 '不正确的资源类型'，因为此处应为 Spring XML 应用程序上下文
  &amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SpringBeanNameConventionInspection" defaultSeverity="WARNING" displayName="Spring Bean 名称违反约定" enabled="false" language="XML" pluginId="com.intellij.spring" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告不遵循 Bean 命名约定的 &lt;strong&gt;&amp;lt;bean&amp;gt;&lt;/strong&gt; 名称。&lt;/p&gt;

&lt;p&gt;
  约定是在命名 Bean 时对实例字段名称使用标准 Java 约定。
  也就是说，Bean 名称以小写字母开头，并从那里开始使用驼峰式大小写。
  此类名称的示例包括 &lt;code&gt;accountManager&lt;/code&gt;、&lt;code&gt;accountService&lt;/code&gt;、&lt;code&gt;userDao&lt;/code&gt;、&lt;code&gt;loginController&lt;/code&gt; 等。
  一致地命名 Bean 会使您的配置更易于阅读和理解。
  此外，如果您使用的是 Spring AOP，那么在将建议应用于一组按名称相关的 Bean 时，会很有用。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RequiredBeanTypeInspection" defaultSeverity="ERROR" displayName="不正确的注入 Bean 类型" enabled="false" language="XML" pluginId="com.intellij.spring" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告在 XML 应用程序上下文中定义的自定义架构 Bean 注入的不正确类型。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class SimpleBean{}

  &amp;lt;beans ...&gt;
    &amp;lt;bean class="SimpleBean" id="simpleBean"/&amp;gt;
       &amp;lt;mvc:annotation-driven
         conversion-service="simpleBean"      &amp;lt;!-- reports "Bean must be of 'org.springframework.core.convert.ConversionService' type" --&amp;gt;
         message-codes-resolver="simpleBean"  &amp;lt;!-- 报告 "Bean 必须为 'org.springframework.validation.MessageCodesResolver' 类型" --&amp;gt;
         validator="simpleBean"               &amp;lt;!-- 报告 "Bean 必须为 'org.springframework.validation.Validator' 类型" --&amp;gt;
    /&amp;gt;
  &amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SpringBeanAttributesInspection" defaultSeverity="WARNING" displayName="Spring Bean 特性冲突" enabled="false" language="XML" pluginId="com.intellij.spring" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 &lt;code&gt;&amp;lt;bean&amp;gt;&lt;/code&gt; 特性的配置冲突。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &amp;lt;beans&amp;gt;
    &amp;lt;bean class="java.lang.String" factory-bean="factoryBean"/&amp;gt;
    &amp;lt;!-- 仅需 'class' 或 'factory-bean' --&amp;gt;
    &amp;lt;bean factory-bean="factoryBean" id="missingFactoryMethod"/&amp;gt; //当 factory-bean 存在时，需要 factory-method

    &amp;lt;bean abstract="false" id="superfluousDefaultAttributeAbstract"/&amp;gt;

    &amp;lt;!-- 具有默认值 'false' 的特性 abstract 是多余的 --&amp;gt;/
    &amp;lt;bean id="superfluousDefaultAttributeScope" scope="singleton"/&amp;gt;

    &amp;lt;!-- 具有默认值 'singleton' 的特性范围是多余的 --&amp;gt;/
    &amp;lt;bean class="java.lang.StringBuilder"&amp;gt;
      &amp;lt;property name="length"&amp;gt;
         &amp;lt;bean id="beanId" // Attribute id is superfluous
              name="beanName"   // Attribute name is superfluous
              scope="prototype" // Attribute scope is superfluous
         /&gt;
      &amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;
  &amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SpringInjectionValueConsistencyInspection" defaultSeverity="ERROR" displayName="XML 应用程序上下文中不一致的注入值" enabled="false" language="XML" pluginId="com.intellij.spring" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 XML 应用程序上下文中注入点的不一致标记和特性。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;&amp;lt;property&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;constructor-arg&amp;gt;&lt;/code&gt; 必须指定 &lt;code&gt;ref&lt;/code&gt;、&lt;code&gt;value&lt;/code&gt; 或子元素&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;&amp;lt;property&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;constructor-arg&amp;gt;&lt;/code&gt; 不能包含多个子元素&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt; 可以包含 &lt;code&gt;bean&lt;/code&gt; 特性、&lt;code&gt;local&lt;/code&gt; 特性或 &lt;code&gt;parent&lt;/code&gt; 特性&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt; 必须指定一个 Bean&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;&amp;lt;idref&amp;gt;&lt;/code&gt; 可以包含 &lt;code&gt;bean&lt;/code&gt; 特性或 &lt;code&gt;local&lt;/code&gt; 特性&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;&amp;lt;idref&amp;gt;&lt;/code&gt; 必须指定一个 Bean&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;&amp;lt;map&amp;gt;&lt;/code&gt; 必须指定一个键&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;&amp;lt;idref&amp;gt;&lt;/code&gt; 可以包含 &lt;code&gt;key&lt;/code&gt; 特性、&lt;code&gt;key-ref&lt;/code&gt; 特性或 &lt;code&gt;&amp;lt;key&amp;gt;&lt;/code&gt; 子元素&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &amp;lt;beans&amp;gt;

  &lt;em&gt;&amp;lt;!-- 1.  属性只允许包含 "ref" 特性或 "value" 特性或子元素 --&amp;gt;&lt;/em&gt;
  &amp;lt;bean class="MyClass"&amp;gt;
    &amp;lt;property name="bean" ref="myBean" value="foo"/&amp;gt;
    // 属性只允许包含 "ref" 特性或 "value" 特性或子元素
  &amp;lt;/bean&amp;gt;

  &lt;em&gt;&amp;lt;!--  2.  属性不得包含多个子元素 --&amp;gt;&lt;/em&gt;
  &amp;lt;bean class="MyFactory"&amp;gt;
    &amp;lt;property name="bean"&amp;gt;
    &amp;lt;ref&amp;gt;bean&amp;lt;/ref&amp;gt; // 属性不得包含多个子元素
     &amp;lt;value&amp;gt;foo&amp;lt;/value&amp;gt; // 属性不得包含多个子元素
     &amp;lt;/property&amp;gt;
  &amp;lt;/bean&amp;gt;

  &lt;em&gt;&amp;lt;!-- 3. 映射条目必须指定一个键  --&amp;gt;&lt;/em&gt;
  &amp;lt;bean class="MyBean"&amp;gt;
     &amp;lt;property name="map"&amp;gt;
        &amp;lt;map&amp;gt;
           &amp;lt;entry value="foo"/&amp;gt;  // 映射条目必须指定一个键
        &amp;lt;/map&amp;gt;
     &amp;lt;/property&amp;gt;
  &amp;lt;/bean&amp;gt;
  &amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SpringFactoryMethodInspection" defaultSeverity="ERROR" displayName="在 &quot;factory-method&quot; 特性中引用的错误定义的方法" enabled="false" language="XML" pluginId="com.intellij.spring" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 &lt;code&gt;&amp;lt;bean&amp;gt;&lt;/code&gt; 元素的 &lt;code&gt;factory-method&lt;/code&gt;特性中不正确的方法引用。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
public class MyFactory {
public static FooBean createBean() {}
}
&amp;lt;beans&amp;gt;
  &amp;lt;bean class="MyFactory" id="factory"/&amp;gt;
  &amp;lt;bean factory-bean="factory" factory-method="createBean"/&amp;gt; // 工厂方法 'createBean' 不得为 static
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="InjectionValueTypeInspection" defaultSeverity="ERROR" displayName="XML 应用程序上下文中不可分配的注入点类型" enabled="false" language="XML" pluginId="com.intellij.spring" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告无效的注入点类型（属性和构造函数实参）。&lt;/p&gt;

&lt;p&gt;允许使用以下注入点类型：&lt;code&gt;ref&lt;/code&gt;、&lt;code&gt;idref&lt;/code&gt;、任何集合类型、内部 Bean 等。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
  public class InjectionValueTypes{
  public List&amp;lt;MyBean&amp;gt; setListBeans() {...}
    public MyBean setMyBean() {...}
    }
  }
  &amp;lt;beans&amp;gt;
    &amp;lt;bean class="MyBean" id="myBean"/&amp;gt;
    &amp;lt;bean class="ErrTypeBean" id="errTypeBean"/&amp;gt;
    &amp;lt;bean class="InjectionValueTypes" id="kt"&amp;gt;
      &amp;lt;property name="myBean" ref="errTypeBean"/&amp;gt;
      // 报告 "'MyBean' 类型的属性不能由 'ErrTypeBean' 注入"
      &amp;lt;property name="listBeans"&amp;gt;
        &amp;lt;list&amp;gt;
          &amp;lt;idref local="myBean"/&amp;gt;
          &amp;lt;ref bean="myBean"/&amp;gt;
          &amp;lt;ref bean="errTypeBean"/&amp;gt; // 报告 "无法添加到 'MyBean' 类型的集合中"
          &amp;lt;bean class="ErrTypeBean"/&amp;gt; // 报告 "Bean 必须为 'MyBean' 类型"
        &amp;lt;/list&amp;gt;
      &amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;
  &amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SpringPlaceholdersInspection" defaultSeverity="WARNING" displayName="Spring XML 应用程序上下文中配置的未解析的占位符" enabled="false" language="XML" pluginId="com.intellij.spring" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告在 Spring XML 上下文中配置的未解析占位符。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &amp;lt;beans&amp;gt;
    &amp;lt;ctx:property-placeholder location="application.properties"/&amp;gt;

    &amp;lt;bean class="beans.ServerComponent"&amp;gt;
      &amp;lt;property name="serverName" value="${server.name}}"/&amp;gt;
      &amp;lt;property name="port" value="${unknown.property}}"/&amp;gt; // 报告 "无法解析属性键"
    &amp;lt;/bean&amp;gt;
  &amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ContextComponentScanInconsistencyInspection" defaultSeverity="ERROR" displayName="基于 XML 的组件扫描中无效的筛选器定义" enabled="false" language="XML" pluginId="com.intellij.spring" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 XML 应用程序上下文 &lt;strong&gt;&amp;lt;component-scan&amp;gt;&lt;/strong&gt; 中不一致的 &lt;strong&gt;&amp;lt;filter&amp;gt;&lt;/strong&gt; 定义。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
  public class NonAnnotationTypeClass {}
  &amp;lt;beans&amp;gt;
    &amp;lt;ctx:component-scan base-package="com.my.company"&amp;gt;
      &amp;lt;ctx:exclude-filter expression="com.my.company.anno.NonAnnotationTypeClass" type="annotation"/&amp;gt;
    &amp;lt;/ctx:component-scan&amp;gt;
  &amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在此示例中，&lt;code&gt;NonAnnotationTypeClass&lt;/code&gt; 应为注解类型。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="UtilSchemaInspection" defaultSeverity="ERROR" displayName="XML 应用程序上下文中定义的配置不正确的 'util' 架构 Bean" enabled="false" language="XML" pluginId="com.intellij.spring" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告在 XML 应用程序上下文中定义的不正确&lt;a href="https://www.springframework.org/schema/util"&gt;架构 Bean&lt;/a&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
  &amp;lt;beans ... xmlns:util="https://www.springframework.org/schema/util"&amp;gt;
    &amp;lt;bean class="MyBean" id="myBean"/&amp;gt;
    &amp;lt;bean class="ErrTypeBean" id="errTypeBean"/&amp;gt;
    &amp;lt;util:list list-class="java.lang.String"/&amp;gt; // 报告 "类必须为 'java.util.List' 的继承者"
    &amp;lt;util:set value-type="MyBean"&amp;gt;
      &amp;lt;ref bean="fooBean"/&amp;gt;
      &amp;lt;ref bean="errTypeBean"/&amp;gt; // 报告 "无法添加到 'MyBean' 类型的集合中"
    &amp;lt;/util:set&amp;gt;
  &amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SpringBeanLookupMethodInspection" defaultSeverity="ERROR" displayName="不正确的 XML Bean 查找方法配置" enabled="false" language="XML" pluginId="com.intellij.spring" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 XML 应用程序上下文中 Bean 的不正确 &lt;strong&gt;&amp;lt;lookup-method&amp;gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public abstract class FooLookupBean {
    protected abstract FooBean createCommand();
    private FooBean createCommand() {...}
    protected static FooBean createCommandStatic() {...}
    protected abstract FooBean createWithArgs(String foo);
    protected abstract OtherBean createOtherBean();
  }

  &amp;lt;beans&amp;gt;
    &amp;lt;bean class="FooLookupBean" id="lookupTest"&amp;gt;
      &amp;lt;lookup-method bean="fooBean" name="createCommand"/&amp;gt;
      &amp;lt;!-- private --&amp;gt;
      &amp;lt;lookup-method bean="fooBean" name="createCommand"/&amp;gt;// "方法必须为 public 或 protected"
      &amp;lt;!-- static --&amp;gt;
      &amp;lt;lookup-method bean="fooBean" name="createCommandStatic"/&amp;gt; // 此处不允许使用 static 方法
      &amp;lt;!-- 有实参 --&amp;gt;
      &amp;lt;lookup-method bean="fooBean" name="createWithArgs"/&amp;gt;// 方法必须没有形参
      &amp;lt;!-- 不存在 --&amp;gt;
      &amp;lt;lookup-method bean="fooBean" name="unknown"/&amp;gt;  // 未知方法
      &amp;lt;!-- 不匹配 --&amp;gt;
      &amp;lt;lookup-method bean="fooBean" name="createOtherBean"/&amp;gt; // 查找方法返回类型与 'FooBean' Bean 类不匹配
    &amp;lt;/bean&amp;gt;

    &amp;lt;bean class="FooBean" id="fooBean"/&amp;gt;
    &amp;lt;bean class="OtherBean" id="otherBean"/&amp;gt;
  &amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SpringXmlModelInspection" defaultSeverity="ERROR" displayName="不正确的 Spring Core 基于 XML 的应用程序上下文" enabled="false" language="XML" pluginId="com.intellij.spring" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 &lt;a href="https://spring.io/projects/spring-framework"&gt;Spring Framework&lt;/a&gt; 基于 XML 的应用程序上下文的问题：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;未解析的 Bean 引用&lt;/li&gt;
  &lt;li&gt;缺少必需的标记或特性&lt;/li&gt;
  &lt;li&gt;属性类型不正确&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;enum&lt;/code&gt; 属性不一致&lt;/li&gt;
  &lt;li&gt;引用 Bean 的类型不正确&lt;/li&gt;
&lt;/ul&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SpringPublicFactoryMethodInspection" defaultSeverity="WARNING" displayName="在 &quot;factory-method&quot; 特性中引用的不正确的非 public 方法" enabled="false" language="XML" pluginId="com.intellij.spring" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告在 &lt;strong&gt;&amp;lt;bean&amp;gt;&lt;/strong&gt; 元素的 &lt;code&gt;factory-method&lt;/code&gt; 特性中引用的非 public 方法。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
public class MyFactory {
  private static FooBean createBean() {...}
  }
}

&lt;hr/&gt;

&amp;lt;beans&amp;gt;
  &amp;lt;bean class="MyFactory" factory-method="createBean"/&amp;gt;
  // 报告 "工厂方法 'createBean' 应为 public"
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SpringXmlAutowireExplicitlyInspection" defaultSeverity="WARNING" displayName="XML 应用程序上下文中不必要的自动装配的依赖项" enabled="false" language="XML" pluginId="com.intellij.spring" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 &lt;code&gt;&amp;lt;bean&amp;gt;&lt;/code&gt; 元素中的 &lt;code&gt;autowire&lt;/code&gt; 特性，并建议在可能的情况下显式注入 Bean 属性。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class MyComponent {
    public void setOtherBean(OtherBean bean){...}
  }

&lt;hr/&gt;

  &amp;lt;beans&amp;gt;
    &amp;lt;bean class="beans.OtherBean" id="bar"/&amp;gt;
    &amp;lt;bean autowire="byType" class="beans.MyComponent"/&amp;gt;
    // "不必要的自动装配的依赖项"
    // 建议 "将自动装配的依赖项设为显式"
  &amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;应用快速修复后：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
  &amp;lt;beans&amp;gt;
    &amp;lt;bean class="beans.OtherBean" id="bar"/&amp;gt;
    &amp;lt;bean class="beans.MyComponent" id="foo"&amp;gt;
      &amp;lt;property name="otherBean" ref="otherBean"/&amp;gt;
    &amp;lt;/bean&amp;gt;
  &amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SpringBeanInstantiationInspection" defaultSeverity="ERROR" displayName="无效的非抽象 Bean 实例化" enabled="false" language="XML" pluginId="com.intellij.spring" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告接口/ abstract 类 &lt;strong&gt;&amp;lt;bean&amp;gt;&lt;/strong&gt; 声明的实例化错误。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &amp;lt;beans&amp;gt;
    &amp;lt;bean class="java.util.List"/&amp;gt;
    // 报告 '非抽象 Bean 不允许接口'
  &amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;

</inspection><inspection shortName="DuplicatedBeanNamesInspection" defaultSeverity="WARNING" displayName="基于 XML 的应用程序上下文中重复的 Bean 名称" enabled="false" language="XML" pluginId="com.intellij.spring" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告在应用程序上下文中定义的重复 Bean 名称。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &amp;lt;beans profile="PROD"&amp;gt;
    &amp;lt;bean class="..." id="duplicatedName"/&amp;gt;  // 错误
    &amp;lt;bean class="..." name="foo_name, duplicatedName"/&amp;gt; // 'duplicatedName' 错误
    &amp;lt;bean class="..." id="toBeAliased"/&amp;gt;

    &amp;lt;alias alias="duplicatedName" name="toBeAliased"/&amp;gt; // 'duplicatedName' 错误
  &amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SpringXmlAutowiringInspection" defaultSeverity="ERROR" displayName="不正确的 XML Spring Bean 自动装配" enabled="false" language="XML" pluginId="com.intellij.spring" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告在 XML 应用程序上下文中配置的 Spring Bean 的不正确自动装配。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
public interface FooInterface {...}
@Component public class FooBean implements FooInterface {...}
@Component public class OtherBean implements FooInterface {...}

@Component
public class MyComponent {
	 public void setFooInterface(FooInterface foo) {...}
}

&lt;hr/&gt;

&amp;lt;beans&amp;gt;
	&amp;lt;bean class="beans.OtherBean" id="otherBean"/&amp;gt;
	&amp;lt;bean class="beans.FooBean" id="fooBean"/&amp;gt;

	&amp;lt;bean autowire="byType" class="beans.MyComponent" id="foo"/&amp;gt; // 报告 "无法自动装配。 有不止一种 'FooInterface' 类型的 Bean。
                                                               //          Beans: otherBean,fooBean. Properties: 'fooInterface' "
&amp;lt;/beans&amp;gt;
&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnparsedCustomBeanInspection" defaultSeverity="WARNING" displayName="未解析的自定义 Spring Bean" enabled="false" language="XML" pluginId="com.intellij.spring" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告尚未解析的未知 Spring Bean 类型，或者 Bean 是否对自定义命名空间使用了不受支持的标记。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="PostgreSQL" path=""><inspection shortName="PgSelectFromProcedureInspection" defaultSeverity="WARNING" displayName="Postgres: 从过程调用中 select" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告从函数执行 SELECT 或执行没有类型别名的 DBLINK（例如 &lt;code&gt; AS t1 (s VARCHAR) &lt;/code&gt;）的情况。
  &lt;p&gt;此要求不适用于标量函数。&lt;/p&gt;
&lt;p&gt;示例（PostgreSQL）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE FUNCTION produce_a_table() RETURNS RECORD AS $$
SELECT 1;
$$ LANGUAGE sql;
SELECT * FROM produce_a_table() AS s (c1 INT);
SELECT * FROM produce_a_table() AS s (c1);
SELECT * FROM DBLINK('dbname=mydb', 'SELECT proname, prosrc FROM pg_proc') AS t1;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;AS s (c1 INT)&lt;/code&gt; 具有类型别名，而 &lt;code&gt;AS s (c1)&lt;/code&gt; 和 &lt;code&gt;AS t1&lt;/code&gt; 没有。
  在这种情况下，将高亮显示 &lt;code&gt;produce_a_table()&lt;/code&gt; 和 &lt;code&gt;DBLINK()&lt;/code&gt; 的第二次调用。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="SQL Server" path=""><inspection shortName="MsOrderByInspection" defaultSeverity="ERROR" displayName="查询中的 ORDER BY" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在视图、内联函数、派生表、子查询和通用表表达式中使用 &lt;code&gt;ORDER BY&lt;/code&gt; 子句而不使用 &lt;code&gt;TOP&lt;/code&gt;、&lt;code&gt;OFFSET&lt;/code&gt; 或 &lt;code&gt;FOR XML&lt;/code&gt; 的用法。
&lt;p&gt;有关 &lt;code&gt;ORDER BY&lt;/code&gt; 用法的详细信息，请参阅 &lt;a
    href="https://docs.microsoft.com/en-us/sql/t-sql/queries/select-order-by-clause-transact-sql"&gt;docs.microsoft.com 上的 SELECT - ORDER BY 子句 (Transact-SQL)&lt;/a&gt; 页面。&lt;/p&gt;
&lt;p&gt;示例（Microsoft SQL Server）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE foo (a INT NOT NULL, b  INT NOT NULL);

SELECT *
FROM (SELECT a, b
FROM foo A
WHERE a &amp;lt; 89
ORDER BY b) ALIAS;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在子查询中，ORDER BY 将被高亮显示为错误。 您可以将 TOP、OFFSET 或 FOR XML 添加到子查询。
  或者，使用&lt;b&gt;删除元素&lt;/b&gt;快速修复来删除 ORDER BY 部分。&lt;/p&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT *
FROM (SELECT a, b
FROM foo A
WHERE a &amp;lt; 89) ALIAS;
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MsBuiltinInspection" defaultSeverity="WARNING" displayName="内置函数" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 ISNULL 函数中字符串实参的截断。

&lt;p&gt;ISNULL 语法是 &lt;code&gt;ISNULL(check_expression, replacement_value)&lt;/code&gt;。
&lt;/p&gt;

&lt;p&gt;根据 &lt;a href="https://docs.microsoft.com/en-us/sql/t-sql/functions/isnull-transact-sql" target="_blank"&gt;docs.microsoft.com 上的 ISNULL&lt;/a&gt;，如果 &lt;code&gt;replacement_value&lt;/code&gt; 比 &lt;code&gt;check_expression&lt;/code&gt; 长，&lt;code&gt;replacement_value&lt;/code&gt; 将被截断。
&lt;/p&gt;

&lt;p&gt;示例（Microsoft SQL 服务器）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DECLARE @name1 VARCHAR(2) = NULL;
DECLARE @name2 VARCHAR(10) = 'Example';
DECLARE @name3 VARCHAR(2) = 'Hi';

  -- `@name2` 是 VARCHAR(10) 并且将被截断
SELECT ISNULL(@name1, @name2);

  -- `@name3` 是 VARCHAR(2)（作为 `@name1`）并且不会被截断
SELECT ISNULL(@name1, @name3);&lt;/code&gt;&lt;/pre&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Java 11" path="Java/Java 语言级别迁移帮助"><inspection shortName="StringRepeatCanBeUsed" defaultSeverity="WARNING" displayName="可以使用 String.repeat()" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以替换为单一 &lt;code&gt;String.repeat()&lt;/code&gt; 方法的循环（自 Java 11 起提供）。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void append(StringBuilder sb, int count, Object obj) {
    for (int i = 0; i &amp;lt; count; i++) {
      sb.append(obj);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void append(StringBuilder sb, int count, Object obj) {
    sb.append(String.valueOf(obj).repeat(Math.max(0, count)));
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  默认情况下，如果不能静态地证明 &lt;code&gt;count&lt;/code&gt; 非负，则该检查可以使用 &lt;code&gt;Math.max(0, count)&lt;/code&gt; 来包装 &lt;code&gt;count&lt;/code&gt;。 这样做的目的是防止可能发生的语义更改，因为 &lt;code&gt;String.repeat()&lt;/code&gt; 拒绝负数。
  必要时，可使用&lt;b&gt;添加 Math.max(0, count) 以避免可能的语义变更&lt;/b&gt;选项禁用此行为。&lt;/p&gt;
  &lt;p&gt;同样，如果不知道要重复的字符串能否为 &lt;code&gt;null&lt;/code&gt;，可将其包装在 &lt;code&gt;String.valueOf&lt;/code&gt; 中，以防止可能发生的 &lt;code&gt;NullPointerException&lt;/code&gt;。
&lt;/p&gt;
&lt;p&gt;仅当项目或模块的语言级别为 11 或更高时，此检查才会报告。&lt;/p&gt;
&lt;p&gt;&lt;small&gt;2019.1 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReadWriteStringCanBeUsed" defaultSeverity="WARNING" displayName="可以使用 'Files.readString()' 或 'Files.writeString()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告使用 &lt;code&gt;java.nio.file.Files&lt;/code&gt; 将 &lt;code&gt;String&lt;/code&gt; 作为字节读取或写入的方法调用
此类调用可被替换为对 Java 11 中引入的 &lt;code&gt;Files.readString()&lt;/code&gt; 或 &lt;code&gt;Files.writeString()&lt;/code&gt; 方法的调用。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String s = "example";
  Files.write(Paths.get("out.txt"), s.getBytes(StandardCharsets.UTF_8), StandardOpenOption.WRITE);
  s = new String(Files.readAllBytes(Paths.get("in.txt")), StandardCharsets.ISO_8859_1);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String s = "example";
  Files.writeString(Paths.get("out.txt"), s, StandardOpenOption.WRITE);
  s = Files.readString(Paths.get("in.txt"), StandardCharsets.ISO_8859_1);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2018.3 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="资源管理" path="Java"><inspection shortName="IOResource" defaultSeverity="WARNING" displayName="I/O 资源已打开，但未安全关闭" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告未安全关闭的 I/O 资源。 此检查所检查的 I/O 资源包括 &lt;code&gt;java.io.InputStream&lt;/code&gt;、&lt;code&gt;java.io.OutputStream&lt;/code&gt;、&lt;code&gt;java.io.Reader&lt;/code&gt;、&lt;code&gt;java.io.Writer&lt;/code&gt;、&lt;code&gt;java.util.zip.ZipFile&lt;/code&gt;、&lt;code&gt;java.io.Closeable&lt;/code&gt; 和 &lt;code&gt;java.io.RandomAccessFile&lt;/code&gt;。
&lt;p&gt;
  不报告由其他 I/O 资源包装的 I/O 资源，因为包装资源将关闭被包装资源。
&lt;/p&gt;
&lt;p&gt;
  默认情况下，该检查假定资源可以由名称中带有 'close' 或 'cleanup' 的任何方法关闭。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void save() throws IOException {
    FileWriter writer = new FileWriter("filename.txt"); //警告
    writer.write("sample");
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用以下选项配置检查：
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;列出不需关闭并且此检查应当忽略的 I/O 资源类。&lt;/li&gt;
  &lt;li&gt;
    是否允许在 &lt;code&gt;try&lt;/code&gt; 块内打开 I/O 资源。
    这种样式不太合意，因为它比在 &lt;code&gt;try&lt;/code&gt; 块前面打开资源更冗长。
  &lt;/li&gt;
  &lt;li&gt;
    资源能否通过任何将资源作为实参传递的方法调用来关闭。
  &lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ChannelResource" defaultSeverity="WARNING" displayName="打开了 'Channel'，但未安全关闭" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告未安全关闭的 &lt;code&gt;Channel&lt;/code&gt; 资源，包括任何通过在文件或套接字资源上调用 &lt;code&gt;getChannel()&lt;/code&gt; 而创建的实例。
&lt;p&gt;
  默认情况下，该检查假定资源可以由名称中带有 'close' 或 'cleanup' 的任何方法关闭。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void send(Socket socket) throws IOException {
    SocketChannel channel = socket.getChannel(); //警告
    channel.write(ByteBuffer.wrap("message".getBytes()));
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用以下选项配置检查：
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    是否允许在 &lt;code&gt;try&lt;/code&gt; 块内打开 &lt;code&gt;Channel&lt;/code&gt; 资源。 这种样式不太合意，因为它比在 &lt;code&gt;try&lt;/code&gt; 块前面打开 &lt;code&gt;Channel&lt;/code&gt; 更复杂。
  &lt;/li&gt;
  &lt;li&gt;
    资源能否通过任何将资源作为实参传递的方法调用来关闭。
  &lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JDBCResource" defaultSeverity="WARNING" displayName="JDBC 资源已打开，但未安全关闭" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告未安全关闭的 JDBC 资源。 此检查报告的 JDBC 资源包括 &lt;code&gt;java.sql.Connection&lt;/code&gt;、&lt;code&gt;java.sql.Statement&lt;/code&gt;、&lt;code&gt;java.sql.PreparedStatement&lt;/code&gt;、&lt;code&gt;java.sql.CallableStatement&lt;/code&gt; 和 &lt;code&gt;java.sql.ResultSet&lt;/code&gt;。
&lt;p&gt;
  默认情况下，该检查假定资源可以由名称中带有 'close' 或 'cleanup' 的任何方法关闭。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  ResultSet findAllElements(Connection connection) throws SQLException {
    PreparedStatement statement = connection.prepareStatement("SELECT * FROM TABLE");//语句未关闭
    statement.execute();
    return statement.getResultSet();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用以下选项配置检查：
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    是否允许在 &lt;code&gt;try&lt;/code&gt; 块内打开 JDBC 资源。 这种样式不太合意，因为它比在 &lt;code&gt;try&lt;/code&gt; 块前面打开资源更冗长。
  &lt;/li&gt;
  &lt;li&gt;
    资源能否通过任何将资源作为实参传递的方法调用来关闭。
  &lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SocketResource" defaultSeverity="WARNING" displayName="套接字已打开，但未安全关闭" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告未安全关闭的套接字资源。 此检查报告的套接字资源包括 &lt;code&gt;java.net.Socket&lt;/code&gt;、&lt;code&gt;java.net.DatagramSocket&lt;/code&gt; 和 &lt;code&gt;java.net.ServerSocket&lt;/code&gt;。
&lt;p&gt;
  默认情况下，该检查假定资源可以由名称中带有 'close' 或 'cleanup' 的任何方法关闭。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  byte[] getMessage(ServerSocket socket) throws IOException {
    Socket client = socket.accept(); //套接字未关闭
    return client.getInputStream().readAllBytes();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用以下选项配置检查：
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    是否允许在 &lt;code&gt;try&lt;/code&gt; 块内打开套接字。
    这种样式不太合意，因为它比在 &lt;code&gt;try&lt;/code&gt; 块前面打开资源更冗长。
  &lt;/li&gt;
  &lt;li&gt;
    资源能否通过任何将资源作为实参传递的方法调用来关闭。
  &lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JNDIResource" defaultSeverity="WARNING" displayName="JNDI 资源已打开，但未安全关闭" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告未安全关闭的 JNDI 资源。 此检查报告的 JNDI 资源包括 &lt;code&gt;javax.naming.InitialContext&lt;/code&gt;和 &lt;code&gt;javax.naming.NamingEnumeration&lt;/code&gt;。
&lt;p&gt;
  默认情况下，该检查假定资源可以由名称中带有 'close' 或 'cleanup' 的任何方法关闭。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Object findObject(Properties properties, String name) throws NamingException {
    Context context = new InitialContext(properties); //上下文未关闭
    return context.lookup(name);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用以下选项配置检查：
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    是否允许在 &lt;code&gt;try&lt;/code&gt; 块内打开 JNDI 资源。
    这种样式不太合意，因为它比在 &lt;code&gt;try&lt;/code&gt; 块前面打开资源更冗长。
  &lt;/li&gt;
  &lt;li&gt;
    资源能否通过任何将资源作为实参传递的方法调用来关闭。
  &lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AutoCloseableResource" defaultSeverity="WARNING" displayName="在没有 'try-with-resources' 的情况下使用 AutoCloseable" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告未在 try-with-resources 语句中使用的 &lt;code&gt;AutoCloseable&lt;/code&gt; 实例，也称 &lt;i&gt;自动资源管理&lt;/i&gt;。
&lt;p&gt;
  这意味着还报告在 try-with-resources 可用前使用的“在 &lt;code&gt;try&lt;/code&gt; 前面/中打开资源，在 &lt;code&gt;finally&lt;/code&gt; 中关闭资源”的样式。
  在 Java 7 及更高版本中开发时，此检查意在取代所有&lt;i&gt;已打开但未安全关闭&lt;/i&gt;的检查。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  private static void foo() throws IOException {
    InputStream profile = Thread.currentThread().getContextClassLoader().getResourceAsStream("/someFile");
    System.out.println(profile.read());
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用以下选项配置检查：
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    列出不需关闭并且此检查应当忽略的 &lt;code&gt;AutoCloseable&lt;/code&gt; 的子类。
    &lt;br/&gt;
    &lt;b&gt;注意&lt;/b&gt;：即便列出将忽略 &lt;code&gt;java.util.stream.Stream&lt;/code&gt;，该检查仍将报告从 &lt;code&gt;java.nio.file.Files&lt;/code&gt; 方法 &lt;code&gt;lines()&lt;/code&gt;、&lt;code&gt;walk()&lt;/code&gt;、&lt;code&gt;list()&lt;/code&gt; 以及 &lt;code&gt;find()&lt;/code&gt; 返回的流。
    这些流包含需要关闭的关联 I/O 资源。
  &lt;/li&gt;
  &lt;li&gt;
    列出在调用时应被忽略的返回 &lt;code&gt;AutoCloseable&lt;/code&gt; 的方法。
  &lt;/li&gt;
  &lt;li&gt;
    如果为方法调用的结果时是否忽略 &lt;code&gt;AutoCloseable&lt;/code&gt;。
    启用此选项时，工厂方法的结果也将被忽略。
  &lt;/li&gt;
  &lt;li&gt;
    当 &lt;code&gt;AutoCloseable&lt;/code&gt; 实例作为方法调用实参传递时，该检查是否应报告。
    如果启用此选项，该检查将假定所调用方法中的资源已关闭。
    不会忽略名称中含有 'close' 的 &lt;code&gt;finally&lt;/code&gt; 块和 &lt;code&gt;AutoCloseable&lt;/code&gt; 实参中的方法调用。
  &lt;/li&gt;
  &lt;li&gt;
    是否忽略对资源类构造函数的方法引用。
  &lt;/li&gt;
  &lt;li&gt;
    是否忽略返回资源且名称以 'get' 开头的方法。
    这可能会减少误报，因为大多数 getter 不转移资源的所有权，并且其调用点不负责关闭资源。
  &lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DriverManagerGetConnection" defaultSeverity="WARNING" displayName="使用 'DriverManager' 获取 JDBC 连接" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告任何使用 &lt;code&gt;java.sql.DriverManager&lt;/code&gt; 获取 JDBC 连接的情况。 
&lt;p&gt;
  &lt;code&gt;java.sql.DriverManager&lt;/code&gt; 已被 &lt;code&gt;javax.sql.Datasource&lt;/code&gt; 取代，后者允许连接池和其他优化。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  Connection conn = DriverManager.getConnection(url, username, password);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="HibernateResource" defaultSeverity="WARNING" displayName="Hibernate 资源已打开，但未安全关闭" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
如果返回的 &lt;code&gt;org.hibernate.Session&lt;/code&gt; 资源没有被安全关闭，报告对 &lt;code&gt;openSession()&lt;/code&gt; 方法的调用。
&lt;p&gt;
  默认情况下，该检查假定资源可以由名称中带有 'close' 或 'cleanup' 的任何方法关闭。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void doHibernateQuery(SessionFactory factory) {
    Session session = factory.openSession(); //警告
    session.createQuery("...");
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用以下选项配置检查：
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    是否允许在 &lt;code&gt;try&lt;/code&gt; 块内打开 &lt;code&gt;org.hibernate.Session&lt;/code&gt; 资源。 这种样式不太合意，因为它比在 &lt;code&gt;try&lt;/code&gt; 块前面打开资源更冗长。
  &lt;/li&gt;
  &lt;li&gt;
    资源能否通过任何将资源作为实参传递的方法调用来关闭。
  &lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="DOM 问题" path="JavaScript and TypeScript"><inspection shortName="DocumentWriteJS" defaultSeverity="WARNING" displayName="调用 'document.write()'" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对 &lt;code&gt;document.write()&lt;/code&gt; 或 &lt;code&gt;document.writeln()&lt;/code&gt; 的方法调用。
在采用显式 DOM 调用（例如 &lt;code&gt;getElementByID()&lt;/code&gt; 
和 &lt;code&gt;createElement()&lt;/code&gt;）时,
此类调用的大多数用法执行效果更好。  此外，&lt;code&gt;write()&lt;/code&gt; 和 &lt;code&gt;writeln()&lt;/code&gt; 调用不适用于 XML 
DOM，包括用于 XHTML 的 DOM（如果以 XML 格式查看）。  这会导致难以指出错误。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="XHTMLIncompatabilitiesJS" defaultSeverity="WARNING" displayName="不兼容的 XHTML 用法" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可能会导致 XHTML 文档出现问题的
常见 JavaScript DOM 模式。 特别是，根据文档是作为 XML 还是 HTML 加载，
所检测到的模式的行为将完全不同。
这可能导致难以捉摸的错误，即脚本行为依赖于文档的 MIME 类型而不是依赖于其内容。
检测到的模式包括
&lt;b&gt;document.body&lt;/b&gt;、
&lt;b&gt;document.images&lt;/b&gt;、
&lt;b&gt;document.applets&lt;/b&gt;、
&lt;b&gt;document.links&lt;/b&gt;、
&lt;b&gt;document.forms&lt;/b&gt; 和
&lt;b&gt;document.anchors&lt;/b&gt;。
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="PlatformDetectionJS" defaultSeverity="WARNING" displayName="平台检测不准确" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告用于检测从中运行脚本的浏览器或
操作系统的通用 JavaScript 模式。 除了指出不可移植的结构外，这些平台检测模式通常不完整并且容易被愚弄。 在大多数情况下，检测单个环境的功能
比尝试检测整个平台更可取。
&lt;p&gt;检测到的模式包括： &lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;document.all&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;document.layers&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;navigator.userAgent&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;navigator.oscpu&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;navigator.appName&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;navigator.appCodeName&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;navigator.platform&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="InnerHTMLJS" defaultSeverity="WARNING" displayName="使用 'innerHTML' 属性" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告使用 &lt;code&gt;innerHTML&lt;/code&gt;  属性以文本形式对 DOM 节点的 JavaScript 访问。
在采用显式 DOM 调用（例如 &lt;code&gt;getElementByID()&lt;/code&gt;
和 &lt;code&gt;createElement()&lt;/code&gt;）时,
&lt;code&gt;innerHTML&lt;/code&gt; 的大多数用法执行效果更好。  此外，&lt;code&gt;innerHTML&lt;/code&gt; 不适用于 XML 
DOM，包括用于 XHTML 的 DOM（如果以 XML 格式查看）。  这可能会导致
难以诊断错误。
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Android Lint: Testing" path=""><inspection shortName="AndroidLintIgnoreWithoutReason" defaultSeverity="WARNING" displayName="@Ignore without Reason" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;@Ignore without Reason&lt;br&gt;&lt;br&gt;Ignoring a test without a reason makes it difficult to figure out the problem later. Please define an explicit reason why it is ignored, and when it can be resolved.&lt;br&gt;&lt;br&gt;Issue id: IgnoreWithoutReason&lt;br&gt;&lt;br&gt;Available options:&lt;br/&gt;
&lt;br/&gt;
&lt;b&gt;allow-comments&lt;/b&gt; (default is true):&lt;br/&gt;
Whether to allow a comment next to the @Ignore tag to be considered providing a reason.&lt;br/&gt;
&lt;br/&gt;
Normally you have to specify an annotation argument to the &lt;code&gt;@Ignore&lt;/code&gt; annotation, but with this option you can configure whether it should also allow ignore reasons to specified by a comment adjacent to the ignore tag.&lt;br/&gt;
&lt;br/&gt;
To configure this option, use a &lt;code&gt;lint.xml&lt;/code&gt; file with an &amp;lt;option&gt; like this:&lt;br/&gt;

&lt;pre&gt;
&amp;lt;lint&gt;
    &amp;lt;issue id="IgnoreWithoutReason"&gt;
        &amp;lt;option name="allow-comments" value="true" /&gt;
    &amp;lt;/issue&gt;
&amp;lt;/lint&gt;
&lt;/pre&gt;
&lt;/body&gt;&lt;/html&gt;</inspection></group><group name="MySQL" path=""><inspection shortName="MysqlLoadDataPathInspection" defaultSeverity="WARNING" displayName="LOAD 语句路径" enabled="false" language="MySQL based" pluginId="com.intellij.database" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 LOAD 语句中以波浪符号开头的路径。
&lt;p&gt;示例（MySQL）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE table_name (id int);
LOAD DATA LOCAL INFILE '~/Documents/some_file.txt'
INTO TABLE table_name FIELDS TERMINATED BY ',' LINES TERMINATED BY '\n'
IGNORE 1 LINES;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用文件的完整路径代替波浪符号。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MysqlParsingInspection" defaultSeverity="WARNING" displayName="8.0 以前的版本中不受支持的语法" enabled="false" language="MySQL based" pluginId="com.intellij.database" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告查询中 UNION 的无效用法。
&lt;p&gt;该检查适用于早于 8.0 的 MySQL 版本。&lt;/p&gt;
&lt;p&gt;示例（MySQL）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
SELECT * FROM (SELECT 1 UNION (SELECT 1 UNION SELECT 2)) a;
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="可能的错误" path="Java"><inspection shortName="CovariantEquals" defaultSeverity="WARNING" displayName="协变 'equals()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
如果包含类没有将 &lt;code&gt;java.lang.Object&lt;/code&gt; 作为其实参类型的其他 &lt;code&gt;equals()&lt;/code&gt; 重载，则报告采用 &lt;code&gt;java.lang.Object&lt;/code&gt; 以外的实参类型的 &lt;code&gt;equals()&lt;/code&gt; 方法。
&lt;p&gt;
  &lt;code&gt;equals()&lt;/code&gt; 的协变版本不会重写 &lt;code&gt;Object.equals(Object)&lt;/code&gt; 方法。 它可能会在运行时导致意外行为。 例如，如果该类用于构造一个标准集合类，该集合类预期会重写 &lt;code&gt;Object.equals(Object)&lt;/code&gt; 方法。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
      public boolean equals(Foo foo) {  // 警告
          return false;
      }
  }
  class Bar {
      public boolean equals(Bar bar) {  // 此处无警告
          return false;
      }
      @Override
      public boolean equals(Object obj) {
          return false;
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SuspiciousToArrayCall" defaultSeverity="WARNING" displayName="可疑的 'Collection.toArray()' 调用" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对 &lt;code&gt;Collection.toArray()&lt;/code&gt; 的可疑调用。
&lt;p&gt;以下类型的调用视为可疑：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    数组实参的类型与结果被转换成的数组类型不相同。
  &lt;/li&gt;
  &lt;li&gt;
    数组实参的类型与集合声明中的类型形参不匹配。
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
void m1(List list) {
  Number[] ns = (Number[]) list.toArray(new String[0]);
}

void m2(List&amp;lt;Number&amp;gt; list) {
  Number[] ns = list.toArray(new String[0]);
}
&lt;/code&gt;&lt;/pre&gt;


&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="IterableUsedAsVararg" defaultSeverity="WARNING" displayName="可迭代对象用作 vararg" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 vararg 方法调用中 &lt;code&gt;Collection&lt;/code&gt; 或 &lt;code&gt;Iterable&lt;/code&gt; 的可疑用法。
&lt;p&gt;例如，在以下方法中：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &amp;lt;T&amp;gt; boolean contains(T needle, T... haystack) {...}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;像下面这样的调用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if(contains("item", listOfStrings)) {...}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;看起来很可疑，因为列表将被包装成一个元素数组。
  此类代码可以被成功编译并且很可能会无异常地运行，但它可能被错误地使用。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2019.2 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PrimitiveArrayArgumentToVariableArgMethod" defaultSeverity="WARNING" displayName="引起混淆的 vararg 方法基元数组实参" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对可变 arity 方法的任何调用，其中该调用在 arity 形参位置有基元数组（例如 &lt;code&gt;System.out.printf("%s", new int[]{1, 2, 3})&lt;/code&gt;）。
此类基元数组实参可能令人困惑，因为它将被包装为单一元素数组，而不是像预期的那样将每个单独的元素装箱。
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String.format("%s", new int[]{1, 2, 3});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String.format("%s", (Object) new int[]{1, 2, 3});
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="EqualsWhichDoesntCheckParameterClass" defaultSeverity="WARNING" displayName="不检查形参的类的 'equals()' 方法" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告不检查其形参类型的 &lt;code&gt;equals()&lt;/code&gt; 方法。
&lt;p&gt;无法检查 &lt;code&gt;equals()&lt;/code&gt; 方法中形参的类型时，如果在无类型集合中使用该对象，可能会导致潜在错误。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class MyClass {
    int x;

    @Override
    public boolean equals(Object obj) {
      // 如果 obj 不为 MyClass，equals 方法应返回 false
      return ((MyClass)obj).x == x;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SuspiciousIntegerDivAssignment" defaultSeverity="WARNING" displayName="可疑的整数除法赋值" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告其右侧是不应截断为整数的除法的赋值。
&lt;p&gt;虽然偶尔是有意为之，但此结构通常表明有错误。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int x = 18;
  x *= 3/2; // 不会因为整数除法的结果而改变 x
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
此代码应替换为：
&lt;pre&gt;&lt;code&gt;
  int x = 18;
  x *= 3.0/2;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  在检查选项中，可以禁用对可疑但可能正确的除法的警告，例如不能静态计算被除数时。
&lt;pre&gt;&lt;code&gt;
  void calc(int d) {
     int x = 18;
     x *= d/2;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;
  &lt;small&gt;2019.2 最新变化&lt;/small&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ObjectEquality" defaultSeverity="INFORMATION" displayName="使用 '==' 而不是 'equals()' 进行对象比较" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告使用 &lt;code&gt;==&lt;/code&gt; 或 &lt;code&gt;!=&lt;/code&gt; 而不是 &lt;code&gt;equals()&lt;/code&gt; 来测试 &lt;code&gt;Object&lt;/code&gt; 相等性的代码。
&lt;p&gt;使用 &lt;code&gt;==&lt;/code&gt; 或 &lt;code&gt;!=&lt;/code&gt; 比较对象通常是错误的，因为它不是通过相等性而是通过同一性来比较对象。
  不报告与 &lt;code&gt;null&lt;/code&gt; 的比较。
  数组、&lt;code&gt;String&lt;/code&gt; 和 &lt;code&gt;Number&lt;/code&gt; 比较由单独的检查报告。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  &lt;b&gt;if&lt;/b&gt; (list1 == list2) {
    &lt;b&gt;return&lt;/b&gt;;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  &lt;b&gt;if&lt;/b&gt; (Object.equals(list1, list2)) {
    &lt;b&gt;return&lt;/b&gt;;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;p&gt;使用检查设置为此检查配置异常。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="InnerClassReferencedViaSubclass" defaultSeverity="WARNING" displayName="通过子类引用的内部类" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对其中的调用由声明类的子类而不是声明类本身限定的内部类和嵌套类的访问。
&lt;p&gt;
  Java 允许此类限定，但是此类访问可能表明继承和重写之间存在难以捉摸的混淆。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Super {
    static class Inner {}
  }

  class Sub extends Super {
    void test() {
      Sub.Inner s = new Sub.Inner(); // 'Inner' 类在 'Super' 类中声明，但通过 'Sub' 类引用
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Super {
    static class Inner {}
  }

  class Sub extends Super {
    void test() {
      Super.Inner s = new Super.Inner();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StringConcatenationMissingWhitespace" defaultSeverity="WARNING" displayName="字符串串联中可能缺少空格" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告缺少空格的字符串串联，即左侧以 Unicode 字母或数字结束，右侧以 Unicode 字母或数字开始。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String sql = "SELECT column" +
               "FROM table";
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用&lt;b&gt;忽略具有变量字符串的串联&lt;/b&gt;选项，只在串联的左右两侧都为文字时报告。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnusedAssignment" defaultSeverity="WARNING" displayName="未使用的赋值" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告赋值后未使用的赋值。
如果不使用，最好移除该赋值，以缩短代码并避免冗余分配。
&lt;p&gt;报告的情况如下：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;该变量在赋值后从未被读取。&lt;/li&gt;
  &lt;li&gt;该变量在被读取前始终被新值重写。&lt;/li&gt;
  &lt;li&gt;变量初始值设定项冗余（出于以上两种原因之一）。&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;配置检查：&lt;/p&gt;
&lt;p&gt;
使用&lt;b&gt;报告冗余初始值设定项&lt;/b&gt;选项可以报告冗余的初始值设定项：
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int getI() {
    int i = 0; // 冗余初始化
    i = 2;
    return i;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
使用&lt;b&gt;在可以替换为(i + 1)时报告 ++i&lt;/b&gt; 选项，报告 &lt;code&gt;++i&lt;/code&gt; 表达式可以替换为 &lt;code&gt;i + 1&lt;/code&gt; 的情况：
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int preInc(int i) {
    int res = i;
    return ++res;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
使用&lt;b&gt;在变更后的值后续未使用时报告 i++&lt;/b&gt; 选项可以报告后续不使用 &lt;code&gt;i++&lt;/code&gt; 表达式的结果的情况：
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int postInc(int i) {
    int res = i;
    return res++;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="HashCodeUsesNonFinalVariable" defaultSeverity="WARNING" displayName="'hashCode()' 中引用了非最终字段" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告访问非 &lt;code&gt;final&lt;/code&gt; 变量的 &lt;code&gt;hashCode()&lt;/code&gt; 的实现。
&lt;p&gt;
  此类访问可能导致 &lt;code&gt;hashCode()&lt;/code&gt; 在该对象生命周期的不同时刻返回不同的值，进而可能在使用标准集合类时导致问题。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Drink {
    String name;
    Drink(String name) { this.name = name; }
    @Override public int hashCode() {
      return Objects.hash(name); //警告
    }
  }
  ...
    Drink coffee = new Drink("Coffee");
    priceMap.put(coffee, 10.0);
    coffee.name = "Tea";
    double coffeePrice = priceMap.get(coffee); //找不到
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;建议通过快速修复将该字段设为 final：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Drink {
    final String name;
    ...
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="EndlessStream" defaultSeverity="WARNING" displayName="非短路操作消耗无限流" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告消耗无限流的非短路运算。 此类运算只能通过抛出异常来完成。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Stream.iterate(0, i -&gt; i + 1).collect(Collectors.toList())
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="OverflowingLoopIndex" defaultSeverity="WARNING" displayName="循环执行零次或无限次" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告没有索引溢出就无法完成的循环或根本不循环的循环。
之所以发生这种情况，通常是因为更新操作中有错误。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void foo(int s) {
    for (int i = s; i &gt; 12; i++) { // i-- 应在此处
      System.out.println(i);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2019.1 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StringConcatenationInMessageFormatCall" defaultSeverity="WARNING" displayName="字符串串联作为 'MessageFormat.format()' 调用的实参" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告用作对 &lt;code&gt;MessageFormat.format()&lt;/code&gt; 的调用实参的非常量字符串串联。
&lt;p&gt;
  虽然偶尔是有意为之，但这通常是误用格式化方法，串联的字符串中包含 &lt;code&gt;{&lt;/code&gt; 等特殊字符时，甚至可能导致异常。
&lt;/p&gt;
&lt;p&gt;
  此外，有时这可能是在本应键入 &lt;code&gt;,&lt;/code&gt; 时键入了 &lt;code&gt;+&lt;/code&gt; 而错误串联字符串格式实参所致。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String formatGreeting(String userName, int balance) {
    return MessageFormat.format("Hello, " + userName + "! Your balance is {0}.", balance);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  这里的 &lt;code&gt;userName&lt;/code&gt; 解读为格式字符串的一部分，这可能导致 &lt;code&gt;IllegalArgumentException&lt;/code&gt;（例如，如果 &lt;code&gt;userName&lt;/code&gt; 为 &lt;code&gt;"{"&lt;/code&gt;）。
  此调用或许应当替换为 &lt;code&gt;MessageFormat.format("Hello, {0}! Your balance is {1}.", userName, balance)&lt;/code&gt;。
&lt;/p&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReplaceAllDot" defaultSeverity="WARNING" displayName="可疑的正则表达式实参" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对其中第一个实参为单一正则表达式元字符实参的 &lt;code&gt;String.replaceAll()&lt;/code&gt; 或 &lt;code&gt;String.split()&lt;/code&gt; 的调用。
&lt;p&gt;
  正则表达式元字符为 &lt;code&gt;.$|()[{^?*+\&lt;/code&gt; 之一。 它们在正则表达式中有特殊的含义。
  例如，调用 &lt;code&gt;"ab.cd".replaceAll(".", "-")&lt;/code&gt; 将生成 &lt;code&gt;"-----"&lt;/code&gt;，因为点匹配任意字符。
  很可能本意是转义变体 &lt;code&gt;"\\."&lt;/code&gt;。
&lt;/p&gt;
&lt;p&gt;
  还报告了将 &lt;code&gt;File.separator&lt;/code&gt; 用作正则表达式的情况。 &lt;code&gt;File.separator&lt;/code&gt; 具有平台特定的值。 它在 Linux 和 Mac 上等于 &lt;code&gt;/&lt;/code&gt;，而在 Windows 上等于 &lt;code&gt;\&lt;/code&gt;，这不是一个有效的正则表达式，因此这样的代码无法移植。
&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  s.replaceAll(".", "-");
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  s.replaceAll("\\.", "-");
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StringEquality" defaultSeverity="WARNING" displayName="使用 '==' 而不是 'equals()' 进行字符串比较" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告使用 &lt;b&gt;==&lt;/b&gt; 或 &lt;b&gt;!=&lt;/b&gt; 比较字符串的代码。
&lt;p&gt;
  这些运算符确定引用相等，而不是比较内容。
  在大多数情况下，应使用 &lt;code&gt;equals()&lt;/code&gt; 对字符串进行比较，当字符串为不同的对象时，会逐字符进行比较。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void foo(String s, String t) {
    final boolean b = t == s;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果已知 &lt;code&gt;t&lt;/code&gt; 为非 null 值，则可以安全地应用“不安全”的快速修复，并获得类似于以下的结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void foo(String s, String t) {
    final boolean b = t.equals(s);
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ImplicitArrayToString" defaultSeverity="WARNING" displayName="调用数组上的 'toString()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;String&lt;/code&gt; 连接中使用的数组，或作为形参传递给 &lt;code&gt;java.io.PrintStream&lt;/code&gt; 方法的数组，如 &lt;code&gt;System.out.println()&lt;/code&gt;。
&lt;p&gt;
  通常使用数组的内容，而不是使用数组对象本身。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void print(Object[] objects) {
    System.out.println(objects);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void print(Object[] objects) {
    System.out.println(Arrays.toString(objects));
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SuspiciousArrayCast" defaultSeverity="WARNING" displayName="可疑的数组转换" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可疑的数组转换。
当数组转换为更具体的数组类型时，数组转换被视为可疑。 虽然此类转换在编译时是合法的，但在运行时可能会因 &lt;code&gt;ClassCastException&lt;/code&gt; 而失败。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Number[] numbers = new Number[]{1L, 2L, 4L};
  Long[] longs = (Long[])numbers;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ArrayEquality" defaultSeverity="WARNING" displayName="使用 '==' 而不是 'Arrays.equals()' 进行数组比较" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告用于测试数组相等性的运算符 &lt;code&gt;==&lt;/code&gt; 和 &lt;code&gt;!=&lt;/code&gt;。
在大多数情况下，如果原本就要测试数组内容的相等性，可以通过 &lt;code&gt;java.util.Arrays.equals()&lt;/code&gt; 方法来完成。
&lt;p&gt;
  建议通过快速修复将 &lt;code&gt;==&lt;/code&gt; 替换为 &lt;code&gt;java.util.Arrays.equals()&lt;/code&gt;。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void foo(Object[] x, Object[] y) {
    boolean comparison = x == y;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void foo(Object[] x, Object[] y) {
    boolean comparison = Arrays.equals(x, y);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ArrayEquals" defaultSeverity="WARNING" displayName="在数组上调用了 'equals()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以比较两个数组的 &lt;code&gt;equals()&lt;/code&gt; 调用。
&lt;p&gt;对数组调用 &lt;code&gt;equals()&lt;/code&gt; 可以比较同一性，相当于使用 &lt;code&gt;==&lt;/code&gt;。
  使用 &lt;code&gt;Arrays.equals()&lt;/code&gt; 比较两个数组的内容，或使用 &lt;code&gt;Arrays.deepEquals()&lt;/code&gt; 比较多维数组的内容。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void sample(int[] first, int[] second){
    if (first.equals(second)) return;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void sample(int[] first, int[] second){
    if (Arrays.equals(first, second)) return;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SuspiciousMethodCalls" defaultSeverity="WARNING" displayName="可疑的集合方法调用" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告实际实参类型与集合的元素类型不一致的形参化集合的方法调用。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  List&amp;lt;Integer&amp;gt; list = getListOfElements();
  list.remove(""); //remove 被高亮显示
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  在检查设置中，可以禁用对可能正确的代码发出警告，如下所示：
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public boolean accept(Map&amp;lt;Integer, String&amp;gt; map, Object key) {
    return map.containsKey(key);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="WrongPackageStatement" defaultSeverity="ERROR" displayName="错误的 package 语句" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
检测与项目目录结构不对应的 &lt;code&gt;package&lt;/code&gt; 语句。
此外，如果不包含 &lt;code&gt;package&lt;/code&gt; 语句的类不是直接位于源根目录中，则报告这种类。
&lt;p&gt;虽然 Java 语言没有严格规定，但最好将软件包 &lt;code&gt;com.example.myapp&lt;/code&gt; 中的类保存在源根下的 &lt;code&gt;com/example/myapp&lt;/code&gt; 目录中。 如果不这样做，可能会导致代码读取器混淆，某些工具也无法正确工作。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AssertWithSideEffects" defaultSeverity="WARNING" displayName="具有副作用的 'assert' 语句" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">  &lt;html&gt;
&lt;body&gt;
报告导致副作用的 &lt;code&gt;assert&lt;/code&gt; 语句。
&lt;p&gt;
  由于断言可能关闭，无法保证这些副作用，这可能导致难以捉摸的错误。 此检查检测到的不受欢迎的常见副作用是变量和字段修改。 涉及到方法调用时，将对它们进行一级深入分析。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  assert i++ &amp;lt; 10;
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="NullArgumentToVariableArgMethod" defaultSeverity="WARNING" displayName="引起混淆的 vararg 方法实参" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对可变 arity 方法的调用，该调用在 vararg 形参位置有一个实参，这个实参要么是 &lt;code&gt;null&lt;/code&gt;，要么是 vararg 形参子类型的数组。
此类实参可能令人困惑，因为不清楚需要 vararg 调用还是非 vararg 调用。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String[] ss = new String[]{"foo", "bar"};
  System.out.printf("%s", ss);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在本例中，不会打印整个数组，而是只打印数组的第一个元素。&lt;/p&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CollectionAddedToSelf" defaultSeverity="WARNING" displayName="集合已添加到自身" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对 &lt;code&gt;java.util.Collection&lt;/code&gt;
或 &lt;code&gt;java.util.Map&lt;/code&gt; 的方法调用的实参是集合或映射本身的情况。
由于复制粘贴，原始类型的代码中可能会出现此类情况。

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  ArrayList list = new ArrayList&amp;lt;&amp;gt;();
  list.add(list); // 此处为警告
  return list.hashCode(); // 抛出 StackOverflowError
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="InstantiationOfUtilityClass" defaultSeverity="WARNING" displayName="实用程序类的实例化" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告使用 &lt;code&gt;new&lt;/code&gt; 关键字的实用程序类的实例化。
&lt;p&gt;
  在实用程序类中，所有字段和方法均为 &lt;code&gt;static&lt;/code&gt;。
  这种类的实例化很可能不必要，并且表明存在错误。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class MyUtils {
    public static double cube(double x) {
      return x * x * x;
    }
  }
  class Main {
    public static void main(String[] args) {
      // 实用类的实例化
      MyUtils utils = new MyUtils();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  为防止实用程序类被实例化，建议使用 &lt;code&gt;private&lt;/code&gt; 构造函数。
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ResultOfObjectAllocationIgnored" defaultSeverity="WARNING" displayName="对象分配的结果已忽略" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告其中分配的对象被忽略，并且既不分配给变量，也不以其他方式使用的对象分配。
&lt;p&gt;
  此类分配表达式虽然在 Java 中合法，但通常要么是无意为之，要么表明存在非常奇怪的对象初始化策略。
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用这些选项可列出此检查应忽略其分配的类。
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="EqualsAndHashcode" defaultSeverity="WARNING" displayName="'equals()' 和 'hashCode()' 未配对" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告重写 &lt;code&gt;equals()&lt;/code&gt; 方法但不重写 &lt;code&gt;hashCode()&lt;/code&gt; 方法的类，反之亦然。将类添加到 &lt;code&gt;Collection&lt;/code&gt; 或 &lt;code&gt;HashMap&lt;/code&gt; 时，可能会导致问题。
&lt;p&gt;该快速修复会为不存在的方法生成默认实现。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
class StringHolder {
  String s;

  @Override public int hashCode() {
    return s != null ? s.hashCode() : 0;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
class StringHolder {
  String s;

  @Override public int hashCode() {
    return s != null ? s.hashCode() : 0;
  }

  @Override
  public boolean equals(Object o) {
    if (this == o) return true;
    if (!(o instanceof StringHolder)) return false;

    StringHolder holder = (StringHolder)o;

    if (s != null ? !s.equals(holder.s) : holder.s != null) return false;

    return true;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="EqualsWithItself" defaultSeverity="WARNING" displayName="在自身上调用了 'equals()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对象与自身进行相等比较的 &lt;code&gt;equals()&lt;/code&gt; 或 &lt;code&gt;compareto()&lt;/code&gt; 调用。
&lt;p&gt;根据方法约定，对于 &lt;code&gt;equals()&lt;/code&gt;，这些运算始终返回 &lt;code&gt;true&lt;/code&gt;；对于 &lt;code&gt;compareTo()&lt;/code&gt;，始终返回 &lt;code&gt;0&lt;/code&gt;。 该检查还可以检查对 &lt;code&gt;Objects.equals()&lt;/code&gt;、&lt;code&gt;Objects.deepEquals()&lt;/code&gt;、&lt;code&gt;Arrays.equals()&lt;/code&gt;、&lt;code&gt;Comparator.compare&lt;/code&gt; 等的调用。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    boolean foo(Object o) {
        return o.equals(o); // 警告
    }

    boolean bar(String[] ss) {
        return Arrays.equals(ss, ss); // 警告
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="OptionalGetWithoutIsPresent" defaultSeverity="WARNING" displayName="在不进行 isPresent() 检查的情况下调用 Optional.get()" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对 &lt;code&gt;Optional&lt;/code&gt; 上的 &lt;code&gt;get()&lt;/code&gt; 的调用而不检查它是否有值。
&lt;p&gt;在空 &lt;code&gt;Optional&lt;/code&gt; 实例上调用 &lt;code&gt;Optional.get()&lt;/code&gt; 将抛出异常。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;void&lt;/b&gt; x(List&amp;lt;Integer&gt; list) {
    &lt;b&gt;final&lt;/b&gt; Optional&amp;lt;Integer&gt; optional =
      list.stream().filter(x -&gt; x &gt; 10).findFirst();
    &lt;b&gt;final&lt;/b&gt; Integer result = optional.get(); // 此处有问题
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="EqualsOnSuspiciousObject" defaultSeverity="WARNING" displayName="在 'StringBuilder'上调用了 'equals()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;StringBuilder&lt;/code&gt; 或 &lt;code&gt;StringBuffer&lt;/code&gt; 实例上的 &lt;code&gt;equals()&lt;/code&gt; 调用。
&lt;p&gt;&lt;code&gt;equals()&lt;/code&gt; 方法在这些类中没有被重写，因此即使两个对象的内容相同，它也可能返回 &lt;code&gt;false&lt;/code&gt;。
如果您打算使用引用相等，我们建议您使用 &lt;code&gt;==&lt;/code&gt; 以避免混淆。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public void test(StringBuilder sb1, StringBuilder sb2) {
    boolean result = sb1.equals(sb2); // 可疑
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2017.2 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SuspiciousIndentAfterControlStatement" defaultSeverity="WARNING" displayName="没有大括号的控制语句后存在可疑缩进" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告不带大括号控制语句后面的语句的可疑缩进。
&lt;p&gt;
  进行此类缩进时，语句看似在控制语句内部，其实它将在控制语句后无条件地执行。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Bar {
      void foo(int i) {
          if (i == 0)
              System.out.println("foo");
              System.out.println("bar"); // 警告
          if (i == 1);
              System.out.println("great"); // 警告
          if (i == 42)
              System.out.println("answer");
                  System.out.println("question"); // 警告
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SuspiciousDateFormat" defaultSeverity="WARNING" displayName="可疑的日期格式模式" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可能错误使用的日期格式模式。
&lt;p&gt;报告的模式如下：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;大写的“Y”，除非“w”出现在附近。 它代表“周年”，几乎总是与正常的“年份”（小写的 "y" 模式）相同，但可能指向 12 月结束后的下一年。&lt;/li&gt;
  &lt;li&gt;靠近 "H"、"K"、"h" 或 "k"（小时）的大写 "M"（月份）。 可能本意是使用小写的 "m"（分钟）。&lt;/li&gt;
  &lt;li&gt;靠近 "y"（年份）或 "d"（一月中的某天）的小写 "m"（分钟）。 可能本意是使用大写的 "M"（分钟）。&lt;/li&gt;
  &lt;li&gt;靠近 "M" 或 "L"（月份）的大写的 "D"（一年中的某天）。 可能本意是使用小写的 "d"（一月中的某天）。&lt;/li&gt;
  &lt;li&gt;靠近 "m"（分钟）的大写的 "S"（毫秒）。 可能本意是使用小写的 "s"（秒）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
  示例：&lt;br&gt;
  &lt;code&gt;new SimpleDateFormat("YYYY-MM-dd")&lt;/code&gt;：可能本意是使用 &lt;code&gt;"yyyy-MM-dd"&lt;/code&gt;。&lt;br&gt;
  &lt;code&gt;new SimpleDateFormat("yyyy-MM-DD")&lt;/code&gt;：可能本意是使用 &lt;code&gt;"yyyy-MM-dd"&lt;/code&gt;。&lt;br&gt;
  &lt;code&gt;new SimpleDateFormat("HH:MM")&lt;/code&gt;：可能本意是使用 &lt;code&gt;"HH:mm"&lt;/code&gt;。
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2020.1 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="IteratorNextDoesNotThrowNoSuchElementException" defaultSeverity="WARNING" displayName="无法抛出 'NoSuchElementException' 的 'Iterator.next()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告不能抛出 &lt;code&gt;java.util.NoSuchElementException&lt;/code&gt; 的 &lt;code&gt;Iterator.next()&lt;/code&gt; 的实现。
&lt;p&gt;
  此类实现违反了 &lt;code&gt;java.util.iterator&lt;/code&gt; 的约定，如果以非标准方式使用迭代器，可能会导致难以捉摸的错误。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Numbers implements Iterator&amp;lt;Integer&amp;gt; {
    @Override
    public Integer next() { //warning
        if (hasNext()) {
            return generateNext();
        } else {
            return null; //而是抛出 NoSuchElementException
        }
    }

    ...
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MagicConstant" defaultSeverity="WARNING" displayName="魔术常量" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告可以替换为“魔术”常量的表达式。
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  // 使用了裸文字 "2"，警告：
  Font font = new Font("Arial", 2)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;示例 2：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  // 使用了预定义常量，良好：
  Font font = new Font("Arial", Font.ITALIC)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  如果可能，该快速修复会插入相应的预定义常量。
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  此检查的行为由 &lt;code&gt;org.intellij.lang.annotations.MagicConstant&lt;/code&gt; 注解进行控制。
  有些标准的 Java 库方法进行了预先注解，但您也可以在代码中使用该注解。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ConfusingMainMethod" defaultSeverity="WARNING" displayName="引起混淆的 'main()' 方法" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告命名为 "main" 但没有 &lt;code&gt;public static void main(String[])&lt;/code&gt; 签名的方法。
&lt;p&gt;此类方法可能令人困惑，因为命名为 "main" 的方法应为应用程序入口点。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Main {
    void main(String[] args) {} //此处有警告，因为没有 "public static" 修饰符
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;只能在编辑器中使用重命名此类方法的快速修复。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ArrayObjectsEquals" defaultSeverity="WARNING" displayName="对数组使用浅层方法或 'Objects' 方法" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告似乎使用不当方法来确定数组相等性或计算其哈希代码的表达式。
&lt;p&gt;报告的方法调用如下：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;针对任何数组，报告 &lt;code&gt;Object.equals()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;针对多维数组，报告 &lt;code&gt;Arrays.equals()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;针对多维数组，报告 &lt;code&gt;Arrays.hashCode()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="CompareToUsesNonFinalVariable" defaultSeverity="WARNING" displayName="'compareTo()' 中引用了非最终字段" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对 &lt;code&gt;compareTo()&lt;/code&gt; 实现中的非 &lt;code&gt;final&lt;/code&gt; 字段的访问。
&lt;p&gt;
  此类访问可能导致 &lt;code&gt;compareTo()&lt;/code&gt; 在对象生命周期的不同时刻返回不同的结果，进而可能在使用 &lt;code&gt;java.util.TreeSet&lt;/code&gt; 等标准集合类时导致问题。
&lt;/p&gt;
&lt;p&gt;
  只有在对该字段不具备写入访问权限时，才可以通过快速修复将该字段设为 &lt;code&gt;final&lt;/code&gt;，否则不建议进行修正。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo implements Comparable&amp;lt;Foo&amp;gt;{
    private int index;
    Foo(int idx) {
      index = idx;
    }
    @Override
    public int compareTo(Foo foo) {
     return Integer.compare(this.index, foo.index);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo implements Comparable&amp;lt;Foo&amp;gt;{
    private final int index;
    Foo(int idx) {
      index = idx;
    }
    @Override
    public int compareTo(Foo foo) {
      return Integer.compare(this.index, foo.index);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="InstanceofIncompatibleInterface" defaultSeverity="WARNING" displayName="具有不兼容接口的 'instanceof'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告其中比较的类型为接口，比较的表达式的类的类型既不实现比较的接口，也不具有实现所比较接口的任何可见子类的 &lt;code&gt;instanceof&lt;/code&gt; 表达式。
&lt;p&gt;
  尽管这可能是有意为之，但通常此类结构很可能表明有错误，其中得到的 &lt;code&gt;instanceof&lt;/code&gt; 表达式的求值结果始终为 &lt;code&gt;false&lt;/code&gt;。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  interface I1 {}

  interface I2 {}

  interface I3 extends I1 {}

  static class Sub1 implements I1 {}

  static class Sub2 extends Sub1 implements I2 {
    void test(Sub1 sub1) {
      if (sub1 instanceof I3) { // 这里的 'I3' 为不兼容的接口
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CapturingCleaner" defaultSeverity="WARNING" displayName="清理器捕获对象引用" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告正在对传递给 &lt;code&gt;Cleaner.register()&lt;/code&gt; 捕获引用的 &lt;code&gt;Runnable&lt;/code&gt; 进行注册的情况。
如果引用被捕获，它将永远不是虚可达的，且永远不会调用清理操作。
&lt;p&gt;此问题的可能来源：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;使用非 static 方法、字段或 &lt;code&gt;this&lt;/code&gt; 本身的 lambda&lt;/li&gt;
  &lt;li&gt;非 static 内部类（匿名与否）在 Java 18 及更低版本中始终捕获此引用&lt;/li&gt;
  &lt;li&gt;实例方法引用&lt;/li&gt;
  &lt;li&gt;从非 static 内部类访问外部类非 static 成员&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;将报告的代码示例： &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int fileDescriptor;
  Cleaner.Cleanable cleanable = Cleaner.create().register(this, () -&gt; {
    System.out.println("adsad");
    //&lt;i&gt;this&lt;/i&gt; 通过 &lt;i&gt;fileDescriptor&lt;/i&gt; 捕获
    fileDescriptor = 0;
  });
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;仅当项目或模块的语言级别为 9 或更高时，此检查才会报告。&lt;/p&gt;
&lt;p&gt;&lt;small&gt;2018.1 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NewStringBufferWithCharArgument" defaultSeverity="WARNING" displayName="StringBuilder 构造函数调用具有 'char' 实参" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对 &lt;code&gt;char&lt;/code&gt; 作为实参的 &lt;code&gt;StringBuffer&lt;/code&gt; 和 &lt;code&gt;StringBuilder&lt;/code&gt; 构造函数的调用。
在本例中，&lt;code&gt;char&lt;/code&gt; 无提示地转换为整数，并解读为缓冲区的初始容量。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  new StringBuilder('(').append("1").append(')');
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  new StringBuilder("(").append("1").append(')');
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TextLabelInSwitchStatement" defaultSeverity="WARNING" displayName="'switch' 语句中的文本标签" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;switch&lt;/code&gt; 语句中的标签语句。
虽然偶尔是有意为之，但此结构通常由拼写错误所致。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  switch (x) {
      case 1:
      case2:   // 警告：'switch' 语句中存在文本标签 'case2:'
      case 3:
          break;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="InvalidComparatorMethodReference" defaultSeverity="WARNING" displayName="用于 'Comparator' 的无效方法引用" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告映射到 &lt;code&gt;Comparator&lt;/code&gt; 接口的不履行其约定的方法引用。
&lt;p&gt;
某些方法引用，例如 &lt;code&gt;Integer::max&lt;/code&gt;，可以映射到 &lt;code&gt;Comparator&lt;/code&gt; 接口。
但是，将它们用作 &lt;code&gt;Comparator&lt;/code&gt; 是没有意义的，结果可能是不可预测的。
&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  ArrayList&amp;lt;Integer&amp;gt; ints = foo();
  ints.sort(Math::min);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  ArrayList&amp;lt;Integer&amp;gt; ints = foo();
  ints.sort(Comparator.reverseOrder());
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="InfiniteRecursion" defaultSeverity="WARNING" displayName="无限递归" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告除非抛出异常否则无限调用自身的方法。
&lt;p&gt;
  此检查报告的方法不能正常返回。
  虽然此类行为可能是有意为之，但在许多情况下，可能纯属疏忽。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  int baz() {
      return baz();
  }&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NumberEquality" defaultSeverity="WARNING" displayName="使用 '==' 而不是 'equals()' 进行数字比较" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告使用 &lt;b&gt;==&lt;/b&gt; 或 &lt;b&gt;!=&lt;/b&gt; 而不是 &lt;code&gt;equals()&lt;/code&gt; 来测试 &lt;code&gt;Number&lt;/code&gt; 相等性的代码。
&lt;p&gt;
  使用自动装箱时很容易犯这样的错误：即不比较两个基元，而是比较包装器类型的两个实例，例如使用  &lt;code&gt;Integer&lt;/code&gt; 而不是 &lt;code&gt;int&lt;/code&gt;。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  void foo(Integer a, Integer b) {
    final boolean bool = a == b;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果已知 &lt;code&gt;a&lt;/code&gt; 为非 null，则可以安全地应用“不安全”的快速修复，并获得类似于如下所示的结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  void foo(Integer a, Integer b) {
    final boolean bool = a.equals(b);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ComparableImplementedButEqualsNotOverridden" defaultSeverity="WARNING" displayName="已实现 'Comparable'，但 'equals()' 未被重写" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告实现 &lt;code&gt;java.lang.Comparable&lt;/code&gt; 但不重写 &lt;code&gt;equals()&lt;/code&gt; 的类。
&lt;p&gt;
  如果未重写 &lt;code&gt;equals()&lt;/code&gt;，&lt;code&gt;equals()&lt;/code&gt; 实现与 &lt;code&gt;compareTo()&lt;/code&gt; 实现将不一致。 如果将这种类的对象添加到 &lt;code&gt;java.util.SortedSet&lt;/code&gt; 等集合，该集合将违反根据 &lt;code&gt;equals()&lt;/code&gt; 定义的 &lt;code&gt;java.util.Set&lt;/code&gt; 的约定。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Length implements Comparable&amp;lt;Length&gt; {
    private int cm = 0;

    @Override
    public int compareTo(@NotNull Length o) {
      if (cm == o.cm) return 0;
      return cm &amp;lt; o.cm ? -1 : 1;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Length implements Comparable&amp;lt;Length&gt; {
    private int cm = 0;

    @Override
    public int compareTo(@NotNull Length o) {
      if (cm == o.cm) return 0;
      return cm &amp;lt; o.cm ? -1 : 1;
    }

    @Override
    public boolean equals(Object o) {
      return o instanceof Length &amp;&amp; compareTo((Length) o) == 0;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StringTokenizerDelimiter" defaultSeverity="WARNING" displayName="'StringTokenizer' 中的分隔符重复" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在分隔符实参中包含重复字符的 &lt;code&gt;StringTokenizer()&lt;/code&gt; 构造函数调用或 &lt;code&gt;nextToken()&lt;/code&gt; 方法调用。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void printTokens(String text) {
    StringTokenizer tokenizer = new StringTokenizer(text, "\n\n");
    while (tokenizer.hasMoreTokens()) {
      System.out.println(tokenizer.nextToken());
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void printTokens(String text) {
    StringTokenizer tokenizer = new StringTokenizer(text, "\n");
    while (tokenizer.hasMoreTokens()) {
      System.out.println(tokenizer.nextToken());
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MeaninglessRecordAnnotationInspection" defaultSeverity="WARNING" displayName="无意义的记录注解" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告记录组件上使用但并没有效果的注解。
&lt;p&gt;这可能发生在以下两种情况下：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;报告的注解具有 METHOD 目标，但显式定义了相应的访问器。&lt;/li&gt;
  &lt;li&gt;报告的注解具有 PARAMETER 目标，但显式定义了规范构造函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
@Target(ElementType.METHOD)
@interface A { }
  
// 该注解根本不会出现在字节码中，
// 因为它应当传播到访问器，但显式定义了访问器
record R(@A int x) {
  public int x() { return x; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2021.1 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SubtractionInCompareTo" defaultSeverity="WARNING" displayName="'compareTo()' 中的减法" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;compareTo()&lt;/code&gt; 方法和实现 &lt;code&gt;java.util.Comparator.compare()&lt;/code&gt; 的方法中的减法。
&lt;p&gt;
  虽然使用整数减法的结果作为 &lt;code&gt;compareTo()&lt;/code&gt; 方法的结果是一种惯常做法，但在整数溢出的情况下，此结构可能会导致难以捉摸的错误。
  在大多数情况下，更好的做法是直接比较整数值并返回 &lt;code&gt;-1&lt;/code&gt;、&lt;code&gt;0&lt;/code&gt; 或 &lt;code&gt;1&lt;/code&gt; 。
&lt;/p&gt;
&lt;p&gt;
  四舍五入可能导致精度损失，因此也会报告直接转换为整型的浮点值减法。
&lt;/p&gt;
&lt;p&gt;
  在静态地确定值范围有限并且决不会发生溢出时，该检查不会报告。
  此外，对 &lt;code&gt;int&lt;/code&gt; 大于或等于 &lt;code&gt;0&lt;/code&gt; 的数字执行减法绝不会溢出。
  因此，在这样的情况下此检查不发出警告。
&lt;/p&gt;
&lt;p&gt;
  总是返回零或更大值的方法可以用 &lt;code&gt;javax.annotation.Nonnegative&lt;/code&gt; 注解进行标记，或者在此检查的选项中指定。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class DoubleHolder implements Comparable&amp;lt;DoubleHolder&amp;gt; {
    double d;
    public int compareTo(DoubleHolder that) {
        return (int)(this.d - that.d);
    }
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这是一个无警告的示例，因为已知 &lt;code&gt;String.length()&lt;/code&gt; 非负：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class A implements Comparable&amp;lt;A&amp;gt; {
    final String s = "";
    public int compareTo(A a) {
        return s.length() - a.s.length();
    }
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用这些选项可列出在减法中安全使用的方法。
  方法返回始终大于或等于 &lt;code&gt;0&lt;/code&gt; 的 &lt;code&gt;int&lt;/code&gt; 值时，表明方法就是安全的。
&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ResultSetIndexZero" defaultSeverity="WARNING" displayName="在 JDBC ResultSet 中使用索引 0" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告访问 &lt;code&gt;java.sql.ResultSet&lt;/code&gt; 或 &lt;code&gt;java.sql.PreparedStatement&lt;/code&gt; 的第 0 列的尝试。
由于历史原因，&lt;code&gt;java.sql.ResultSet&lt;/code&gt; 和 &lt;code&gt;java.sql.PreparedStatement&lt;/code&gt; 的列不是从 &lt;b&gt;0&lt;/b&gt; 开始编号，而是从 &lt;b&gt;1&lt;/b&gt; 开始编号，并且访问第 0 列是 JDBC 编程中的常见错误。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String getName(ResultSet rs) {
    &lt;b&gt;return&lt;/b&gt; rs.getString(0);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="OverwrittenKey" defaultSeverity="WARNING" displayName="被覆盖的 Map、Set 或数组元素" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告覆盖 &lt;code&gt;Map&lt;/code&gt; 键、&lt;code&gt;Set&lt;/code&gt; 元素或 &lt;code&gt;add&lt;/code&gt;/&lt;code&gt;put&lt;/code&gt; 调用序列中的数组元素或使用类似于 &lt;code&gt;Set.of&lt;/code&gt; 的 Java 9 工厂方法（将导致运行时异常）的代码。
&lt;p&gt;这通常是复制粘贴错误所致。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  map.put("A", 1);
  map.put("B", 2);
  map.put("C", 3);
  map.put("D", 4);
  map.put("A", 5); // 键 "A" 重复，覆盖以前写入的条目
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2017.3 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="EqualsBetweenInconvertibleTypes" defaultSeverity="WARNING" displayName="'equals()' 位于不可转换类型的对象之间" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对目标和实参的类型不兼容的 &lt;code&gt;equals()&lt;/code&gt; 的调用。
&lt;p&gt;虽然此类调用理论上可能有用，但很可能是错误。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  new HashSet&amp;lt;String&amp;gt;().equals(new TreeSet&amp;lt;Integer&amp;gt;());
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ClassGetClass" defaultSeverity="WARNING" displayName="'Class.getClass()' 调用可疑" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在 &lt;code&gt;java.lang.Class&lt;/code&gt; 实例上调用的 &lt;code&gt;getClass()&lt;/code&gt; 方法。
&lt;p&gt;这通常是一个错误，因为结果总是等同于 &lt;code&gt;Class.class&lt;/code&gt;。
如果是错误，那么最好移除 &lt;code&gt;getClass()&lt;/code&gt; 调用并直接使用限定符。
  如果行为是故意的，最好显式编写 &lt;code&gt;Class.class&lt;/code&gt; 以避免混淆。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void test(Class&amp;lt;?&amp;gt; clazz) {
    String name = clazz.getClass().getName();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用可能的快速修复之一后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void test(Class&amp;lt;?&amp;gt; clazz) {
    String name = clazz.getName();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2018.2 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="EmptyStatementBody" defaultSeverity="WARNING" displayName="带空体的语句" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告语句体为空的 &lt;code&gt;if&lt;/code&gt;、&lt;code&gt;while&lt;/code&gt;、&lt;code&gt;do&lt;/code&gt;、&lt;code&gt;for&lt;/code&gt;、&lt;code&gt;switch&lt;/code&gt; 语句。
&lt;p&gt;虽然偶尔是有意为之，但此类代码令人困惑，并且通常是由拼写错误所致。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;JSP 文件中禁用了此检查。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="VariableNotUsedInsideIf" defaultSeverity="WARNING" displayName="'if' 内未使用检查为 'null' 的引用" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对在 &lt;code&gt;if&lt;/code&gt; 语句或条件表达式的条件中检查可 null 性但未在该 &lt;code&gt;if&lt;/code&gt; 语句内部使用的变量的引用。
&lt;p&gt;
  这通常意味着不必要进行该检查，或者在 &lt;code&gt;if&lt;/code&gt; 语句中没有错误引用变量。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void test(Integer i) {
    if (i != null) { // 这里的 'i' 没有在 'if' 语句内部使用
      System.out.println();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReflectionForUnavailableAnnotation" defaultSeverity="WARNING" displayName="对仅源注解的反射访问" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对非运行时注解的存在与否执行反射性检查的尝试。
&lt;p&gt;使用 &lt;code&gt;Class.isAnnotationPresent()&lt;/code&gt; 测试保留策略设置为 &lt;code&gt;SOURCE&lt;/code&gt; 或 &lt;code&gt;CLASS&lt;/code&gt;（默认值）的注解是否始终得到否定结果。 此错误很容易被忽视。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  {
    getClass().isAnnotationPresent(SourceAnnotation.class); //始终为 false
  }

  @Retention(RetentionPolicy.SOURCE)
  @interface SourceAnnotation {}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MathRandomCastToInt" defaultSeverity="WARNING" displayName="'Math.random()' 转换为 'int'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对立即转换为 &lt;code&gt;int&lt;/code&gt; 的 &lt;code&gt;Math.random()&lt;/code&gt; 的调用。 
&lt;p&gt;将 &lt;code&gt;0.0&lt;/code&gt;（包括）和 &lt;code&gt;1.0&lt;/code&gt;（不包括）之间的 &lt;code&gt;double&lt;/code&gt; 转换为 &lt;code&gt;int&lt;/code&gt; 将始终舍入为零。 在将该值转换为 &lt;code&gt;int&lt;/code&gt; 前，应先将其乘以某个因子，以获取介于零（包括）和乘法因子（不包括）之间的值。
  另一种可能的解决办法是使用 &lt;code&gt;java.util.Random&lt;/code&gt; 的 &lt;code&gt;nextInt()&lt;/code&gt; 方法。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  &lt;b&gt;int&lt;/b&gt; r = (&lt;b&gt;int&lt;/b&gt;)Math.random() * 10;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  &lt;b&gt;int&lt;/b&gt; r = (&lt;b&gt;int&lt;/b&gt;)(Math.random() * 10);
&lt;/code&gt;&lt;/pre&gt;
  &lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SuspiciousSystemArraycopy" defaultSeverity="WARNING" displayName="可疑的 'System.arraycopy()' 调用" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对 &lt;code&gt;System.arraycopy()&lt;/code&gt; 的可疑调用。
&lt;p&gt;此类调用在以下情况下可疑：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;源或目标非数组类型
&lt;li&gt;源和目标的类型不同
&lt;li&gt;复制的块长度大于 &lt;code&gt;src.length - srcPos&lt;/code&gt;
&lt;li&gt;复制的块长度大于 &lt;code&gt;dest.length - destPos&lt;/code&gt;
&lt;li&gt;当源和目标为同一个数组时，范围始终相交
&lt;/ul&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void foo() {
    int[] src = new int[] { 1, 2, 3, 4 };
    System.arraycopy(src, 0, src, 1, 2); // 警告：复制到具有相交范围的同一数组
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SuspiciousNameCombination" defaultSeverity="WARNING" displayName="可疑的变量/形参名称组合" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告目标变量或函数形参的名称与分配给它的值的名称不匹配的赋值和函数调用。
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;int&lt;/b&gt; x = 0;
  &lt;b&gt;int&lt;/b&gt; y = x; // x 用作 y 坐标
  &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;示例 2：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;int&lt;/b&gt; x = 0, y = 0;
  // x 用作 y 坐标，y 用作 x 坐标
  Rectangle rc = &lt;b&gt;new&lt;/b&gt; Rectangle(y, x, 20, 20);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;配置检查：&lt;/p&gt;
&lt;p&gt;使用&lt;b&gt;名称组&lt;/b&gt;区域可以指定不应一起使用的名称：如果形参名称或赋值目标名称包含一个组中的字词，而赋值或传递的变量名称包含另一个组中的字词，就会报告错误。
&lt;p&gt;使用&lt;b&gt;忽略方法&lt;/b&gt;区域可以指定不应检查但名称可能存疑的方法。
例如，&lt;code&gt;Integer.compare()&lt;/code&gt; 形参被命名为 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt;，但与坐标无关。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SuspiciousListRemoveInLoop" defaultSeverity="WARNING" displayName="循环中的 'List.remove()' 可疑" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告升序计数循环中的 &lt;code&gt;list.remove(index)&lt;/code&gt; 调用。
&lt;p&gt;
  这很可疑，因为移除后列表变短，下一个元素被跳过。 简单的修正方法是在移除后减小索引变量，但更稳健的做法可能是通过迭代器或使用 &lt;code&gt;removeIf()&lt;/code&gt; 方法（Java 8 及更高版本）移除。
  如果您不希望 &lt;code&gt;remove()&lt;/code&gt; 在循环中被多次调用，不妨在它后面添加 &lt;code&gt;break&lt;/code&gt;。
&lt;/p&gt;

&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  public static void main(String[] args) {
    process(new ArrayList&amp;lt;&gt;(
      Arrays.asList("1", "2", "|", "3", "4")));
  }

  static void process(List&amp;lt;String&amp;gt; list) {
    for (int i = 0; i &amp;lt; list.size(); i++) {
      if (list.get(i).equals("|")) {
        list.remove(i);
        continue;
      }
      System.out.println(list.get(i));
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;代码看起来像是会打印 &lt;code&gt;1 2 3 4&lt;/code&gt;，但实则在输出中将跳过 &lt;code&gt;3&lt;/code&gt;。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2018.2 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MisspelledEquals" defaultSeverity="WARNING" displayName="'equal()' 代替 'equals()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告带有单个形参的 &lt;code&gt;equal()&lt;/code&gt; 的声明。
通常，这是拼写错误，&lt;code&gt;equals()&lt;/code&gt; 实际上是有意的。
&lt;p&gt;建议通过快速修复将方法重命名为 &lt;code&gt;equals&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Main {
    public boolean equal(Object obj) {
      return true;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Main {
    public boolean equals(Object obj) {
      return true;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="IgnoreResultOfCall" defaultSeverity="WARNING" displayName="方法调用的结果已忽略" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告其结果被忽略的方法调用。
&lt;p&gt;忽略结果对于许多方法完全合法，但对于某些方法，几乎肯定是错误。 忽略结果可能是错误之举的方法示例包括返回实际读取字节数的 &lt;code&gt;java.io.inputStream.read()&lt;/code&gt;，以及 &lt;code&gt;java.lang.String&lt;/code&gt; 或 &lt;code&gt;java.math.BigInteger&lt;/code&gt; 上的任何方法。 这些方法不会产生副作用，因此忽略它们的结果将毫无意义。
&lt;/p&gt;
&lt;p&gt;将检查对以下方法的调用：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;简单 getter（除返回字段外别无他用）&lt;/li&gt;
  &lt;li&gt;在此检查的设置中指定的方法&lt;/li&gt;
  &lt;li&gt;使用 &lt;code&gt;org.jetbrains.annotations.Contract(pure=true)&lt;/code&gt; 注解的方法&lt;/li&gt;
  &lt;li&gt;使用 .*.&lt;code&gt;CheckReturnValue&lt;/code&gt; 注解的方法&lt;/li&gt;
  &lt;li&gt;使用 &lt;code&gt;javax.annotation.CheckReturnValue&lt;/code&gt; 注解的类或软件包中的方法&lt;/li&gt;
  &lt;li&gt;所有非库方法（可选）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不会报告对使用 Error Prone 或 AssertJ 的 &lt;code&gt;@CanIgnoreReturnValue&lt;/code&gt; 注解进行注解的方法的调用。

&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用检查设置指定要检查的类。
  方法采用 Java 正则表达式语法按名称或名称模式进行匹配。
  对于类，请使用完全限定名称。 每个条目都应用于该类及其所有继承者。
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConstantValue" defaultSeverity="WARNING" displayName="常量值" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告始终产生相同结果的表达式和条件，如 true、false、null 或零。
此类表达式可以替换为相应的常量值。 但通常情况下，它们表示代码中存在错误。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  // 始终为 true
  // 根本原因：使用了 ||，而非 &amp;&amp;
  if (x &amp;gt; 0 || x &amp;lt; 10) {}

  System.out.println(str.trim());
  // 始终为 false
  // 根本原因：在 null 检查之前取消了引用变量
  if (str == null) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  检查行为可能由许多注解控制，例如&lt;a href="https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html"&gt;可 null 性&lt;/a&gt;注解、&lt;code&gt;&lt;a href="https://www.jetbrains.com/help/idea/contract-annotations.html"&gt;@Contract&lt;/a&gt;&lt;/code&gt; 注解、&lt;code&gt;@Range&lt;/code&gt; 注解等。
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;配置检查：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;使用&lt;b&gt;不报告条件静态证明始终为 true 的断言&lt;/b&gt;选项可避免报告静态证明始终为 true 的断言。 这还包括 &lt;code&gt;if (alwaysFalseCondition) throw new IllegalArgumentException();&lt;/code&gt; 等条件。&lt;/li&gt;
  &lt;li&gt;使用&lt;b&gt;忽略 assert 语句&lt;/b&gt;选项可控制检查如何处理 &lt;code&gt;assert&lt;/code&gt; 语句。 默认情况下，该选项被禁用，这意味着断言视为被执行（-ea 模式）。 如果启用该选项，断言将被完全忽略（-da 模式）。&lt;/li&gt;
  &lt;li&gt;使用&lt;b&gt;当常量存储在变量中时发出警告&lt;/b&gt;选项可以在使用变量（已知其值为常量）时显示警告。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
  在 IntelliJ IDEA 2022.3 版本之前，此检查为“常量条件和异常”检查的一部分。 现在，它被拆分成了两个检查：“常量值”和“可空性和数据流问题”。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SuspiciousInvocationHandlerImplementation" defaultSeverity="WARNING" displayName="可疑的 'InvocationHandler' 实现" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告不代理 &lt;code&gt;hashCode()&lt;/code&gt;、&lt;code&gt;equals()&lt;/code&gt; 和 &lt;code&gt;toString()&lt;/code&gt; 等标准 &lt;code&gt;Object&lt;/code&gt; 方法的 &lt;code&gt;InvocationHandler&lt;/code&gt; 的实现。
&lt;p&gt;未能处理这些方法可能会在代理实例上调用它们时导致意外问题。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  InvocationHandler myHandler = (proxy, method, params) -&amp;gt; {
    System.out.println("Hello World!");
    &lt;b&gt;return&lt;/b&gt; null;
  };
  Runnable myProxy = (Runnable) Proxy.newProxyInstance(
    Thread.currentThread().getContextClassLoader(),
    &lt;b&gt;new&lt;/b&gt; Class[] {Runnable.class}, myHandler
  );
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  此代码段的宗旨是仅代理 &lt;code&gt;Runnable.run()&lt;/code&gt; 方法。
  但是，也会代理对 &lt;code&gt;hashCode()&lt;/code&gt; 等任何 &lt;code&gt;Object&lt;/code&gt; 方法的调用。
  这可能导致 &lt;code&gt;NullPointerException&lt;/code&gt; 等问题，例如在将 &lt;code&gt;myProxy&lt;/code&gt; 添加到 &lt;code&gt;HashSet&lt;/code&gt; 时。
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2020.2 最新变化&lt;/small&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NonShortCircuitBoolean" defaultSeverity="WARNING" displayName="非短路布尔表达式" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告布尔 'and' 和 'or' 的非短路形式（&lt;code&gt;&amp;amp;&lt;/code&gt;、&lt;code&gt;|&lt;/code&gt;、&lt;code&gt;&amp;amp;=&lt;/code&gt; 和 &lt;code&gt;|=&lt;/code&gt;）的用法。
尽管非短路版本偶尔有用，但在大多数情况下，本应使用短路形式（&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 和 &lt;code&gt;||&lt;/code&gt;），此类无意的用法可能会导致难以捉摸的错误。
&lt;p&gt;
  建议通过快速修复来使用短路版本。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void foo(boolean x, boolean y, boolean z) {
    if (x | y) { x |= z; }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void foo(boolean x, boolean y) {
    if (x || y) { x = x || z; }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="IncorrectDateTimeFormat" defaultSeverity="WARNING" displayName="'DateTimeFormat' 模式不正确" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;!-- Copyright 2000-2022 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license. --&gt;
&lt;html&gt;
&lt;body&gt;
报告错误的日期时间格式模式。
&lt;p&gt;报告以下错误：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;不支持的模式字母，如 "TT"&lt;/li&gt;
  &lt;li&gt;使用保留字符，如 "#"&lt;/li&gt;
  &lt;li&gt;不正确的填充用法&lt;/li&gt;
  &lt;li&gt;不平衡的中括号&lt;/li&gt;
  &lt;li&gt;连续模式字母的数量不正确&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  DateTimeFormatter.ofPattern("[][]]"); // 右 ']' 之前没有左 '['
  DateTimeFormatter.ofPattern("TT"); // 非法的模式字母 'T'
  DateTimeFormatter.ofPattern("{"); // 使用了保留字符 '{'
  DateTimeFormatter.ofPattern("MMMMMM"); // 过多的连续模式字母 'M'
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2022.3 最新变化&lt;/small&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DataFlowIssue" defaultSeverity="WARNING" displayName="为 null 性和数据流问题" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
根据数据流分析，报告总是违反可空性约定、可能抛出异常或只是冗余的代码结构。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if (array.length &amp;lt; index) {
  System.out.println(array[index]);
} // 数组索引始终超出界限

if (str == null) System.out.println("str is null");
System.out.println(str.trim());
// 最后一个语句可能会抛出 NPE

@NotNull
Integer square(@Nullable Integer input) {
    // 违反方法约定
    return input == null ? null : input * input;
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  检查行为可能由许多注解控制，例如&lt;a href="https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html"&gt;可 null 性&lt;/a&gt;注解、&lt;code&gt;&lt;a href="https://www.jetbrains.com/help/idea/contract-annotations.html"&gt;@Contract&lt;/a&gt;&lt;/code&gt; 注解、&lt;code&gt;@Range&lt;/code&gt; 注解等。
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;配置检查：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;使用&lt;b&gt;对可 null 值的方法/字段/形参建议使用 @Nullable 注解&lt;/b&gt;选项可以在以下情况下发出警告：null 值作为实参传递给具有非注解形参的方法时，存储到非注解字段时，或从非注解方法返回时。 在这种情况下，该检查将建议传播 &lt;code&gt;@Nullable&lt;/code&gt; 注解。 您还可以使用&lt;b&gt;配置注解&lt;/b&gt;按钮配置可 null 性注解。&lt;/li&gt;
  &lt;li&gt;使用&lt;b&gt;将未注解的成员和形参视为 @Nullable&lt;/b&gt; 选项可假设非注解成员可以为 null，因此不得在非 null 上下文中使用。&lt;/li&gt;
  &lt;li&gt;使用&lt;b&gt;报告使用 null 文字实参用法的非 null 必需形参&lt;/b&gt;&gt;选项可以报告不能为 null（例如在方法体中立即取消引用），但存在传递 &lt;code&gt;null&lt;/code&gt; 文字的调用点的方法形参。&lt;/li&gt;
  &lt;li&gt;使用&lt;b&gt;报告始终返回非 null 值的可 null 方法&lt;/b&gt;选项，可报告注解为 &lt;code&gt;@Nullable&lt;/code&gt; 但始终返回非 null 值的方法。 在这种情况下，建议您将注解更改为 &lt;code&gt;@NotNull&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;使用&lt;b&gt;忽略 assert 语句&lt;/b&gt;选项可控制检查如何处理 &lt;code&gt;assert&lt;/code&gt; 语句。 默认情况下，该选项被禁用，这意味着断言视为被执行（-ea 模式）。 如果启用该选项，断言将被完全忽略（-da 模式）。&lt;/li&gt;
  &lt;li&gt;使用&lt;b&gt;报告仅在某些代码路径上发生的问题&lt;/b&gt;选项可控制是否报告仅在某些代码路径上发生的问题。 如果禁用此选项，则不会报告 &lt;i&gt;exception is possible&lt;/i&gt; 等警告。 该检查只会报告类似 &lt;i&gt;exception will definitely occur&lt;/i&gt; 的警告。 这种模式可以大大减少误报的数量，特别是如果代码没有一致地使用可 null 性和约定注解进行注解。 这就是为什么它对于查找传统代码库中最重要的问题很有用。
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
  在 IntelliJ IDEA 2022.3 版本之前，此检查为“常量条件和异常”检查的一部分。
  现在，它被拆分成了两个检查：“常量值”和“可空性和数据流问题”。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="MalformedFormatString" defaultSeverity="WARNING" displayName="字符串的格式错误" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告不符合标准 Java 语法的格式字符串。
&lt;p&gt;默认情况下，如果编译时常量被用作 &lt;code&gt;java.util.Formatter&lt;/code&gt;、&lt;code&gt;java.lang.String&lt;/code&gt;、&lt;code&gt;java.io.PrintWriter&lt;/code&gt; 或
&lt;code&gt;java.io.PrintStream&lt;/code&gt; 上相应方法的实参，则该检查会将其视为格式字符串。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String.format("x = %d, y = %d", 42);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;使用检查设置可以将其他类和方法标记为与字符串格式相关。&lt;/p&gt;
&lt;p&gt;作为替代方案，您可以使用 &lt;code&gt;org.intellij.lang.annotations.PrintFormat&lt;/code&gt; 注解
来标记格式字符串方法形参。 在这种情况下，格式实参形参必须紧跟在格式字符串之后，并且必须是最后一个方法形参。 示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void myFormatMethod(int mode, @PrintFormat String formatString, Object... args) {...}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  以这种方式注解的方法也将被此检查识别。
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="IteratorHasNextCallsIteratorNext" defaultSeverity="WARNING" displayName="调用 'next()' 的 'Iterator.hasNext()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告迭代器实例上调用 &lt;code&gt;Iterator.next()&lt;/code&gt; 或 &lt;code&gt;ListIterator.previous()&lt;/code&gt; 的 &lt;code&gt;Iterator.hasNext()&lt;/code&gt; 或 &lt;code&gt;ListIterator.hasPrevious()&lt;/code&gt; 的实现。 此类调用几乎肯定是错误，因为 &lt;code&gt;hasNext()&lt;/code&gt; 之类的方法不应修改迭代器状态，而 &lt;code&gt;next()&lt;/code&gt; 应修改迭代器状态。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class MyIterator implements Iterator&amp;lt;Integer&amp;gt; {
    public boolean hasNext() {
      return next() != null;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ScheduledThreadPoolExecutorWithZeroCoreThreads" defaultSeverity="WARNING" displayName="带零个核心线程的 'ScheduledThreadPoolExecutor'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告任何通过 &lt;code&gt;setCorePoolSize&lt;/code&gt; 方法或对象构造函数将 &lt;code&gt;corePoolSize&lt;/code&gt; 设置为零的 &lt;code&gt;java.util.concurrent.ScheduledThreadPoolExecutor&lt;/code&gt; 实例。
&lt;p&gt;
  无核心线程的 &lt;code&gt;ScheduledThreadPoolExecutor&lt;/code&gt; 不运行任何内容。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void foo(int corePoolSize) {
      if (corePoolSize != 0) return;
      ThreadPoolExecutor executor = new ScheduledThreadPoolExecutor(corePoolSize); // 警告
      executor.setCorePoolSize(corePoolSize); // 警告
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ComparatorResultComparison" defaultSeverity="WARNING" displayName="compare 方法的可疑用法" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;Comparator.compare()&lt;/code&gt; 或 &lt;code&gt;Comparable.compareTo()&lt;/code&gt; 调用结果与非零常量的比较。
根据约定，这些方法可以返回任何整数（不只是 -1、0 或 1），因此与特定数字比较是一种不好的做法。 某些广泛使用的比较方法（例如 &lt;code&gt;String.compareTo()&lt;/code&gt;）实际上返回 [-1..1] 范围之外的值，此类比较可能会导致不正确的程序行为。
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void validate(String s1, String s2) {
    // 与 1 比较不正确
    if (s1.compareTo(s2) == 1) {
      throw new IllegalArgumentException("Incorrect order");
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void validate(String s1, String s2) {
    if (s1.compareTo(s2) &gt; 0) {
      throw new IllegalArgumentException("Incorrect order");
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2017.2 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MismatchedArrayReadWrite" defaultSeverity="WARNING" displayName="数组的读取和写入不匹配" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告其内容已读取但未更新或已更新但未读取的数组。 此类不一致读写毫无意义，可能表明死码、代码不完整或错误。
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  final int[] bar = new int[3];
  bar[2] = 3;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CastConflictsWithInstanceof" defaultSeverity="WARNING" displayName="转换与 'instanceof' 冲突" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告前面包含用于检查不同类型的 &lt;code&gt;instanceof&lt;/code&gt; 的类型转换表达式。
&lt;p&gt;
  尽管这可能是有意为之，但此类结构很可能是错误，在运行时将导致 &lt;code&gt;java.lang.ClassCastException&lt;/code&gt;。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Main {
    int whenCharSequenceCastToNumber(Object o){
      if (o instanceof CharSequence) {
        return ((Number) o).intValue();
      }
      return 0;
    }

    int earlyReturnWhenNotCharSequence(Object o){
      if (!(o instanceof CharSequence)) return 0;
      return ((Number)o).intValue();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StaticCallOnSubclass" defaultSeverity="WARNING" displayName="static 方法通过子类引用" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告其中的调用由声明类的子类而不是声明类本身限定的 static 方法调用。
&lt;p&gt;
  Java 允许对类进行此类限定，但是此类调用可能表明继承和重写之间存在微妙的混淆。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Parent {
    public static void print(String str) {}
  }
  class Child extends Parent {}

  Child.print("Hello, world!");
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Parent.print("Hello, world!");
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="Contract" defaultSeverity="WARNING" displayName="合同的问题" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告方法 &lt;code&gt;@Contract&lt;/code&gt; 注解中的问题。 可以报告的问题类型有：
&lt;ul&gt;
&lt;li&gt;约定语法错误&lt;/li&gt;
&lt;li&gt;不符合方法签名的约定（错误的形参计数）&lt;/li&gt;
&lt;li&gt;与约定不一致的方法实现（例如，即使约定声明 &lt;code&gt; false&lt;/code&gt;，也返回 &lt;code&gt;true&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  // 方法没有形参，参约定预期 1
  @Contract("_ -&gt; fail")
  &lt;b&gt;void&lt;/b&gt; x() {
    &lt;b&gt;throw&lt;/b&gt; new AssertionError();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="EqualsUsesNonFinalVariable" defaultSeverity="WARNING" displayName="'equals()' 中引用了非最终字段" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告访问非 &lt;code&gt;final&lt;/code&gt; 变量的 &lt;code&gt;equals()&lt;/code&gt; 的实现。 此类访问可能导致 &lt;code&gt;equals()&lt;/code&gt; 在该对象生命周期的不同时刻返回不同的结果，进而可能在使用标准集合类时导致问题。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Person {
    private String lastName;

    @Override
    public boolean equals(Object obj) {
      ...
      Person other = (Person) obj;
      if (lastName == null) {
        if (!lastName.equals(other.lastName)) {
        return false;
      ...
      }
    }
  }
  &lt;/code&gt;
&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NewObjectEquality" defaultSeverity="WARNING" displayName="使用 '==' 比较新对象" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告将 &lt;code&gt;==&lt;/code&gt; 或 &lt;code&gt;!=&lt;/code&gt; 应用于新分配对象而不是调用 &lt;code&gt;equals()&lt;/code&gt; 的代码。
&lt;p&gt;
  对新分配对象的引用不能指向现有对象，因此比较结果始终为 &lt;code&gt;false&lt;/code&gt;。 该检查还可以报告从简单方法返回的新建对象。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void test(Object obj) {
    if (new Object() == obj) {...}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void test(Object obj) {
    if (new Object().equals(obj)) {...}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  &lt;small&gt;2018.3 最新变化&lt;/small&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConstantAssertCondition" defaultSeverity="WARNING" displayName="'assert' 语句中的常量条件" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告为常量的 &lt;code&gt;assert&lt;/code&gt; 语句条件。 具有常量条件的 &lt;code&gt;assert&lt;/code&gt; 语句要么总是失败，要么总是成功。
此类语句可能在重构后遗留下来，并且可能不是有意的。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    void foo() {
        assert true;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UseOfPropertiesAsHashtable" defaultSeverity="WARNING" displayName="将 'Properties' 对象用作 'Hashtable'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对 &lt;code&gt;java.util.Properties&lt;/code&gt; 对象上的以下方法的调用：
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;put()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;putIfAbsent()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;putAll()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;get()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
  由于历史原因，&lt;code&gt;java.util.Properties&lt;/code&gt; 继承自 &lt;code&gt;java.util.Hashtable&lt;/code&gt;，但为防止污染 &lt;code&gt;String&lt;/code&gt; 以外类型的属性值，不建议使用这些方法。
&lt;/p&gt;
&lt;p&gt;
  当映射中的键和值形参都为 &lt;code&gt;String&lt;/code&gt; 类型时，不会报告对 &lt;code&gt;java.util.Properties.putAll()&lt;/code&gt; 的调用。
  此类调用是安全的，且没有更好的选择。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Object f(Properties props) {
    props.put("hello", "world");
    props.putIfAbsent("hello", "world");
    props.putAll(new HashMap&amp;lt;&amp;gt;());
    return props.get("Hello");
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Object f(Properties props) {
    props.setProperty("hello", "world");
    props.putIfAbsent("hello", "world");
    props.putAll(new HashMap&amp;lt;&amp;gt;());
    return props.getProperty("hello");
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SuspiciousTernaryOperatorInVarargsCall" defaultSeverity="WARNING" displayName="vararg 方法调用中的可疑三元运算符" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告使用具有混合数组分支和非数组分支的三元运算符的 vararg 方法调用。
&lt;p&gt;
编译时，两个分支都被包装在数组中。 结果，数组分支变成了二维数组，这可能说明有问题。
&lt;/p&gt;
&lt;p&gt;
该快速修复会将非数组分支包装在数组中以防止编译器执行转换。
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    static void bar(boolean flag) {
        Object[] a = {1, 2};
        Object b = "hello";
        foo(flag ? a : b);
    }
    static void foo(Object... obj) {
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;应用该快速修复后： &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    static void bar(boolean flag) {
        Object[] a = {1, 2};
        Object b = "hello";
        foo(flag ? a : new Object[]{b});
    }
    static void foo(Object... obj) {
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;small&gt;2020.3 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ComparatorMethodParameterNotUsed" defaultSeverity="WARNING" displayName="可疑的 'Comparator.compare()' 实现" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;Comparator.compare()&lt;/code&gt; 和 &lt;code&gt;Comparable.compareTo()&lt;/code&gt; 实现中的问题。
&lt;p&gt;报告的情况如下：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    未使用形参。 很可能这是拼写错误，另一个形参与本身相比较，或者未正确实现方法。
  &lt;/li&gt;
  &lt;li&gt;
    显然，对于相同的元素，该方法不会返回 &lt;code&gt;0&lt;/code&gt;。 这种比较方法违反了约定，当遇到相同的元素时，可能会产生不可预测的结果。 特别是，某些数据可能会出现异常而导致排序失败。&lt;/li&gt;
  &lt;li&gt;
    比较方法从不返回正值或负值。 为了履行约定，如果比较方法返回正值，那么如果以相反的顺序提供实参，它也应该返回负值。
  &lt;/li&gt;
  &lt;li&gt;
    比较方法返回 &lt;code&gt;Integer.MIN_VALUE&lt;/code&gt;。 虽然约定允许，但它可能容易出错，因为一些调用站点可能会错误地使用一元减号来反转比较方法的返回值。 在这种情况下，&lt;code&gt;Integer.MIN_VALUE&lt;/code&gt; 将保持负值。
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Comparator&amp;lt;String&amp;gt; lambda =
    (a, b) -&amp;gt; a.length() &amp;gt; b.length()
              ? 0
              : Math.random() &amp;gt; 0.5 ? -1 : 1;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SortedCollectionWithNonComparableKeys" defaultSeverity="WARNING" displayName="包含不可比较元素的排序集合" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告排序集合的结构，例如 &lt;code&gt;TreeSet&lt;/code&gt;，它依赖于自然排序，其元素类型不实现 &lt;code&gt;Comparable&lt;/code&gt; 接口。
&lt;p&gt;此类集合不太可能正常工作。&lt;/p&gt;
&lt;p&gt;
  如果集合元素类型是不可比较的父类型，但集合只打算保存可比较的子类型，则可能出现误报。 即便这样，也最好缩小集合元素类型的范围或将父类型声明为 &lt;code&gt;Comparable&lt;/code&gt; ，因为上述方法容易出错。
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  该检查还会报告集合元素是未声明为 &lt;code&gt;extends Comparable&lt;/code&gt; 的类型形参的情况。
  您可以使用所提供的选项禁止对类型形参发出警告（例如，为了保持 API 兼容性）。
&lt;/p&gt;
&lt;p&gt;
  &lt;small&gt;2018.3 最新变化&lt;/small&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MismatchedCollectionQueryUpdate" defaultSeverity="WARNING" displayName="不匹配的集合查询和更新" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告其内容已查询但未更新或已更新但未查询的集合。
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  此类不一致查询和更新毫无意义，可能表明有死码或拼写错误。
&lt;/p&gt;
&lt;p&gt;
  使用检查设置可以指定与更新/查询方法相对应的名称模式。
  返回元素的查询方法会被自动检测，并且只需指定将数据写入输出形参的查询方法（例如 &lt;code&gt;OutputStream&lt;/code&gt;）。
&lt;p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;假设您有一个包含方法 &lt;code&gt;store()&lt;/code&gt; 的自定义 &lt;code&gt;FixedStack&lt;/code&gt; 类：
&lt;pre&gt;&lt;code&gt;
  public class FixedStack&amp;lt;T&amp;gt; extends Collection&amp;lt;T&amp;gt; {
    public T store(T t) {
      // 实现
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;您可以将 &lt;code&gt;store&lt;/code&gt; 添加到更新方法表中，以报告不匹配的查询，例如：
&lt;pre&gt;&lt;code&gt;
  void test(int i) {
    FixedStack&amp;lt;Integer&amp;gt; stack = new FixedStack&amp;lt;&amp;gt;();
    stack.store(i);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CopyConstructorMissesField" defaultSeverity="WARNING" displayName="复制缺少字段的构造函数" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告不复制该类所有字段的复制构造函数。
&lt;p&gt;
  带有初始值设定项的 &lt;code&gt;final&lt;/code&gt; 字段和 &lt;code&gt;transient&lt;/code&gt; 字段被视为不必复制。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Point {

    private int x;
    private int y;

    Point(int x, int y) {
      this.x = x;
      this.y = y;
    }

    Point(Point other) {
      // 字段 x 和 y 未初始化
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2018.1 最新变化&lt;/small&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantOperationOnEmptyContainer" defaultSeverity="WARNING" displayName="空容器上存在冗余操作" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对空集合、映射或数组的冗余操作。
&lt;p&gt;
  在空集合上迭代、移除元素、排序和某些其他操作没有任何效果，可以移除。 此外，它们可能表明存在错误。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (numbers.isEmpty()){
    //由于缺少否定，因此出现错误
    int max = numbers.stream().max(Comparator.naturalOrder()).get();
    ...
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2019.1 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CastToIncompatibleInterface" defaultSeverity="WARNING" displayName="转换为不兼容的接口" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告其中的转换类型为接口，且转换表达式的类的类型既不实现转换接口，也不包含任何实现该转换接口的可见子类的类型转换表达式。
&lt;p&gt;
  尽管这可能是有意为之，但此类结构很可能是错误，在运行时将导致 &lt;code&gt;java.lang.ClassCastException&lt;/code&gt;。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  interface A {}
  interface Z {}
  static class C {}

  void x(C c) {
    if (c instanceof Z) {
      A a = ((A)c); // 转换为不兼容的接口 'A'
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MismatchedStringCase" defaultSeverity="WARNING" displayName="'String' 操作中不匹配的大小写" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告因为在仅大写的字符串中搜索小写字符或在仅小写的字符串中搜索大写字符而始终返回相同值（&lt;code&gt;-1&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt;）的 &lt;code&gt;String&lt;/code&gt; 方法调用。
&lt;p&gt;报告的方法包括 &lt;code&gt;equals&lt;/code&gt;、&lt;code&gt;startsWith&lt;/code&gt;、&lt;code&gt;endsWith&lt;/code&gt;、&lt;code&gt;contains&lt;/code&gt;、&lt;code&gt;indexOf&lt;/code&gt; 和 &lt;code&gt;lastIndexOf&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
  if (columnName.toLowerCase().equals("ID")) {...}
&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2019.3 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ArrayHashCode" defaultSeverity="WARNING" displayName="在数组上调用了 'hashCode()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告数组的不正确哈希代码计算。
&lt;p&gt;为正确计算数组的哈希代码，请执行以下操作：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;为线性数组使用 &lt;code&gt;Arrays.hashcode()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;为多维数组使用 &lt;code&gt;Arrays.deepHashcode()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
当输入值序列包含数组时，例如 &lt;code&gt;Objects.hash(string, Arrays.hashcode(array))&lt;/code&gt;，这些方法还应与 &lt;code&gt;Objects.hash()&lt;/code&gt; 一起使用：
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="StaticFieldReferenceOnSubclass" defaultSeverity="WARNING" displayName="static 字段通过子类引用" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对其中的调用由声明类的子类而不是由声明类本身限定的 static 字段的访问。
&lt;p&gt;
  Java 允许此类限定，但是此类访问可能表明继承和重写之间存在难以捉摸的混淆。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Parent {
    static int foo = 0;
  }

  class Child extends Parent { }

  void bar() {
    System.out.println(Child.foo);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;应用快速修复后，结果如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Parent {
    static int foo = 0;
  }

  class Child extends Parent { }

  void bar() {
    System.out.println(Parent.foo);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StringEqualsCharSequence" defaultSeverity="WARNING" displayName="使用 'CharSequence' 实参调用了 'String.equals()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对 &lt;code&gt;CharSequence&lt;/code&gt; 作为实参的 &lt;code&gt;String.equals()&lt;/code&gt; 的调用。
&lt;p&gt;
  对于 &lt;code&gt;String&lt;/code&gt; 实参，&lt;code&gt;String.equals()&lt;/code&gt; 只能返回 &lt;code&gt;true&lt;/code&gt;。
  要比较包含非 &lt;code&gt;String&lt;/code&gt; &lt;code&gt;CharSequence&lt;/code&gt; 实参的 &lt;code&gt;String&lt;/code&gt; 的内容，请使用 &lt;code&gt;contentEquals()&lt;/code&gt; 方法。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean equals(String s, CharSequence ch) {
    return s.equals(ch);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean equals(String s, CharSequence ch) {
    return s.contentEquals(ch);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;small&gt;2017.3 最新变化&lt;/small&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MismatchedStringBuilderQueryUpdate" defaultSeverity="WARNING" displayName="'StringBuilder' 的查询和更新不匹配" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告其内容已读取但未写入，或已写入但未读取的 &lt;code&gt;StringBuilder&lt;/code&gt; 或 &lt;code&gt;StringBuffer&lt;/code&gt; 对象。
&lt;p&gt;此类不一致读写毫无意义，可能表明死码、代码不完整或错误。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public void m1() {
    StringBuilder sb = new StringBuilder();
    sb.append("a");
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ObjectToString" defaultSeverity="WARNING" displayName="调用默认 'toString()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对使用 &lt;code&gt;java.lang.Object&lt;/code&gt; 中默认实现的 &lt;code&gt;toString()&lt;/code&gt; 的调用。
&lt;p&gt;该默认实现很少是有意为之，可能是误用。&lt;/p&gt;
&lt;p&gt;
  此检查将忽略对包含 &lt;code&gt;java.lang.Object&lt;/code&gt;、接口或 abstract 类类型的对象的 &lt;code&gt;toString()&lt;/code&gt; 调用。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Bar {
      void foo1(Bar bar) {
          String s = bar.toString(); // 警告
          /* ... */
      }

      void foo2(Object obj) {
          String s = obj.toString(); // 此处无警告
          /* ... */
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="WriteOnlyObject" defaultSeverity="WARNING" displayName="只写入对象" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告已修改但从未查询的对象。
&lt;p&gt;该检查依赖于方法突变协定，对于某些库方法，可以推断或预先注解突变协定。 此检查不报告集合、映射和字符串构建器，因为其他更精准的检查会报告这些类型。
&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  AtomicReference&amp;lt;String&amp;gt; ref = new AtomicReference&amp;lt;&amp;gt;();
  ref.set("hello"); // ref 不再使用
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  使用&lt;b&gt;忽略不纯的构造函数&lt;/b&gt;选项可以控制是否处理由构造函数或纯度未知的方法创建的对象。
  如果在构造过程中故意泄漏对象引用，取消选中该选项可能会引起某些误报。
&lt;/p&gt;
&lt;b&gt;&lt;small&gt;2021.2 最新变化&lt;/small&gt;&lt;/b&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StringConcatenationInFormatCall" defaultSeverity="WARNING" displayName="字符串串联作为 'format()' 调用的实参" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告用作格式字符串实参的非常量字符串串联。
&lt;p&gt;
  虽然偶尔是有意为之，但这通常是误用格式化方法，串联的字符串中使用的变量包含 &lt;code&gt;%&lt;/code&gt; 等特殊字符时，甚至可能导致安全问题。
&lt;/p&gt;
&lt;p&gt;
  此外，有时这可能是在本应键入 &lt;code&gt;,&lt;/code&gt; 时键入了 &lt;code&gt;+&lt;/code&gt; 而错误串联字符串格式实参所致。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  static String formatGreeting(String userName) {
    return String.format("Hello, " + userName);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  这里的 &lt;code&gt;userName&lt;/code&gt; 将解释为格式字符串的一部分，从而可能导致 &lt;code&gt;IllegalFormatException&lt;/code&gt;（例如，如果 &lt;code&gt;userName&lt;/code&gt; 为 &lt;code&gt;"%"&lt;/code&gt;）或使用大量内存（例如，如果 &lt;code&gt;userName&lt;/code&gt; 为 &lt;code&gt;"%2000000000%"&lt;/code&gt;）。
  该调用可能应替换为 &lt;code&gt;String.format("Hello, %s", userName);&lt;/code&gt;。
&lt;/p&gt;
&lt;p&gt;
  此检查将检查对 &lt;code&gt;java.util.Formatter&lt;/code&gt;、&lt;code&gt;java.lang.String&lt;/code&gt;、&lt;code&gt;java.io.PrintWriter&lt;/code&gt; 或 &lt;code&gt;java.io.PrintStream&lt;/code&gt; 的格式化方法的调用。
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SuspiciousArrayMethodCall" defaultSeverity="WARNING" displayName="可疑的 'Arrays' 方法调用" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对 &lt;code&gt;Arrays.fill()&lt;/code&gt; 等实参类型不匹配的非泛型数组操作方法的调用。
此类调用不会执行任何有用的工作，很可能是错误的。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int foo(String[] strings) {
    return Arrays.binarySearch(strings, 1);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2017.2 最新变化&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ThrowableNotThrown" defaultSeverity="WARNING" displayName="'Throwable' 未抛出" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
当创建的 &lt;code&gt;Throwable&lt;/code&gt; 从未真正抛出时，报告 &lt;code&gt;Throwable&lt;/code&gt; 或其子类的实例化。
此外，当方法调用的结果未抛出时，此检查会报告返回 &lt;code&gt;Throwable&lt;/code&gt; 或其子类实例的方法调用。
&lt;p&gt;不会报告对使用 Error Prone 或 AssertJ 的 &lt;code&gt;@CanIgnoreReturnValue&lt;/code&gt; 注解进行注解的方法的调用。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    void check(String s) {
        if (s == null) {
            new NullPointerException("s");
        }
        // ...
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ClassNewInstance" defaultSeverity="WARNING" displayName="对 'Class.newInstance()' 的调用不安全" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对 &lt;code&gt;java.lang.Class.newInstance()&lt;/code&gt; 的调用。
&lt;p&gt;
  此方法会传播由无实参构造函数抛出的异常，包括已检查的异常。 使用此方法可以有效地绕过本由编译器执行的编译时异常检查。
&lt;/p&gt;
&lt;p&gt;
  建议通过快速修复将该调用替换为对 &lt;code&gt;java.lang.reflect.Constructor.newInstance()&lt;/code&gt; 方法的调用，这种方式将构造函数抛出的任何异常包装在（已检查的）&lt;code&gt;java.lang.reflect.InvocationTargetException&lt;/code&gt; 中，从而可以避免这个问题。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  clazz.newInstance()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  clazz.getConstructor().newInstance();
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Reactor" path="Reactive Streams"><inspection shortName="CallingSubscribeInNonBlockingScope" defaultSeverity="WARNING" displayName="在 &quot;reactive&quot; 方法中调用 'subscribe'" enabled="false" language="UAST" pluginId="com.intellij.reactivestreams" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告 "reactive" 方法中的 &lt;code&gt;subscribe()&lt;/code&gt; 调用。&lt;/p&gt;
&lt;p&gt;返回 &lt;code&gt;Publisher&lt;/code&gt; 类型（包括 &lt;code&gt;Flux&lt;/code&gt; 和 &lt;code&gt;Mono&lt;/code&gt;）的方法不应直接调用 &lt;code&gt;subscribe()&lt;/code&gt; 方法，因为它可能破坏反应式调用链。&lt;/p&gt;
&lt;p&gt;不要使用 &lt;code&gt;subscribe()&lt;/code&gt;，而是考虑使用组合运算符，例如 &lt;code&gt;flatMap()&lt;/code&gt;、&lt;code&gt;zip()&lt;/code&gt;、&lt;code&gt;then()&lt;/code&gt; &gt; 等。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Flux&amp;lt;String&amp;gt; stringFlux(){
    Flux&amp;lt;String&amp;gt; flux = Flux.just("abc");
    flux.subscribe(); // &amp;lt;- 在非阻塞上下文中阻塞 'subscribe' 调用
    return flux;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnfinishedStepVerifier" defaultSeverity="WARNING" displayName="未完成的 StepVerifier" enabled="false" language="UAST" pluginId="com.intellij.reactivestreams" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告缺失的 &lt;code&gt;StepVerifier&lt;/code&gt; 终端调用。&lt;/p&gt;
&lt;p&gt;
  启动 &lt;code&gt;Publisher&lt;/code&gt; 订阅和断言需要调用终端验证方法，例如&lt;code&gt;verify()&lt;/code&gt;、&lt;code&gt;verifyComplete()&lt;/code&gt; 等。
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
StepVerifier.create(Flux.just(1,2,3)).expectNext(1);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
StepVerifier.create(Flux.just(1,2,3)).expectNext(1).verifyComplete();
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReactorAutomaticDebugger" defaultSeverity="WEAK WARNING" displayName="不必要的调试初始化" enabled="false" language="UAST" pluginId="com.intellij.reactivestreams" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;报告冗余的 &lt;code&gt;ReactorDebugAgent.init()&lt;/code&gt; 调用。&lt;/p&gt;
&lt;p&gt;
  IDE 可以自动初始化 Reactor Debug 模式，因此用户不需要显式调用 &lt;code&gt;ReactorDebugAgent.init()&lt;/code&gt; 或 &lt;code&gt;Hooks.onOperatorDebug()&lt;/code&gt;。
  &lt;/p&gt;

  &lt;p&gt;此外，同时调用 &lt;code&gt;ReactorDebugAgent.init()&lt;/code&gt; 和 &lt;code&gt;Hooks.onOperatorDebug()&lt;/code&gt; 会导致 Reactor 生成双倍的调试堆栈帧。
  &lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Flow 类型检查器" path="JavaScript and TypeScript"><inspection shortName="FlowJSError" defaultSeverity="ERROR" displayName="Flow 类型检查器" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;a href="https://flowtype.org/"&gt;Flow&lt;/a&gt; 中的错误。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FlowJSCoverage" defaultSeverity="WEAK WARNING" displayName="Flow 不涵盖代码" enabled="false" language="Flow JS" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 Flow 类型检查器未覆盖的 JavaScript 代码段。
要使用此检查，请在&lt;a href="settings://Settings.JavaScript"&gt;设置 | 语言和框架 | JavaScript&lt;/a&gt; 中配置 Flow 可执行文件。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FlowJSFlagCommentPlacement" defaultSeverity="WARNING" displayName="位置错误的 @flow 标记" enabled="false" language="Flow JS" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告不位于文件顶部的 &lt;code&gt;@flow&lt;/code&gt; 标志注释。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FlowJSConfig" defaultSeverity="WARNING" displayName="缺少 .flowconfig" enabled="false" language="Flow JS" pluginId="JavaScript" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在项目中没有关联的 &lt;code&gt;.flowconfig&lt;/code&gt; 文件且带有 &lt;code&gt;@flow&lt;/code&gt; 标志的 JavaScript 文件。
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="GPath" path="Groovy"><inspection shortName="GroovyListSetCanBeKeyedAccess" defaultSeverity="WARNING" displayName="对 List.set 的调用可以是键控访问" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对 &lt;code&gt;java.util.List.set()&lt;/code&gt; 方法的调用。 此类调用可由更简短明确的键控访问形式替代。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
def list = ["foo"]
list.set(0, "bar") // list.set(0, "bar") 可以替换为 list[0] = "bar"
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
def list = ["foo"]
list[0] = "bar"
&lt;/code&gt;
&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyListGetCanBeKeyedAccess" defaultSeverity="WARNING" displayName="对 List.get 的调用可以是键控访问" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对 &lt;code&gt;java.util.List.get()&lt;/code&gt; 方法的调用。 此类调用可由更简短明确的键控访问形式替代。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
def list = ["foo"]
def str = list.get(0) // list.get(0) 可以替换为 list[0]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
def list = ["foo"]
def str = list[0]
&lt;/code&gt;
&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyMapGetCanBeKeyedAccess" defaultSeverity="WARNING" displayName="对 Map.get 的调用可以是键控访问" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对 &lt;code&gt;java.util.Map.get()&lt;/code&gt; 方法的调用。 此类调用可由更简短明确的键控访问形式替代。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
def map = ["foo": "bar"]
def str = map.get("foo") // map.get("foo") 可以替换为 map["foo"]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
def map = ["foo": "bar"]
def str = map["foo"]
&lt;/code&gt;
&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyMapPutCanBeKeyedAccess" defaultSeverity="WARNING" displayName="对 Map.put 的调用可以是键控访问" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告对 &lt;code&gt;java.util.Map.put()&lt;/code&gt; 方法的调用。 此类调用可由更简短明确的键控访问形式替代。
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
def map = ["foo": "bar"]
map.put("foo", "baz") // map.put("foo", "baz") 可以替换为 map["foo"] = "baz"
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
def map = ["foo": "bar"]
map["foo"] = "baz"
&lt;/code&gt;
&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="Android Lint: Interoperability" path=""><inspection shortName="AndroidLintUnknownNullness" defaultSeverity="WARNING" displayName="Unknown nullness" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Unknown nullness&lt;br&gt;&lt;br&gt;To improve referencing this code from Kotlin, consider adding explicit nullness information here with either &lt;code&gt;@NonNull&lt;/code&gt; or &lt;code&gt;@Nullable&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: UnknownNullness&lt;br&gt;&lt;br&gt;Available options:&lt;br/&gt;
&lt;br/&gt;
&lt;b&gt;ignore-deprecated&lt;/b&gt; (default is false):&lt;br/&gt;
Whether to ignore classes and members that have been annotated with &lt;code&gt;@Deprecated&lt;/code&gt;.&lt;br/&gt;
&lt;br/&gt;
Normally this lint check will flag all unannotated elements, but by setting this option to &lt;code&gt;true&lt;/code&gt; it will skip any deprecated elements.&lt;br/&gt;
&lt;br/&gt;
To configure this option, use a &lt;code&gt;lint.xml&lt;/code&gt; file with an &amp;lt;option&gt; like this:&lt;br/&gt;

&lt;pre&gt;
&amp;lt;lint&gt;
    &amp;lt;issue id="UnknownNullness"&gt;
        &amp;lt;option name="ignore-deprecated" value="false" /&gt;
    &amp;lt;/issue&gt;
&amp;lt;/lint&gt;
&lt;/pre&gt;
&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/kotlin/interop#nullability_annotations"&gt;https://developer.android.com/kotlin/interop#nullability_annotations&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintJavaPluginLanguageLevel" defaultSeverity="WARNING" displayName="Java Plugin Language Level" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;No Explicit Java Language Level Given&lt;br&gt;&lt;br&gt;In modules using plugins deriving from the Gradle &lt;code&gt;java&lt;/code&gt; plugin (e.g. &lt;code&gt;java-library&lt;/code&gt; or &lt;code&gt;application&lt;/code&gt;), the java source and target compatibility default to the version of the JDK being used to run Gradle, which may cause compatibility problems with Android (or other) modules.&lt;br/&gt;
&lt;br/&gt;
You can specify an explicit sourceCompatibility and targetCompatibility in this module to maintain compatibility no matter which JDK is used to run Gradle.&lt;br&gt;&lt;br&gt;Issue id: JavaPluginLanguageLevel&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintNoHardKeywords" defaultSeverity="WARNING" displayName="No Hard Kotlin Keywords" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;No Hard Kotlin Keywords&lt;br&gt;&lt;br&gt;Do not use Kotlin&amp;#8217;s hard keywords as the name of methods or fields. These require the use of backticks to escape when calling from Kotlin. Soft keywords, modifier keywords, and special identifiers are allowed.&lt;br/&gt;
&lt;br/&gt;
For example, ActionEvent's &lt;code&gt;getWhen()&lt;/code&gt; method requires backticks when used from Kotlin:
&lt;pre&gt;
val timestamp = event.`when`
&lt;/pre&gt;
&lt;br&gt;&lt;br&gt;Issue id: NoHardKeywords&lt;br&gt;&lt;br&gt;&lt;a href="https://android.github.io/kotlin-guides/interop.html#no-hard-keywords"&gt;https://android.github.io/kotlin-guides/interop.html#no-hard-keywords&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintLambdaLast" defaultSeverity="WARNING" displayName="Lambda Parameters Last" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Lambda Parameters Last&lt;br&gt;&lt;br&gt;To improve calling this code from Kotlin, parameter types eligible for SAM conversion should be last.&lt;br&gt;&lt;br&gt;Issue id: LambdaLast&lt;br&gt;&lt;br&gt;&lt;a href="https://android.github.io/kotlin-guides/interop.html#lambda-parameters-last"&gt;https://android.github.io/kotlin-guides/interop.html#lambda-parameters-last&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintKotlinPropertyAccess" defaultSeverity="WARNING" displayName="Kotlin Property Access" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Beta 2.223.8836.41" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Kotlin Property Access&lt;br&gt;&lt;br&gt;For a method to be represented as a property in Kotlin, strict &amp;#8220;bean&amp;#8221;-style prefixing must be used.&lt;br/&gt;
&lt;br/&gt;
Accessor methods require a &lt;code&gt;get&lt;/code&gt; prefix or for boolean-returning methods an &lt;code&gt;is&lt;/code&gt; prefix can be used.&lt;br&gt;&lt;br&gt;Issue id: KotlinPropertyAccess&lt;br&gt;&lt;br&gt;&lt;a href="https://android.github.io/kotlin-guides/interop.html#property-prefixes"&gt;https://android.github.io/kotlin-guides/interop.html#property-prefixes&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection></group><group name="Angular" path=""><inspection shortName="AngularInvalidTemplateReferenceVariable" defaultSeverity="ERROR" displayName="模板引用变量未绑定或不明确" enabled="false" language="HtmlCompatible" pluginId="AngularJS" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在使用 &lt;code&gt;exportAs&lt;/code&gt; 时未赋给一条指令或赋给多条指令的模板引用变量。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AngularInaccessibleComponentMemberInAotMode" defaultSeverity="WARNING" displayName="在 AOT 模式下无法访问组件成员" enabled="false" pluginId="AngularJS" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告从组件模板访问组件的 private 或 protected 成员的情况。 此类用法会导致 AOT 编译失败。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AngularInvalidSelector" defaultSeverity="ERROR" displayName="选择器缺失或无效" enabled="false" pluginId="AngularJS" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告组件或指令的无效 &lt;code&gt;selector&lt;/code&gt; 属性。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AngularInvalidEntryComponent" defaultSeverity="ERROR" displayName="入口组件无效" enabled="false" language="TypeScript" pluginId="AngularJS" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告在模块的 &lt;code&gt;bootstrap&lt;/code&gt; 或 &lt;code&gt;entryComponents&lt;/code&gt; 属性中指定的无效 Angular 组件。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AngularUndefinedTag" defaultSeverity="ERROR" displayName="未定义的标记" enabled="false" language="HtmlCompatible" pluginId="AngularJS" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告由超出当前范围的组件或指令定义的标记。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AngularMultipleStructuralDirectives" defaultSeverity="ERROR" displayName="一个元素上有多个结构指令" enabled="false" language="HtmlCompatible" pluginId="AngularJS" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告一个元素中的多条结构型指令（&lt;code&gt;*ngIf&lt;/code&gt;、&lt;code&gt;*ngFor&lt;/code&gt; 等）。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AngularNonEmptyNgContent" defaultSeverity="ERROR" displayName="内容位于 &lt;ng-content&gt; 标记中" enabled="false" language="HtmlCompatible" pluginId="AngularJS" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告用于内容投影的 &lt;code&gt;&amp;lt;ng-content&amp;gt;&lt;/code&gt; 标记内出现的文本或标记。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AngularInsecureBindingToEvent" defaultSeverity="WARNING" displayName="绑定到事件不安全" enabled="false" language="HtmlCompatible" pluginId="AngularJS" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告与事件属性或特性的绑定，
例如 &lt;code&gt;[onclick]&lt;/code&gt; 或 &lt;code&gt;[attr.onclick]&lt;/code&gt; 而不是
&lt;code&gt;(click)&lt;/code&gt;。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AngularRecursiveModuleImportExport" defaultSeverity="ERROR" displayName="递归导入或导出 Angular 模块" enabled="false" language="TypeScript" pluginId="AngularJS" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 Angular 模块之间的循环依赖关系。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AngularInvalidI18nAttribute" defaultSeverity="WARNING" displayName="i18n 特性无效" enabled="false" language="HtmlCompatible" pluginId="AngularJS" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;i18n-*&lt;/code&gt; 特性的问题。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AngularMissingOrInvalidDeclarationInModule" defaultSeverity="ERROR" displayName="模块中的组件、指令或管道声明缺失或无效" enabled="false" language="TypeScript" pluginId="AngularJS" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告未在任何模块中声明或在多个模块中声明的非独立 Angular 组件、指令或管道。
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="AngularInvalidAnimationTriggerAssignment" defaultSeverity="ERROR" displayName="动画触发器赋值无效" enabled="false" language="HtmlCompatible" pluginId="AngularJS" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告动画触发器的无效赋值。 要将动画附加到元素，请使用
&lt;code&gt;[@triggerName]="expression"&lt;/code&gt; 或不含 &lt;code&gt;@triggerName&lt;/code&gt; 值的特性。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AngularInvalidImportedOrDeclaredSymbol" defaultSeverity="ERROR" displayName="导入或声明的符号无效" enabled="false" language="TypeScript" pluginId="AngularJS" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告由不是模块、组件、指令或管道或不能在属性上下文中使用的 Angular 模块所声明、导入或导出的任何符号。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AngularUndefinedBinding" defaultSeverity="ERROR" displayName="未定义的绑定" enabled="false" language="HtmlCompatible" pluginId="AngularJS" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告元素中未定义的属性、事件或结构型指令绑定。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AngularAmbiguousComponentTag" defaultSeverity="ERROR" displayName="不明确的组件标记" enabled="false" language="HtmlCompatible" pluginId="AngularJS" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告与嵌入的模板元素 &lt;code&gt;&amp;lt;ng-template&amp;gt;&lt;/code&gt; 匹配的一个组件
或与其他任何元素匹配的多个组件。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AngularCliAddDependency" defaultSeverity="WARNING" displayName="Angular CLI 添加依赖项" enabled="false" language="JSON" pluginId="AngularJS" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
建议使用 &lt;code&gt;ng add&lt;/code&gt; 命令安装依赖项。
&lt;p&gt;&lt;code&gt;ng add&lt;/code&gt; 将使用软件包管理器进行下载，并调用原理图，该原理图可以通过配置更改、添加附加依赖项（例如 polyfills）或基架软件包特定的初始化代码来更新项目。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AngularUndefinedModuleExport" defaultSeverity="ERROR" displayName="未定义从 Angular 模块导出" enabled="false" language="TypeScript" pluginId="AngularJS" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告从 Angular 模块导出的未声明或未导入的组件、指令或管道。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AngularIncorrectTemplateDefinition" defaultSeverity="ERROR" displayName="组件模板定义不正确" enabled="false" language="TypeScript" pluginId="AngularJS" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告没有关联模板或同时使用 &lt;code&gt;template&lt;/code&gt; 和 &lt;code&gt;templateUrl&lt;/code&gt; 属性的组件。
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AngularMissingEventHandler" defaultSeverity="ERROR" displayName="缺少事件处理程序" enabled="false" language="HtmlCompatible" pluginId="AngularJS" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告事件绑定缺少的事件处理程序语句。
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="导入" path="Java"><inspection shortName="OnDemandImport" defaultSeverity="WARNING" displayName="'*' 导入" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告任何涵盖整个软件包的 &lt;code&gt;import&lt;/code&gt; 语句 ('* imports')。
&lt;p&gt;某些编码标准禁止此类 &lt;code&gt;import&lt;/code&gt; 语句。&lt;/p&gt;
&lt;p&gt;
  您可以将 IntelliJ IDEA 配置为使用&lt;b&gt;优化 import&lt;/b&gt; 命令检测和修正此类语句。 转到&lt;a href="settings://preferences.sourceCode.Java?Use%20single%20class%20import"&gt;设置 | 编辑器 | 代码样式 | Java | 导入&lt;/a&gt;，确保启用&lt;b&gt;使用单个类导入&lt;/b&gt;选项，并在&lt;b&gt;将 import 与 '*' 搭配使用的类计数&lt;/b&gt;和&lt;b&gt;将静态 import 与 '*' 搭配使用的名称计数&lt;/b&gt;字段中指定值。
  因此，对于不打算更改的代码库的脱机报告，此检查非常有用。
&lt;/p&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SingleClassImport" defaultSeverity="WARNING" displayName="单个类导入" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告导入单个类（而不是整个软件包）的 &lt;code&gt;import&lt;/code&gt; 语句。
&lt;p&gt;某些编码标准禁止此类 &lt;code&gt;import&lt;/code&gt; 语句。&lt;/p&gt;
&lt;p&gt;
  您可以将 IntelliJ IDEA 配置为使用&lt;b&gt;优化 import&lt;/b&gt; 命令检测和修正此类语句。 转到&lt;a href="settings://preferences.sourceCode.Java?Use%20single%20class%20import"&gt;设置 | 编辑器 | 代码样式 | Java | 导入&lt;/a&gt;，并清除&lt;b&gt;使用单个类导入&lt;/b&gt;复选框。 因此，对于不打算更改的代码库的脱机报告，此检查非常有用。
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UNUSED_IMPORT" defaultSeverity="WARNING" displayName="未使用的 import" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
报告冗余的 &lt;code&gt;import&lt;/code&gt; 语句。
&lt;p&gt;如果不使用源文件中导入的类和软件包，则不必使用常规 &lt;code&gt;import&lt;/code&gt; 语句。
这同样适用于源文件中未使用但已导入的 &lt;code&gt;static&lt;/code&gt; 字段和方法。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例：&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  import java.util.ArrayList;
  public class Example {
    public static void main(String[] args) {
      System.out.println("Hello World!");
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在应用快速修复后：
&lt;pre&gt;&lt;code&gt;
  public class Example {
    public static void main(String[] args) {
      System.out.println("Hello World!");
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JavaLangImport" defaultSeverity="WARNING" displayName="'java.lang' 软件包中有不必要的 import" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告引用 &lt;code&gt;java.lang&lt;/code&gt; 软件包的 &lt;code&gt;import&lt;/code&gt; 语句。
&lt;p&gt;
  &lt;code&gt;java.lang&lt;/code&gt; 类始终隐式导入，因此此类 import 语句冗余，也令人困惑。
&lt;/p&gt;
&lt;p&gt;
  IntelliJ IDEA 可以通过&lt;b&gt;优化 import&lt;/b&gt; 命令自动检测并修正此类语句，对于不打算更改的代码库的脱机报告，此检查非常有用。
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SamePackageImport" defaultSeverity="WARNING" displayName="相同软件包中的不必要 import" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告引用的软件包与包含文件相同的 &lt;code&gt;import&lt;/code&gt; 语句。
&lt;p&gt;
  相同软件包的文件始终隐式导入，因此，此类 &lt;code&gt;import&lt;/code&gt; 语句冗余，而且令人困惑。
&lt;/p&gt;
&lt;p&gt;
  由于 IntelliJ IDEA 可以通过&lt;b&gt;优化导入&lt;/b&gt;命令自动检测并修正此类语句，对于不打算更改的代码库的脱机报告，此检查非常有用。
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StaticImport" defaultSeverity="WARNING" displayName="静态导入" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="223.8836.41" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
报告 &lt;code&gt;import static&lt;/code&gt; 语句。
&lt;p&gt;Java 1.4 或更早版本的 JVM 不支持此类 &lt;code&gt;import&lt;/code&gt; 语句。&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;配置检查：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;使用下表可以指定在 &lt;code&gt;import static&lt;/code&gt; 语句中使用时该检查将忽略的类。&lt;/li&gt;
  &lt;li&gt;使用&lt;b&gt;忽略单字段 static import&lt;/b&gt;复选框可以忽略单字段 &lt;code&gt;import static&lt;/code&gt; 语句。&lt;/li&gt;
  &lt;li&gt;使用&lt;b&gt;忽略单方法 static import&lt;/b&gt; 复选框可以忽略单方法 &lt;code&gt;import static&lt;/code&gt; 语句。&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group></inspections>